var Iee = Object.defineProperty;
var $ee = (t, e, r) => e in t ? Iee(t, e, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : t[e] = r;
var le = (t, e, r) => ($ee(t, typeof e != "symbol" ? e + "" : e, r), r);
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver(i => {
    for (const a of i)
      if (a.type === "childList")
        for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && n(s)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function r(i) {
    const a = {};
    return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a
  }

  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const a = r(i);
    fetch(i.href, a)
  }
})();
var me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function PI(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function Cee(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      if (this instanceof n) {
        var i = [null];
        i.push.apply(i, arguments);
        var a = Function.bind.apply(e, i);
        return new a
      }
      return e.apply(this, arguments)
    };
    r.prototype = e.prototype
  } else r = {};
  return Object.defineProperty(r, "__esModule", {
    value: !0
  }), Object.keys(t).forEach(function (n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function () {
        return t[n]
      }
    })
  }), r
}
var p0 = {},
  kee = {
    get exports() {
      return p0
    },
    set exports(t) {
      p0 = t
    }
  },
  bp = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var LL = Object.getOwnPropertySymbols,
  Oee = Object.prototype.hasOwnProperty,
  Lee = Object.prototype.propertyIsEnumerable;

function Pee(t) {
  if (t == null) throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(t)
}

function Nee() {
  try {
    if (!Object.assign) return !1;
    var t = new String("abc");
    if (t[5] = "de", Object.getOwnPropertyNames(t)[0] === "5") return !1;
    for (var e = {}, r = 0; r < 10; r++) e["_" + String.fromCharCode(r)] = r;
    var n = Object.getOwnPropertyNames(e).map(function (a) {
      return e[a]
    });
    if (n.join("") !== "0123456789") return !1;
    var i = {};
    return "abcdefghijklmnopqrst".split("").forEach(function (a) {
      i[a] = a
    }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst"
  } catch {
    return !1
  }
}
var NI = Nee() ? Object.assign : function (t, e) {
    for (var r, n = Pee(t), i, a = 1; a < arguments.length; a++) {
      r = Object(arguments[a]);
      for (var s in r) Oee.call(r, s) && (n[s] = r[s]);
      if (LL) {
        i = LL(r);
        for (var o = 0; o < i.length; o++) Lee.call(r, i[o]) && (n[i[o]] = r[i[o]])
      }
    }
    return n
  },
  A = {},
  Dee = {
    get exports() {
      return A
    },
    set exports(t) {
      A = t
    }
  },
  je = {};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DI = NI,
  Mf = 60103,
  j9 = 60106;
je.Fragment = 60107;
je.StrictMode = 60108;
je.Profiler = 60114;
var H9 = 60109,
  z9 = 60110,
  G9 = 60112;
je.Suspense = 60113;
var V9 = 60115,
  W9 = 60116;
if (typeof Symbol == "function" && Symbol.for) {
  var pi = Symbol.for;
  Mf = pi("react.element"), j9 = pi("react.portal"), je.Fragment = pi("react.fragment"), je.StrictMode = pi("react.strict_mode"), je.Profiler = pi("react.profiler"), H9 = pi("react.provider"), z9 = pi("react.context"), G9 = pi("react.forward_ref"), je.Suspense = pi("react.suspense"), V9 = pi("react.memo"), W9 = pi("react.lazy")
}
var PL = typeof Symbol == "function" && Symbol.iterator;

function Mee(t) {
  return t === null || typeof t != "object" ? null : (t = PL && t[PL] || t["@@iterator"], typeof t == "function" ? t : null)
}

function Ep(t) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++) e += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var K9 = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  Y9 = {};

function Ff(t, e, r) {
  this.props = t, this.context = e, this.refs = Y9, this.updater = r || K9
}
Ff.prototype.isReactComponent = {};
Ff.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null) throw Error(Ep(85));
  this.updater.enqueueSetState(this, t, e, "setState")
};
Ff.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function q9() {}
q9.prototype = Ff.prototype;

function MI(t, e, r) {
  this.props = t, this.context = e, this.refs = Y9, this.updater = r || K9
}
var FI = MI.prototype = new q9;
FI.constructor = MI;
DI(FI, Ff.prototype);
FI.isPureReactComponent = !0;
var BI = {
    current: null
  },
  X9 = Object.prototype.hasOwnProperty,
  Q9 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function Z9(t, e, r) {
  var n, i = {},
    a = null,
    s = null;
  if (e != null)
    for (n in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (a = "" + e.key), e) X9.call(e, n) && !Q9.hasOwnProperty(n) && (i[n] = e[n]);
  var o = arguments.length - 2;
  if (o === 1) i.children = r;
  else if (1 < o) {
    for (var c = Array(o), l = 0; l < o; l++) c[l] = arguments[l + 2];
    i.children = c
  }
  if (t && t.defaultProps)
    for (n in o = t.defaultProps, o) i[n] === void 0 && (i[n] = o[n]);
  return {
    $$typeof: Mf,
    type: t,
    key: a,
    ref: s,
    props: i,
    _owner: BI.current
  }
}

function Fee(t, e) {
  return {
    $$typeof: Mf,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner
  }
}

function UI(t) {
  return typeof t == "object" && t !== null && t.$$typeof === Mf
}

function Bee(t) {
  var e = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + t.replace(/[=:]/g, function (r) {
    return e[r]
  })
}
var NL = /\/+/g;

function WE(t, e) {
  return typeof t == "object" && t !== null && t.key != null ? Bee("" + t.key) : e.toString(36)
}

function Ev(t, e, r, n, i) {
  var a = typeof t;
  (a === "undefined" || a === "boolean") && (t = null);
  var s = !1;
  if (t === null) s = !0;
  else switch (a) {
    case "string":
    case "number":
      s = !0;
      break;
    case "object":
      switch (t.$$typeof) {
        case Mf:
        case j9:
          s = !0
      }
  }
  if (s) return s = t, i = i(s), t = n === "" ? "." + WE(s, 0) : n, Array.isArray(i) ? (r = "", t != null && (r = t.replace(NL, "$&/") + "/"), Ev(i, e, r, "", function (l) {
    return l
  })) : i != null && (UI(i) && (i = Fee(i, r + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(NL, "$&/") + "/") + t)), e.push(i)), 1;
  if (s = 0, n = n === "" ? "." : n + ":", Array.isArray(t))
    for (var o = 0; o < t.length; o++) {
      a = t[o];
      var c = n + WE(a, o);
      s += Ev(a, e, r, c, i)
    } else if (c = Mee(t), typeof c == "function")
      for (t = c.call(t), o = 0; !(a = t.next()).done;) a = a.value, c = n + WE(a, o++), s += Ev(a, e, r, c, i);
    else if (a === "object") throw e = "" + t, Error(Ep(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
  return s
}

function Dg(t, e, r) {
  if (t == null) return t;
  var n = [],
    i = 0;
  return Ev(t, n, "", "", function (a) {
    return e.call(r, a, i++)
  }), n
}

function Uee(t) {
  if (t._status === -1) {
    var e = t._result;
    e = e(), t._status = 0, t._result = e, e.then(function (r) {
      t._status === 0 && (r = r.default, t._status = 1, t._result = r)
    }, function (r) {
      t._status === 0 && (t._status = 2, t._result = r)
    })
  }
  if (t._status === 1) return t._result;
  throw t._result
}
var J9 = {
  current: null
};

function ds() {
  var t = J9.current;
  if (t === null) throw Error(Ep(321));
  return t
}
var jee = {
  ReactCurrentDispatcher: J9,
  ReactCurrentBatchConfig: {
    transition: 0
  },
  ReactCurrentOwner: BI,
  IsSomeRendererActing: {
    current: !1
  },
  assign: DI
};
je.Children = {
  map: Dg,
  forEach: function (t, e, r) {
    Dg(t, function () {
      e.apply(this, arguments)
    }, r)
  },
  count: function (t) {
    var e = 0;
    return Dg(t, function () {
      e++
    }), e
  },
  toArray: function (t) {
    return Dg(t, function (e) {
      return e
    }) || []
  },
  only: function (t) {
    if (!UI(t)) throw Error(Ep(143));
    return t
  }
};
je.Component = Ff;
je.PureComponent = MI;
je.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jee;
je.cloneElement = function (t, e, r) {
  if (t == null) throw Error(Ep(267, t));
  var n = DI({}, t.props),
    i = t.key,
    a = t.ref,
    s = t._owner;
  if (e != null) {
    if (e.ref !== void 0 && (a = e.ref, s = BI.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var o = t.type.defaultProps;
    for (c in e) X9.call(e, c) && !Q9.hasOwnProperty(c) && (n[c] = e[c] === void 0 && o !== void 0 ? o[c] : e[c])
  }
  var c = arguments.length - 2;
  if (c === 1) n.children = r;
  else if (1 < c) {
    o = Array(c);
    for (var l = 0; l < c; l++) o[l] = arguments[l + 2];
    n.children = o
  }
  return {
    $$typeof: Mf,
    type: t.type,
    key: i,
    ref: a,
    props: n,
    _owner: s
  }
};
je.createContext = function (t, e) {
  return e === void 0 && (e = null), t = {
    $$typeof: z9,
    _calculateChangedBits: e,
    _currentValue: t,
    _currentValue2: t,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  }, t.Provider = {
    $$typeof: H9,
    _context: t
  }, t.Consumer = t
};
je.createElement = Z9;
je.createFactory = function (t) {
  var e = Z9.bind(null, t);
  return e.type = t, e
};
je.createRef = function () {
  return {
    current: null
  }
};
je.forwardRef = function (t) {
  return {
    $$typeof: G9,
    render: t
  }
};
je.isValidElement = UI;
je.lazy = function (t) {
  return {
    $$typeof: W9,
    _payload: {
      _status: -1,
      _result: t
    },
    _init: Uee
  }
};
je.memo = function (t, e) {
  return {
    $$typeof: V9,
    type: t,
    compare: e === void 0 ? null : e
  }
};
je.useCallback = function (t, e) {
  return ds().useCallback(t, e)
};
je.useContext = function (t, e) {
  return ds().useContext(t, e)
};
je.useDebugValue = function () {};
je.useEffect = function (t, e) {
  return ds().useEffect(t, e)
};
je.useImperativeHandle = function (t, e, r) {
  return ds().useImperativeHandle(t, e, r)
};
je.useLayoutEffect = function (t, e) {
  return ds().useLayoutEffect(t, e)
};
je.useMemo = function (t, e) {
  return ds().useMemo(t, e)
};
je.useReducer = function (t, e, r) {
  return ds().useReducer(t, e, r)
};
je.useRef = function (t) {
  return ds().useRef(t)
};
je.useState = function (t) {
  return ds().useState(t)
};
je.version = "17.0.2";
(function (t) {
  t.exports = je
})(Dee);
const ce = PI(A);
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hee = A,
  ej = 60103;
bp.Fragment = 60107;
if (typeof Symbol == "function" && Symbol.for) {
  var DL = Symbol.for;
  ej = DL("react.element"), bp.Fragment = DL("react.fragment")
}
var zee = Hee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Gee = Object.prototype.hasOwnProperty,
  Vee = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function tj(t, e, r) {
  var n, i = {},
    a = null,
    s = null;
  r !== void 0 && (a = "" + r), e.key !== void 0 && (a = "" + e.key), e.ref !== void 0 && (s = e.ref);
  for (n in e) Gee.call(e, n) && !Vee.hasOwnProperty(n) && (i[n] = e[n]);
  if (t && t.defaultProps)
    for (n in e = t.defaultProps, e) i[n] === void 0 && (i[n] = e[n]);
  return {
    $$typeof: ej,
    type: t,
    key: a,
    ref: s,
    props: i,
    _owner: zee.current
  }
}
bp.jsx = tj;
bp.jsxs = tj;
(function (t) {
  t.exports = bp
})(kee);
const yr = p0.Fragment,
  E = p0.jsx,
  Y = p0.jsxs;
var ML = {},
  Wee = {
    get exports() {
      return ML
    },
    set exports(t) {
      ML = t
    }
  },
  Mg = function (t) {
    return t && t.Math == Math && t
  },
  he = Mg(typeof globalThis == "object" && globalThis) || Mg(typeof window == "object" && window) || Mg(typeof self == "object" && self) || Mg(typeof me == "object" && me) || function () {
    return this
  }() || Function("return this")(),
  ar = {},
  re = function (t) {
    try {
      return !!t()
    } catch {
      return !0
    }
  },
  Kee = re,
  _e = !Kee(function () {
    return Object.defineProperty({}, 1, {
      get: function () {
        return 7
      }
    })[1] != 7
  }),
  Yee = re,
  Sp = !Yee(function () {
    var t = function () {}.bind();
    return typeof t != "function" || t.hasOwnProperty("prototype")
  }),
  qee = Sp,
  Fg = Function.prototype.call,
  $e = qee ? Fg.bind(Fg) : function () {
    return Fg.apply(Fg, arguments)
  },
  _p = {},
  rj = {}.propertyIsEnumerable,
  nj = Object.getOwnPropertyDescriptor,
  Xee = nj && !rj.call({
    1: 2
  }, 1);
_p.f = Xee ? function (e) {
  var r = nj(this, e);
  return !!r && r.enumerable
} : rj;
var ri = function (t, e) {
    return {
      enumerable: !(t & 1),
      configurable: !(t & 2),
      writable: !(t & 4),
      value: e
    }
  },
  ij = Sp,
  aj = Function.prototype,
  Jw = aj.call,
  Qee = ij && aj.bind.bind(Jw, Jw),
  ie = ij ? Qee : function (t) {
    return function () {
      return Jw.apply(t, arguments)
    }
  },
  sj = ie,
  Zee = sj({}.toString),
  Jee = sj("".slice),
  Lr = function (t) {
    return Jee(Zee(t), 8, -1)
  },
  ete = ie,
  tte = re,
  rte = Lr,
  KE = Object,
  nte = ete("".split),
  Bf = tte(function () {
    return !KE("z").propertyIsEnumerable(0)
  }) ? function (t) {
    return rte(t) == "String" ? nte(t, "") : KE(t)
  } : KE,
  on = function (t) {
    return t == null
  },
  ite = on,
  ate = TypeError,
  Dt = function (t) {
    if (ite(t)) throw ate("Can't call method on " + t);
    return t
  },
  ste = Bf,
  ote = Dt,
  qt = function (t) {
    return ste(ote(t))
  },
  e2 = typeof document == "object" && document.all,
  lte = typeof e2 > "u" && e2 !== void 0,
  oj = {
    all: e2,
    IS_HTMLDDA: lte
  },
  lj = oj,
  cte = lj.all,
  De = lj.IS_HTMLDDA ? function (t) {
    return typeof t == "function" || t === cte
  } : function (t) {
    return typeof t == "function"
  },
  FL = De,
  cj = oj,
  ute = cj.all,
  Me = cj.IS_HTMLDDA ? function (t) {
    return typeof t == "object" ? t !== null : FL(t) || t === ute
  } : function (t) {
    return typeof t == "object" ? t !== null : FL(t)
  },
  YE = he,
  fte = De,
  dte = function (t) {
    return fte(t) ? t : void 0
  },
  ht = function (t, e) {
    return arguments.length < 2 ? dte(YE[t]) : YE[t] && YE[t][e]
  },
  hte = ie,
  ni = hte({}.isPrototypeOf),
  hs = typeof navigator < "u" && String(navigator.userAgent) || "",
  uj = he,
  qE = hs,
  BL = uj.process,
  UL = uj.Deno,
  jL = BL && BL.versions || UL && UL.version,
  HL = jL && jL.v8,
  bi, fy;
HL && (bi = HL.split("."), fy = bi[0] > 0 && bi[0] < 4 ? 1 : +(bi[0] + bi[1]));
!fy && qE && (bi = qE.match(/Edge\/(\d+)/), (!bi || bi[1] >= 74) && (bi = qE.match(/Chrome\/(\d+)/), bi && (fy = +bi[1])));
var ps = fy,
  zL = ps,
  pte = re,
  Uf = !!Object.getOwnPropertySymbols && !pte(function () {
    var t = Symbol();
    return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && zL && zL < 41
  }),
  gte = Uf,
  fj = gte && !Symbol.sham && typeof Symbol.iterator == "symbol",
  mte = ht,
  vte = De,
  yte = ni,
  xte = fj,
  bte = Object,
  cc = xte ? function (t) {
    return typeof t == "symbol"
  } : function (t) {
    var e = mte("Symbol");
    return vte(e) && yte(e.prototype, bte(t))
  },
  Ete = String,
  uc = function (t) {
    try {
      return Ete(t)
    } catch {
      return "Object"
    }
  },
  Ste = De,
  _te = uc,
  Tte = TypeError,
  It = function (t) {
    if (Ste(t)) return t;
    throw Tte(_te(t) + " is not a function")
  },
  wte = It,
  Rte = on,
  gs = function (t, e) {
    var r = t[e];
    return Rte(r) ? void 0 : wte(r)
  },
  XE = $e,
  QE = De,
  ZE = Me,
  Ate = TypeError,
  dj = function (t, e) {
    var r, n;
    if (e === "string" && QE(r = t.toString) && !ZE(n = XE(r, t)) || QE(r = t.valueOf) && !ZE(n = XE(r, t)) || e !== "string" && QE(r = t.toString) && !ZE(n = XE(r, t))) return n;
    throw Ate("Can't convert object to primitive value")
  },
  wo = {},
  Ite = {
    get exports() {
      return wo
    },
    set exports(t) {
      wo = t
    }
  },
  jI = !1,
  GL = he,
  $te = Object.defineProperty,
  HI = function (t, e) {
    try {
      $te(GL, t, {
        value: e,
        configurable: !0,
        writable: !0
      })
    } catch {
      GL[t] = e
    }
    return e
  },
  Cte = he,
  kte = HI,
  VL = "__core-js_shared__",
  Ote = Cte[VL] || kte(VL, {}),
  zI = Ote,
  WL = zI;
(Ite.exports = function (t, e) {
  return WL[t] || (WL[t] = e !== void 0 ? e : {})
})("versions", []).push({
  version: "3.30.1",
  mode: "global",
  copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var Lte = Dt,
  Pte = Object,
  We = function (t) {
    return Pte(Lte(t))
  },
  Nte = ie,
  Dte = We,
  Mte = Nte({}.hasOwnProperty),
  He = Object.hasOwn || function (e, r) {
    return Mte(Dte(e), r)
  },
  Fte = ie,
  Bte = 0,
  Ute = Math.random(),
  jte = Fte(1.toString),
  jf = function (t) {
    return "Symbol(" + (t === void 0 ? "" : t) + ")_" + jte(++Bte + Ute, 36)
  },
  Hte = he,
  zte = wo,
  KL = He,
  Gte = jf,
  Vte = Uf,
  Wte = fj,
  fu = Hte.Symbol,
  JE = zte("wks"),
  Kte = Wte ? fu.for || fu : fu && fu.withoutSetter || Gte,
  Fe = function (t) {
    return KL(JE, t) || (JE[t] = Vte && KL(fu, t) ? fu[t] : Kte("Symbol." + t)), JE[t]
  },
  Yte = $e,
  YL = Me,
  qL = cc,
  qte = gs,
  Xte = dj,
  Qte = Fe,
  Zte = TypeError,
  Jte = Qte("toPrimitive"),
  kx = function (t, e) {
    if (!YL(t) || qL(t)) return t;
    var r = qte(t, Jte),
      n;
    if (r) {
      if (e === void 0 && (e = "default"), n = Yte(r, t, e), !YL(n) || qL(n)) return n;
      throw Zte("Can't convert object to primitive value")
    }
    return e === void 0 && (e = "number"), Xte(t, e)
  },
  ere = kx,
  tre = cc,
  Ho = function (t) {
    var e = ere(t, "string");
    return tre(e) ? e : e + ""
  },
  rre = he,
  XL = Me,
  t2 = rre.document,
  nre = XL(t2) && XL(t2.createElement),
  Ox = function (t) {
    return nre ? t2.createElement(t) : {}
  },
  ire = _e,
  are = re,
  sre = Ox,
  hj = !ire && !are(function () {
    return Object.defineProperty(sre("div"), "a", {
      get: function () {
        return 7
      }
    }).a != 7
  }),
  ore = _e,
  lre = $e,
  cre = _p,
  ure = ri,
  fre = qt,
  dre = Ho,
  hre = He,
  pre = hj,
  QL = Object.getOwnPropertyDescriptor;
ar.f = ore ? QL : function (e, r) {
  if (e = fre(e), r = dre(r), pre) try {
    return QL(e, r)
  } catch {}
  if (hre(e, r)) return ure(!lre(cre.f, e, r), e[r])
};
var pt = {},
  gre = _e,
  mre = re,
  pj = gre && mre(function () {
    return Object.defineProperty(function () {}, "prototype", {
      value: 42,
      writable: !1
    }).prototype != 42
  }),
  vre = Me,
  yre = String,
  xre = TypeError,
  Ie = function (t) {
    if (vre(t)) return t;
    throw xre(yre(t) + " is not an object")
  },
  bre = _e,
  Ere = hj,
  Sre = pj,
  Bg = Ie,
  ZL = Ho,
  _re = TypeError,
  eS = Object.defineProperty,
  Tre = Object.getOwnPropertyDescriptor,
  tS = "enumerable",
  rS = "configurable",
  nS = "writable";
pt.f = bre ? Sre ? function (e, r, n) {
  if (Bg(e), r = ZL(r), Bg(n), typeof e == "function" && r === "prototype" && "value" in n && nS in n && !n[nS]) {
    var i = Tre(e, r);
    i && i[nS] && (e[r] = n.value, n = {
      configurable: rS in n ? n[rS] : i[rS],
      enumerable: tS in n ? n[tS] : i[tS],
      writable: !1
    })
  }
  return eS(e, r, n)
} : eS : function (e, r, n) {
  if (Bg(e), r = ZL(r), Bg(n), Ere) try {
    return eS(e, r, n)
  } catch {}
  if ("get" in n || "set" in n) throw _re("Accessors not supported");
  return "value" in n && (e[r] = n.value), e
};
var wre = _e,
  Rre = pt,
  Are = ri,
  Pr = wre ? function (t, e, r) {
    return Rre.f(t, e, Are(1, r))
  } : function (t, e, r) {
    return t[e] = r, t
  },
  g0 = {},
  Ire = {
    get exports() {
      return g0
    },
    set exports(t) {
      g0 = t
    }
  },
  r2 = _e,
  $re = He,
  gj = Function.prototype,
  Cre = r2 && Object.getOwnPropertyDescriptor,
  GI = $re(gj, "name"),
  kre = GI && function () {}.name === "something",
  Ore = GI && (!r2 || r2 && Cre(gj, "name").configurable),
  Hf = {
    EXISTS: GI,
    PROPER: kre,
    CONFIGURABLE: Ore
  },
  Lre = ie,
  Pre = De,
  n2 = zI,
  Nre = Lre(Function.toString);
Pre(n2.inspectSource) || (n2.inspectSource = function (t) {
  return Nre(t)
});
var VI = n2.inspectSource,
  Dre = he,
  Mre = De,
  JL = Dre.WeakMap,
  mj = Mre(JL) && /native code/.test(String(JL)),
  Fre = wo,
  Bre = jf,
  eP = Fre("keys"),
  Lx = function (t) {
    return eP[t] || (eP[t] = Bre(t))
  },
  Tp = {},
  Ure = mj,
  vj = he,
  jre = Me,
  Hre = Pr,
  iS = He,
  aS = zI,
  zre = Lx,
  Gre = Tp,
  tP = "Object already initialized",
  i2 = vj.TypeError,
  Vre = vj.WeakMap,
  dy, m0, hy, Wre = function (t) {
    return hy(t) ? m0(t) : dy(t, {})
  },
  Kre = function (t) {
    return function (e) {
      var r;
      if (!jre(e) || (r = m0(e)).type !== t) throw i2("Incompatible receiver, " + t + " required");
      return r
    }
  };
if (Ure || aS.state) {
  var Wi = aS.state || (aS.state = new Vre);
  Wi.get = Wi.get, Wi.has = Wi.has, Wi.set = Wi.set, dy = function (t, e) {
    if (Wi.has(t)) throw i2(tP);
    return e.facade = t, Wi.set(t, e), e
  }, m0 = function (t) {
    return Wi.get(t) || {}
  }, hy = function (t) {
    return Wi.has(t)
  }
} else {
  var Cc = zre("state");
  Gre[Cc] = !0, dy = function (t, e) {
    if (iS(t, Cc)) throw i2(tP);
    return e.facade = t, Hre(t, Cc, e), e
  }, m0 = function (t) {
    return iS(t, Cc) ? t[Cc] : {}
  }, hy = function (t) {
    return iS(t, Cc)
  }
}
var Mt = {
    set: dy,
    get: m0,
    has: hy,
    enforce: Wre,
    getterFor: Kre
  },
  WI = ie,
  Yre = re,
  qre = De,
  Ug = He,
  a2 = _e,
  Xre = Hf.CONFIGURABLE,
  Qre = VI,
  yj = Mt,
  Zre = yj.enforce,
  Jre = yj.get,
  rP = String,
  Sv = Object.defineProperty,
  ene = WI("".slice),
  tne = WI("".replace),
  rne = WI([].join),
  nne = a2 && !Yre(function () {
    return Sv(function () {}, "length", {
      value: 8
    }).length !== 8
  }),
  ine = String(String).split("String"),
  ane = Ire.exports = function (t, e, r) {
    ene(rP(e), 0, 7) === "Symbol(" && (e = "[" + tne(rP(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (e = "get " + e), r && r.setter && (e = "set " + e), (!Ug(t, "name") || Xre && t.name !== e) && (a2 ? Sv(t, "name", {
      value: e,
      configurable: !0
    }) : t.name = e), nne && r && Ug(r, "arity") && t.length !== r.arity && Sv(t, "length", {
      value: r.arity
    });
    try {
      r && Ug(r, "constructor") && r.constructor ? a2 && Sv(t, "prototype", {
        writable: !1
      }) : t.prototype && (t.prototype = void 0)
    } catch {}
    var n = Zre(t);
    return Ug(n, "source") || (n.source = rne(ine, typeof e == "string" ? e : "")), t
  };
Function.prototype.toString = ane(function () {
  return qre(this) && Jre(this).source || Qre(this)
}, "toString");
var sne = De,
  one = pt,
  lne = g0,
  cne = HI,
  _t = function (t, e, r, n) {
    n || (n = {});
    var i = n.enumerable,
      a = n.name !== void 0 ? n.name : e;
    if (sne(r) && lne(r, a, n), n.global) i ? t[e] = r : cne(e, r);
    else {
      try {
        n.unsafe ? t[e] && (i = !0) : delete t[e]
      } catch {}
      i ? t[e] = r : one.f(t, e, {
        value: r,
        enumerable: !1,
        configurable: !n.nonConfigurable,
        writable: !n.nonWritable
      })
    }
    return t
  },
  ms = {},
  une = Math.ceil,
  fne = Math.floor,
  xj = Math.trunc || function (e) {
    var r = +e;
    return (r > 0 ? fne : une)(r)
  },
  dne = xj,
  $t = function (t) {
    var e = +t;
    return e !== e || e === 0 ? 0 : dne(e)
  },
  hne = $t,
  pne = Math.max,
  gne = Math.min,
  ba = function (t, e) {
    var r = hne(t);
    return r < 0 ? pne(r + e, 0) : gne(r, e)
  },
  mne = $t,
  vne = Math.min,
  Tn = function (t) {
    return t > 0 ? vne(mne(t), 9007199254740991) : 0
  },
  yne = Tn,
  Ye = function (t) {
    return yne(t.length)
  },
  xne = qt,
  bne = ba,
  Ene = Ye,
  nP = function (t) {
    return function (e, r, n) {
      var i = xne(e),
        a = Ene(i),
        s = bne(n, a),
        o;
      if (t && r != r) {
        for (; a > s;)
          if (o = i[s++], o != o) return !0
      } else
        for (; a > s; s++)
          if ((t || s in i) && i[s] === r) return t || s || 0;
      return !t && -1
    }
  },
  wp = {
    includes: nP(!0),
    indexOf: nP(!1)
  },
  Sne = ie,
  sS = He,
  _ne = qt,
  Tne = wp.indexOf,
  wne = Tp,
  iP = Sne([].push),
  bj = function (t, e) {
    var r = _ne(t),
      n = 0,
      i = [],
      a;
    for (a in r) !sS(wne, a) && sS(r, a) && iP(i, a);
    for (; e.length > n;) sS(r, a = e[n++]) && (~Tne(i, a) || iP(i, a));
    return i
  },
  KI = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
  Rne = bj,
  Ane = KI,
  Ine = Ane.concat("length", "prototype");
ms.f = Object.getOwnPropertyNames || function (e) {
  return Rne(e, Ine)
};
var Rp = {};
Rp.f = Object.getOwnPropertySymbols;
var $ne = ht,
  Cne = ie,
  kne = ms,
  One = Rp,
  Lne = Ie,
  Pne = Cne([].concat),
  YI = $ne("Reflect", "ownKeys") || function (e) {
    var r = kne.f(Lne(e)),
      n = One.f;
    return n ? Pne(r, n(e)) : r
  },
  aP = He,
  Nne = YI,
  Dne = ar,
  Mne = pt,
  Px = function (t, e, r) {
    for (var n = Nne(e), i = Mne.f, a = Dne.f, s = 0; s < n.length; s++) {
      var o = n[s];
      !aP(t, o) && !(r && aP(r, o)) && i(t, o, a(e, o))
    }
  },
  Fne = re,
  Bne = De,
  Une = /#|\.prototype\./,
  Ap = function (t, e) {
    var r = Hne[jne(t)];
    return r == Gne ? !0 : r == zne ? !1 : Bne(e) ? Fne(e) : !!e
  },
  jne = Ap.normalize = function (t) {
    return String(t).replace(Une, ".").toLowerCase()
  },
  Hne = Ap.data = {},
  zne = Ap.NATIVE = "N",
  Gne = Ap.POLYFILL = "P",
  Ip = Ap,
  oS = he,
  Vne = ar.f,
  Wne = Pr,
  Kne = _t,
  Yne = HI,
  qne = Px,
  Xne = Ip,
  j = function (t, e) {
    var r = t.target,
      n = t.global,
      i = t.stat,
      a, s, o, c, l, u;
    if (n ? s = oS : i ? s = oS[r] || Yne(r, {}) : s = (oS[r] || {}).prototype, s)
      for (o in e) {
        if (l = e[o], t.dontCallGetSet ? (u = Vne(s, o), c = u && u.value) : c = s[o], a = Xne(n ? o : r + (i ? "." : "#") + o, t.forced), !a && c !== void 0) {
          if (typeof l == typeof c) continue;
          qne(l, c)
        }(t.sham || c && c.sham) && Wne(l, "sham", !0), Kne(s, o, l, t)
      }
  },
  Qne = Fe,
  Zne = Qne("toStringTag"),
  Ej = {};
Ej[Zne] = "z";
var qI = String(Ej) === "[object z]",
  Jne = qI,
  eie = De,
  _v = Lr,
  tie = Fe,
  rie = tie("toStringTag"),
  nie = Object,
  iie = _v(function () {
    return arguments
  }()) == "Arguments",
  aie = function (t, e) {
    try {
      return t[e]
    } catch {}
  },
  Ea = Jne ? _v : function (t) {
    var e, r, n;
    return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (r = aie(e = nie(t), rie)) == "string" ? r : iie ? _v(e) : (n = _v(e)) == "Object" && eie(e.callee) ? "Arguments" : n
  },
  sie = Ea,
  oie = String,
  Ce = function (t) {
    if (sie(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
    return oie(t)
  },
  Nx = {},
  lie = bj,
  cie = KI,
  $p = Object.keys || function (e) {
    return lie(e, cie)
  },
  uie = _e,
  fie = pj,
  die = pt,
  hie = Ie,
  pie = qt,
  gie = $p;
Nx.f = uie && !fie ? Object.defineProperties : function (e, r) {
  hie(e);
  for (var n = pie(r), i = gie(r), a = i.length, s = 0, o; a > s;) die.f(e, o = i[s++], n[o]);
  return e
};
var mie = ht,
  Sj = mie("document", "documentElement"),
  vie = Ie,
  yie = Nx,
  sP = KI,
  xie = Tp,
  bie = Sj,
  Eie = Ox,
  Sie = Lx,
  oP = ">",
  lP = "<",
  s2 = "prototype",
  o2 = "script",
  _j = Sie("IE_PROTO"),
  lS = function () {},
  Tj = function (t) {
    return lP + o2 + oP + t + lP + "/" + o2 + oP
  },
  cP = function (t) {
    t.write(Tj("")), t.close();
    var e = t.parentWindow.Object;
    return t = null, e
  },
  _ie = function () {
    var t = Eie("iframe"),
      e = "java" + o2 + ":",
      r;
    return t.style.display = "none", bie.appendChild(t), t.src = String(e), r = t.contentWindow.document, r.open(), r.write(Tj("document.F=Object")), r.close(), r.F
  },
  jg, Tv = function () {
    try {
      jg = new ActiveXObject("htmlfile")
    } catch {}
    Tv = typeof document < "u" ? document.domain && jg ? cP(jg) : _ie() : cP(jg);
    for (var t = sP.length; t--;) delete Tv[s2][sP[t]];
    return Tv()
  };
xie[_j] = !0;
var ii = Object.create || function (e, r) {
    var n;
    return e !== null ? (lS[s2] = vie(e), n = new lS, lS[s2] = null, n[_j] = e) : n = Tv(), r === void 0 ? n : yie.f(n, r)
  },
  Dx = {},
  Tie = Ho,
  wie = pt,
  Rie = ri,
  vs = function (t, e, r) {
    var n = Tie(e);
    n in t ? wie.f(t, n, Rie(0, r)) : t[n] = r
  },
  uP = ba,
  Aie = Ye,
  Iie = vs,
  $ie = Array,
  Cie = Math.max,
  Cp = function (t, e, r) {
    for (var n = Aie(t), i = uP(e, n), a = uP(r === void 0 ? n : r, n), s = $ie(Cie(a - i, 0)), o = 0; i < a; i++, o++) Iie(s, o, t[i]);
    return s.length = o, s
  },
  kie = Lr,
  Oie = qt,
  wj = ms.f,
  Lie = Cp,
  Rj = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
  Pie = function (t) {
    try {
      return wj(t)
    } catch {
      return Lie(Rj)
    }
  };
Dx.f = function (e) {
  return Rj && kie(e) == "Window" ? Pie(e) : wj(Oie(e))
};
var fP = g0,
  Nie = pt,
  sr = function (t, e, r) {
    return r.get && fP(r.get, e, {
      getter: !0
    }), r.set && fP(r.set, e, {
      setter: !0
    }), Nie.f(t, e, r)
  },
  XI = {},
  Die = Fe;
XI.f = Die;
var Mie = he,
  QI = Mie,
  dP = QI,
  Fie = He,
  Bie = XI,
  Uie = pt.f,
  ln = function (t) {
    var e = dP.Symbol || (dP.Symbol = {});
    Fie(e, t) || Uie(e, t, {
      value: Bie.f(t)
    })
  },
  jie = $e,
  Hie = ht,
  zie = Fe,
  Gie = _t,
  Aj = function () {
    var t = Hie("Symbol"),
      e = t && t.prototype,
      r = e && e.valueOf,
      n = zie("toPrimitive");
    e && !e[n] && Gie(e, n, function (i) {
      return jie(r, this)
    }, {
      arity: 1
    })
  },
  Vie = pt.f,
  Wie = He,
  Kie = Fe,
  hP = Kie("toStringTag"),
  wn = function (t, e, r) {
    t && !r && (t = t.prototype), t && !Wie(t, hP) && Vie(t, hP, {
      configurable: !0,
      value: e
    })
  },
  Yie = Lr,
  qie = ie,
  zo = function (t) {
    if (Yie(t) === "Function") return qie(t)
  },
  pP = zo,
  Xie = It,
  Qie = Sp,
  Zie = pP(pP.bind),
  Ni = function (t, e) {
    return Xie(t), e === void 0 ? t : Qie ? Zie(t, e) : function () {
      return t.apply(e, arguments)
    }
  },
  Jie = Lr,
  Go = Array.isArray || function (e) {
    return Jie(e) == "Array"
  },
  eae = ie,
  tae = re,
  Ij = De,
  rae = Ea,
  nae = ht,
  iae = VI,
  $j = function () {},
  aae = [],
  Cj = nae("Reflect", "construct"),
  ZI = /^\s*(?:class|function)\b/,
  sae = eae(ZI.exec),
  oae = !ZI.exec($j),
  Td = function (e) {
    if (!Ij(e)) return !1;
    try {
      return Cj($j, aae, e), !0
    } catch {
      return !1
    }
  },
  kj = function (e) {
    if (!Ij(e)) return !1;
    switch (rae(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    try {
      return oae || !!sae(ZI, iae(e))
    } catch {
      return !0
    }
  };
kj.sham = !0;
var zf = !Cj || tae(function () {
    var t;
    return Td(Td.call) || !Td(Object) || !Td(function () {
      t = !0
    }) || t
  }) ? kj : Td,
  gP = Go,
  lae = zf,
  cae = Me,
  uae = Fe,
  fae = uae("species"),
  mP = Array,
  dae = function (t) {
    var e;
    return gP(t) && (e = t.constructor, lae(e) && (e === mP || gP(e.prototype)) ? e = void 0 : cae(e) && (e = e[fae], e === null && (e = void 0))), e === void 0 ? mP : e
  },
  hae = dae,
  kp = function (t, e) {
    return new(hae(t))(e === 0 ? 0 : e)
  },
  pae = Ni,
  gae = ie,
  mae = Bf,
  vae = We,
  yae = Ye,
  xae = kp,
  vP = gae([].push),
  Cs = function (t) {
    var e = t == 1,
      r = t == 2,
      n = t == 3,
      i = t == 4,
      a = t == 6,
      s = t == 7,
      o = t == 5 || a;
    return function (c, l, u, f) {
      for (var d = vae(c), h = mae(d), p = pae(l, u), v = yae(h), g = 0, m = f || xae, y = e ? m(c, v) : r || s ? m(c, 0) : void 0, x, b; v > g; g++)
        if ((o || g in h) && (x = h[g], b = p(x, g, d), t))
          if (e) y[g] = b;
          else if (b) switch (t) {
        case 3:
          return !0;
        case 5:
          return x;
        case 6:
          return g;
        case 2:
          vP(y, x)
      } else switch (t) {
        case 4:
          return !1;
        case 7:
          vP(y, x)
      }
      return a ? -1 : n || i ? i : y
    }
  },
  or = {
    forEach: Cs(0),
    map: Cs(1),
    filter: Cs(2),
    some: Cs(3),
    every: Cs(4),
    find: Cs(5),
    findIndex: Cs(6),
    filterReject: Cs(7)
  },
  Mx = j,
  JI = he,
  e$ = $e,
  bae = ie,
  af = _e,
  sf = Uf,
  Eae = re,
  Gt = He,
  Sae = ni,
  l2 = Ie,
  Fx = qt,
  t$ = Ho,
  _ae = Ce,
  c2 = ri,
  v0 = ii,
  Oj = $p,
  Tae = ms,
  Lj = Dx,
  wae = Rp,
  Pj = ar,
  Nj = pt,
  Rae = Nx,
  Dj = _p,
  cS = _t,
  Aae = sr,
  r$ = wo,
  Iae = Lx,
  Mj = Tp,
  yP = jf,
  $ae = Fe,
  Cae = XI,
  kae = ln,
  Oae = Aj,
  Lae = wn,
  Fj = Mt,
  Bx = or.forEach,
  Yr = Iae("hidden"),
  Ux = "Symbol",
  y0 = "prototype",
  Pae = Fj.set,
  xP = Fj.getterFor(Ux),
  qn = Object[y0],
  Ml = JI.Symbol,
  ph = Ml && Ml[y0],
  Nae = JI.TypeError,
  uS = JI.QObject,
  Bj = Pj.f,
  El = Nj.f,
  Uj = Lj.f,
  Dae = Dj.f,
  jj = bae([].push),
  is = r$("symbols"),
  Op = r$("op-symbols"),
  Mae = r$("wks"),
  u2 = !uS || !uS[y0] || !uS[y0].findChild,
  f2 = af && Eae(function () {
    return v0(El({}, "a", {
      get: function () {
        return El(this, "a", {
          value: 7
        }).a
      }
    })).a != 7
  }) ? function (t, e, r) {
    var n = Bj(qn, e);
    n && delete qn[e], El(t, e, r), n && t !== qn && El(qn, e, n)
  } : El,
  fS = function (t, e) {
    var r = is[t] = v0(ph);
    return Pae(r, {
      type: Ux,
      tag: t,
      description: e
    }), af || (r.description = e), r
  },
  jx = function (e, r, n) {
    e === qn && jx(Op, r, n), l2(e);
    var i = t$(r);
    return l2(n), Gt(is, i) ? (n.enumerable ? (Gt(e, Yr) && e[Yr][i] && (e[Yr][i] = !1), n = v0(n, {
      enumerable: c2(0, !1)
    })) : (Gt(e, Yr) || El(e, Yr, c2(1, {})), e[Yr][i] = !0), f2(e, i, n)) : El(e, i, n)
  },
  n$ = function (e, r) {
    l2(e);
    var n = Fx(r),
      i = Oj(n).concat(Gj(n));
    return Bx(i, function (a) {
      (!af || e$(d2, n, a)) && jx(e, a, n[a])
    }), e
  },
  Fae = function (e, r) {
    return r === void 0 ? v0(e) : n$(v0(e), r)
  },
  d2 = function (e) {
    var r = t$(e),
      n = e$(Dae, this, r);
    return this === qn && Gt(is, r) && !Gt(Op, r) ? !1 : n || !Gt(this, r) || !Gt(is, r) || Gt(this, Yr) && this[Yr][r] ? n : !0
  },
  Hj = function (e, r) {
    var n = Fx(e),
      i = t$(r);
    if (!(n === qn && Gt(is, i) && !Gt(Op, i))) {
      var a = Bj(n, i);
      return a && Gt(is, i) && !(Gt(n, Yr) && n[Yr][i]) && (a.enumerable = !0), a
    }
  },
  zj = function (e) {
    var r = Uj(Fx(e)),
      n = [];
    return Bx(r, function (i) {
      !Gt(is, i) && !Gt(Mj, i) && jj(n, i)
    }), n
  },
  Gj = function (t) {
    var e = t === qn,
      r = Uj(e ? Op : Fx(t)),
      n = [];
    return Bx(r, function (i) {
      Gt(is, i) && (!e || Gt(qn, i)) && jj(n, is[i])
    }), n
  };
sf || (Ml = function () {
  if (Sae(ph, this)) throw Nae("Symbol is not a constructor");
  var e = !arguments.length || arguments[0] === void 0 ? void 0 : _ae(arguments[0]),
    r = yP(e),
    n = function (i) {
      this === qn && e$(n, Op, i), Gt(this, Yr) && Gt(this[Yr], r) && (this[Yr][r] = !1), f2(this, r, c2(1, i))
    };
  return af && u2 && f2(qn, r, {
    configurable: !0,
    set: n
  }), fS(r, e)
}, ph = Ml[y0], cS(ph, "toString", function () {
  return xP(this).tag
}), cS(Ml, "withoutSetter", function (t) {
  return fS(yP(t), t)
}), Dj.f = d2, Nj.f = jx, Rae.f = n$, Pj.f = Hj, Tae.f = Lj.f = zj, wae.f = Gj, Cae.f = function (t) {
  return fS($ae(t), t)
}, af && (Aae(ph, "description", {
  configurable: !0,
  get: function () {
    return xP(this).description
  }
}), cS(qn, "propertyIsEnumerable", d2, {
  unsafe: !0
})));
Mx({
  global: !0,
  constructor: !0,
  wrap: !0,
  forced: !sf,
  sham: !sf
}, {
  Symbol: Ml
});
Bx(Oj(Mae), function (t) {
  kae(t)
});
Mx({
  target: Ux,
  stat: !0,
  forced: !sf
}, {
  useSetter: function () {
    u2 = !0
  },
  useSimple: function () {
    u2 = !1
  }
});
Mx({
  target: "Object",
  stat: !0,
  forced: !sf,
  sham: !af
}, {
  create: Fae,
  defineProperty: jx,
  defineProperties: n$,
  getOwnPropertyDescriptor: Hj
});
Mx({
  target: "Object",
  stat: !0,
  forced: !sf
}, {
  getOwnPropertyNames: zj
});
Oae();
Lae(Ml, Ux);
Mj[Yr] = !0;
var Bae = Uf,
  Vj = Bae && !!Symbol.for && !!Symbol.keyFor,
  Uae = j,
  jae = ht,
  Hae = He,
  zae = Ce,
  Wj = wo,
  Gae = Vj,
  dS = Wj("string-to-symbol-registry"),
  Vae = Wj("symbol-to-string-registry");
Uae({
  target: "Symbol",
  stat: !0,
  forced: !Gae
}, {
  for: function (t) {
    var e = zae(t);
    if (Hae(dS, e)) return dS[e];
    var r = jae("Symbol")(e);
    return dS[e] = r, Vae[r] = e, r
  }
});
var Wae = j,
  Kae = He,
  Yae = cc,
  qae = uc,
  Xae = wo,
  Qae = Vj,
  bP = Xae("symbol-to-string-registry");
Wae({
  target: "Symbol",
  stat: !0,
  forced: !Qae
}, {
  keyFor: function (e) {
    if (!Yae(e)) throw TypeError(qae(e) + " is not a symbol");
    if (Kae(bP, e)) return bP[e]
  }
});
var Zae = Sp,
  Kj = Function.prototype,
  EP = Kj.apply,
  SP = Kj.call,
  ai = typeof Reflect == "object" && Reflect.apply || (Zae ? SP.bind(EP) : function () {
    return SP.apply(EP, arguments)
  }),
  Jae = ie,
  fc = Jae([].slice),
  ese = ie,
  _P = Go,
  tse = De,
  TP = Lr,
  rse = Ce,
  wP = ese([].push),
  nse = function (t) {
    if (tse(t)) return t;
    if (_P(t)) {
      for (var e = t.length, r = [], n = 0; n < e; n++) {
        var i = t[n];
        typeof i == "string" ? wP(r, i) : (typeof i == "number" || TP(i) == "Number" || TP(i) == "String") && wP(r, rse(i))
      }
      var a = r.length,
        s = !0;
      return function (o, c) {
        if (s) return s = !1, c;
        if (_P(this)) return c;
        for (var l = 0; l < a; l++)
          if (r[l] === o) return c
      }
    }
  },
  ise = j,
  Yj = ht,
  qj = ai,
  ase = $e,
  Lp = ie,
  Xj = re,
  RP = De,
  AP = cc,
  Qj = fc,
  sse = nse,
  ose = Uf,
  lse = String,
  so = Yj("JSON", "stringify"),
  Hg = Lp(/./.exec),
  IP = Lp("".charAt),
  cse = Lp("".charCodeAt),
  use = Lp("".replace),
  fse = Lp(1.toString),
  dse = /[\uD800-\uDFFF]/g,
  $P = /^[\uD800-\uDBFF]$/,
  CP = /^[\uDC00-\uDFFF]$/,
  kP = !ose || Xj(function () {
    var t = Yj("Symbol")();
    return so([t]) != "[null]" || so({
      a: t
    }) != "{}" || so(Object(t)) != "{}"
  }),
  OP = Xj(function () {
    return so("\uDF06\uD834") !== '"\\udf06\\ud834"' || so("\uDEAD") !== '"\\udead"'
  }),
  hse = function (t, e) {
    var r = Qj(arguments),
      n = sse(e);
    if (!(!RP(n) && (t === void 0 || AP(t)))) return r[1] = function (i, a) {
      if (RP(n) && (a = ase(n, this, lse(i), a)), !AP(a)) return a
    }, qj(so, null, r)
  },
  pse = function (t, e, r) {
    var n = IP(r, e - 1),
      i = IP(r, e + 1);
    return Hg($P, t) && !Hg(CP, i) || Hg(CP, t) && !Hg($P, n) ? "\\u" + fse(cse(t, 0), 16) : t
  };
so && ise({
  target: "JSON",
  stat: !0,
  arity: 3,
  forced: kP || OP
}, {
  stringify: function (e, r, n) {
    var i = Qj(arguments),
      a = qj(kP ? hse : so, null, i);
    return OP && typeof a == "string" ? use(a, dse, pse) : a
  }
});
var gse = j,
  mse = Uf,
  vse = re,
  Zj = Rp,
  yse = We,
  xse = !mse || vse(function () {
    Zj.f(1)
  });
gse({
  target: "Object",
  stat: !0,
  forced: xse
}, {
  getOwnPropertySymbols: function (e) {
    var r = Zj.f;
    return r ? r(yse(e)) : []
  }
});
var bse = j,
  Ese = _e,
  Sse = he,
  zg = ie,
  _se = He,
  Tse = De,
  wse = ni,
  Rse = Ce,
  Ase = sr,
  Ise = Px,
  Ma = Sse.Symbol,
  al = Ma && Ma.prototype;
if (Ese && Tse(Ma) && (!("description" in al) || Ma().description !== void 0)) {
  var LP = {},
    Gg = function () {
      var e = arguments.length < 1 || arguments[0] === void 0 ? void 0 : Rse(arguments[0]),
        r = wse(al, this) ? new Ma(e) : e === void 0 ? Ma() : Ma(e);
      return e === "" && (LP[r] = !0), r
    };
  Ise(Gg, Ma), Gg.prototype = al, al.constructor = Gg;
  var $se = String(Ma("test")) == "Symbol(test)",
    Cse = zg(al.valueOf),
    kse = zg(al.toString),
    Ose = /^Symbol\((.*)\)[^)]+$/,
    Lse = zg("".replace),
    Pse = zg("".slice);
  Ase(al, "description", {
    configurable: !0,
    get: function () {
      var e = Cse(this);
      if (_se(LP, e)) return "";
      var r = kse(e),
        n = $se ? Pse(r, 7, -1) : Lse(r, Ose, "$1");
      return n === "" ? void 0 : n
    }
  }), bse({
    global: !0,
    constructor: !0,
    forced: !0
  }, {
    Symbol: Gg
  })
}
var Nse = ln;
Nse("asyncIterator");
var Dse = ln;
Dse("hasInstance");
var Mse = ln;
Mse("isConcatSpreadable");
var Fse = ln;
Fse("iterator");
var Bse = ln;
Bse("match");
var Use = ln;
Use("matchAll");
var jse = ln;
jse("replace");
var Hse = ln;
Hse("search");
var zse = ln;
zse("species");
var Gse = ln;
Gse("split");
var Vse = ln,
  Wse = Aj;
Vse("toPrimitive");
Wse();
var Kse = ht,
  Yse = ln,
  qse = wn;
Yse("toStringTag");
qse(Kse("Symbol"), "Symbol");
var Xse = ln;
Xse("unscopables");
var Qse = ie,
  Zse = It,
  Jse = function (t, e, r) {
    try {
      return Qse(Zse(Object.getOwnPropertyDescriptor(t, e)[r]))
    } catch {}
  },
  eoe = De,
  toe = String,
  roe = TypeError,
  Jj = function (t) {
    if (typeof t == "object" || eoe(t)) return t;
    throw roe("Can't set " + toe(t) + " as a prototype")
  },
  noe = Jse,
  ioe = Ie,
  aoe = Jj,
  Sa = Object.setPrototypeOf || ("__proto__" in {} ? function () {
    var t = !1,
      e = {},
      r;
    try {
      r = noe(Object.prototype, "__proto__", "set"), r(e, []), t = e instanceof Array
    } catch {}
    return function (i, a) {
      return ioe(i), aoe(a), t ? r(i, a) : i.__proto__ = a, i
    }
  }() : void 0),
  soe = pt.f,
  eH = function (t, e, r) {
    r in t || soe(t, r, {
      configurable: !0,
      get: function () {
        return e[r]
      },
      set: function (n) {
        e[r] = n
      }
    })
  },
  ooe = De,
  loe = Me,
  PP = Sa,
  Gf = function (t, e, r) {
    var n, i;
    return PP && ooe(n = e.constructor) && n !== r && loe(i = n.prototype) && i !== r.prototype && PP(t, i), t
  },
  coe = Ce,
  Pp = function (t, e) {
    return t === void 0 ? arguments.length < 2 ? "" : e : coe(t)
  },
  uoe = Me,
  foe = Pr,
  tH = function (t, e) {
    uoe(e) && "cause" in e && foe(t, "cause", e.cause)
  },
  doe = ie,
  rH = Error,
  hoe = doe("".replace),
  poe = function (t) {
    return String(rH(t).stack)
  }("zxcasd"),
  nH = /\n\s*at [^:]*:[^\n]*/,
  goe = nH.test(poe),
  i$ = function (t, e) {
    if (goe && typeof t == "string" && !rH.prepareStackTrace)
      for (; e--;) t = hoe(t, nH, "");
    return t
  },
  moe = re,
  voe = ri,
  iH = !moe(function () {
    var t = Error("a");
    return "stack" in t ? (Object.defineProperty(t, "stack", voe(1, 7)), t.stack !== 7) : !0
  }),
  yoe = Pr,
  xoe = i$,
  boe = iH,
  NP = Error.captureStackTrace,
  aH = function (t, e, r, n) {
    boe && (NP ? NP(t, e) : yoe(t, "stack", xoe(r, n)))
  },
  DP = ht,
  Eoe = He,
  MP = Pr,
  Soe = ni,
  FP = Sa,
  BP = Px,
  UP = eH,
  _oe = Gf,
  Toe = Pp,
  woe = tH,
  Roe = aH,
  Aoe = _e,
  sH = function (t, e, r, n) {
    var i = "stackTraceLimit",
      a = n ? 2 : 1,
      s = t.split("."),
      o = s[s.length - 1],
      c = DP.apply(null, s);
    if (c) {
      var l = c.prototype;
      if (Eoe(l, "cause") && delete l.cause, !r) return c;
      var u = DP("Error"),
        f = e(function (d, h) {
          var p = Toe(n ? h : d, void 0),
            v = n ? new c(d) : new c;
          return p !== void 0 && MP(v, "message", p), Roe(v, f, v.stack, 2), this && Soe(l, this) && _oe(v, this, f), arguments.length > a && woe(v, arguments[a]), v
        });
      f.prototype = l, o !== "Error" ? FP ? FP(f, u) : BP(f, u, {
        name: !0
      }) : Aoe && i in c && (UP(f, c, i), UP(f, c, "prepareStackTrace")), BP(f, c);
      try {
        l.name !== o && MP(l, "name", o), l.constructor = f
      } catch {}
      return f
    }
  },
  oH = j,
  Ioe = he,
  _a = ai,
  lH = sH,
  h2 = "WebAssembly",
  jP = Ioe[h2],
  py = Error("e", {
    cause: 7
  }).cause !== 7,
  dc = function (t, e) {
    var r = {};
    r[t] = lH(t, e, py), oH({
      global: !0,
      constructor: !0,
      arity: 1,
      forced: py
    }, r)
  },
  a$ = function (t, e) {
    if (jP && jP[t]) {
      var r = {};
      r[t] = lH(h2 + "." + t, e, py), oH({
        target: h2,
        stat: !0,
        constructor: !0,
        arity: 1,
        forced: py
      }, r)
    }
  };
dc("Error", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("EvalError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("RangeError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("ReferenceError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("SyntaxError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("TypeError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
dc("URIError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
a$("CompileError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
a$("LinkError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
a$("RuntimeError", function (t) {
  return function (r) {
    return _a(t, this, arguments)
  }
});
var $oe = _e,
  Coe = re,
  koe = Ie,
  Ooe = ii,
  HP = Pp,
  wv = Error.prototype.toString,
  Loe = Coe(function () {
    if ($oe) {
      var t = Ooe(Object.defineProperty({}, "name", {
        get: function () {
          return this === t
        }
      }));
      if (wv.call(t) !== "true") return !0
    }
    return wv.call({
      message: 1,
      name: 2
    }) !== "2: 1" || wv.call({}) !== "Error"
  }),
  cH = Loe ? function () {
    var e = koe(this),
      r = HP(e.name, "Error"),
      n = HP(e.message);
    return r ? n ? r + ": " + n : r : n
  } : wv,
  Poe = _t,
  zP = cH,
  GP = Error.prototype;
GP.toString !== zP && Poe(GP, "toString", zP);
var Noe = re,
  s$ = !Noe(function () {
    function t() {}
    return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
  }),
  Doe = He,
  Moe = De,
  Foe = We,
  Boe = Lx,
  Uoe = s$,
  VP = Boe("IE_PROTO"),
  p2 = Object,
  joe = p2.prototype,
  si = Uoe ? p2.getPrototypeOf : function (t) {
    var e = Foe(t);
    if (Doe(e, VP)) return e[VP];
    var r = e.constructor;
    return Moe(r) && e instanceof r ? r.prototype : e instanceof p2 ? joe : null
  },
  Np = {},
  Hoe = Fe,
  zoe = Np,
  Goe = Hoe("iterator"),
  Voe = Array.prototype,
  o$ = function (t) {
    return t !== void 0 && (zoe.Array === t || Voe[Goe] === t)
  },
  Woe = Ea,
  WP = gs,
  Koe = on,
  Yoe = Np,
  qoe = Fe,
  Xoe = qoe("iterator"),
  Dp = function (t) {
    if (!Koe(t)) return WP(t, Xoe) || WP(t, "@@iterator") || Yoe[Woe(t)]
  },
  Qoe = $e,
  Zoe = It,
  Joe = Ie,
  ele = uc,
  tle = Dp,
  rle = TypeError,
  Hx = function (t, e) {
    var r = arguments.length < 2 ? tle(t) : e;
    if (Zoe(r)) return Joe(Qoe(r, t));
    throw rle(ele(t) + " is not iterable")
  },
  nle = $e,
  KP = Ie,
  ile = gs,
  uH = function (t, e, r) {
    var n, i;
    KP(t);
    try {
      if (n = ile(t, "return"), !n) {
        if (e === "throw") throw r;
        return r
      }
      n = nle(n, t)
    } catch (a) {
      i = !0, n = a
    }
    if (e === "throw") throw r;
    if (i) throw n;
    return KP(n), r
  },
  ale = Ni,
  sle = $e,
  ole = Ie,
  lle = uc,
  cle = o$,
  ule = Ye,
  YP = ni,
  fle = Hx,
  dle = Dp,
  qP = uH,
  hle = TypeError,
  Rv = function (t, e) {
    this.stopped = t, this.result = e
  },
  XP = Rv.prototype,
  Ta = function (t, e, r) {
    var n = r && r.that,
      i = !!(r && r.AS_ENTRIES),
      a = !!(r && r.IS_RECORD),
      s = !!(r && r.IS_ITERATOR),
      o = !!(r && r.INTERRUPTED),
      c = ale(e, n),
      l, u, f, d, h, p, v, g = function (y) {
        return l && qP(l, "normal", y), new Rv(!0, y)
      },
      m = function (y) {
        return i ? (ole(y), o ? c(y[0], y[1], g) : c(y[0], y[1])) : o ? c(y, g) : c(y)
      };
    if (a) l = t.iterator;
    else if (s) l = t;
    else {
      if (u = dle(t), !u) throw hle(lle(t) + " is not iterable");
      if (cle(u)) {
        for (f = 0, d = ule(t); d > f; f++)
          if (h = m(t[f]), h && YP(XP, h)) return h;
        return new Rv(!1)
      }
      l = fle(t, u)
    }
    for (p = a ? t.next : l.next; !(v = sle(p, l)).done;) {
      try {
        h = m(v.value)
      } catch (y) {
        qP(l, "throw", y)
      }
      if (typeof h == "object" && h && YP(XP, h)) return h
    }
    return new Rv(!1)
  },
  ple = j,
  gle = ni,
  mle = si,
  gy = Sa,
  vle = Px,
  fH = ii,
  hS = Pr,
  pS = ri,
  yle = tH,
  xle = aH,
  ble = Ta,
  Ele = Pp,
  Sle = Fe,
  _le = Sle("toStringTag"),
  my = Error,
  Tle = [].push,
  of = function (e, r) {
    var n = gle(gS, this),
      i;
    gy ? i = gy(my(), n ? mle(this) : gS) : (i = n ? this : fH(gS), hS(i, _le, "Error")), r !== void 0 && hS(i, "message", Ele(r)), xle(i, of , i.stack, 1), arguments.length > 2 && yle(i, arguments[2]);
    var a = [];
    return ble(e, Tle, {
      that: a
    }), hS(i, "errors", a), i
  };
gy ? gy( of , my) : vle( of , my, {
  name: !0
});
var gS = of .prototype = fH(my.prototype, {
  constructor: pS(1, of ),
  message: pS(1, ""),
  name: pS(1, "AggregateError")
});
ple({
  global: !0,
  constructor: !0,
  arity: 2
}, {
  AggregateError: of
});
var wle = j,
  Rle = ht,
  Ale = ai,
  QP = re,
  Ile = sH,
  l$ = "AggregateError",
  ZP = Rle(l$),
  JP = !QP(function () {
    return ZP([1]).errors[0] !== 1
  }) && QP(function () {
    return ZP([1], l$, {
      cause: 7
    }).cause !== 7
  });
wle({
  global: !0,
  constructor: !0,
  arity: 2,
  forced: JP
}, {
  AggregateError: Ile(l$, function (t) {
    return function (r, n) {
      return Ale(t, this, arguments)
    }
  }, JP, !0)
});
var $le = Fe,
  Cle = ii,
  kle = pt.f,
  g2 = $le("unscopables"),
  m2 = Array.prototype;
m2[g2] == null && kle(m2, g2, {
  configurable: !0,
  value: Cle(null)
});
var cn = function (t) {
    m2[g2][t] = !0
  },
  Ole = j,
  Lle = We,
  Ple = Ye,
  Nle = $t,
  Dle = cn;
Ole({
  target: "Array",
  proto: !0
}, {
  at: function (e) {
    var r = Lle(this),
      n = Ple(r),
      i = Nle(e),
      a = i >= 0 ? i : n + i;
    return a < 0 || a >= n ? void 0 : r[a]
  }
});
Dle("at");
var Mle = TypeError,
  Fle = 9007199254740991,
  Vf = function (t) {
    if (t > Fle) throw Mle("Maximum allowed index exceeded");
    return t
  },
  Ble = re,
  Ule = Fe,
  jle = ps,
  Hle = Ule("species"),
  Mp = function (t) {
    return jle >= 51 || !Ble(function () {
      var e = [],
        r = e.constructor = {};
      return r[Hle] = function () {
        return {
          foo: 1
        }
      }, e[t](Boolean).foo !== 1
    })
  },
  zle = j,
  Gle = re,
  Vle = Go,
  Wle = Me,
  Kle = We,
  Yle = Ye,
  eN = Vf,
  tN = vs,
  qle = kp,
  Xle = Mp,
  Qle = Fe,
  Zle = ps,
  dH = Qle("isConcatSpreadable"),
  Jle = Zle >= 51 || !Gle(function () {
    var t = [];
    return t[dH] = !1, t.concat()[0] !== t
  }),
  ece = function (t) {
    if (!Wle(t)) return !1;
    var e = t[dH];
    return e !== void 0 ? !!e : Vle(t)
  },
  tce = !Jle || !Xle("concat");
zle({
  target: "Array",
  proto: !0,
  arity: 1,
  forced: tce
}, {
  concat: function (e) {
    var r = Kle(this),
      n = qle(r, 0),
      i = 0,
      a, s, o, c, l;
    for (a = -1, o = arguments.length; a < o; a++)
      if (l = a === -1 ? r : arguments[a], ece(l))
        for (c = Yle(l), eN(i + c), s = 0; s < c; s++, i++) s in l && tN(n, i, l[s]);
      else eN(i + 1), tN(n, i++, l);
    return n.length = i, n
  }
});
var rN = uc,
  rce = TypeError,
  zx = function (t, e) {
    if (!delete t[e]) throw rce("Cannot delete property " + rN(e) + " of " + rN(t))
  },
  nce = We,
  mS = ba,
  ice = Ye,
  ace = zx,
  sce = Math.min,
  hH = [].copyWithin || function (e, r) {
    var n = nce(this),
      i = ice(n),
      a = mS(e, i),
      s = mS(r, i),
      o = arguments.length > 2 ? arguments[2] : void 0,
      c = sce((o === void 0 ? i : mS(o, i)) - s, i - a),
      l = 1;
    for (s < a && a < s + c && (l = -1, s += c - 1, a += c - 1); c-- > 0;) s in n ? n[a] = n[s] : ace(n, a), a += l, s += l;
    return n
  },
  oce = j,
  lce = hH,
  cce = cn;
oce({
  target: "Array",
  proto: !0
}, {
  copyWithin: lce
});
cce("copyWithin");
var uce = re,
  ys = function (t, e) {
    var r = [][t];
    return !!r && uce(function () {
      r.call(null, e || function () {
        return 1
      }, 1)
    })
  },
  fce = j,
  dce = or.every,
  hce = ys,
  pce = hce("every");
fce({
  target: "Array",
  proto: !0,
  forced: !pce
}, {
  every: function (e) {
    return dce(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var gce = We,
  nN = ba,
  mce = Ye,
  c$ = function (e) {
    for (var r = gce(this), n = mce(r), i = arguments.length, a = nN(i > 1 ? arguments[1] : void 0, n), s = i > 2 ? arguments[2] : void 0, o = s === void 0 ? n : nN(s, n); o > a;) r[a++] = e;
    return r
  },
  vce = j,
  yce = c$,
  xce = cn;
vce({
  target: "Array",
  proto: !0
}, {
  fill: yce
});
xce("fill");
var bce = j,
  Ece = or.filter,
  Sce = Mp,
  _ce = Sce("filter");
bce({
  target: "Array",
  proto: !0,
  forced: !_ce
}, {
  filter: function (e) {
    return Ece(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var Tce = j,
  wce = or.find,
  Rce = cn,
  v2 = "find",
  pH = !0;
v2 in [] && Array(1)[v2](function () {
  pH = !1
});
Tce({
  target: "Array",
  proto: !0,
  forced: pH
}, {
  find: function (e) {
    return wce(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
Rce(v2);
var Ace = j,
  Ice = or.findIndex,
  $ce = cn,
  y2 = "findIndex",
  gH = !0;
y2 in [] && Array(1)[y2](function () {
  gH = !1
});
Ace({
  target: "Array",
  proto: !0,
  forced: gH
}, {
  findIndex: function (e) {
    return Ice(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
$ce(y2);
var Cce = Ni,
  kce = Bf,
  Oce = We,
  Lce = Ye,
  iN = function (t) {
    var e = t == 1;
    return function (r, n, i) {
      for (var a = Oce(r), s = kce(a), o = Cce(n, i), c = Lce(s), l, u; c-- > 0;)
        if (l = s[c], u = o(l, c, a), u) switch (t) {
          case 0:
            return l;
          case 1:
            return c
        }
      return e ? -1 : void 0
    }
  },
  Gx = {
    findLast: iN(0),
    findLastIndex: iN(1)
  },
  Pce = j,
  Nce = Gx.findLast,
  Dce = cn;
Pce({
  target: "Array",
  proto: !0
}, {
  findLast: function (e) {
    return Nce(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
Dce("findLast");
var Mce = j,
  Fce = Gx.findLastIndex,
  Bce = cn;
Mce({
  target: "Array",
  proto: !0
}, {
  findLastIndex: function (e) {
    return Fce(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
Bce("findLastIndex");
var Uce = Go,
  jce = Ye,
  Hce = Vf,
  zce = Ni,
  mH = function (t, e, r, n, i, a, s, o) {
    for (var c = i, l = 0, u = s ? zce(s, o) : !1, f, d; l < n;) l in r && (f = u ? u(r[l], l, e) : r[l], a > 0 && Uce(f) ? (d = jce(f), c = mH(t, e, f, d, c, a - 1) - 1) : (Hce(c + 1), t[c] = f), c++), l++;
    return c
  },
  vH = mH,
  Gce = j,
  Vce = vH,
  Wce = We,
  Kce = Ye,
  Yce = $t,
  qce = kp;
Gce({
  target: "Array",
  proto: !0
}, {
  flat: function () {
    var e = arguments.length ? arguments[0] : void 0,
      r = Wce(this),
      n = Kce(r),
      i = qce(r, 0);
    return i.length = Vce(i, r, r, n, 0, e === void 0 ? 1 : Yce(e)), i
  }
});
var Xce = j,
  Qce = vH,
  Zce = It,
  Jce = We,
  eue = Ye,
  tue = kp;
Xce({
  target: "Array",
  proto: !0
}, {
  flatMap: function (e) {
    var r = Jce(this),
      n = eue(r),
      i;
    return Zce(e), i = tue(r, 0), i.length = Qce(i, r, r, n, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), i
  }
});
var rue = or.forEach,
  nue = ys,
  iue = nue("forEach"),
  yH = iue ? [].forEach : function (e) {
    return rue(this, e, arguments.length > 1 ? arguments[1] : void 0)
  },
  aue = j,
  aN = yH;
aue({
  target: "Array",
  proto: !0,
  forced: [].forEach != aN
}, {
  forEach: aN
});
var sue = Ie,
  oue = uH,
  lue = function (t, e, r, n) {
    try {
      return n ? e(sue(r)[0], r[1]) : e(r)
    } catch (i) {
      oue(t, "throw", i)
    }
  },
  cue = Ni,
  uue = $e,
  fue = We,
  due = lue,
  hue = o$,
  pue = zf,
  gue = Ye,
  sN = vs,
  mue = Hx,
  vue = Dp,
  oN = Array,
  xH = function (e) {
    var r = fue(e),
      n = pue(this),
      i = arguments.length,
      a = i > 1 ? arguments[1] : void 0,
      s = a !== void 0;
    s && (a = cue(a, i > 2 ? arguments[2] : void 0));
    var o = vue(r),
      c = 0,
      l, u, f, d, h, p;
    if (o && !(this === oN && hue(o)))
      for (d = mue(r, o), h = d.next, u = n ? new this : []; !(f = uue(h, d)).done; c++) p = s ? due(d, a, [f.value, c], !0) : f.value, sN(u, c, p);
    else
      for (l = gue(r), u = n ? new this(l) : oN(l); l > c; c++) p = s ? a(r[c], c) : r[c], sN(u, c, p);
    return u.length = c, u
  },
  yue = Fe,
  bH = yue("iterator"),
  EH = !1;
try {
  var xue = 0,
    lN = {
      next: function () {
        return {
          done: !!xue++
        }
      },
      return: function () {
        EH = !0
      }
    };
  lN[bH] = function () {
    return this
  }, Array.from(lN, function () {
    throw 2
  })
} catch {}
var Vx = function (t, e) {
    if (!e && !EH) return !1;
    var r = !1;
    try {
      var n = {};
      n[bH] = function () {
        return {
          next: function () {
            return {
              done: r = !0
            }
          }
        }
      }, t(n)
    } catch {}
    return r
  },
  bue = j,
  Eue = xH,
  Sue = Vx,
  _ue = !Sue(function (t) {
    Array.from(t)
  });
bue({
  target: "Array",
  stat: !0,
  forced: _ue
}, {
  from: Eue
});
var Tue = j,
  wue = wp.includes,
  Rue = re,
  Aue = cn,
  Iue = Rue(function () {
    return !Array(1).includes()
  });
Tue({
  target: "Array",
  proto: !0,
  forced: Iue
}, {
  includes: function (e) {
    return wue(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
Aue("includes");
var $ue = j,
  Cue = zo,
  kue = wp.indexOf,
  Oue = ys,
  x2 = Cue([].indexOf),
  SH = !!x2 && 1 / x2([1], 1, -0) < 0,
  Lue = SH || !Oue("indexOf");
$ue({
  target: "Array",
  proto: !0,
  forced: Lue
}, {
  indexOf: function (e) {
    var r = arguments.length > 1 ? arguments[1] : void 0;
    return SH ? x2(this, e, r) || 0 : kue(this, e, r)
  }
});
var Pue = j,
  Nue = Go;
Pue({
  target: "Array",
  stat: !0
}, {
  isArray: Nue
});
var Due = re,
  Mue = De,
  Fue = Me,
  cN = si,
  Bue = _t,
  Uue = Fe,
  b2 = Uue("iterator"),
  _H = !1,
  Vl, vS, yS;
[].keys && (yS = [].keys(), "next" in yS ? (vS = cN(cN(yS)), vS !== Object.prototype && (Vl = vS)) : _H = !0);
var jue = !Fue(Vl) || Due(function () {
  var t = {};
  return Vl[b2].call(t) !== t
});
jue && (Vl = {});
Mue(Vl[b2]) || Bue(Vl, b2, function () {
  return this
});
var TH = {
    IteratorPrototype: Vl,
    BUGGY_SAFARI_ITERATORS: _H
  },
  Hue = TH.IteratorPrototype,
  zue = ii,
  Gue = ri,
  Vue = wn,
  Wue = Np,
  Kue = function () {
    return this
  },
  u$ = function (t, e, r, n) {
    var i = e + " Iterator";
    return t.prototype = zue(Hue, {
      next: Gue(+!n, r)
    }), Vue(t, i, !1), Wue[i] = Kue, t
  },
  Yue = j,
  que = $e,
  wH = Hf,
  Xue = De,
  Que = u$,
  uN = si,
  fN = Sa,
  Zue = wn,
  Jue = Pr,
  xS = _t,
  efe = Fe,
  tfe = Np,
  RH = TH,
  rfe = wH.PROPER,
  nfe = wH.CONFIGURABLE,
  dN = RH.IteratorPrototype,
  Vg = RH.BUGGY_SAFARI_ITERATORS,
  wd = efe("iterator"),
  hN = "keys",
  Rd = "values",
  pN = "entries",
  ife = function () {
    return this
  },
  f$ = function (t, e, r, n, i, a, s) {
    Que(r, e, n);
    var o = function (m) {
        if (m === i && d) return d;
        if (!Vg && m in u) return u[m];
        switch (m) {
          case hN:
            return function () {
              return new r(this, m)
            };
          case Rd:
            return function () {
              return new r(this, m)
            };
          case pN:
            return function () {
              return new r(this, m)
            }
        }
        return function () {
          return new r(this)
        }
      },
      c = e + " Iterator",
      l = !1,
      u = t.prototype,
      f = u[wd] || u["@@iterator"] || i && u[i],
      d = !Vg && f || o(i),
      h = e == "Array" && u.entries || f,
      p, v, g;
    if (h && (p = uN(h.call(new t)), p !== Object.prototype && p.next && (uN(p) !== dN && (fN ? fN(p, dN) : Xue(p[wd]) || xS(p, wd, ife)), Zue(p, c, !0))), rfe && i == Rd && f && f.name !== Rd && (nfe ? Jue(u, "name", Rd) : (l = !0, d = function () {
        return que(f, this)
      })), i)
      if (v = {
          values: o(Rd),
          keys: a ? d : o(hN),
          entries: o(pN)
        }, s)
        for (g in v)(Vg || l || !(g in u)) && xS(u, g, v[g]);
      else Yue({
        target: e,
        proto: !0,
        forced: Vg || l
      }, v);
    return u[wd] !== d && xS(u, wd, d, {
      name: i
    }), tfe[e] = d, v
  },
  Wx = function (t, e) {
    return {
      value: t,
      done: e
    }
  },
  afe = qt,
  d$ = cn,
  gN = Np,
  AH = Mt,
  sfe = pt.f,
  ofe = f$,
  Wg = Wx,
  lfe = _e,
  IH = "Array Iterator",
  cfe = AH.set,
  ufe = AH.getterFor(IH),
  $H = ofe(Array, "Array", function (t, e) {
    cfe(this, {
      type: IH,
      target: afe(t),
      index: 0,
      kind: e
    })
  }, function () {
    var t = ufe(this),
      e = t.target,
      r = t.kind,
      n = t.index++;
    return !e || n >= e.length ? (t.target = void 0, Wg(void 0, !0)) : r == "keys" ? Wg(n, !1) : r == "values" ? Wg(e[n], !1) : Wg([n, e[n]], !1)
  }, "values"),
  mN = gN.Arguments = gN.Array;
d$("keys");
d$("values");
d$("entries");
if (lfe && mN.name !== "values") try {
  sfe(mN, "name", {
    value: "values"
  })
} catch {}
var ffe = j,
  dfe = ie,
  hfe = Bf,
  pfe = qt,
  gfe = ys,
  mfe = dfe([].join),
  vfe = hfe != Object,
  yfe = vfe || !gfe("join", ",");
ffe({
  target: "Array",
  proto: !0,
  forced: yfe
}, {
  join: function (e) {
    return mfe(pfe(this), e === void 0 ? "," : e)
  }
});
var xfe = ai,
  bfe = qt,
  Efe = $t,
  Sfe = Ye,
  _fe = ys,
  Tfe = Math.min,
  E2 = [].lastIndexOf,
  CH = !!E2 && 1 / [1].lastIndexOf(1, -0) < 0,
  wfe = _fe("lastIndexOf"),
  Rfe = CH || !wfe,
  kH = Rfe ? function (e) {
    if (CH) return xfe(E2, this, arguments) || 0;
    var r = bfe(this),
      n = Sfe(r),
      i = n - 1;
    for (arguments.length > 1 && (i = Tfe(i, Efe(arguments[1]))), i < 0 && (i = n + i); i >= 0; i--)
      if (i in r && r[i] === e) return i || 0;
    return -1
  } : E2,
  Afe = j,
  vN = kH;
Afe({
  target: "Array",
  proto: !0,
  forced: vN !== [].lastIndexOf
}, {
  lastIndexOf: vN
});
var Ife = j,
  $fe = or.map,
  Cfe = Mp,
  kfe = Cfe("map");
Ife({
  target: "Array",
  proto: !0,
  forced: !kfe
}, {
  map: function (e) {
    return $fe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var Ofe = j,
  Lfe = re,
  Pfe = zf,
  Nfe = vs,
  OH = Array,
  Dfe = Lfe(function () {
    function t() {}
    return !(OH.of.call(t) instanceof t)
  });
Ofe({
  target: "Array",
  stat: !0,
  forced: Dfe
}, {
  of: function () {
    for (var e = 0, r = arguments.length, n = new(Pfe(this) ? this : OH)(r); r > e;) Nfe(n, e, arguments[e++]);
    return n.length = r, n
  }
});
var Mfe = _e,
  Ffe = Go,
  Bfe = TypeError,
  Ufe = Object.getOwnPropertyDescriptor,
  jfe = Mfe && ! function () {
    if (this !== void 0) return !0;
    try {
      Object.defineProperty([], "length", {
        writable: !1
      }).length = 1
    } catch (t) {
      return t instanceof TypeError
    }
  }(),
  h$ = jfe ? function (t, e) {
    if (Ffe(t) && !Ufe(t, "length").writable) throw Bfe("Cannot set read only .length");
    return t.length = e
  } : function (t, e) {
    return t.length = e
  },
  Hfe = j,
  zfe = We,
  Gfe = Ye,
  Vfe = h$,
  Wfe = Vf,
  Kfe = re,
  Yfe = Kfe(function () {
    return [].push.call({
      length: 4294967296
    }, 1) !== 4294967297
  }),
  qfe = function () {
    try {
      Object.defineProperty([], "length", {
        writable: !1
      }).push()
    } catch (t) {
      return t instanceof TypeError
    }
  },
  Xfe = Yfe || !qfe();
Hfe({
  target: "Array",
  proto: !0,
  arity: 1,
  forced: Xfe
}, {
  push: function (e) {
    var r = zfe(this),
      n = Gfe(r),
      i = arguments.length;
    Wfe(n + i);
    for (var a = 0; a < i; a++) r[n] = arguments[a], n++;
    return Vfe(r, n), n
  }
});
var Qfe = It,
  Zfe = We,
  Jfe = Bf,
  ede = Ye,
  tde = TypeError,
  yN = function (t) {
    return function (e, r, n, i) {
      Qfe(r);
      var a = Zfe(e),
        s = Jfe(a),
        o = ede(a),
        c = t ? o - 1 : 0,
        l = t ? -1 : 1;
      if (n < 2)
        for (;;) {
          if (c in s) {
            i = s[c], c += l;
            break
          }
          if (c += l, t ? c < 0 : o <= c) throw tde("Reduce of empty array with no initial value")
        }
      for (; t ? c >= 0 : o > c; c += l) c in s && (i = r(i, s[c], c, a));
      return i
    }
  },
  Kx = {
    left: yN(!1),
    right: yN(!0)
  },
  rde = Lr,
  xs = typeof process < "u" && rde(process) == "process",
  nde = j,
  ide = Kx.left,
  ade = ys,
  xN = ps,
  sde = xs,
  ode = !sde && xN > 79 && xN < 83,
  lde = ode || !ade("reduce");
nde({
  target: "Array",
  proto: !0,
  forced: lde
}, {
  reduce: function (e) {
    var r = arguments.length;
    return ide(this, e, r, r > 1 ? arguments[1] : void 0)
  }
});
var cde = j,
  ude = Kx.right,
  fde = ys,
  bN = ps,
  dde = xs,
  hde = !dde && bN > 79 && bN < 83,
  pde = hde || !fde("reduceRight");
cde({
  target: "Array",
  proto: !0,
  forced: pde
}, {
  reduceRight: function (e) {
    return ude(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var gde = j,
  mde = ie,
  vde = Go,
  yde = mde([].reverse),
  EN = [1, 2];
gde({
  target: "Array",
  proto: !0,
  forced: String(EN) === String(EN.reverse())
}, {
  reverse: function () {
    return vde(this) && (this.length = this.length), yde(this)
  }
});
var xde = j,
  SN = Go,
  bde = zf,
  Ede = Me,
  _N = ba,
  Sde = Ye,
  _de = qt,
  Tde = vs,
  wde = Fe,
  Rde = Mp,
  Ade = fc,
  Ide = Rde("slice"),
  $de = wde("species"),
  bS = Array,
  Cde = Math.max;
xde({
  target: "Array",
  proto: !0,
  forced: !Ide
}, {
  slice: function (e, r) {
    var n = _de(this),
      i = Sde(n),
      a = _N(e, i),
      s = _N(r === void 0 ? i : r, i),
      o, c, l;
    if (SN(n) && (o = n.constructor, bde(o) && (o === bS || SN(o.prototype)) ? o = void 0 : Ede(o) && (o = o[$de], o === null && (o = void 0)), o === bS || o === void 0)) return Ade(n, a, s);
    for (c = new(o === void 0 ? bS : o)(Cde(s - a, 0)), l = 0; a < s; a++, l++) a in n && Tde(c, l, n[a]);
    return c.length = l, c
  }
});
var kde = j,
  Ode = or.some,
  Lde = ys,
  Pde = Lde("some");
kde({
  target: "Array",
  proto: !0,
  forced: !Pde
}, {
  some: function (e) {
    return Ode(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var TN = Cp,
  Nde = Math.floor,
  S2 = function (t, e) {
    var r = t.length,
      n = Nde(r / 2);
    return r < 8 ? Dde(t, e) : Mde(t, S2(TN(t, 0, n), e), S2(TN(t, n), e), e)
  },
  Dde = function (t, e) {
    for (var r = t.length, n = 1, i, a; n < r;) {
      for (a = n, i = t[n]; a && e(t[a - 1], i) > 0;) t[a] = t[--a];
      a !== n++ && (t[a] = i)
    }
    return t
  },
  Mde = function (t, e, r, n) {
    for (var i = e.length, a = r.length, s = 0, o = 0; s < i || o < a;) t[s + o] = s < i && o < a ? n(e[s], r[o]) <= 0 ? e[s++] : r[o++] : s < i ? e[s++] : r[o++];
    return t
  },
  p$ = S2,
  Fde = hs,
  wN = Fde.match(/firefox\/(\d+)/i),
  LH = !!wN && +wN[1],
  Bde = hs,
  PH = /MSIE|Trident/.test(Bde),
  Ude = hs,
  RN = Ude.match(/AppleWebKit\/(\d+)\./),
  g$ = !!RN && +RN[1],
  jde = j,
  NH = ie,
  Hde = It,
  zde = We,
  AN = Ye,
  Gde = zx,
  IN = Ce,
  m$ = re,
  Vde = p$,
  Wde = ys,
  $N = LH,
  Kde = PH,
  CN = ps,
  kN = g$,
  Xs = [],
  ON = NH(Xs.sort),
  Yde = NH(Xs.push),
  qde = m$(function () {
    Xs.sort(void 0)
  }),
  Xde = m$(function () {
    Xs.sort(null)
  }),
  Qde = Wde("sort"),
  DH = !m$(function () {
    if (CN) return CN < 70;
    if (!($N && $N > 3)) {
      if (Kde) return !0;
      if (kN) return kN < 603;
      var t = "",
        e, r, n, i;
      for (e = 65; e < 76; e++) {
        switch (r = String.fromCharCode(e), e) {
          case 66:
          case 69:
          case 70:
          case 72:
            n = 3;
            break;
          case 68:
          case 71:
            n = 4;
            break;
          default:
            n = 2
        }
        for (i = 0; i < 47; i++) Xs.push({
          k: r + i,
          v: n
        })
      }
      for (Xs.sort(function (a, s) {
          return s.v - a.v
        }), i = 0; i < Xs.length; i++) r = Xs[i].k.charAt(0), t.charAt(t.length - 1) !== r && (t += r);
      return t !== "DGBEFHACIJK"
    }
  }),
  Zde = qde || !Xde || !Qde || !DH,
  Jde = function (t) {
    return function (e, r) {
      return r === void 0 ? -1 : e === void 0 ? 1 : t !== void 0 ? +t(e, r) || 0 : IN(e) > IN(r) ? 1 : -1
    }
  };
jde({
  target: "Array",
  proto: !0,
  forced: Zde
}, {
  sort: function (e) {
    e !== void 0 && Hde(e);
    var r = zde(this);
    if (DH) return e === void 0 ? ON(r) : ON(r, e);
    var n = [],
      i = AN(r),
      a, s;
    for (s = 0; s < i; s++) s in r && Yde(n, r[s]);
    for (Vde(n, Jde(e)), a = AN(n), s = 0; s < a;) r[s] = n[s++];
    for (; s < i;) Gde(r, s++);
    return r
  }
});
var ehe = ht,
  the = sr,
  rhe = Fe,
  nhe = _e,
  LN = rhe("species"),
  Wf = function (t) {
    var e = ehe(t);
    nhe && e && !e[LN] && the(e, LN, {
      configurable: !0,
      get: function () {
        return this
      }
    })
  },
  ihe = Wf;
ihe("Array");
var ahe = j,
  she = We,
  ohe = ba,
  lhe = $t,
  che = Ye,
  uhe = h$,
  fhe = Vf,
  dhe = kp,
  hhe = vs,
  ES = zx,
  phe = Mp,
  ghe = phe("splice"),
  mhe = Math.max,
  vhe = Math.min;
ahe({
  target: "Array",
  proto: !0,
  forced: !ghe
}, {
  splice: function (e, r) {
    var n = she(this),
      i = che(n),
      a = ohe(e, i),
      s = arguments.length,
      o, c, l, u, f, d;
    for (s === 0 ? o = c = 0 : s === 1 ? (o = 0, c = i - a) : (o = s - 2, c = vhe(mhe(lhe(r), 0), i - a)), fhe(i + o - c), l = dhe(n, c), u = 0; u < c; u++) f = a + u, f in n && hhe(l, u, n[f]);
    if (l.length = c, o < c) {
      for (u = a; u < i - c; u++) f = u + c, d = u + o, f in n ? n[d] = n[f] : ES(n, d);
      for (u = i; u > i - c + o; u--) ES(n, u - 1)
    } else if (o > c)
      for (u = i - c; u > a; u--) f = u + c - 1, d = u + o - 1, f in n ? n[d] = n[f] : ES(n, d);
    for (u = 0; u < o; u++) n[u + a] = arguments[u + 2];
    return uhe(n, i - c + o), l
  }
});
var yhe = Ye,
  MH = function (t, e) {
    for (var r = yhe(t), n = new e(r), i = 0; i < r; i++) n[i] = t[r - i - 1];
    return n
  },
  xhe = j,
  bhe = MH,
  Ehe = qt,
  She = cn,
  _he = Array;
xhe({
  target: "Array",
  proto: !0
}, {
  toReversed: function () {
    return bhe(Ehe(this), _he)
  }
});
She("toReversed");
var The = Ye,
  v$ = function (t, e) {
    for (var r = 0, n = The(e), i = new t(n); n > r;) i[r] = e[r++];
    return i
  },
  whe = he,
  Rhe = function (t) {
    return whe[t].prototype
  },
  Ahe = j,
  Ihe = ie,
  $he = It,
  Che = qt,
  khe = v$,
  Ohe = Rhe,
  Lhe = cn,
  Phe = Array,
  Nhe = Ihe(Ohe("Array").sort);
Ahe({
  target: "Array",
  proto: !0
}, {
  toSorted: function (e) {
    e !== void 0 && $he(e);
    var r = Che(this),
      n = khe(Phe, r);
    return Nhe(n, e)
  }
});
Lhe("toSorted");
var Dhe = j,
  Mhe = cn,
  Fhe = Vf,
  Bhe = Ye,
  Uhe = ba,
  jhe = qt,
  Hhe = $t,
  zhe = Array,
  Ghe = Math.max,
  Vhe = Math.min;
Dhe({
  target: "Array",
  proto: !0
}, {
  toSpliced: function (e, r) {
    var n = jhe(this),
      i = Bhe(n),
      a = Uhe(e, i),
      s = arguments.length,
      o = 0,
      c, l, u, f;
    for (s === 0 ? c = l = 0 : s === 1 ? (c = 0, l = i - a) : (c = s - 2, l = Vhe(Ghe(Hhe(r), 0), i - a)), u = Fhe(i + c - l), f = zhe(u); o < a; o++) f[o] = n[o];
    for (; o < a + c; o++) f[o] = arguments[o - a + 2];
    for (; o < u; o++) f[o] = n[o + l - c];
    return f
  }
});
Mhe("toSpliced");
var Whe = cn;
Whe("flat");
var Khe = cn;
Khe("flatMap");
var Yhe = j,
  qhe = We,
  Xhe = Ye,
  Qhe = h$,
  Zhe = zx,
  Jhe = Vf,
  e0e = [].unshift(0) !== 1,
  t0e = function () {
    try {
      Object.defineProperty([], "length", {
        writable: !1
      }).unshift()
    } catch (t) {
      return t instanceof TypeError
    }
  },
  r0e = e0e || !t0e();
Yhe({
  target: "Array",
  proto: !0,
  arity: 1,
  forced: r0e
}, {
  unshift: function (e) {
    var r = qhe(this),
      n = Xhe(r),
      i = arguments.length;
    if (i) {
      Jhe(n + i);
      for (var a = n; a--;) {
        var s = a + i;
        a in r ? r[s] = r[a] : Zhe(r, s)
      }
      for (var o = 0; o < i; o++) r[o] = arguments[o]
    }
    return Qhe(r, n + i)
  }
});
var n0e = Ye,
  i0e = $t,
  a0e = RangeError,
  FH = function (t, e, r, n) {
    var i = n0e(t),
      a = i0e(r),
      s = a < 0 ? i + a : a;
    if (s >= i || s < 0) throw a0e("Incorrect index");
    for (var o = new e(i), c = 0; c < i; c++) o[c] = c === s ? n : t[c];
    return o
  },
  s0e = j,
  o0e = FH,
  l0e = qt,
  c0e = Array;
s0e({
  target: "Array",
  proto: !0
}, {
  with: function (t, e) {
    return o0e(l0e(this), c0e, t, e)
  }
});
var y$ = typeof ArrayBuffer < "u" && typeof DataView < "u",
  u0e = _t,
  Fp = function (t, e, r) {
    for (var n in e) u0e(t, n, e[n], r);
    return t
  },
  f0e = ni,
  d0e = TypeError,
  wa = function (t, e) {
    if (f0e(e, t)) return t;
    throw d0e("Incorrect invocation")
  },
  h0e = $t,
  p0e = Tn,
  g0e = RangeError,
  BH = function (t) {
    if (t === void 0) return 0;
    var e = h0e(t),
      r = p0e(e);
    if (e !== r) throw g0e("Wrong length or index");
    return r
  },
  m0e = Array,
  v0e = Math.abs,
  Fa = Math.pow,
  y0e = Math.floor,
  x0e = Math.log,
  b0e = Math.LN2,
  E0e = function (t, e, r) {
    var n = m0e(r),
      i = r * 8 - e - 1,
      a = (1 << i) - 1,
      s = a >> 1,
      o = e === 23 ? Fa(2, -24) - Fa(2, -77) : 0,
      c = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0,
      l = 0,
      u, f, d;
    for (t = v0e(t), t != t || t === 1 / 0 ? (f = t != t ? 1 : 0, u = a) : (u = y0e(x0e(t) / b0e), d = Fa(2, -u), t * d < 1 && (u--, d *= 2), u + s >= 1 ? t += o / d : t += o * Fa(2, 1 - s), t * d >= 2 && (u++, d /= 2), u + s >= a ? (f = 0, u = a) : u + s >= 1 ? (f = (t * d - 1) * Fa(2, e), u = u + s) : (f = t * Fa(2, s - 1) * Fa(2, e), u = 0)); e >= 8;) n[l++] = f & 255, f /= 256, e -= 8;
    for (u = u << e | f, i += e; i > 0;) n[l++] = u & 255, u /= 256, i -= 8;
    return n[--l] |= c * 128, n
  },
  S0e = function (t, e) {
    var r = t.length,
      n = r * 8 - e - 1,
      i = (1 << n) - 1,
      a = i >> 1,
      s = n - 7,
      o = r - 1,
      c = t[o--],
      l = c & 127,
      u;
    for (c >>= 7; s > 0;) l = l * 256 + t[o--], s -= 8;
    for (u = l & (1 << -s) - 1, l >>= -s, s += e; s > 0;) u = u * 256 + t[o--], s -= 8;
    if (l === 0) l = 1 - a;
    else {
      if (l === i) return u ? NaN : c ? -1 / 0 : 1 / 0;
      u = u + Fa(2, e), l = l - a
    }
    return (c ? -1 : 1) * u * Fa(2, l - e)
  },
  _0e = {
    pack: E0e,
    unpack: S0e
  },
  Yx = he,
  x$ = ie,
  SS = _e,
  T0e = y$,
  UH = Hf,
  PN = Pr,
  w0e = sr,
  NN = Fp,
  _S = re,
  Kg = wa,
  R0e = $t,
  A0e = Tn,
  vy = BH,
  jH = _0e,
  I0e = si,
  DN = Sa,
  $0e = ms.f,
  C0e = c$,
  k0e = Cp,
  HH = wn,
  b$ = Mt,
  O0e = UH.PROPER,
  MN = UH.CONFIGURABLE,
  wu = "ArrayBuffer",
  qx = "DataView",
  Ru = "prototype",
  L0e = "Wrong length",
  zH = "Wrong index",
  FN = b$.getterFor(wu),
  kh = b$.getterFor(qx),
  BN = b$.set,
  Fn = Yx[wu],
  gn = Fn,
  kc = gn && gn[Ru],
  ea = Yx[qx],
  sl = ea && ea[Ru],
  UN = Object.prototype,
  P0e = Yx.Array,
  yy = Yx.RangeError,
  N0e = x$(C0e),
  D0e = x$([].reverse),
  GH = jH.pack,
  jN = jH.unpack,
  HN = function (t) {
    return [t & 255]
  },
  zN = function (t) {
    return [t & 255, t >> 8 & 255]
  },
  GN = function (t) {
    return [t & 255, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
  },
  VN = function (t) {
    return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
  },
  M0e = function (t) {
    return GH(t, 23, 4)
  },
  F0e = function (t) {
    return GH(t, 52, 8)
  },
  Yg = function (t, e, r) {
    w0e(t[Ru], e, {
      configurable: !0,
      get: function () {
        return r(this)[e]
      }
    })
  },
  ks = function (t, e, r, n) {
    var i = vy(r),
      a = kh(t);
    if (i + e > a.byteLength) throw yy(zH);
    var s = a.bytes,
      o = i + a.byteOffset,
      c = k0e(s, o, o + e);
    return n ? c : D0e(c)
  },
  Os = function (t, e, r, n, i, a) {
    var s = vy(r),
      o = kh(t);
    if (s + e > o.byteLength) throw yy(zH);
    for (var c = o.bytes, l = s + o.byteOffset, u = n(+i), f = 0; f < e; f++) c[l + f] = u[a ? f : e - f - 1]
  };
if (!T0e) gn = function (e) {
  Kg(this, kc);
  var r = vy(e);
  BN(this, {
    type: wu,
    bytes: N0e(P0e(r), 0),
    byteLength: r
  }), SS || (this.byteLength = r, this.detached = !1)
}, kc = gn[Ru], ea = function (e, r, n) {
  Kg(this, sl), Kg(e, kc);
  var i = FN(e),
    a = i.byteLength,
    s = R0e(r);
  if (s < 0 || s > a) throw yy("Wrong offset");
  if (n = n === void 0 ? a - s : A0e(n), s + n > a) throw yy(L0e);
  BN(this, {
    type: qx,
    buffer: e,
    byteLength: n,
    byteOffset: s,
    bytes: i.bytes
  }), SS || (this.buffer = e, this.byteLength = n, this.byteOffset = s)
}, sl = ea[Ru], SS && (Yg(gn, "byteLength", FN), Yg(ea, "buffer", kh), Yg(ea, "byteLength", kh), Yg(ea, "byteOffset", kh)), NN(sl, {
  getInt8: function (e) {
    return ks(this, 1, e)[0] << 24 >> 24
  },
  getUint8: function (e) {
    return ks(this, 1, e)[0]
  },
  getInt16: function (e) {
    var r = ks(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
    return (r[1] << 8 | r[0]) << 16 >> 16
  },
  getUint16: function (e) {
    var r = ks(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
    return r[1] << 8 | r[0]
  },
  getInt32: function (e) {
    return VN(ks(this, 4, e, arguments.length > 1 ? arguments[1] : void 0))
  },
  getUint32: function (e) {
    return VN(ks(this, 4, e, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
  },
  getFloat32: function (e) {
    return jN(ks(this, 4, e, arguments.length > 1 ? arguments[1] : void 0), 23)
  },
  getFloat64: function (e) {
    return jN(ks(this, 8, e, arguments.length > 1 ? arguments[1] : void 0), 52)
  },
  setInt8: function (e, r) {
    Os(this, 1, e, HN, r)
  },
  setUint8: function (e, r) {
    Os(this, 1, e, HN, r)
  },
  setInt16: function (e, r) {
    Os(this, 2, e, zN, r, arguments.length > 2 ? arguments[2] : void 0)
  },
  setUint16: function (e, r) {
    Os(this, 2, e, zN, r, arguments.length > 2 ? arguments[2] : void 0)
  },
  setInt32: function (e, r) {
    Os(this, 4, e, GN, r, arguments.length > 2 ? arguments[2] : void 0)
  },
  setUint32: function (e, r) {
    Os(this, 4, e, GN, r, arguments.length > 2 ? arguments[2] : void 0)
  },
  setFloat32: function (e, r) {
    Os(this, 4, e, M0e, r, arguments.length > 2 ? arguments[2] : void 0)
  },
  setFloat64: function (e, r) {
    Os(this, 8, e, F0e, r, arguments.length > 2 ? arguments[2] : void 0)
  }
});
else {
  var WN = O0e && Fn.name !== wu;
  if (!_S(function () {
      Fn(1)
    }) || !_S(function () {
      new Fn(-1)
    }) || _S(function () {
      return new Fn, new Fn(1.5), new Fn(NaN), Fn.length != 1 || WN && !MN
    })) {
    gn = function (e) {
      return Kg(this, kc), new Fn(vy(e))
    }, gn[Ru] = kc;
    for (var KN = $0e(Fn), YN = 0, TS; KN.length > YN;)(TS = KN[YN++]) in gn || PN(gn, TS, Fn[TS]);
    kc.constructor = gn
  } else WN && MN && PN(Fn, "name", wu);
  DN && I0e(sl) !== UN && DN(sl, UN);
  var qg = new ea(new gn(2)),
    qN = x$(sl.setInt8);
  qg.setInt8(0, 2147483648), qg.setInt8(1, 2147483649), (qg.getInt8(0) || !qg.getInt8(1)) && NN(sl, {
    setInt8: function (e, r) {
      qN(this, e, r << 24 >> 24)
    },
    setUint8: function (e, r) {
      qN(this, e, r << 24 >> 24)
    }
  }, {
    unsafe: !0
  })
}
HH(gn, wu);
HH(ea, qx);
var Xx = {
    ArrayBuffer: gn,
    DataView: ea
  },
  B0e = j,
  U0e = he,
  j0e = Xx,
  H0e = Wf,
  E$ = "ArrayBuffer",
  XN = j0e[E$],
  z0e = U0e[E$];
B0e({
  global: !0,
  constructor: !0,
  forced: z0e !== XN
}, {
  ArrayBuffer: XN
});
H0e(E$);
var G0e = y$,
  S$ = _e,
  Cr = he,
  VH = De,
  Qx = Me,
  Ro = He,
  _$ = Ea,
  V0e = uc,
  W0e = Pr,
  _2 = _t,
  K0e = sr,
  Y0e = ni,
  Zx = si,
  Kf = Sa,
  q0e = Fe,
  X0e = jf,
  WH = Mt,
  KH = WH.enforce,
  Q0e = WH.get,
  xy = Cr.Int8Array,
  T2 = xy && xy.prototype,
  QN = Cr.Uint8ClampedArray,
  ZN = QN && QN.prototype,
  na = xy && Zx(xy),
  wi = T2 && Zx(T2),
  Z0e = Object.prototype,
  T$ = Cr.TypeError,
  JN = q0e("toStringTag"),
  w2 = X0e("TYPED_ARRAY_TAG"),
  by = "TypedArrayConstructor",
  as = G0e && !!Kf && _$(Cr.opera) !== "Opera",
  YH = !1,
  Qr, Qs, Au, ss = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  },
  w$ = {
    BigInt64Array: 8,
    BigUint64Array: 8
  },
  J0e = function (e) {
    if (!Qx(e)) return !1;
    var r = _$(e);
    return r === "DataView" || Ro(ss, r) || Ro(w$, r)
  },
  qH = function (t) {
    var e = Zx(t);
    if (Qx(e)) {
      var r = Q0e(e);
      return r && Ro(r, by) ? r[by] : qH(e)
    }
  },
  XH = function (t) {
    if (!Qx(t)) return !1;
    var e = _$(t);
    return Ro(ss, e) || Ro(w$, e)
  },
  epe = function (t) {
    if (XH(t)) return t;
    throw T$("Target is not a typed array")
  },
  tpe = function (t) {
    if (VH(t) && (!Kf || Y0e(na, t))) return t;
    throw T$(V0e(t) + " is not a typed array constructor")
  },
  rpe = function (t, e, r, n) {
    if (S$) {
      if (r)
        for (var i in ss) {
          var a = Cr[i];
          if (a && Ro(a.prototype, t)) try {
            delete a.prototype[t]
          } catch {
            try {
              a.prototype[t] = e
            } catch {}
          }
        }(!wi[t] || r) && _2(wi, t, r ? e : as && T2[t] || e, n)
    }
  },
  npe = function (t, e, r) {
    var n, i;
    if (S$) {
      if (Kf) {
        if (r) {
          for (n in ss)
            if (i = Cr[n], i && Ro(i, t)) try {
              delete i[t]
            } catch {}
        }
        if (!na[t] || r) try {
          return _2(na, t, r ? e : as && na[t] || e)
        } catch {} else return
      }
      for (n in ss) i = Cr[n], i && (!i[t] || r) && _2(i, t, e)
    }
  };
for (Qr in ss) Qs = Cr[Qr], Au = Qs && Qs.prototype, Au ? KH(Au)[by] = Qs : as = !1;
for (Qr in w$) Qs = Cr[Qr], Au = Qs && Qs.prototype, Au && (KH(Au)[by] = Qs);
if ((!as || !VH(na) || na === Function.prototype) && (na = function () {
    throw T$("Incorrect invocation")
  }, as))
  for (Qr in ss) Cr[Qr] && Kf(Cr[Qr], na);
if ((!as || !wi || wi === Z0e) && (wi = na.prototype, as))
  for (Qr in ss) Cr[Qr] && Kf(Cr[Qr].prototype, wi);
as && Zx(ZN) !== wi && Kf(ZN, wi);
if (S$ && !Ro(wi, JN)) {
  YH = !0, K0e(wi, JN, {
    configurable: !0,
    get: function () {
      return Qx(this) ? this[w2] : void 0
    }
  });
  for (Qr in ss) Cr[Qr] && W0e(Cr[Qr], w2, Qr)
}
var Le = {
    NATIVE_ARRAY_BUFFER_VIEWS: as,
    TYPED_ARRAY_TAG: YH && w2,
    aTypedArray: epe,
    aTypedArrayConstructor: tpe,
    exportTypedArrayMethod: rpe,
    exportTypedArrayStaticMethod: npe,
    getTypedArrayConstructor: qH,
    isView: J0e,
    isTypedArray: XH,
    TypedArray: na,
    TypedArrayPrototype: wi
  },
  ipe = j,
  QH = Le,
  ape = QH.NATIVE_ARRAY_BUFFER_VIEWS;
ipe({
  target: "ArrayBuffer",
  stat: !0,
  forced: !ape
}, {
  isView: QH.isView
});
var spe = zf,
  ope = uc,
  lpe = TypeError,
  R$ = function (t) {
    if (spe(t)) return t;
    throw lpe(ope(t) + " is not a constructor")
  },
  eD = Ie,
  cpe = R$,
  upe = on,
  fpe = Fe,
  dpe = fpe("species"),
  Yf = function (t, e) {
    var r = eD(t).constructor,
      n;
    return r === void 0 || upe(n = eD(r)[dpe]) ? e : cpe(n)
  },
  hpe = j,
  A$ = zo,
  ppe = re,
  ZH = Xx,
  tD = Ie,
  rD = ba,
  gpe = Tn,
  mpe = Yf,
  I$ = ZH.ArrayBuffer,
  R2 = ZH.DataView,
  JH = R2.prototype,
  nD = A$(I$.prototype.slice),
  vpe = A$(JH.getUint8),
  ype = A$(JH.setUint8),
  xpe = ppe(function () {
    return !new I$(2).slice(1, void 0).byteLength
  });
hpe({
  target: "ArrayBuffer",
  proto: !0,
  unsafe: !0,
  forced: xpe
}, {
  slice: function (e, r) {
    if (nD && r === void 0) return nD(tD(this), e);
    for (var n = tD(this).byteLength, i = rD(e, n), a = rD(r === void 0 ? n : r, n), s = new(mpe(this, I$))(gpe(a - i)), o = new R2(this), c = new R2(s), l = 0; i < a;) ype(c, l++, vpe(o, i++));
    return s
  }
});
var bpe = j,
  Epe = Xx,
  Spe = y$;
bpe({
  global: !0,
  constructor: !0,
  forced: !Spe
}, {
  DataView: Epe.DataView
});
var _pe = j,
  Tpe = ie,
  wpe = re,
  Rpe = wpe(function () {
    return new Date(16e11).getYear() !== 120
  }),
  Ape = Tpe(Date.prototype.getFullYear);
_pe({
  target: "Date",
  proto: !0,
  forced: Rpe
}, {
  getYear: function () {
    return Ape(this) - 1900
  }
});
var Ipe = j,
  $pe = ie,
  ez = Date,
  Cpe = $pe(ez.prototype.getTime);
Ipe({
  target: "Date",
  stat: !0
}, {
  now: function () {
    return Cpe(new ez)
  }
});
var kpe = j,
  tz = ie,
  Ope = $t,
  rz = Date.prototype,
  Lpe = tz(rz.getTime),
  Ppe = tz(rz.setFullYear);
kpe({
  target: "Date",
  proto: !0
}, {
  setYear: function (e) {
    Lpe(this);
    var r = Ope(e),
      n = 0 <= r && r <= 99 ? r + 1900 : r;
    return Ppe(this, n)
  }
});
var Npe = j;
Npe({
  target: "Date",
  proto: !0
}, {
  toGMTString: Date.prototype.toUTCString
});
var Dpe = $t,
  Mpe = Ce,
  Fpe = Dt,
  Bpe = RangeError,
  Jx = function (e) {
    var r = Mpe(Fpe(this)),
      n = "",
      i = Dpe(e);
    if (i < 0 || i == 1 / 0) throw Bpe("Wrong number of repetitions");
    for (; i > 0;
      (i >>>= 1) && (r += r)) i & 1 && (n += r);
    return n
  },
  nz = ie,
  Upe = Tn,
  iD = Ce,
  jpe = Jx,
  Hpe = Dt,
  zpe = nz(jpe),
  Gpe = nz("".slice),
  Vpe = Math.ceil,
  aD = function (t) {
    return function (e, r, n) {
      var i = iD(Hpe(e)),
        a = Upe(r),
        s = i.length,
        o = n === void 0 ? " " : iD(n),
        c, l;
      return a <= s || o == "" ? i : (c = a - s, l = zpe(o, Vpe(c / o.length)), l.length > c && (l = Gpe(l, 0, c)), t ? i + l : l + i)
    }
  },
  $$ = {
    start: aD(!1),
    end: aD(!0)
  },
  Vo = ie,
  sD = re,
  ol = $$.start,
  Wpe = RangeError,
  Kpe = isFinite,
  Ype = Math.abs,
  bs = Date.prototype,
  wS = bs.toISOString,
  qpe = Vo(bs.getTime),
  Xpe = Vo(bs.getUTCDate),
  Qpe = Vo(bs.getUTCFullYear),
  Zpe = Vo(bs.getUTCHours),
  Jpe = Vo(bs.getUTCMilliseconds),
  ege = Vo(bs.getUTCMinutes),
  tge = Vo(bs.getUTCMonth),
  rge = Vo(bs.getUTCSeconds),
  nge = sD(function () {
    return wS.call(new Date(-5e13 - 1)) != "0385-07-25T07:06:39.999Z"
  }) || !sD(function () {
    wS.call(new Date(NaN))
  }) ? function () {
    if (!Kpe(qpe(this))) throw Wpe("Invalid time value");
    var e = this,
      r = Qpe(e),
      n = Jpe(e),
      i = r < 0 ? "-" : r > 9999 ? "+" : "";
    return i + ol(Ype(r), i ? 6 : 4, 0) + "-" + ol(tge(e) + 1, 2, 0) + "-" + ol(Xpe(e), 2, 0) + "T" + ol(Zpe(e), 2, 0) + ":" + ol(ege(e), 2, 0) + ":" + ol(rge(e), 2, 0) + "." + ol(n, 3, 0) + "Z"
  } : wS,
  ige = j,
  oD = nge;
ige({
  target: "Date",
  proto: !0,
  forced: Date.prototype.toISOString !== oD
}, {
  toISOString: oD
});
var age = j,
  sge = re,
  oge = We,
  lge = kx,
  cge = sge(function () {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
      toISOString: function () {
        return 1
      }
    }) !== 1
  });
age({
  target: "Date",
  proto: !0,
  arity: 1,
  forced: cge
}, {
  toJSON: function (e) {
    var r = oge(this),
      n = lge(r, "number");
    return typeof n == "number" && !isFinite(n) ? null : r.toISOString()
  }
});
var uge = Ie,
  fge = dj,
  dge = TypeError,
  hge = function (t) {
    if (uge(this), t === "string" || t === "default") t = "string";
    else if (t !== "number") throw dge("Incorrect hint");
    return fge(this, t)
  },
  pge = He,
  gge = _t,
  mge = hge,
  vge = Fe,
  lD = vge("toPrimitive"),
  cD = Date.prototype;
pge(cD, lD) || gge(cD, lD, mge);
var iz = ie,
  yge = _t,
  C$ = Date.prototype,
  uD = "Invalid Date",
  az = "toString",
  xge = iz(C$[az]),
  bge = iz(C$.getTime);
String(new Date(NaN)) != uD && yge(C$, az, function () {
  var e = bge(this);
  return e === e ? xge(this) : uD
});
var Ege = j,
  Bp = ie,
  Sge = Ce,
  _ge = Bp("".charAt),
  Tge = Bp("".charCodeAt),
  wge = Bp(/./.exec),
  Rge = Bp(1.toString),
  Age = Bp("".toUpperCase),
  Ige = /[\w*+\-./@]/,
  fD = function (t, e) {
    for (var r = Rge(t, 16); r.length < e;) r = "0" + r;
    return r
  };
Ege({
  global: !0
}, {
  escape: function (e) {
    for (var r = Sge(e), n = "", i = r.length, a = 0, s, o; a < i;) s = _ge(r, a++), wge(Ige, s) ? n += s : (o = Tge(s, 0), o < 256 ? n += "%" + fD(o, 2) : n += "%u" + Age(fD(o, 4)));
    return n
  }
});
var sz = ie,
  $ge = It,
  Cge = Me,
  kge = He,
  dD = fc,
  Oge = Sp,
  oz = Function,
  Lge = sz([].concat),
  Pge = sz([].join),
  RS = {},
  Nge = function (t, e, r) {
    if (!kge(RS, e)) {
      for (var n = [], i = 0; i < e; i++) n[i] = "a[" + i + "]";
      RS[e] = oz("C,a", "return new C(" + Pge(n, ",") + ")")
    }
    return RS[e](t, r)
  },
  lz = Oge ? oz.bind : function (e) {
    var r = $ge(this),
      n = r.prototype,
      i = dD(arguments, 1),
      a = function () {
        var o = Lge(i, dD(arguments));
        return this instanceof a ? Nge(r, o.length, o) : r.apply(e, o)
      };
    return Cge(n) && (a.prototype = n), a
  },
  Dge = j,
  hD = lz;
Dge({
  target: "Function",
  proto: !0,
  forced: Function.bind !== hD
}, {
  bind: hD
});
var Mge = De,
  pD = Me,
  Fge = pt,
  Bge = si,
  Uge = Fe,
  jge = g0,
  AS = Uge("hasInstance"),
  gD = Function.prototype;
AS in gD || Fge.f(gD, AS, {
  value: jge(function (t) {
    if (!Mge(this) || !pD(t)) return !1;
    var e = this.prototype;
    if (!pD(e)) return t instanceof this;
    for (; t = Bge(t);)
      if (e === t) return !0;
    return !1
  }, AS)
});
var Hge = _e,
  zge = Hf.EXISTS,
  cz = ie,
  Gge = sr,
  uz = Function.prototype,
  Vge = cz(uz.toString),
  fz = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,
  Wge = cz(fz.exec),
  Kge = "name";
Hge && !zge && Gge(uz, Kge, {
  configurable: !0,
  get: function () {
    try {
      return Wge(fz, Vge(this))[1]
    } catch {
      return ""
    }
  }
});
var Yge = j,
  IS = he;
Yge({
  global: !0,
  forced: IS.globalThis !== IS
}, {
  globalThis: IS
});
var qge = he,
  Xge = wn;
Xge(qge.JSON, "JSON", !0);
var os = {},
  Qge = {
    get exports() {
      return os
    },
    set exports(t) {
      os = t
    }
  },
  Zge = re,
  k$ = Zge(function () {
    if (typeof ArrayBuffer == "function") {
      var t = new ArrayBuffer(8);
      Object.isExtensible(t) && Object.defineProperty(t, "a", {
        value: 8
      })
    }
  }),
  Jge = re,
  eme = Me,
  tme = Lr,
  mD = k$,
  Av = Object.isExtensible,
  rme = Jge(function () {
    Av(1)
  }),
  O$ = rme || mD ? function (e) {
    return !eme(e) || mD && tme(e) == "ArrayBuffer" ? !1 : Av ? Av(e) : !0
  } : Av,
  nme = re,
  qf = !nme(function () {
    return Object.isExtensible(Object.preventExtensions({}))
  }),
  ime = j,
  ame = ie,
  sme = Tp,
  ome = Me,
  L$ = He,
  lme = pt.f,
  vD = ms,
  cme = Dx,
  P$ = O$,
  ume = jf,
  fme = qf,
  dz = !1,
  ls = ume("meta"),
  dme = 0,
  N$ = function (t) {
    lme(t, ls, {
      value: {
        objectID: "O" + dme++,
        weakData: {}
      }
    })
  },
  hme = function (t, e) {
    if (!ome(t)) return typeof t == "symbol" ? t : (typeof t == "string" ? "S" : "P") + t;
    if (!L$(t, ls)) {
      if (!P$(t)) return "F";
      if (!e) return "E";
      N$(t)
    }
    return t[ls].objectID
  },
  pme = function (t, e) {
    if (!L$(t, ls)) {
      if (!P$(t)) return !0;
      if (!e) return !1;
      N$(t)
    }
    return t[ls].weakData
  },
  gme = function (t) {
    return fme && dz && P$(t) && !L$(t, ls) && N$(t), t
  },
  mme = function () {
    vme.enable = function () {}, dz = !0;
    var t = vD.f,
      e = ame([].splice),
      r = {};
    r[ls] = 1, t(r).length && (vD.f = function (n) {
      for (var i = t(n), a = 0, s = i.length; a < s; a++)
        if (i[a] === ls) {
          e(i, a, 1);
          break
        } return i
    }, ime({
      target: "Object",
      stat: !0,
      forced: !0
    }, {
      getOwnPropertyNames: cme.f
    }))
  },
  vme = Qge.exports = {
    enable: mme,
    fastKey: hme,
    getWeakData: pme,
    onFreeze: gme
  };
sme[ls] = !0;
var yme = j,
  xme = he,
  bme = ie,
  yD = Ip,
  Eme = _t,
  Sme = os,
  _me = Ta,
  Tme = wa,
  wme = De,
  Rme = on,
  $S = Me,
  CS = re,
  Ame = Vx,
  Ime = wn,
  $me = Gf,
  eb = function (t, e, r) {
    var n = t.indexOf("Map") !== -1,
      i = t.indexOf("Weak") !== -1,
      a = n ? "set" : "add",
      s = xme[t],
      o = s && s.prototype,
      c = s,
      l = {},
      u = function (m) {
        var y = bme(o[m]);
        Eme(o, m, m == "add" ? function (b) {
          return y(this, b === 0 ? 0 : b), this
        } : m == "delete" ? function (x) {
          return i && !$S(x) ? !1 : y(this, x === 0 ? 0 : x)
        } : m == "get" ? function (b) {
          return i && !$S(b) ? void 0 : y(this, b === 0 ? 0 : b)
        } : m == "has" ? function (b) {
          return i && !$S(b) ? !1 : y(this, b === 0 ? 0 : b)
        } : function (b, _) {
          return y(this, b === 0 ? 0 : b, _), this
        })
      },
      f = yD(t, !wme(s) || !(i || o.forEach && !CS(function () {
        new s().entries().next()
      })));
    if (f) c = r.getConstructor(e, t, n, a), Sme.enable();
    else if (yD(t, !0)) {
      var d = new c,
        h = d[a](i ? {} : -0, 1) != d,
        p = CS(function () {
          d.has(1)
        }),
        v = Ame(function (m) {
          new s(m)
        }),
        g = !i && CS(function () {
          for (var m = new s, y = 5; y--;) m[a](y, y);
          return !m.has(-0)
        });
      v || (c = e(function (m, y) {
        Tme(m, o);
        var x = $me(new s, m, c);
        return Rme(y) || _me(y, x[a], {
          that: x,
          AS_ENTRIES: n
        }), x
      }), c.prototype = o, o.constructor = c), (p || g) && (u("delete"), u("has"), n && u("get")), (g || h) && u(a), i && o.clear && delete o.clear
    }
    return l[t] = c, yme({
      global: !0,
      constructor: !0,
      forced: c != s
    }, l), Ime(c, t), i || r.setStrong(c, t, n), c
  },
  Cme = ii,
  kme = sr,
  xD = Fp,
  Ome = Ni,
  Lme = wa,
  Pme = on,
  Nme = Ta,
  Dme = f$,
  Xg = Wx,
  Mme = Wf,
  Ad = _e,
  bD = os.fastKey,
  hz = Mt,
  ED = hz.set,
  kS = hz.getterFor,
  pz = {
    getConstructor: function (t, e, r, n) {
      var i = t(function (l, u) {
          Lme(l, a), ED(l, {
            type: e,
            index: Cme(null),
            first: void 0,
            last: void 0,
            size: 0
          }), Ad || (l.size = 0), Pme(u) || Nme(u, l[n], {
            that: l,
            AS_ENTRIES: r
          })
        }),
        a = i.prototype,
        s = kS(e),
        o = function (l, u, f) {
          var d = s(l),
            h = c(l, u),
            p, v;
          return h ? h.value = f : (d.last = h = {
            index: v = bD(u, !0),
            key: u,
            value: f,
            previous: p = d.last,
            next: void 0,
            removed: !1
          }, d.first || (d.first = h), p && (p.next = h), Ad ? d.size++ : l.size++, v !== "F" && (d.index[v] = h)), l
        },
        c = function (l, u) {
          var f = s(l),
            d = bD(u),
            h;
          if (d !== "F") return f.index[d];
          for (h = f.first; h; h = h.next)
            if (h.key == u) return h
        };
      return xD(a, {
        clear: function () {
          for (var u = this, f = s(u), d = f.index, h = f.first; h;) h.removed = !0, h.previous && (h.previous = h.previous.next = void 0), delete d[h.index], h = h.next;
          f.first = f.last = void 0, Ad ? f.size = 0 : u.size = 0
        },
        delete: function (l) {
          var u = this,
            f = s(u),
            d = c(u, l);
          if (d) {
            var h = d.next,
              p = d.previous;
            delete f.index[d.index], d.removed = !0, p && (p.next = h), h && (h.previous = p), f.first == d && (f.first = h), f.last == d && (f.last = p), Ad ? f.size-- : u.size--
          }
          return !!d
        },
        forEach: function (u) {
          for (var f = s(this), d = Ome(u, arguments.length > 1 ? arguments[1] : void 0), h; h = h ? h.next : f.first;)
            for (d(h.value, h.key, this); h && h.removed;) h = h.previous
        },
        has: function (u) {
          return !!c(this, u)
        }
      }), xD(a, r ? {
        get: function (u) {
          var f = c(this, u);
          return f && f.value
        },
        set: function (u, f) {
          return o(this, u === 0 ? 0 : u, f)
        }
      } : {
        add: function (u) {
          return o(this, u = u === 0 ? 0 : u, u)
        }
      }), Ad && kme(a, "size", {
        configurable: !0,
        get: function () {
          return s(this).size
        }
      }), i
    },
    setStrong: function (t, e, r) {
      var n = e + " Iterator",
        i = kS(e),
        a = kS(n);
      Dme(t, e, function (s, o) {
        ED(this, {
          type: n,
          target: s,
          state: i(s),
          kind: o,
          last: void 0
        })
      }, function () {
        for (var s = a(this), o = s.kind, c = s.last; c && c.removed;) c = c.previous;
        return !s.target || !(s.last = c = c ? c.next : s.state.first) ? (s.target = void 0, Xg(void 0, !0)) : o == "keys" ? Xg(c.key, !1) : o == "values" ? Xg(c.value, !1) : Xg([c.key, c.value], !1)
      }, r ? "entries" : "values", !r, !0), Mme(e)
    }
  },
  Fme = eb,
  Bme = pz;
Fme("Map", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0)
  }
}, Bme);
var Ume = Math.log,
  gz = Math.log1p || function (e) {
    var r = +e;
    return r > -1e-8 && r < 1e-8 ? r - r * r / 2 : Ume(1 + r)
  },
  jme = j,
  Hme = gz,
  OS = Math.acosh,
  zme = Math.log,
  SD = Math.sqrt,
  Gme = Math.LN2,
  Vme = !OS || Math.floor(OS(Number.MAX_VALUE)) != 710 || OS(1 / 0) != 1 / 0;
jme({
  target: "Math",
  stat: !0,
  forced: Vme
}, {
  acosh: function (e) {
    var r = +e;
    return r < 1 ? NaN : r > 9490626562425156e-8 ? zme(r) + Gme : Hme(r - 1 + SD(r - 1) * SD(r + 1))
  }
});
var Wme = j,
  _D = Math.asinh,
  Kme = Math.log,
  Yme = Math.sqrt;

function mz(t) {
  var e = +t;
  return !isFinite(e) || e == 0 ? e : e < 0 ? -mz(-e) : Kme(e + Yme(e * e + 1))
}
var qme = !(_D && 1 / _D(0) > 0);
Wme({
  target: "Math",
  stat: !0,
  forced: qme
}, {
  asinh: mz
});
var Xme = j,
  TD = Math.atanh,
  Qme = Math.log,
  Zme = !(TD && 1 / TD(-0) < 0);
Xme({
  target: "Math",
  stat: !0,
  forced: Zme
}, {
  atanh: function (e) {
    var r = +e;
    return r == 0 ? r : Qme((1 + r) / (1 - r)) / 2
  }
});
var D$ = Math.sign || function (e) {
    var r = +e;
    return r == 0 || r != r ? r : r < 0 ? -1 : 1
  },
  Jme = j,
  eve = D$,
  tve = Math.abs,
  rve = Math.pow;
Jme({
  target: "Math",
  stat: !0
}, {
  cbrt: function (e) {
    var r = +e;
    return eve(r) * rve(tve(r), 1 / 3)
  }
});
var nve = j,
  ive = Math.floor,
  ave = Math.log,
  sve = Math.LOG2E;
nve({
  target: "Math",
  stat: !0
}, {
  clz32: function (e) {
    var r = e >>> 0;
    return r ? 31 - ive(ave(r + .5) * sve) : 32
  }
});
var Id = Math.expm1,
  ove = Math.exp,
  tb = !Id || Id(10) > 22025.465794806718 || Id(10) < 22025.465794806718 || Id(-2e-17) != -2e-17 ? function (e) {
    var r = +e;
    return r == 0 ? r : r > -1e-6 && r < 1e-6 ? r + r * r / 2 : ove(r) - 1
  } : Id,
  lve = j,
  cve = tb,
  wD = Math.cosh,
  uve = Math.abs,
  LS = Math.E,
  fve = !wD || wD(710) === 1 / 0;
lve({
  target: "Math",
  stat: !0,
  forced: fve
}, {
  cosh: function (e) {
    var r = cve(uve(e) - 1) + 1;
    return (r + 1 / (r * LS * LS)) * (LS / 2)
  }
});
var dve = j,
  RD = tb;
dve({
  target: "Math",
  stat: !0,
  forced: RD != Math.expm1
}, {
  expm1: RD
});
var hve = D$,
  pve = Math.abs,
  rb = Math.pow,
  A2 = rb(2, -52),
  Iv = rb(2, -23),
  gve = rb(2, 127) * (2 - Iv),
  PS = rb(2, -126),
  mve = function (t) {
    return t + 1 / A2 - 1 / A2
  },
  vve = Math.fround || function (e) {
    var r = +e,
      n = pve(r),
      i = hve(r),
      a, s;
    return n < PS ? i * mve(n / PS / Iv) * PS * Iv : (a = (1 + Iv / A2) * n, s = a - (a - n), s > gve || s != s ? i * (1 / 0) : i * s)
  },
  yve = j,
  xve = vve;
yve({
  target: "Math",
  stat: !0
}, {
  fround: xve
});
var bve = j,
  AD = Math.hypot,
  Eve = Math.abs,
  Sve = Math.sqrt,
  _ve = !!AD && AD(1 / 0, NaN) !== 1 / 0;
bve({
  target: "Math",
  stat: !0,
  arity: 2,
  forced: _ve
}, {
  hypot: function (e, r) {
    for (var n = 0, i = 0, a = arguments.length, s = 0, o, c; i < a;) o = Eve(arguments[i++]), s < o ? (c = s / o, n = n * c * c + 1, s = o) : o > 0 ? (c = o / s, n += c * c) : n += o;
    return s === 1 / 0 ? 1 / 0 : s * Sve(n)
  }
});
var Tve = j,
  wve = re,
  ID = Math.imul,
  Rve = wve(function () {
    return ID(4294967295, 5) != -5 || ID.length != 2
  });
Tve({
  target: "Math",
  stat: !0,
  forced: Rve
}, {
  imul: function (e, r) {
    var n = 65535,
      i = +e,
      a = +r,
      s = n & i,
      o = n & a;
    return 0 | s * o + ((n & i >>> 16) * o + s * (n & a >>> 16) << 16 >>> 0)
  }
});
var Ave = Math.log,
  Ive = Math.LOG10E,
  vz = Math.log10 || function (e) {
    return Ave(e) * Ive
  },
  $ve = j,
  Cve = vz;
$ve({
  target: "Math",
  stat: !0
}, {
  log10: Cve
});
var kve = j,
  Ove = gz;
kve({
  target: "Math",
  stat: !0
}, {
  log1p: Ove
});
var Lve = j,
  Pve = Math.log,
  Nve = Math.LN2;
Lve({
  target: "Math",
  stat: !0
}, {
  log2: function (e) {
    return Pve(e) / Nve
  }
});
var Dve = j,
  Mve = D$;
Dve({
  target: "Math",
  stat: !0
}, {
  sign: Mve
});
var Fve = j,
  Bve = re,
  $D = tb,
  Uve = Math.abs,
  CD = Math.exp,
  jve = Math.E,
  Hve = Bve(function () {
    return Math.sinh(-2e-17) != -2e-17
  });
Fve({
  target: "Math",
  stat: !0,
  forced: Hve
}, {
  sinh: function (e) {
    var r = +e;
    return Uve(r) < 1 ? ($D(r) - $D(-r)) / 2 : (CD(r - 1) - CD(-r - 1)) * (jve / 2)
  }
});
var zve = j,
  kD = tb,
  OD = Math.exp;
zve({
  target: "Math",
  stat: !0
}, {
  tanh: function (e) {
    var r = +e,
      n = kD(r),
      i = kD(-r);
    return n == 1 / 0 ? 1 : i == 1 / 0 ? -1 : (n - i) / (OD(r) + OD(-r))
  }
});
var Gve = wn;
Gve(Math, "Math", !0);
var Vve = j,
  Wve = xj;
Vve({
  target: "Math",
  stat: !0
}, {
  trunc: Wve
});
var Kve = ie,
  nb = Kve(1.valueOf),
  ib = `	
\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF`,
  Yve = ie,
  qve = Dt,
  Xve = Ce,
  I2 = ib,
  LD = Yve("".replace),
  Qve = RegExp("^[" + I2 + "]+"),
  Zve = RegExp("(^|[^" + I2 + "])[" + I2 + "]+$"),
  NS = function (t) {
    return function (e) {
      var r = Xve(qve(e));
      return t & 1 && (r = LD(r, Qve, "")), t & 2 && (r = LD(r, Zve, "$1")), r
    }
  },
  Xf = {
    start: NS(1),
    end: NS(2),
    trim: NS(3)
  },
  Jve = j,
  yz = jI,
  eye = _e,
  xz = he,
  bz = QI,
  Ez = ie,
  tye = Ip,
  PD = He,
  rye = Gf,
  nye = ni,
  iye = cc,
  Sz = kx,
  aye = re,
  sye = ms.f,
  oye = ar.f,
  lye = pt.f,
  cye = nb,
  uye = Xf.trim,
  ab = "Number",
  Iu = xz[ab];
bz[ab];
var M$ = Iu.prototype,
  fye = xz.TypeError,
  dye = Ez("".slice),
  Qg = Ez("".charCodeAt),
  hye = function (t) {
    var e = Sz(t, "number");
    return typeof e == "bigint" ? e : pye(e)
  },
  pye = function (t) {
    var e = Sz(t, "number"),
      r, n, i, a, s, o, c, l;
    if (iye(e)) throw fye("Cannot convert a Symbol value to a number");
    if (typeof e == "string" && e.length > 2) {
      if (e = uye(e), r = Qg(e, 0), r === 43 || r === 45) {
        if (n = Qg(e, 2), n === 88 || n === 120) return NaN
      } else if (r === 48) {
        switch (Qg(e, 1)) {
          case 66:
          case 98:
            i = 2, a = 49;
            break;
          case 79:
          case 111:
            i = 8, a = 55;
            break;
          default:
            return +e
        }
        for (s = dye(e, 2), o = s.length, c = 0; c < o; c++)
          if (l = Qg(s, c), l < 48 || l > a) return NaN;
        return parseInt(s, i)
      }
    }
    return +e
  },
  F$ = tye(ab, !Iu(" 0o1") || !Iu("0b1") || Iu("+0x1")),
  gye = function (t) {
    return nye(M$, t) && aye(function () {
      cye(t)
    })
  },
  sb = function (e) {
    var r = arguments.length < 1 ? 0 : Iu(hye(e));
    return gye(this) ? rye(Object(r), this, sb) : r
  };
sb.prototype = M$;
F$ && !yz && (M$.constructor = sb);
Jve({
  global: !0,
  constructor: !0,
  wrap: !0,
  forced: F$
}, {
  Number: sb
});
var mye = function (t, e) {
  for (var r = eye ? sye(e) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), n = 0, i; r.length > n; n++) PD(e, i = r[n]) && !PD(t, i) && lye(t, i, oye(e, i))
};
(F$ || yz) && mye(bz[ab], Iu);
var vye = j;
vye({
  target: "Number",
  stat: !0,
  nonConfigurable: !0,
  nonWritable: !0
}, {
  EPSILON: Math.pow(2, -52)
});
var yye = he,
  xye = yye.isFinite,
  bye = Number.isFinite || function (e) {
    return typeof e == "number" && xye(e)
  },
  Eye = j,
  Sye = bye;
Eye({
  target: "Number",
  stat: !0
}, {
  isFinite: Sye
});
var _ye = Me,
  Tye = Math.floor,
  B$ = Number.isInteger || function (e) {
    return !_ye(e) && isFinite(e) && Tye(e) === e
  },
  wye = j,
  Rye = B$;
wye({
  target: "Number",
  stat: !0
}, {
  isInteger: Rye
});
var Aye = j;
Aye({
  target: "Number",
  stat: !0
}, {
  isNaN: function (e) {
    return e != e
  }
});
var Iye = j,
  $ye = B$,
  Cye = Math.abs;
Iye({
  target: "Number",
  stat: !0
}, {
  isSafeInteger: function (e) {
    return $ye(e) && Cye(e) <= 9007199254740991
  }
});
var kye = j;
kye({
  target: "Number",
  stat: !0,
  nonConfigurable: !0,
  nonWritable: !0
}, {
  MAX_SAFE_INTEGER: 9007199254740991
});
var Oye = j;
Oye({
  target: "Number",
  stat: !0,
  nonConfigurable: !0,
  nonWritable: !0
}, {
  MIN_SAFE_INTEGER: -9007199254740991
});
var _z = he,
  Lye = re,
  Pye = ie,
  Nye = Ce,
  Dye = Xf.trim,
  Mye = ib,
  Fye = Pye("".charAt),
  Ey = _z.parseFloat,
  ND = _z.Symbol,
  DD = ND && ND.iterator,
  Bye = 1 / Ey(Mye + "-0") !== -1 / 0 || DD && !Lye(function () {
    Ey(Object(DD))
  }),
  Tz = Bye ? function (e) {
    var r = Dye(Nye(e)),
      n = Ey(r);
    return n === 0 && Fye(r, 0) == "-" ? -0 : n
  } : Ey,
  Uye = j,
  MD = Tz;
Uye({
  target: "Number",
  stat: !0,
  forced: Number.parseFloat != MD
}, {
  parseFloat: MD
});
var wz = he,
  jye = re,
  Hye = ie,
  zye = Ce,
  Gye = Xf.trim,
  FD = ib,
  Oh = wz.parseInt,
  BD = wz.Symbol,
  UD = BD && BD.iterator,
  Rz = /^[+-]?0x/i,
  Vye = Hye(Rz.exec),
  Wye = Oh(FD + "08") !== 8 || Oh(FD + "0x16") !== 22 || UD && !jye(function () {
    Oh(Object(UD))
  }),
  Az = Wye ? function (e, r) {
    var n = Gye(zye(e));
    return Oh(n, r >>> 0 || (Vye(Rz, n) ? 16 : 10))
  } : Oh,
  Kye = j,
  jD = Az;
Kye({
  target: "Number",
  stat: !0,
  forced: Number.parseInt != jD
}, {
  parseInt: jD
});
var Yye = j,
  U$ = ie,
  qye = $t,
  Xye = nb,
  Qye = Jx,
  Zye = vz,
  $2 = re,
  Jye = RangeError,
  HD = String,
  e1e = isFinite,
  t1e = Math.abs,
  r1e = Math.floor,
  zD = Math.pow,
  n1e = Math.round,
  ia = U$(1.toExponential),
  i1e = U$(Qye),
  GD = U$("".slice),
  Iz = ia(-69e-12, 4) === "-6.9000e-11" && ia(1.255, 2) === "1.25e+0" && ia(12345, 3) === "1.235e+4" && ia(25, 0) === "3e+1",
  a1e = function () {
    return $2(function () {
      ia(1, 1 / 0)
    }) && $2(function () {
      ia(1, -1 / 0)
    })
  },
  s1e = function () {
    return !$2(function () {
      ia(1 / 0, 1 / 0), ia(NaN, 1 / 0)
    })
  },
  o1e = !Iz || !a1e() || !s1e();
Yye({
  target: "Number",
  proto: !0,
  forced: o1e
}, {
  toExponential: function (e) {
    var r = Xye(this);
    if (e === void 0) return ia(r);
    var n = qye(e);
    if (!e1e(r)) return String(r);
    if (n < 0 || n > 20) throw Jye("Incorrect fraction digits");
    if (Iz) return ia(r, n);
    var i = "",
      a = "",
      s = 0,
      o = "",
      c = "";
    if (r < 0 && (i = "-", r = -r), r === 0) s = 0, a = i1e("0", n + 1);
    else {
      var l = Zye(r);
      s = r1e(l);
      var u = 0,
        f = zD(10, s - n);
      u = n1e(r / f), 2 * r >= (2 * u + 1) * f && (u += 1), u >= zD(10, n + 1) && (u /= 10, s += 1), a = HD(u)
    }
    return n !== 0 && (a = GD(a, 0, 1) + "." + GD(a, 1)), s === 0 ? (o = "+", c = "0") : (o = s > 0 ? "+" : "-", c = HD(t1e(s))), a += "e" + o + c, i + a
  }
});
var l1e = j,
  j$ = ie,
  c1e = $t,
  u1e = nb,
  f1e = Jx,
  VD = re,
  d1e = RangeError,
  $z = String,
  Cz = Math.floor,
  C2 = j$(f1e),
  WD = j$("".slice),
  $d = j$(1.toFixed),
  du = function (t, e, r) {
    return e === 0 ? r : e % 2 === 1 ? du(t, e - 1, r * t) : du(t * t, e / 2, r)
  },
  h1e = function (t) {
    for (var e = 0, r = t; r >= 4096;) e += 12, r /= 4096;
    for (; r >= 2;) e += 1, r /= 2;
    return e
  },
  Oc = function (t, e, r) {
    for (var n = -1, i = r; ++n < 6;) i += e * t[n], t[n] = i % 1e7, i = Cz(i / 1e7)
  },
  DS = function (t, e) {
    for (var r = 6, n = 0; --r >= 0;) n += t[r], t[r] = Cz(n / e), n = n % e * 1e7
  },
  KD = function (t) {
    for (var e = 6, r = ""; --e >= 0;)
      if (r !== "" || e === 0 || t[e] !== 0) {
        var n = $z(t[e]);
        r = r === "" ? n : r + C2("0", 7 - n.length) + n
      } return r
  },
  p1e = VD(function () {
    return $d(8e-5, 3) !== "0.000" || $d(.9, 0) !== "1" || $d(1.255, 2) !== "1.25" || $d(0xde0b6b3a7640080, 0) !== "1000000000000000128"
  }) || !VD(function () {
    $d({})
  });
l1e({
  target: "Number",
  proto: !0,
  forced: p1e
}, {
  toFixed: function (e) {
    var r = u1e(this),
      n = c1e(e),
      i = [0, 0, 0, 0, 0, 0],
      a = "",
      s = "0",
      o, c, l, u;
    if (n < 0 || n > 20) throw d1e("Incorrect fraction digits");
    if (r != r) return "NaN";
    if (r <= -1e21 || r >= 1e21) return $z(r);
    if (r < 0 && (a = "-", r = -r), r > 1e-21)
      if (o = h1e(r * du(2, 69, 1)) - 69, c = o < 0 ? r * du(2, -o, 1) : r / du(2, o, 1), c *= 4503599627370496, o = 52 - o, o > 0) {
        for (Oc(i, 0, c), l = n; l >= 7;) Oc(i, 1e7, 0), l -= 7;
        for (Oc(i, du(10, l, 1), 0), l = o - 1; l >= 23;) DS(i, 1 << 23), l -= 23;
        DS(i, 1 << l), Oc(i, 1, 1), DS(i, 2), s = KD(i)
      } else Oc(i, 0, c), Oc(i, 1 << -o, 0), s = KD(i) + C2("0", n);
    return n > 0 ? (u = s.length, s = a + (u <= n ? "0." + C2("0", n - u) + s : WD(s, 0, u - n) + "." + WD(s, u - n))) : s = a + s, s
  }
});
var g1e = j,
  m1e = ie,
  YD = re,
  qD = nb,
  Sy = m1e(1.toPrecision),
  v1e = YD(function () {
    return Sy(1, void 0) !== "1"
  }) || !YD(function () {
    Sy({})
  });
g1e({
  target: "Number",
  proto: !0,
  forced: v1e
}, {
  toPrecision: function (e) {
    return e === void 0 ? Sy(qD(this)) : Sy(qD(this), e)
  }
});
var XD = _e,
  y1e = ie,
  x1e = $e,
  b1e = re,
  MS = $p,
  E1e = Rp,
  S1e = _p,
  _1e = We,
  T1e = Bf,
  Lc = Object.assign,
  QD = Object.defineProperty,
  w1e = y1e([].concat),
  kz = !Lc || b1e(function () {
    if (XD && Lc({
        b: 1
      }, Lc(QD({}, "a", {
        enumerable: !0,
        get: function () {
          QD(this, "b", {
            value: 3,
            enumerable: !1
          })
        }
      }), {
        b: 2
      })).b !== 1) return !0;
    var t = {},
      e = {},
      r = Symbol(),
      n = "abcdefghijklmnopqrst";
    return t[r] = 7, n.split("").forEach(function (i) {
      e[i] = i
    }), Lc({}, t)[r] != 7 || MS(Lc({}, e)).join("") != n
  }) ? function (e, r) {
    for (var n = _1e(e), i = arguments.length, a = 1, s = E1e.f, o = S1e.f; i > a;)
      for (var c = T1e(arguments[a++]), l = s ? w1e(MS(c), s(c)) : MS(c), u = l.length, f = 0, d; u > f;) d = l[f++], (!XD || x1e(o, c, d)) && (n[d] = c[d]);
    return n
  } : Lc,
  R1e = j,
  ZD = kz;
R1e({
  target: "Object",
  stat: !0,
  arity: 2,
  forced: Object.assign !== ZD
}, {
  assign: ZD
});
var A1e = j,
  I1e = _e,
  $1e = ii;
A1e({
  target: "Object",
  stat: !0,
  sham: !I1e
}, {
  create: $1e
});
var C1e = he,
  k1e = re,
  JD = g$,
  ob = !k1e(function () {
    if (!(JD && JD < 535)) {
      var t = Math.random();
      __defineSetter__.call(null, t, function () {}), delete C1e[t]
    }
  }),
  O1e = j,
  L1e = _e,
  P1e = ob,
  N1e = It,
  D1e = We,
  M1e = pt;
L1e && O1e({
  target: "Object",
  proto: !0,
  forced: P1e
}, {
  __defineGetter__: function (e, r) {
    M1e.f(D1e(this), e, {
      get: N1e(r),
      enumerable: !0,
      configurable: !0
    })
  }
});
var F1e = j,
  B1e = _e,
  e3 = Nx.f;
F1e({
  target: "Object",
  stat: !0,
  forced: Object.defineProperties !== e3,
  sham: !B1e
}, {
  defineProperties: e3
});
var U1e = j,
  j1e = _e,
  t3 = pt.f;
U1e({
  target: "Object",
  stat: !0,
  forced: Object.defineProperty !== t3,
  sham: !j1e
}, {
  defineProperty: t3
});
var H1e = j,
  z1e = _e,
  G1e = ob,
  V1e = It,
  W1e = We,
  K1e = pt;
z1e && H1e({
  target: "Object",
  proto: !0,
  forced: G1e
}, {
  __defineSetter__: function (e, r) {
    K1e.f(W1e(this), e, {
      set: V1e(r),
      enumerable: !0,
      configurable: !0
    })
  }
});
var Y1e = _e,
  Oz = ie,
  q1e = $p,
  X1e = qt,
  Q1e = _p.f,
  Z1e = Oz(Q1e),
  J1e = Oz([].push),
  r3 = function (t) {
    return function (e) {
      for (var r = X1e(e), n = q1e(r), i = n.length, a = 0, s = [], o; i > a;) o = n[a++], (!Y1e || Z1e(r, o)) && J1e(s, t ? [o, r[o]] : r[o]);
      return s
    }
  },
  Lz = {
    entries: r3(!0),
    values: r3(!1)
  },
  exe = j,
  txe = Lz.entries;
exe({
  target: "Object",
  stat: !0
}, {
  entries: function (e) {
    return txe(e)
  }
});
var rxe = j,
  nxe = qf,
  ixe = re,
  axe = Me,
  sxe = os.onFreeze,
  k2 = Object.freeze,
  oxe = ixe(function () {
    k2(1)
  });
rxe({
  target: "Object",
  stat: !0,
  forced: oxe,
  sham: !nxe
}, {
  freeze: function (e) {
    return k2 && axe(e) ? k2(sxe(e)) : e
  }
});
var lxe = j,
  cxe = Ta,
  uxe = vs;
lxe({
  target: "Object",
  stat: !0
}, {
  fromEntries: function (e) {
    var r = {};
    return cxe(e, function (n, i) {
      uxe(r, n, i)
    }, {
      AS_ENTRIES: !0
    }), r
  }
});
var fxe = j,
  dxe = re,
  hxe = qt,
  Pz = ar.f,
  Nz = _e,
  pxe = !Nz || dxe(function () {
    Pz(1)
  });
fxe({
  target: "Object",
  stat: !0,
  forced: pxe,
  sham: !Nz
}, {
  getOwnPropertyDescriptor: function (e, r) {
    return Pz(hxe(e), r)
  }
});
var gxe = j,
  mxe = _e,
  vxe = YI,
  yxe = qt,
  xxe = ar,
  bxe = vs;
gxe({
  target: "Object",
  stat: !0,
  sham: !mxe
}, {
  getOwnPropertyDescriptors: function (e) {
    for (var r = yxe(e), n = xxe.f, i = vxe(r), a = {}, s = 0, o, c; i.length > s;) c = n(r, o = i[s++]), c !== void 0 && bxe(a, o, c);
    return a
  }
});
var Exe = j,
  Sxe = re,
  _xe = Dx.f,
  Txe = Sxe(function () {
    return !Object.getOwnPropertyNames(1)
  });
Exe({
  target: "Object",
  stat: !0,
  forced: Txe
}, {
  getOwnPropertyNames: _xe
});
var wxe = j,
  Rxe = re,
  Axe = We,
  Dz = si,
  Ixe = s$,
  $xe = Rxe(function () {
    Dz(1)
  });
wxe({
  target: "Object",
  stat: !0,
  forced: $xe,
  sham: !Ixe
}, {
  getPrototypeOf: function (e) {
    return Dz(Axe(e))
  }
});
var Cxe = j,
  kxe = He;
Cxe({
  target: "Object",
  stat: !0
}, {
  hasOwn: kxe
});
var Mz = Object.is || function (e, r) {
    return e === r ? e !== 0 || 1 / e === 1 / r : e != e && r != r
  },
  Oxe = j,
  Lxe = Mz;
Oxe({
  target: "Object",
  stat: !0
}, {
  is: Lxe
});
var Pxe = j,
  n3 = O$;
Pxe({
  target: "Object",
  stat: !0,
  forced: Object.isExtensible !== n3
}, {
  isExtensible: n3
});
var Nxe = j,
  Dxe = re,
  Mxe = Me,
  Fxe = Lr,
  Fz = k$,
  O2 = Object.isFrozen,
  Bxe = Fz || Dxe(function () {
    O2(1)
  });
Nxe({
  target: "Object",
  stat: !0,
  forced: Bxe
}, {
  isFrozen: function (e) {
    return !Mxe(e) || Fz && Fxe(e) == "ArrayBuffer" ? !0 : O2 ? O2(e) : !1
  }
});
var Uxe = j,
  jxe = re,
  Hxe = Me,
  zxe = Lr,
  Bz = k$,
  L2 = Object.isSealed,
  Gxe = Bz || jxe(function () {
    L2(1)
  });
Uxe({
  target: "Object",
  stat: !0,
  forced: Gxe
}, {
  isSealed: function (e) {
    return !Hxe(e) || Bz && zxe(e) == "ArrayBuffer" ? !0 : L2 ? L2(e) : !1
  }
});
var Vxe = j,
  Wxe = We,
  Uz = $p,
  Kxe = re,
  Yxe = Kxe(function () {
    Uz(1)
  });
Vxe({
  target: "Object",
  stat: !0,
  forced: Yxe
}, {
  keys: function (e) {
    return Uz(Wxe(e))
  }
});
var qxe = j,
  Xxe = _e,
  Qxe = ob,
  Zxe = We,
  Jxe = Ho,
  ebe = si,
  tbe = ar.f;
Xxe && qxe({
  target: "Object",
  proto: !0,
  forced: Qxe
}, {
  __lookupGetter__: function (e) {
    var r = Zxe(this),
      n = Jxe(e),
      i;
    do
      if (i = tbe(r, n)) return i.get; while (r = ebe(r))
  }
});
var rbe = j,
  nbe = _e,
  ibe = ob,
  abe = We,
  sbe = Ho,
  obe = si,
  lbe = ar.f;
nbe && rbe({
  target: "Object",
  proto: !0,
  forced: ibe
}, {
  __lookupSetter__: function (e) {
    var r = abe(this),
      n = sbe(e),
      i;
    do
      if (i = lbe(r, n)) return i.set; while (r = obe(r))
  }
});
var cbe = j,
  ube = Me,
  fbe = os.onFreeze,
  dbe = qf,
  hbe = re,
  P2 = Object.preventExtensions,
  pbe = hbe(function () {
    P2(1)
  });
cbe({
  target: "Object",
  stat: !0,
  forced: pbe,
  sham: !dbe
}, {
  preventExtensions: function (e) {
    return P2 && ube(e) ? P2(fbe(e)) : e
  }
});
var gbe = _e,
  mbe = sr,
  i3 = Me,
  vbe = We,
  ybe = Dt,
  a3 = Object.getPrototypeOf,
  s3 = Object.setPrototypeOf,
  o3 = Object.prototype,
  l3 = "__proto__";
if (gbe && a3 && s3 && !(l3 in o3)) try {
  mbe(o3, l3, {
    configurable: !0,
    get: function () {
      return a3(vbe(this))
    },
    set: function (e) {
      var r = ybe(this);
      !i3(e) && e !== null || !i3(r) || s3(r, e)
    }
  })
} catch {}
var xbe = j,
  bbe = Me,
  Ebe = os.onFreeze,
  Sbe = qf,
  _be = re,
  N2 = Object.seal,
  Tbe = _be(function () {
    N2(1)
  });
xbe({
  target: "Object",
  stat: !0,
  forced: Tbe,
  sham: !Sbe
}, {
  seal: function (e) {
    return N2 && bbe(e) ? N2(Ebe(e)) : e
  }
});
var wbe = j,
  Rbe = Sa;
wbe({
  target: "Object",
  stat: !0
}, {
  setPrototypeOf: Rbe
});
var Abe = qI,
  Ibe = Ea,
  $be = Abe ? {}.toString : function () {
    return "[object " + Ibe(this) + "]"
  },
  Cbe = qI,
  kbe = _t,
  Obe = $be;
Cbe || kbe(Object.prototype, "toString", Obe, {
  unsafe: !0
});
var Lbe = j,
  Pbe = Lz.values;
Lbe({
  target: "Object",
  stat: !0
}, {
  values: function (e) {
    return Pbe(e)
  }
});
var Nbe = j,
  c3 = Tz;
Nbe({
  global: !0,
  forced: parseFloat != c3
}, {
  parseFloat: c3
});
var Dbe = j,
  u3 = Az;
Dbe({
  global: !0,
  forced: parseInt != u3
}, {
  parseInt: u3
});
var Mbe = TypeError,
  Es = function (t, e) {
    if (t < e) throw Mbe("Not enough arguments");
    return t
  },
  Fbe = hs,
  jz = /(?:ipad|iphone|ipod).*applewebkit/i.test(Fbe),
  bn = he,
  Bbe = ai,
  Ube = Ni,
  f3 = De,
  jbe = He,
  Hz = re,
  d3 = Sj,
  Hbe = fc,
  h3 = Ox,
  zbe = Es,
  Gbe = jz,
  Vbe = xs,
  D2 = bn.setImmediate,
  M2 = bn.clearImmediate,
  Wbe = bn.process,
  FS = bn.Dispatch,
  Kbe = bn.Function,
  p3 = bn.MessageChannel,
  Ybe = bn.String,
  BS = 0,
  Lh = {},
  g3 = "onreadystatechange",
  x0, ll, US, jS;
Hz(function () {
  x0 = bn.location
});
var H$ = function (t) {
    if (jbe(Lh, t)) {
      var e = Lh[t];
      delete Lh[t], e()
    }
  },
  HS = function (t) {
    return function () {
      H$(t)
    }
  },
  m3 = function (t) {
    H$(t.data)
  },
  v3 = function (t) {
    bn.postMessage(Ybe(t), x0.protocol + "//" + x0.host)
  };
(!D2 || !M2) && (D2 = function (e) {
  zbe(arguments.length, 1);
  var r = f3(e) ? e : Kbe(e),
    n = Hbe(arguments, 1);
  return Lh[++BS] = function () {
    Bbe(r, void 0, n)
  }, ll(BS), BS
}, M2 = function (e) {
  delete Lh[e]
}, Vbe ? ll = function (t) {
  Wbe.nextTick(HS(t))
} : FS && FS.now ? ll = function (t) {
  FS.now(HS(t))
} : p3 && !Gbe ? (US = new p3, jS = US.port2, US.port1.onmessage = m3, ll = Ube(jS.postMessage, jS)) : bn.addEventListener && f3(bn.postMessage) && !bn.importScripts && x0 && x0.protocol !== "file:" && !Hz(v3) ? (ll = v3, bn.addEventListener("message", m3, !1)) : g3 in h3("script") ? ll = function (t) {
  d3.appendChild(h3("script"))[g3] = function () {
    d3.removeChild(this), H$(t)
  }
} : ll = function (t) {
  setTimeout(HS(t), 0)
});
var lb = {
    set: D2,
    clear: M2
  },
  zz = function () {
    this.head = null, this.tail = null
  };
zz.prototype = {
  add: function (t) {
    var e = {
        item: t,
        next: null
      },
      r = this.tail;
    r ? r.next = e : this.head = e, this.tail = e
  },
  get: function () {
    var t = this.head;
    if (t) {
      var e = this.head = t.next;
      return e === null && (this.tail = null), t.item
    }
  }
};
var Gz = zz,
  qbe = hs,
  Xbe = /ipad|iphone|ipod/i.test(qbe) && typeof Pebble < "u",
  Qbe = hs,
  Zbe = /web0s(?!.*chrome)/i.test(Qbe),
  Wl = he,
  y3 = Ni,
  Jbe = ar.f,
  zS = lb.set,
  eEe = Gz,
  tEe = jz,
  rEe = Xbe,
  nEe = Zbe,
  GS = xs,
  x3 = Wl.MutationObserver || Wl.WebKitMutationObserver,
  b3 = Wl.document,
  E3 = Wl.process,
  Zg = Wl.Promise,
  S3 = Jbe(Wl, "queueMicrotask"),
  F2 = S3 && S3.value,
  Pc, VS, WS, Jg, _3;
if (!F2) {
  var em = new eEe,
    tm = function () {
      var t, e;
      for (GS && (t = E3.domain) && t.exit(); e = em.get();) try {
        e()
      } catch (r) {
        throw em.head && Pc(), r
      }
      t && t.enter()
    };
  !tEe && !GS && !nEe && x3 && b3 ? (VS = !0, WS = b3.createTextNode(""), new x3(tm).observe(WS, {
    characterData: !0
  }), Pc = function () {
    WS.data = VS = !VS
  }) : !rEe && Zg && Zg.resolve ? (Jg = Zg.resolve(void 0), Jg.constructor = Zg, _3 = y3(Jg.then, Jg), Pc = function () {
    _3(tm)
  }) : GS ? Pc = function () {
    E3.nextTick(tm)
  } : (zS = y3(zS, Wl), Pc = function () {
    zS(tm)
  }), F2 = function (t) {
    em.head || Pc(), em.add(t)
  }
}
var Vz = F2,
  iEe = function (t, e) {
    try {
      arguments.length == 1 ? console.error(t) : console.error(t, e)
    } catch {}
  },
  Up = function (t) {
    try {
      return {
        error: !1,
        value: t()
      }
    } catch (e) {
      return {
        error: !0,
        value: e
      }
    }
  },
  aEe = he,
  jp = aEe.Promise,
  z$ = typeof Deno == "object" && Deno && typeof Deno.version == "object",
  sEe = z$,
  oEe = xs,
  Wz = !sEe && !oEe && typeof window == "object" && typeof document == "object",
  lEe = he,
  Ph = jp,
  cEe = De,
  uEe = Ip,
  fEe = VI,
  dEe = Fe,
  hEe = Wz,
  pEe = z$,
  KS = ps;
Ph && Ph.prototype;
var gEe = dEe("species"),
  B2 = !1,
  Kz = cEe(lEe.PromiseRejectionEvent),
  mEe = uEe("Promise", function () {
    var t = fEe(Ph),
      e = t !== String(Ph);
    if (!e && KS === 66) return !0;
    if (!KS || KS < 51 || !/native code/.test(t)) {
      var r = new Ph(function (a) {
          a(1)
        }),
        n = function (a) {
          a(function () {}, function () {})
        },
        i = r.constructor = {};
      if (i[gEe] = n, B2 = r.then(function () {}) instanceof n, !B2) return !0
    }
    return !e && (hEe || pEe) && !Kz
  }),
  Hp = {
    CONSTRUCTOR: mEe,
    REJECTION_EVENT: Kz,
    SUBCLASSING: B2
  },
  Wo = {},
  T3 = It,
  vEe = TypeError,
  yEe = function (t) {
    var e, r;
    this.promise = new t(function (n, i) {
      if (e !== void 0 || r !== void 0) throw vEe("Bad Promise constructor");
      e = n, r = i
    }), this.resolve = T3(e), this.reject = T3(r)
  };
Wo.f = function (t) {
  return new yEe(t)
};
var xEe = j,
  _y = xs,
  Ao = he,
  lf = $e,
  w3 = _t,
  R3 = Sa,
  bEe = wn,
  EEe = Wf,
  SEe = It,
  $v = De,
  _Ee = Me,
  TEe = wa,
  wEe = Yf,
  Yz = lb.set,
  G$ = Vz,
  REe = iEe,
  AEe = Up,
  IEe = Gz,
  qz = Mt,
  Ty = jp,
  V$ = Hp,
  Xz = Wo,
  cb = "Promise",
  Qz = V$.CONSTRUCTOR,
  $Ee = V$.REJECTION_EVENT,
  CEe = V$.SUBCLASSING,
  YS = qz.getterFor(cb),
  kEe = qz.set,
  tu = Ty && Ty.prototype,
  Sl = Ty,
  rm = tu,
  Zz = Ao.TypeError,
  U2 = Ao.document,
  W$ = Ao.process,
  j2 = Xz.f,
  OEe = j2,
  LEe = !!(U2 && U2.createEvent && Ao.dispatchEvent),
  Jz = "unhandledrejection",
  PEe = "rejectionhandled",
  A3 = 0,
  eG = 1,
  NEe = 2,
  K$ = 1,
  tG = 2,
  nm, I3, DEe, $3, rG = function (t) {
    var e;
    return _Ee(t) && $v(e = t.then) ? e : !1
  },
  nG = function (t, e) {
    var r = e.value,
      n = e.state == eG,
      i = n ? t.ok : t.fail,
      a = t.resolve,
      s = t.reject,
      o = t.domain,
      c, l, u;
    try {
      i ? (n || (e.rejection === tG && FEe(e), e.rejection = K$), i === !0 ? c = r : (o && o.enter(), c = i(r), o && (o.exit(), u = !0)), c === t.promise ? s(Zz("Promise-chain cycle")) : (l = rG(c)) ? lf(l, c, a, s) : a(c)) : s(r)
    } catch (f) {
      o && !u && o.exit(), s(f)
    }
  },
  iG = function (t, e) {
    t.notified || (t.notified = !0, G$(function () {
      for (var r = t.reactions, n; n = r.get();) nG(n, t);
      t.notified = !1, e && !t.rejection && MEe(t)
    }))
  },
  aG = function (t, e, r) {
    var n, i;
    LEe ? (n = U2.createEvent("Event"), n.promise = e, n.reason = r, n.initEvent(t, !1, !0), Ao.dispatchEvent(n)) : n = {
      promise: e,
      reason: r
    }, !$Ee && (i = Ao["on" + t]) ? i(n) : t === Jz && REe("Unhandled promise rejection", r)
  },
  MEe = function (t) {
    lf(Yz, Ao, function () {
      var e = t.facade,
        r = t.value,
        n = C3(t),
        i;
      if (n && (i = AEe(function () {
          _y ? W$.emit("unhandledRejection", r, e) : aG(Jz, e, r)
        }), t.rejection = _y || C3(t) ? tG : K$, i.error)) throw i.value
    })
  },
  C3 = function (t) {
    return t.rejection !== K$ && !t.parent
  },
  FEe = function (t) {
    lf(Yz, Ao, function () {
      var e = t.facade;
      _y ? W$.emit("rejectionHandled", e) : aG(PEe, e, t.value)
    })
  },
  hu = function (t, e, r) {
    return function (n) {
      t(e, n, r)
    }
  },
  $u = function (t, e, r) {
    t.done || (t.done = !0, r && (t = r), t.value = e, t.state = NEe, iG(t, !0))
  },
  H2 = function (t, e, r) {
    if (!t.done) {
      t.done = !0, r && (t = r);
      try {
        if (t.facade === e) throw Zz("Promise can't be resolved itself");
        var n = rG(e);
        n ? G$(function () {
          var i = {
            done: !1
          };
          try {
            lf(n, e, hu(H2, i, t), hu($u, i, t))
          } catch (a) {
            $u(i, a, t)
          }
        }) : (t.value = e, t.state = eG, iG(t, !1))
      } catch (i) {
        $u({
          done: !1
        }, i, t)
      }
    }
  };
if (Qz && (Sl = function (e) {
    TEe(this, rm), SEe(e), lf(nm, this);
    var r = YS(this);
    try {
      e(hu(H2, r), hu($u, r))
    } catch (n) {
      $u(r, n)
    }
  }, rm = Sl.prototype, nm = function (e) {
    kEe(this, {
      type: cb,
      done: !1,
      notified: !1,
      parent: !1,
      reactions: new IEe,
      rejection: !1,
      state: A3,
      value: void 0
    })
  }, nm.prototype = w3(rm, "then", function (e, r) {
    var n = YS(this),
      i = j2(wEe(this, Sl));
    return n.parent = !0, i.ok = $v(e) ? e : !0, i.fail = $v(r) && r, i.domain = _y ? W$.domain : void 0, n.state == A3 ? n.reactions.add(i) : G$(function () {
      nG(i, n)
    }), i.promise
  }), I3 = function () {
    var t = new nm,
      e = YS(t);
    this.promise = t, this.resolve = hu(H2, e), this.reject = hu($u, e)
  }, Xz.f = j2 = function (t) {
    return t === Sl || t === DEe ? new I3(t) : OEe(t)
  }, $v(Ty) && tu !== Object.prototype)) {
  $3 = tu.then, CEe || w3(tu, "then", function (e, r) {
    var n = this;
    return new Sl(function (i, a) {
      lf($3, n, i, a)
    }).then(e, r)
  }, {
    unsafe: !0
  });
  try {
    delete tu.constructor
  } catch {}
  R3 && R3(tu, rm)
}
xEe({
  global: !0,
  constructor: !0,
  wrap: !0,
  forced: Qz
}, {
  Promise: Sl
});
bEe(Sl, cb, !1);
EEe(cb);
var BEe = jp,
  UEe = Vx,
  jEe = Hp.CONSTRUCTOR,
  ub = jEe || !UEe(function (t) {
    BEe.all(t).then(void 0, function () {})
  }),
  HEe = j,
  zEe = $e,
  GEe = It,
  VEe = Wo,
  WEe = Up,
  KEe = Ta,
  YEe = ub;
HEe({
  target: "Promise",
  stat: !0,
  forced: YEe
}, {
  all: function (e) {
    var r = this,
      n = VEe.f(r),
      i = n.resolve,
      a = n.reject,
      s = WEe(function () {
        var o = GEe(r.resolve),
          c = [],
          l = 0,
          u = 1;
        KEe(e, function (f) {
          var d = l++,
            h = !1;
          u++, zEe(o, r, f).then(function (p) {
            h || (h = !0, c[d] = p, --u || i(c))
          }, a)
        }), --u || i(c)
      });
    return s.error && a(s.value), n.promise
  }
});
var qEe = j,
  XEe = Hp.CONSTRUCTOR,
  z2 = jp,
  QEe = ht,
  ZEe = De,
  JEe = _t,
  k3 = z2 && z2.prototype;
qEe({
  target: "Promise",
  proto: !0,
  forced: XEe,
  real: !0
}, {
  catch: function (t) {
    return this.then(void 0, t)
  }
});
if (ZEe(z2)) {
  var O3 = QEe("Promise").prototype.catch;
  k3.catch !== O3 && JEe(k3, "catch", O3, {
    unsafe: !0
  })
}
var eSe = j,
  tSe = $e,
  rSe = It,
  nSe = Wo,
  iSe = Up,
  aSe = Ta,
  sSe = ub;
eSe({
  target: "Promise",
  stat: !0,
  forced: sSe
}, {
  race: function (e) {
    var r = this,
      n = nSe.f(r),
      i = n.reject,
      a = iSe(function () {
        var s = rSe(r.resolve);
        aSe(e, function (o) {
          tSe(s, r, o).then(n.resolve, i)
        })
      });
    return a.error && i(a.value), n.promise
  }
});
var oSe = j,
  lSe = $e,
  cSe = Wo,
  uSe = Hp.CONSTRUCTOR;
oSe({
  target: "Promise",
  stat: !0,
  forced: uSe
}, {
  reject: function (e) {
    var r = cSe.f(this);
    return lSe(r.reject, void 0, e), r.promise
  }
});
var fSe = Ie,
  dSe = Me,
  hSe = Wo,
  sG = function (t, e) {
    if (fSe(t), dSe(e) && e.constructor === t) return e;
    var r = hSe.f(t),
      n = r.resolve;
    return n(e), r.promise
  },
  pSe = j,
  gSe = ht,
  mSe = Hp.CONSTRUCTOR,
  vSe = sG;
gSe("Promise");
pSe({
  target: "Promise",
  stat: !0,
  forced: mSe
}, {
  resolve: function (e) {
    return vSe(this, e)
  }
});
var ySe = j,
  xSe = $e,
  bSe = It,
  ESe = Wo,
  SSe = Up,
  _Se = Ta,
  TSe = ub;
ySe({
  target: "Promise",
  stat: !0,
  forced: TSe
}, {
  allSettled: function (e) {
    var r = this,
      n = ESe.f(r),
      i = n.resolve,
      a = n.reject,
      s = SSe(function () {
        var o = bSe(r.resolve),
          c = [],
          l = 0,
          u = 1;
        _Se(e, function (f) {
          var d = l++,
            h = !1;
          u++, xSe(o, r, f).then(function (p) {
            h || (h = !0, c[d] = {
              status: "fulfilled",
              value: p
            }, --u || i(c))
          }, function (p) {
            h || (h = !0, c[d] = {
              status: "rejected",
              reason: p
            }, --u || i(c))
          })
        }), --u || i(c)
      });
    return s.error && a(s.value), n.promise
  }
});
var wSe = j,
  RSe = $e,
  ASe = It,
  ISe = ht,
  $Se = Wo,
  CSe = Up,
  kSe = Ta,
  OSe = ub,
  L3 = "No one promise resolved";
wSe({
  target: "Promise",
  stat: !0,
  forced: OSe
}, {
  any: function (e) {
    var r = this,
      n = ISe("AggregateError"),
      i = $Se.f(r),
      a = i.resolve,
      s = i.reject,
      o = CSe(function () {
        var c = ASe(r.resolve),
          l = [],
          u = 0,
          f = 1,
          d = !1;
        kSe(e, function (h) {
          var p = u++,
            v = !1;
          f++, RSe(c, r, h).then(function (g) {
            v || d || (d = !0, a(g))
          }, function (g) {
            v || d || (v = !0, l[p] = g, --f || s(new n(l, L3)))
          })
        }), --f || s(new n(l, L3))
      });
    return o.error && s(o.value), i.promise
  }
});
var LSe = j,
  wy = jp,
  PSe = re,
  oG = ht,
  lG = De,
  NSe = Yf,
  P3 = sG,
  DSe = _t,
  G2 = wy && wy.prototype,
  MSe = !!wy && PSe(function () {
    G2.finally.call({
      then: function () {}
    }, function () {})
  });
LSe({
  target: "Promise",
  proto: !0,
  real: !0,
  forced: MSe
}, {
  finally: function (t) {
    var e = NSe(this, oG("Promise")),
      r = lG(t);
    return this.then(r ? function (n) {
      return P3(e, t()).then(function () {
        return n
      })
    } : t, r ? function (n) {
      return P3(e, t()).then(function () {
        throw n
      })
    } : t)
  }
});
if (lG(wy)) {
  var N3 = oG("Promise").prototype.finally;
  G2.finally !== N3 && DSe(G2, "finally", N3, {
    unsafe: !0
  })
}
var FSe = j,
  BSe = ai,
  USe = It,
  jSe = Ie,
  HSe = re,
  zSe = !HSe(function () {
    Reflect.apply(function () {})
  });
FSe({
  target: "Reflect",
  stat: !0,
  forced: zSe
}, {
  apply: function (e, r, n) {
    return BSe(USe(e), r, jSe(n))
  }
});
var GSe = j,
  VSe = ht,
  qS = ai,
  WSe = lz,
  D3 = R$,
  KSe = Ie,
  M3 = Me,
  YSe = ii,
  cG = re,
  Y$ = VSe("Reflect", "construct"),
  qSe = Object.prototype,
  XSe = [].push,
  uG = cG(function () {
    function t() {}
    return !(Y$(function () {}, [], t) instanceof t)
  }),
  fG = !cG(function () {
    Y$(function () {})
  }),
  F3 = uG || fG;
GSe({
  target: "Reflect",
  stat: !0,
  forced: F3,
  sham: F3
}, {
  construct: function (e, r) {
    D3(e), KSe(r);
    var n = arguments.length < 3 ? e : D3(arguments[2]);
    if (fG && !uG) return Y$(e, r, n);
    if (e == n) {
      switch (r.length) {
        case 0:
          return new e;
        case 1:
          return new e(r[0]);
        case 2:
          return new e(r[0], r[1]);
        case 3:
          return new e(r[0], r[1], r[2]);
        case 4:
          return new e(r[0], r[1], r[2], r[3])
      }
      var i = [null];
      return qS(XSe, i, r), new(qS(WSe, e, i))
    }
    var a = n.prototype,
      s = YSe(M3(a) ? a : qSe),
      o = qS(e, s, r);
    return M3(o) ? o : s
  }
});
var QSe = j,
  ZSe = _e,
  B3 = Ie,
  JSe = Ho,
  dG = pt,
  e_e = re,
  t_e = e_e(function () {
    Reflect.defineProperty(dG.f({}, 1, {
      value: 1
    }), 1, {
      value: 2
    })
  });
QSe({
  target: "Reflect",
  stat: !0,
  forced: t_e,
  sham: !ZSe
}, {
  defineProperty: function (e, r, n) {
    B3(e);
    var i = JSe(r);
    B3(n);
    try {
      return dG.f(e, i, n), !0
    } catch {
      return !1
    }
  }
});
var r_e = j,
  n_e = Ie,
  i_e = ar.f;
r_e({
  target: "Reflect",
  stat: !0
}, {
  deleteProperty: function (e, r) {
    var n = i_e(n_e(e), r);
    return n && !n.configurable ? !1 : delete e[r]
  }
});
var U3 = He,
  hG = function (t) {
    return t !== void 0 && (U3(t, "value") || U3(t, "writable"))
  },
  a_e = j,
  s_e = $e,
  o_e = Me,
  l_e = Ie,
  c_e = hG,
  u_e = ar,
  f_e = si;

function pG(t, e) {
  var r = arguments.length < 3 ? t : arguments[2],
    n, i;
  if (l_e(t) === r) return t[e];
  if (n = u_e.f(t, e), n) return c_e(n) ? n.value : n.get === void 0 ? void 0 : s_e(n.get, r);
  if (o_e(i = f_e(t))) return pG(i, e, r)
}
a_e({
  target: "Reflect",
  stat: !0
}, {
  get: pG
});
var d_e = j,
  h_e = _e,
  p_e = Ie,
  g_e = ar;
d_e({
  target: "Reflect",
  stat: !0,
  sham: !h_e
}, {
  getOwnPropertyDescriptor: function (e, r) {
    return g_e.f(p_e(e), r)
  }
});
var m_e = j,
  v_e = Ie,
  y_e = si,
  x_e = s$;
m_e({
  target: "Reflect",
  stat: !0,
  sham: !x_e
}, {
  getPrototypeOf: function (e) {
    return y_e(v_e(e))
  }
});
var b_e = j;
b_e({
  target: "Reflect",
  stat: !0
}, {
  has: function (e, r) {
    return r in e
  }
});
var E_e = j,
  S_e = Ie,
  __e = O$;
E_e({
  target: "Reflect",
  stat: !0
}, {
  isExtensible: function (e) {
    return S_e(e), __e(e)
  }
});
var T_e = j,
  w_e = YI;
T_e({
  target: "Reflect",
  stat: !0
}, {
  ownKeys: w_e
});
var R_e = j,
  A_e = ht,
  I_e = Ie,
  $_e = qf;
R_e({
  target: "Reflect",
  stat: !0,
  sham: !$_e
}, {
  preventExtensions: function (e) {
    I_e(e);
    try {
      var r = A_e("Object", "preventExtensions");
      return r && r(e), !0
    } catch {
      return !1
    }
  }
});
var C_e = j,
  k_e = $e,
  O_e = Ie,
  j3 = Me,
  L_e = hG,
  P_e = re,
  V2 = pt,
  H3 = ar,
  N_e = si,
  z3 = ri;

function gG(t, e, r) {
  var n = arguments.length < 4 ? t : arguments[3],
    i = H3.f(O_e(t), e),
    a, s, o;
  if (!i) {
    if (j3(s = N_e(t))) return gG(s, e, r, n);
    i = z3(0)
  }
  if (L_e(i)) {
    if (i.writable === !1 || !j3(n)) return !1;
    if (a = H3.f(n, e)) {
      if (a.get || a.set || a.writable === !1) return !1;
      a.value = r, V2.f(n, e, a)
    } else V2.f(n, e, z3(0, r))
  } else {
    if (o = i.set, o === void 0) return !1;
    k_e(o, n, r)
  }
  return !0
}
var D_e = P_e(function () {
  var t = function () {},
    e = V2.f(new t, "a", {
      configurable: !0
    });
  return Reflect.set(t.prototype, "a", 1, e) !== !1
});
C_e({
  target: "Reflect",
  stat: !0,
  forced: D_e
}, {
  set: gG
});
var M_e = j,
  F_e = Ie,
  B_e = Jj,
  G3 = Sa;
G3 && M_e({
  target: "Reflect",
  stat: !0
}, {
  setPrototypeOf: function (e, r) {
    F_e(e), B_e(r);
    try {
      return G3(e, r), !0
    } catch {
      return !1
    }
  }
});
var U_e = j,
  j_e = he,
  H_e = wn;
U_e({
  global: !0
}, {
  Reflect: {}
});
H_e(j_e.Reflect, "Reflect", !0);
var z_e = Me,
  G_e = Lr,
  V_e = Fe,
  W_e = V_e("match"),
  zp = function (t) {
    var e;
    return z_e(t) && ((e = t[W_e]) !== void 0 ? !!e : G_e(t) == "RegExp")
  },
  K_e = Ie,
  q$ = function () {
    var t = K_e(this),
      e = "";
    return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
  },
  Y_e = $e,
  q_e = He,
  X_e = ni,
  Q_e = q$,
  V3 = RegExp.prototype,
  Gp = function (t) {
    var e = t.flags;
    return e === void 0 && !("flags" in V3) && !q_e(t, "flags") && X_e(V3, t) ? Y_e(Q_e, t) : e
  },
  X$ = re,
  Z_e = he,
  Q$ = Z_e.RegExp,
  Z$ = X$(function () {
    var t = Q$("a", "y");
    return t.lastIndex = 2, t.exec("abcd") != null
  }),
  J_e = Z$ || X$(function () {
    return !Q$("a", "y").sticky
  }),
  eTe = Z$ || X$(function () {
    var t = Q$("^r", "gy");
    return t.lastIndex = 2, t.exec("str") != null
  }),
  fb = {
    BROKEN_CARET: eTe,
    MISSED_STICKY: J_e,
    UNSUPPORTED_Y: Z$
  },
  tTe = re,
  rTe = he,
  nTe = rTe.RegExp,
  J$ = tTe(function () {
    var t = nTe(".", "s");
    return !(t.dotAll && t.exec(`
`) && t.flags === "s")
  }),
  iTe = re,
  aTe = he,
  sTe = aTe.RegExp,
  mG = iTe(function () {
    var t = sTe("(?<a>b)", "g");
    return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc"
  }),
  oTe = _e,
  eC = he,
  Vp = ie,
  lTe = Ip,
  cTe = Gf,
  uTe = Pr,
  fTe = ms.f,
  W3 = ni,
  dTe = zp,
  K3 = Ce,
  hTe = Gp,
  vG = fb,
  pTe = eH,
  gTe = _t,
  mTe = re,
  vTe = He,
  yTe = Mt.enforce,
  xTe = Wf,
  bTe = Fe,
  yG = J$,
  xG = mG,
  ETe = bTe("match"),
  oo = eC.RegExp,
  ru = oo.prototype,
  STe = eC.SyntaxError,
  _Te = Vp(ru.exec),
  Ry = Vp("".charAt),
  Y3 = Vp("".replace),
  q3 = Vp("".indexOf),
  TTe = Vp("".slice),
  wTe = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,
  Fl = /a/g,
  XS = /a/g,
  RTe = new oo(Fl) !== Fl,
  bG = vG.MISSED_STICKY,
  ATe = vG.UNSUPPORTED_Y,
  ITe = oTe && (!RTe || bG || yG || xG || mTe(function () {
    return XS[ETe] = !1, oo(Fl) != Fl || oo(XS) == XS || oo(Fl, "i") != "/a/i"
  })),
  $Te = function (t) {
    for (var e = t.length, r = 0, n = "", i = !1, a; r <= e; r++) {
      if (a = Ry(t, r), a === "\\") {
        n += a + Ry(t, ++r);
        continue
      }!i && a === "." ? n += "[\\s\\S]" : (a === "[" ? i = !0 : a === "]" && (i = !1), n += a)
    }
    return n
  },
  CTe = function (t) {
    for (var e = t.length, r = 0, n = "", i = [], a = {}, s = !1, o = !1, c = 0, l = "", u; r <= e; r++) {
      if (u = Ry(t, r), u === "\\") u = u + Ry(t, ++r);
      else if (u === "]") s = !1;
      else if (!s) switch (!0) {
        case u === "[":
          s = !0;
          break;
        case u === "(":
          _Te(wTe, TTe(t, r + 1)) && (r += 2, o = !0), n += u, c++;
          continue;
        case (u === ">" && o):
          if (l === "" || vTe(a, l)) throw new STe("Invalid capture group name");
          a[l] = !0, i[i.length] = [l, c], o = !1, l = "";
          continue
      }
      o ? l += u : n += u
    }
    return [n, i]
  };
if (lTe("RegExp", ITe)) {
  for (var cl = function (e, r) {
      var n = W3(ru, this),
        i = dTe(e),
        a = r === void 0,
        s = [],
        o = e,
        c, l, u, f, d, h;
      if (!n && i && a && e.constructor === cl) return e;
      if ((i || W3(ru, e)) && (e = e.source, a && (r = hTe(o))), e = e === void 0 ? "" : K3(e), r = r === void 0 ? "" : K3(r), o = e, yG && "dotAll" in Fl && (l = !!r && q3(r, "s") > -1, l && (r = Y3(r, /s/g, ""))), c = r, bG && "sticky" in Fl && (u = !!r && q3(r, "y") > -1, u && ATe && (r = Y3(r, /y/g, ""))), xG && (f = CTe(e), e = f[0], s = f[1]), d = cTe(oo(e, r), n ? this : ru, cl), (l || u || s.length) && (h = yTe(d), l && (h.dotAll = !0, h.raw = cl($Te(e), c)), u && (h.sticky = !0), s.length && (h.groups = s)), e !== o) try {
        uTe(d, "source", o === "" ? "(?:)" : o)
      } catch {}
      return d
    }, X3 = fTe(oo), Q3 = 0; X3.length > Q3;) pTe(cl, oo, X3[Q3++]);
  ru.constructor = cl, cl.prototype = ru, gTe(eC, "RegExp", cl, {
    constructor: !0
  })
}
xTe("RegExp");
var kTe = _e,
  OTe = J$,
  LTe = Lr,
  PTe = sr,
  NTe = Mt.get,
  Z3 = RegExp.prototype,
  DTe = TypeError;
kTe && OTe && PTe(Z3, "dotAll", {
  configurable: !0,
  get: function () {
    if (this !== Z3) {
      if (LTe(this) === "RegExp") return !!NTe(this).dotAll;
      throw DTe("Incompatible receiver, RegExp required")
    }
  }
});
var pu = $e,
  db = ie,
  MTe = Ce,
  FTe = q$,
  BTe = fb,
  UTe = wo,
  jTe = ii,
  HTe = Mt.get,
  zTe = J$,
  GTe = mG,
  VTe = UTe("native-string-replace", String.prototype.replace),
  Ay = RegExp.prototype.exec,
  W2 = Ay,
  WTe = db("".charAt),
  KTe = db("".indexOf),
  YTe = db("".replace),
  QS = db("".slice),
  K2 = function () {
    var t = /a/,
      e = /b*/g;
    return pu(Ay, t, "a"), pu(Ay, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0
  }(),
  EG = BTe.BROKEN_CARET,
  Y2 = /()??/.exec("")[1] !== void 0,
  qTe = K2 || Y2 || EG || zTe || GTe;
qTe && (W2 = function (e) {
  var r = this,
    n = HTe(r),
    i = MTe(e),
    a = n.raw,
    s, o, c, l, u, f, d;
  if (a) return a.lastIndex = r.lastIndex, s = pu(W2, a, i), r.lastIndex = a.lastIndex, s;
  var h = n.groups,
    p = EG && r.sticky,
    v = pu(FTe, r),
    g = r.source,
    m = 0,
    y = i;
  if (p && (v = YTe(v, "y", ""), KTe(v, "g") === -1 && (v += "g"), y = QS(i, r.lastIndex), r.lastIndex > 0 && (!r.multiline || r.multiline && WTe(i, r.lastIndex - 1) !== `
`) && (g = "(?: " + g + ")", y = " " + y, m++), o = new RegExp("^(?:" + g + ")", v)), Y2 && (o = new RegExp("^" + g + "$(?!\\s)", v)), K2 && (c = r.lastIndex), l = pu(Ay, p ? o : r, y), p ? l ? (l.input = QS(l.input, m), l[0] = QS(l[0], m), l.index = r.lastIndex, r.lastIndex += l[0].length) : r.lastIndex = 0 : K2 && l && (r.lastIndex = r.global ? l.index + l[0].length : c), Y2 && l && l.length > 1 && pu(VTe, l[0], o, function () {
      for (u = 1; u < arguments.length - 2; u++) arguments[u] === void 0 && (l[u] = void 0)
    }), l && h)
    for (l.groups = f = jTe(null), u = 0; u < h.length; u++) d = h[u], f[d[0]] = l[d[1]];
  return l
});
var hb = W2,
  XTe = j,
  J3 = hb;
XTe({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== J3
}, {
  exec: J3
});
var QTe = he,
  ZTe = _e,
  JTe = sr,
  ewe = q$,
  twe = re,
  SG = QTe.RegExp,
  _G = SG.prototype,
  rwe = ZTe && twe(function () {
    var t = !0;
    try {
      SG(".", "d")
    } catch {
      t = !1
    }
    var e = {},
      r = "",
      n = t ? "dgimsy" : "gimsy",
      i = function (c, l) {
        Object.defineProperty(e, c, {
          get: function () {
            return r += l, !0
          }
        })
      },
      a = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
    t && (a.hasIndices = "d");
    for (var s in a) i(s, a[s]);
    var o = Object.getOwnPropertyDescriptor(_G, "flags").get.call(e);
    return o !== n || r !== n
  });
rwe && JTe(_G, "flags", {
  configurable: !0,
  get: ewe
});
var nwe = _e,
  iwe = fb.MISSED_STICKY,
  awe = Lr,
  swe = sr,
  owe = Mt.get,
  e4 = RegExp.prototype,
  lwe = TypeError;
nwe && iwe && swe(e4, "sticky", {
  configurable: !0,
  get: function () {
    if (this !== e4) {
      if (awe(this) === "RegExp") return !!owe(this).sticky;
      throw lwe("Incompatible receiver, RegExp required")
    }
  }
});
var cwe = j,
  t4 = $e,
  uwe = De,
  r4 = Ie,
  fwe = Ce,
  dwe = function () {
    var t = !1,
      e = /[ac]/;
    return e.exec = function () {
      return t = !0, /./.exec.apply(this, arguments)
    }, e.test("abc") === !0 && t
  }(),
  hwe = /./.test;
cwe({
  target: "RegExp",
  proto: !0,
  forced: !dwe
}, {
  test: function (t) {
    var e = r4(this),
      r = fwe(t),
      n = e.exec;
    if (!uwe(n)) return t4(hwe, e, r);
    var i = t4(n, e, r);
    return i === null ? !1 : (r4(i), !0)
  }
});
var pwe = Hf.PROPER,
  gwe = _t,
  mwe = Ie,
  n4 = Ce,
  vwe = re,
  ywe = Gp,
  tC = "toString",
  xwe = RegExp.prototype,
  TG = xwe[tC],
  bwe = vwe(function () {
    return TG.call({
      source: "a",
      flags: "b"
    }) != "/a/b"
  }),
  Ewe = pwe && TG.name != tC;
(bwe || Ewe) && gwe(RegExp.prototype, tC, function () {
  var e = mwe(this),
    r = n4(e.source),
    n = n4(ywe(e));
  return "/" + r + "/" + n
}, {
  unsafe: !0
});
var Swe = eb,
  _we = pz;
Swe("Set", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0)
  }
}, _we);
var Twe = j,
  wwe = ie,
  Rwe = Dt,
  Awe = $t,
  Iwe = Ce,
  $we = re,
  Cwe = wwe("".charAt),
  kwe = $we(function () {
    return "ð ®·".at(-2) !== "\uD842"
  });
Twe({
  target: "String",
  proto: !0,
  forced: kwe
}, {
  at: function (e) {
    var r = Iwe(Rwe(this)),
      n = r.length,
      i = Awe(e),
      a = i >= 0 ? i : n + i;
    return a < 0 || a >= n ? void 0 : Cwe(r, a)
  }
});
var rC = ie,
  Owe = $t,
  Lwe = Ce,
  Pwe = Dt,
  Nwe = rC("".charAt),
  i4 = rC("".charCodeAt),
  Dwe = rC("".slice),
  a4 = function (t) {
    return function (e, r) {
      var n = Lwe(Pwe(e)),
        i = Owe(r),
        a = n.length,
        s, o;
      return i < 0 || i >= a ? t ? "" : void 0 : (s = i4(n, i), s < 55296 || s > 56319 || i + 1 === a || (o = i4(n, i + 1)) < 56320 || o > 57343 ? t ? Nwe(n, i) : s : t ? Dwe(n, i, i + 2) : (s - 55296 << 10) + (o - 56320) + 65536)
    }
  },
  pb = {
    codeAt: a4(!1),
    charAt: a4(!0)
  },
  Mwe = j,
  Fwe = pb.codeAt;
Mwe({
  target: "String",
  proto: !0
}, {
  codePointAt: function (e) {
    return Fwe(this, e)
  }
});
var Bwe = zp,
  Uwe = TypeError,
  nC = function (t) {
    if (Bwe(t)) throw Uwe("The method doesn't accept regular expressions");
    return t
  },
  jwe = Fe,
  Hwe = jwe("match"),
  iC = function (t) {
    var e = /./;
    try {
      "/./" [t](e)
    } catch {
      try {
        return e[Hwe] = !1, "/./" [t](e)
      } catch {}
    }
    return !1
  },
  zwe = j,
  wG = zo,
  Gwe = ar.f,
  Vwe = Tn,
  s4 = Ce,
  Wwe = nC,
  Kwe = Dt,
  Ywe = iC,
  o4 = wG("".endsWith),
  qwe = wG("".slice),
  Xwe = Math.min,
  RG = Ywe("endsWith"),
  Qwe = !RG && !! function () {
    var t = Gwe(String.prototype, "endsWith");
    return t && !t.writable
  }();
zwe({
  target: "String",
  proto: !0,
  forced: !Qwe && !RG
}, {
  endsWith: function (e) {
    var r = s4(Kwe(this));
    Wwe(e);
    var n = arguments.length > 1 ? arguments[1] : void 0,
      i = r.length,
      a = n === void 0 ? i : Xwe(Vwe(n), i),
      s = s4(e);
    return o4 ? o4(r, s, a) : qwe(r, a - s.length, a) === s
  }
});
var Zwe = j,
  Jwe = ie,
  e2e = ba,
  t2e = RangeError,
  l4 = String.fromCharCode,
  c4 = String.fromCodePoint,
  r2e = Jwe([].join),
  n2e = !!c4 && c4.length != 1;
Zwe({
  target: "String",
  stat: !0,
  arity: 1,
  forced: n2e
}, {
  fromCodePoint: function (e) {
    for (var r = [], n = arguments.length, i = 0, a; n > i;) {
      if (a = +arguments[i++], e2e(a, 1114111) !== a) throw t2e(a + " is not a valid code point");
      r[i] = a < 65536 ? l4(a) : l4(((a -= 65536) >> 10) + 55296, a % 1024 + 56320)
    }
    return r2e(r, "")
  }
});
var i2e = j,
  a2e = ie,
  s2e = nC,
  o2e = Dt,
  u4 = Ce,
  l2e = iC,
  c2e = a2e("".indexOf);
i2e({
  target: "String",
  proto: !0,
  forced: !l2e("includes")
}, {
  includes: function (e) {
    return !!~c2e(u4(o2e(this)), u4(s2e(e)), arguments.length > 1 ? arguments[1] : void 0)
  }
});
var u2e = pb.charAt,
  f2e = Ce,
  AG = Mt,
  d2e = f$,
  f4 = Wx,
  IG = "String Iterator",
  h2e = AG.set,
  p2e = AG.getterFor(IG);
d2e(String, "String", function (t) {
  h2e(this, {
    type: IG,
    string: f2e(t),
    index: 0
  })
}, function () {
  var e = p2e(this),
    r = e.string,
    n = e.index,
    i;
  return n >= r.length ? f4(void 0, !0) : (i = u2e(r, n), e.index += i.length, f4(i, !1))
});
var d4 = zo,
  h4 = _t,
  g2e = hb,
  p4 = re,
  $G = Fe,
  m2e = Pr,
  v2e = $G("species"),
  ZS = RegExp.prototype,
  gb = function (t, e, r, n) {
    var i = $G(t),
      a = !p4(function () {
        var l = {};
        return l[i] = function () {
          return 7
        }, "" [t](l) != 7
      }),
      s = a && !p4(function () {
        var l = !1,
          u = /a/;
        return t === "split" && (u = {}, u.constructor = {}, u.constructor[v2e] = function () {
          return u
        }, u.flags = "", u[i] = /./ [i]), u.exec = function () {
          return l = !0, null
        }, u[i](""), !l
      });
    if (!a || !s || r) {
      var o = d4(/./ [i]),
        c = e(i, "" [t], function (l, u, f, d, h) {
          var p = d4(l),
            v = u.exec;
          return v === g2e || v === ZS.exec ? a && !h ? {
            done: !0,
            value: o(u, f, d)
          } : {
            done: !0,
            value: p(f, u, d)
          } : {
            done: !1
          }
        });
      h4(String.prototype, t, c[0]), h4(ZS, i, c[1])
    }
    n && m2e(ZS[i], "sham", !0)
  },
  y2e = pb.charAt,
  mb = function (t, e, r) {
    return e + (r ? y2e(t, e).length : 1)
  },
  g4 = $e,
  x2e = Ie,
  b2e = De,
  E2e = Lr,
  S2e = hb,
  _2e = TypeError,
  Wp = function (t, e) {
    var r = t.exec;
    if (b2e(r)) {
      var n = g4(r, t, e);
      return n !== null && x2e(n), n
    }
    if (E2e(t) === "RegExp") return g4(S2e, t, e);
    throw _2e("RegExp#exec called on incompatible receiver")
  },
  T2e = $e,
  w2e = gb,
  R2e = Ie,
  A2e = on,
  I2e = Tn,
  JS = Ce,
  $2e = Dt,
  C2e = gs,
  k2e = mb,
  m4 = Wp;
w2e("match", function (t, e, r) {
  return [function (i) {
    var a = $2e(this),
      s = A2e(i) ? void 0 : C2e(i, t);
    return s ? T2e(s, i, a) : new RegExp(i)[t](JS(a))
  }, function (n) {
    var i = R2e(this),
      a = JS(n),
      s = r(e, i, a);
    if (s.done) return s.value;
    if (!i.global) return m4(i, a);
    var o = i.unicode;
    i.lastIndex = 0;
    for (var c = [], l = 0, u;
      (u = m4(i, a)) !== null;) {
      var f = JS(u[0]);
      c[l] = f, f === "" && (i.lastIndex = k2e(a, I2e(i.lastIndex), o)), l++
    }
    return l === 0 ? null : c
  }]
});
var O2e = j,
  L2e = $e,
  CG = zo,
  P2e = u$,
  im = Wx,
  v4 = Dt,
  kG = Tn,
  b0 = Ce,
  N2e = Ie,
  D2e = on,
  M2e = Lr,
  F2e = zp,
  OG = Gp,
  B2e = gs,
  U2e = _t,
  j2e = re,
  H2e = Fe,
  z2e = Yf,
  G2e = mb,
  V2e = Wp,
  LG = Mt,
  W2e = jI,
  Iy = H2e("matchAll"),
  PG = "RegExp String",
  NG = PG + " Iterator",
  K2e = LG.set,
  Y2e = LG.getterFor(NG),
  y4 = RegExp.prototype,
  q2e = TypeError,
  q2 = CG("".indexOf),
  $y = CG("".matchAll),
  e_ = !!$y && !j2e(function () {
    $y("a", /./)
  }),
  X2e = P2e(function (e, r, n, i) {
    K2e(this, {
      type: NG,
      regexp: e,
      string: r,
      global: n,
      unicode: i,
      done: !1
    })
  }, PG, function () {
    var e = Y2e(this);
    if (e.done) return im(void 0, !0);
    var r = e.regexp,
      n = e.string,
      i = V2e(r, n);
    return i === null ? (e.done = !0, im(void 0, !0)) : e.global ? (b0(i[0]) === "" && (r.lastIndex = G2e(n, kG(r.lastIndex), e.unicode)), im(i, !1)) : (e.done = !0, im(i, !1))
  }),
  DG = function (t) {
    var e = N2e(this),
      r = b0(t),
      n = z2e(e, RegExp),
      i = b0(OG(e)),
      a, s, o;
    return a = new n(n === RegExp ? e.source : e, i), s = !!~q2(i, "g"), o = !!~q2(i, "u"), a.lastIndex = kG(e.lastIndex), new X2e(a, r, s, o)
  };
O2e({
  target: "String",
  proto: !0,
  forced: e_
}, {
  matchAll: function (e) {
    var r = v4(this),
      n, i, a, s;
    if (D2e(e)) {
      if (e_) return $y(r, e)
    } else {
      if (F2e(e) && (n = b0(v4(OG(e))), !~q2(n, "g"))) throw q2e("`.matchAll` does not allow non-global regexes");
      if (e_) return $y(r, e);
      if (a = B2e(e, Iy), a === void 0 && W2e && M2e(e) == "RegExp" && (a = DG), a) return L2e(a, e, r)
    }
    return i = b0(r), s = new RegExp(e, "g"), s[Iy](i)
  }
});
Iy in y4 || U2e(y4, Iy, DG);
var Q2e = hs,
  MG = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(Q2e),
  Z2e = j,
  J2e = $$.end,
  eRe = MG;
Z2e({
  target: "String",
  proto: !0,
  forced: eRe
}, {
  padEnd: function (e) {
    return J2e(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var tRe = j,
  rRe = $$.start,
  nRe = MG;
tRe({
  target: "String",
  proto: !0,
  forced: nRe
}, {
  padStart: function (e) {
    return rRe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var iRe = j,
  FG = ie,
  aRe = qt,
  sRe = We,
  x4 = Ce,
  oRe = Ye,
  b4 = FG([].push),
  lRe = FG([].join);
iRe({
  target: "String",
  stat: !0
}, {
  raw: function (e) {
    var r = aRe(sRe(e).raw),
      n = oRe(r);
    if (!n) return "";
    for (var i = arguments.length, a = [], s = 0;;) {
      if (b4(a, x4(r[s++])), s === n) return lRe(a, "");
      s < i && b4(a, x4(arguments[s]))
    }
  }
});
var cRe = j,
  uRe = Jx;
cRe({
  target: "String",
  proto: !0
}, {
  repeat: uRe
});
var aC = ie,
  fRe = We,
  dRe = Math.floor,
  t_ = aC("".charAt),
  hRe = aC("".replace),
  r_ = aC("".slice),
  pRe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
  gRe = /\$([$&'`]|\d{1,2})/g,
  BG = function (t, e, r, n, i, a) {
    var s = r + t.length,
      o = n.length,
      c = gRe;
    return i !== void 0 && (i = fRe(i), c = pRe), hRe(a, c, function (l, u) {
      var f;
      switch (t_(u, 0)) {
        case "$":
          return "$";
        case "&":
          return t;
        case "`":
          return r_(e, 0, r);
        case "'":
          return r_(e, s);
        case "<":
          f = i[r_(u, 1, -1)];
          break;
        default:
          var d = +u;
          if (d === 0) return l;
          if (d > o) {
            var h = dRe(d / 10);
            return h === 0 ? l : h <= o ? n[h - 1] === void 0 ? t_(u, 1) : n[h - 1] + t_(u, 1) : l
          }
          f = n[d - 1]
      }
      return f === void 0 ? "" : f
    })
  },
  mRe = ai,
  E4 = $e,
  vb = ie,
  vRe = gb,
  yRe = re,
  xRe = Ie,
  bRe = De,
  ERe = on,
  SRe = $t,
  _Re = Tn,
  Nc = Ce,
  TRe = Dt,
  wRe = mb,
  RRe = gs,
  ARe = BG,
  IRe = Wp,
  $Re = Fe,
  X2 = $Re("replace"),
  CRe = Math.max,
  kRe = Math.min,
  ORe = vb([].concat),
  n_ = vb([].push),
  S4 = vb("".indexOf),
  _4 = vb("".slice),
  LRe = function (t) {
    return t === void 0 ? t : String(t)
  },
  PRe = function () {
    return "a".replace(/./, "$0") === "$0"
  }(),
  T4 = function () {
    return /./ [X2] ? /./ [X2]("a", "$0") === "" : !1
  }(),
  NRe = !yRe(function () {
    var t = /./;
    return t.exec = function () {
      var e = [];
      return e.groups = {
        a: "7"
      }, e
    }, "".replace(t, "$<a>") !== "7"
  });
vRe("replace", function (t, e, r) {
  var n = T4 ? "$" : "$0";
  return [function (a, s) {
    var o = TRe(this),
      c = ERe(a) ? void 0 : RRe(a, X2);
    return c ? E4(c, a, o, s) : E4(e, Nc(o), a, s)
  }, function (i, a) {
    var s = xRe(this),
      o = Nc(i);
    if (typeof a == "string" && S4(a, n) === -1 && S4(a, "$<") === -1) {
      var c = r(e, s, o, a);
      if (c.done) return c.value
    }
    var l = bRe(a);
    l || (a = Nc(a));
    var u = s.global;
    if (u) {
      var f = s.unicode;
      s.lastIndex = 0
    }
    for (var d = [];;) {
      var h = IRe(s, o);
      if (h === null || (n_(d, h), !u)) break;
      var p = Nc(h[0]);
      p === "" && (s.lastIndex = wRe(o, _Re(s.lastIndex), f))
    }
    for (var v = "", g = 0, m = 0; m < d.length; m++) {
      h = d[m];
      for (var y = Nc(h[0]), x = CRe(kRe(SRe(h.index), o.length), 0), b = [], _ = 1; _ < h.length; _++) n_(b, LRe(h[_]));
      var S = h.groups;
      if (l) {
        var T = ORe([y], b, x, o);
        S !== void 0 && n_(T, S);
        var R = Nc(mRe(a, void 0, T))
      } else R = ARe(y, o, x, b, S, a);
      x >= g && (v += _4(o, g, x) + R, g = x + y.length)
    }
    return v + _4(o, g)
  }]
}, !NRe || !PRe || T4);
var DRe = j,
  MRe = $e,
  sC = ie,
  w4 = Dt,
  FRe = De,
  BRe = on,
  URe = zp,
  Cd = Ce,
  jRe = gs,
  HRe = Gp,
  zRe = BG,
  GRe = Fe,
  VRe = GRe("replace"),
  WRe = TypeError,
  UG = sC("".indexOf);
sC("".replace);
var R4 = sC("".slice),
  KRe = Math.max,
  A4 = function (t, e, r) {
    return r > t.length ? -1 : e === "" ? r : UG(t, e, r)
  };
DRe({
  target: "String",
  proto: !0
}, {
  replaceAll: function (e, r) {
    var n = w4(this),
      i, a, s, o, c, l, u, f, d, h = 0,
      p = 0,
      v = "";
    if (!BRe(e)) {
      if (i = URe(e), i && (a = Cd(w4(HRe(e))), !~UG(a, "g"))) throw WRe("`.replaceAll` does not allow non-global regexes");
      if (s = jRe(e, VRe), s) return MRe(s, e, n, r)
    }
    for (o = Cd(n), c = Cd(e), l = FRe(r), l || (r = Cd(r)), u = c.length, f = KRe(1, u), h = A4(o, c, 0); h !== -1;) d = l ? Cd(r(c, h, o)) : zRe(c, o, h, [], void 0, r), v += R4(o, p, h) + d, p = h + u, h = A4(o, c, h + f);
    return p < o.length && (v += R4(o, p)), v
  }
});
var YRe = $e,
  qRe = gb,
  XRe = Ie,
  QRe = on,
  ZRe = Dt,
  I4 = Mz,
  $4 = Ce,
  JRe = gs,
  eAe = Wp;
qRe("search", function (t, e, r) {
  return [function (i) {
    var a = ZRe(this),
      s = QRe(i) ? void 0 : JRe(i, t);
    return s ? YRe(s, i, a) : new RegExp(i)[t]($4(a))
  }, function (n) {
    var i = XRe(this),
      a = $4(n),
      s = r(e, i, a);
    if (s.done) return s.value;
    var o = i.lastIndex;
    I4(o, 0) || (i.lastIndex = 0);
    var c = eAe(i, a);
    return I4(i.lastIndex, o) || (i.lastIndex = o), c === null ? -1 : c.index
  }]
});
var tAe = ai,
  kd = $e,
  oC = ie,
  rAe = gb,
  nAe = Ie,
  iAe = on,
  aAe = zp,
  C4 = Dt,
  sAe = Yf,
  oAe = mb,
  lAe = Tn,
  i_ = Ce,
  cAe = gs,
  k4 = Cp,
  O4 = Wp,
  uAe = hb,
  fAe = fb,
  dAe = re,
  Dc = fAe.UNSUPPORTED_Y,
  L4 = 4294967295,
  hAe = Math.min,
  jG = [].push,
  pAe = oC(/./.exec),
  Mc = oC(jG),
  Od = oC("".slice),
  gAe = !dAe(function () {
    var t = /(?:)/,
      e = t.exec;
    t.exec = function () {
      return e.apply(this, arguments)
    };
    var r = "ab".split(t);
    return r.length !== 2 || r[0] !== "a" || r[1] !== "b"
  });
rAe("split", function (t, e, r) {
  var n;
  return "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? n = function (i, a) {
    var s = i_(C4(this)),
      o = a === void 0 ? L4 : a >>> 0;
    if (o === 0) return [];
    if (i === void 0) return [s];
    if (!aAe(i)) return kd(e, s, i, o);
    for (var c = [], l = (i.ignoreCase ? "i" : "") + (i.multiline ? "m" : "") + (i.unicode ? "u" : "") + (i.sticky ? "y" : ""), u = 0, f = new RegExp(i.source, l + "g"), d, h, p;
      (d = kd(uAe, f, s)) && (h = f.lastIndex, !(h > u && (Mc(c, Od(s, u, d.index)), d.length > 1 && d.index < s.length && tAe(jG, c, k4(d, 1)), p = d[0].length, u = h, c.length >= o)));) f.lastIndex === d.index && f.lastIndex++;
    return u === s.length ? (p || !pAe(f, "")) && Mc(c, "") : Mc(c, Od(s, u)), c.length > o ? k4(c, 0, o) : c
  } : "0".split(void 0, 0).length ? n = function (i, a) {
    return i === void 0 && a === 0 ? [] : kd(e, this, i, a)
  } : n = e, [function (a, s) {
    var o = C4(this),
      c = iAe(a) ? void 0 : cAe(a, t);
    return c ? kd(c, a, o, s) : kd(n, i_(o), a, s)
  }, function (i, a) {
    var s = nAe(this),
      o = i_(i),
      c = r(n, s, o, a, n !== e);
    if (c.done) return c.value;
    var l = sAe(s, RegExp),
      u = s.unicode,
      f = (s.ignoreCase ? "i" : "") + (s.multiline ? "m" : "") + (s.unicode ? "u" : "") + (Dc ? "g" : "y"),
      d = new l(Dc ? "^(?:" + s.source + ")" : s, f),
      h = a === void 0 ? L4 : a >>> 0;
    if (h === 0) return [];
    if (o.length === 0) return O4(d, o) === null ? [o] : [];
    for (var p = 0, v = 0, g = []; v < o.length;) {
      d.lastIndex = Dc ? 0 : v;
      var m = O4(d, Dc ? Od(o, v) : o),
        y;
      if (m === null || (y = hAe(lAe(d.lastIndex + (Dc ? v : 0)), o.length)) === p) v = oAe(o, v, u);
      else {
        if (Mc(g, Od(o, p, v)), g.length === h) return g;
        for (var x = 1; x <= m.length - 1; x++)
          if (Mc(g, m[x]), g.length === h) return g;
        v = p = y
      }
    }
    return Mc(g, Od(o, p)), g
  }]
}, !gAe, Dc);
var mAe = j,
  HG = zo,
  vAe = ar.f,
  yAe = Tn,
  P4 = Ce,
  xAe = nC,
  bAe = Dt,
  EAe = iC,
  N4 = HG("".startsWith),
  SAe = HG("".slice),
  _Ae = Math.min,
  zG = EAe("startsWith"),
  TAe = !zG && !! function () {
    var t = vAe(String.prototype, "startsWith");
    return t && !t.writable
  }();
mAe({
  target: "String",
  proto: !0,
  forced: !TAe && !zG
}, {
  startsWith: function (e) {
    var r = P4(bAe(this));
    xAe(e);
    var n = yAe(_Ae(arguments.length > 1 ? arguments[1] : void 0, r.length)),
      i = P4(e);
    return N4 ? N4(r, i, n) : SAe(r, n, n + i.length) === i
  }
});
var wAe = j,
  RAe = ie,
  AAe = Dt,
  D4 = $t,
  IAe = Ce,
  $Ae = RAe("".slice),
  CAe = Math.max,
  kAe = Math.min,
  OAe = !"".substr || "ab".substr(-1) !== "b";
wAe({
  target: "String",
  proto: !0,
  forced: OAe
}, {
  substr: function (e, r) {
    var n = IAe(AAe(this)),
      i = n.length,
      a = D4(e),
      s, o;
    return a === 1 / 0 && (a = 0), a < 0 && (a = CAe(i + a, 0)), s = r === void 0 ? i : D4(r), s <= 0 || s === 1 / 0 ? "" : (o = kAe(a + s, i), a >= o ? "" : $Ae(n, a, o))
  }
});
var LAe = Hf.PROPER,
  PAe = re,
  M4 = ib,
  F4 = "âÂá ",
  lC = function (t) {
    return PAe(function () {
      return !!M4[t]() || F4[t]() !== F4 || LAe && M4[t].name !== t
    })
  },
  NAe = j,
  DAe = Xf.trim,
  MAe = lC;
NAe({
  target: "String",
  proto: !0,
  forced: MAe("trim")
}, {
  trim: function () {
    return DAe(this)
  }
});
var FAe = Xf.end,
  BAe = lC,
  GG = BAe("trimEnd") ? function () {
    return FAe(this)
  } : "".trimEnd,
  UAe = j,
  B4 = GG;
UAe({
  target: "String",
  proto: !0,
  name: "trimEnd",
  forced: "".trimRight !== B4
}, {
  trimRight: B4
});
var jAe = j,
  U4 = GG;
jAe({
  target: "String",
  proto: !0,
  name: "trimEnd",
  forced: "".trimEnd !== U4
}, {
  trimEnd: U4
});
var HAe = Xf.start,
  zAe = lC,
  VG = zAe("trimStart") ? function () {
    return HAe(this)
  } : "".trimStart,
  GAe = j,
  j4 = VG;
GAe({
  target: "String",
  proto: !0,
  name: "trimStart",
  forced: "".trimLeft !== j4
}, {
  trimLeft: j4
});
var VAe = j,
  H4 = VG;
VAe({
  target: "String",
  proto: !0,
  name: "trimStart",
  forced: "".trimStart !== H4
}, {
  trimStart: H4
});
var WAe = ie,
  KAe = Dt,
  z4 = Ce,
  YAe = /"/g,
  qAe = WAe("".replace),
  Rn = function (t, e, r, n) {
    var i = z4(KAe(t)),
      a = "<" + e;
    return r !== "" && (a += " " + r + '="' + qAe(z4(n), YAe, "&quot;") + '"'), a + ">" + i + "</" + e + ">"
  },
  XAe = re,
  An = function (t) {
    return XAe(function () {
      var e = "" [t]('"');
      return e !== e.toLowerCase() || e.split('"').length > 3
    })
  },
  QAe = j,
  ZAe = Rn,
  JAe = An;
QAe({
  target: "String",
  proto: !0,
  forced: JAe("anchor")
}, {
  anchor: function (e) {
    return ZAe(this, "a", "name", e)
  }
});
var eIe = j,
  tIe = Rn,
  rIe = An;
eIe({
  target: "String",
  proto: !0,
  forced: rIe("big")
}, {
  big: function () {
    return tIe(this, "big", "", "")
  }
});
var nIe = j,
  iIe = Rn,
  aIe = An;
nIe({
  target: "String",
  proto: !0,
  forced: aIe("blink")
}, {
  blink: function () {
    return iIe(this, "blink", "", "")
  }
});
var sIe = j,
  oIe = Rn,
  lIe = An;
sIe({
  target: "String",
  proto: !0,
  forced: lIe("bold")
}, {
  bold: function () {
    return oIe(this, "b", "", "")
  }
});
var cIe = j,
  uIe = Rn,
  fIe = An;
cIe({
  target: "String",
  proto: !0,
  forced: fIe("fixed")
}, {
  fixed: function () {
    return uIe(this, "tt", "", "")
  }
});
var dIe = j,
  hIe = Rn,
  pIe = An;
dIe({
  target: "String",
  proto: !0,
  forced: pIe("fontcolor")
}, {
  fontcolor: function (e) {
    return hIe(this, "font", "color", e)
  }
});
var gIe = j,
  mIe = Rn,
  vIe = An;
gIe({
  target: "String",
  proto: !0,
  forced: vIe("fontsize")
}, {
  fontsize: function (e) {
    return mIe(this, "font", "size", e)
  }
});
var yIe = j,
  xIe = Rn,
  bIe = An;
yIe({
  target: "String",
  proto: !0,
  forced: bIe("italics")
}, {
  italics: function () {
    return xIe(this, "i", "", "")
  }
});
var EIe = j,
  SIe = Rn,
  _Ie = An;
EIe({
  target: "String",
  proto: !0,
  forced: _Ie("link")
}, {
  link: function (e) {
    return SIe(this, "a", "href", e)
  }
});
var TIe = j,
  wIe = Rn,
  RIe = An;
TIe({
  target: "String",
  proto: !0,
  forced: RIe("small")
}, {
  small: function () {
    return wIe(this, "small", "", "")
  }
});
var AIe = j,
  IIe = Rn,
  $Ie = An;
AIe({
  target: "String",
  proto: !0,
  forced: $Ie("strike")
}, {
  strike: function () {
    return IIe(this, "strike", "", "")
  }
});
var CIe = j,
  kIe = Rn,
  OIe = An;
CIe({
  target: "String",
  proto: !0,
  forced: OIe("sub")
}, {
  sub: function () {
    return kIe(this, "sub", "", "")
  }
});
var LIe = j,
  PIe = Rn,
  NIe = An;
LIe({
  target: "String",
  proto: !0,
  forced: NIe("sup")
}, {
  sup: function () {
    return PIe(this, "sup", "", "")
  }
});
var ki = {},
  G4 = {
    get exports() {
      return ki
    },
    set exports(t) {
      ki = t
    }
  },
  WG = he,
  a_ = re,
  DIe = Vx,
  MIe = Le.NATIVE_ARRAY_BUFFER_VIEWS,
  FIe = WG.ArrayBuffer,
  ul = WG.Int8Array,
  cC = !MIe || !a_(function () {
    ul(1)
  }) || !a_(function () {
    new ul(-1)
  }) || !DIe(function (t) {
    new ul, new ul(null), new ul(1.5), new ul(t)
  }, !0) || a_(function () {
    return new ul(new FIe(2), 1, void 0).length !== 1
  }),
  BIe = $t,
  UIe = RangeError,
  jIe = function (t) {
    var e = BIe(t);
    if (e < 0) throw UIe("The argument can't be less than 0");
    return e
  },
  HIe = jIe,
  zIe = RangeError,
  KG = function (t, e) {
    var r = HIe(t);
    if (r % e) throw zIe("Wrong offset");
    return r
  },
  GIe = Ea,
  YG = function (t) {
    var e = GIe(t);
    return e == "BigInt64Array" || e == "BigUint64Array"
  },
  VIe = kx,
  WIe = TypeError,
  uC = function (t) {
    var e = VIe(t, "number");
    if (typeof e == "number") throw WIe("Can't convert number to bigint");
    return BigInt(e)
  },
  KIe = Ni,
  YIe = $e,
  qIe = R$,
  XIe = We,
  QIe = Ye,
  ZIe = Hx,
  JIe = Dp,
  e$e = o$,
  t$e = YG,
  r$e = Le.aTypedArrayConstructor,
  n$e = uC,
  qG = function (e) {
    var r = qIe(this),
      n = XIe(e),
      i = arguments.length,
      a = i > 1 ? arguments[1] : void 0,
      s = a !== void 0,
      o = JIe(n),
      c, l, u, f, d, h, p, v;
    if (o && !e$e(o))
      for (p = ZIe(n, o), v = p.next, n = []; !(h = YIe(v, p)).done;) n.push(h.value);
    for (s && i > 2 && (a = KIe(a, arguments[2])), l = QIe(n), u = new(r$e(r))(l), f = t$e(u), c = 0; l > c; c++) d = s ? a(n[c], c) : n[c], u[c] = f ? n$e(d) : +d;
    return u
  },
  V4 = j,
  XG = he,
  W4 = $e,
  i$e = _e,
  a$e = cC,
  Qf = Le,
  QG = Xx,
  K4 = wa,
  s$e = ri,
  Ld = Pr,
  o$e = B$,
  l$e = Tn,
  Y4 = BH,
  s_ = KG,
  ZG = Ho,
  Pd = He,
  c$e = Ea,
  Q2 = Me,
  u$e = cc,
  f$e = ii,
  d$e = ni,
  am = Sa,
  h$e = ms.f,
  q4 = qG,
  p$e = or.forEach,
  g$e = Wf,
  m$e = sr,
  JG = pt,
  eV = ar,
  fC = Mt,
  v$e = Gf,
  Z2 = fC.get,
  y$e = fC.set,
  x$e = fC.enforce,
  tV = JG.f,
  b$e = eV.f,
  E$e = Math.round,
  o_ = XG.RangeError,
  rV = QG.ArrayBuffer,
  S$e = rV.prototype,
  _$e = QG.DataView,
  sm = Qf.NATIVE_ARRAY_BUFFER_VIEWS,
  X4 = Qf.TYPED_ARRAY_TAG,
  Q4 = Qf.TypedArray,
  Nd = Qf.TypedArrayPrototype,
  T$e = Qf.aTypedArrayConstructor,
  J2 = Qf.isTypedArray,
  om = "BYTES_PER_ELEMENT",
  l_ = "Wrong length",
  Z4 = function (t, e) {
    T$e(t);
    for (var r = 0, n = e.length, i = new t(n); n > r;) i[r] = e[r++];
    return i
  },
  lm = function (t, e) {
    m$e(t, e, {
      configurable: !0,
      get: function () {
        return Z2(this)[e]
      }
    })
  },
  J4 = function (t) {
    var e;
    return d$e(S$e, t) || (e = c$e(t)) == "ArrayBuffer" || e == "SharedArrayBuffer"
  },
  nV = function (t, e) {
    return J2(t) && !u$e(e) && e in t && o$e(+e) && e >= 0
  },
  e8 = function (e, r) {
    return r = ZG(r), nV(e, r) ? s$e(2, e[r]) : b$e(e, r)
  },
  t8 = function (e, r, n) {
    return r = ZG(r), nV(e, r) && Q2(n) && Pd(n, "value") && !Pd(n, "get") && !Pd(n, "set") && !n.configurable && (!Pd(n, "writable") || n.writable) && (!Pd(n, "enumerable") || n.enumerable) ? (e[r] = n.value, e) : tV(e, r, n)
  };
i$e ? (sm || (eV.f = e8, JG.f = t8, lm(Nd, "buffer"), lm(Nd, "byteOffset"), lm(Nd, "byteLength"), lm(Nd, "length")), V4({
  target: "Object",
  stat: !0,
  forced: !sm
}, {
  getOwnPropertyDescriptor: e8,
  defineProperty: t8
}), G4.exports = function (t, e, r) {
  var n = t.match(/\d+/)[0] / 8,
    i = t + (r ? "Clamped" : "") + "Array",
    a = "get" + t,
    s = "set" + t,
    o = XG[i],
    c = o,
    l = c && c.prototype,
    u = {},
    f = function (v, g) {
      var m = Z2(v);
      return m.view[a](g * n + m.byteOffset, !0)
    },
    d = function (v, g, m) {
      var y = Z2(v);
      r && (m = (m = E$e(m)) < 0 ? 0 : m > 255 ? 255 : m & 255), y.view[s](g * n + y.byteOffset, m, !0)
    },
    h = function (v, g) {
      tV(v, g, {
        get: function () {
          return f(this, g)
        },
        set: function (m) {
          return d(this, g, m)
        },
        enumerable: !0
      })
    };
  sm ? a$e && (c = e(function (v, g, m, y) {
    return K4(v, l), v$e(function () {
      return Q2(g) ? J4(g) ? y !== void 0 ? new o(g, s_(m, n), y) : m !== void 0 ? new o(g, s_(m, n)) : new o(g) : J2(g) ? Z4(c, g) : W4(q4, c, g) : new o(Y4(g))
    }(), v, c)
  }), am && am(c, Q4), p$e(h$e(o), function (v) {
    v in c || Ld(c, v, o[v])
  }), c.prototype = l) : (c = e(function (v, g, m, y) {
    K4(v, l);
    var x = 0,
      b = 0,
      _, S, T;
    if (!Q2(g)) T = Y4(g), S = T * n, _ = new rV(S);
    else if (J4(g)) {
      _ = g, b = s_(m, n);
      var R = g.byteLength;
      if (y === void 0) {
        if (R % n || (S = R - b, S < 0)) throw o_(l_)
      } else if (S = l$e(y) * n, S + b > R) throw o_(l_);
      T = S / n
    } else return J2(g) ? Z4(c, g) : W4(q4, c, g);
    for (y$e(v, {
        buffer: _,
        byteOffset: b,
        byteLength: S,
        length: T,
        view: new _$e(_)
      }); x < T;) h(v, x++)
  }), am && am(c, Q4), l = c.prototype = f$e(Nd)), l.constructor !== c && Ld(l, "constructor", c), x$e(l).TypedArrayConstructor = c, X4 && Ld(l, X4, i);
  var p = c != o;
  u[i] = c, V4({
    global: !0,
    constructor: !0,
    forced: p,
    sham: !sm
  }, u), om in c || Ld(c, om, n), om in l || Ld(l, om, n), g$e(i)
}) : G4.exports = function () {};
var w$e = ki;
w$e("Float32", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var R$e = ki;
R$e("Float64", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var A$e = ki;
A$e("Int8", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var I$e = ki;
I$e("Int16", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var $$e = ki;
$$e("Int32", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var C$e = ki;
C$e("Uint8", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var k$e = ki;
k$e("Uint8", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
}, !0);
var O$e = ki;
O$e("Uint16", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var L$e = ki;
L$e("Uint32", function (t) {
  return function (r, n, i) {
    return t(this, r, n, i)
  }
});
var iV = Le,
  P$e = Ye,
  N$e = $t,
  D$e = iV.aTypedArray,
  M$e = iV.exportTypedArrayMethod;
M$e("at", function (e) {
  var r = D$e(this),
    n = P$e(r),
    i = N$e(e),
    a = i >= 0 ? i : n + i;
  return a < 0 || a >= n ? void 0 : r[a]
});
var F$e = ie,
  aV = Le,
  B$e = hH,
  U$e = F$e(B$e),
  j$e = aV.aTypedArray,
  H$e = aV.exportTypedArrayMethod;
H$e("copyWithin", function (e, r) {
  return U$e(j$e(this), e, r, arguments.length > 2 ? arguments[2] : void 0)
});
var sV = Le,
  z$e = or.every,
  G$e = sV.aTypedArray,
  V$e = sV.exportTypedArrayMethod;
V$e("every", function (e) {
  return z$e(G$e(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var oV = Le,
  W$e = c$,
  K$e = uC,
  Y$e = Ea,
  q$e = $e,
  X$e = ie,
  Q$e = re,
  Z$e = oV.aTypedArray,
  J$e = oV.exportTypedArrayMethod,
  eCe = X$e("".slice),
  tCe = Q$e(function () {
    var t = 0;
    return new Int8Array(2).fill({
      valueOf: function () {
        return t++
      }
    }), t !== 1
  });
J$e("fill", function (e) {
  var r = arguments.length;
  Z$e(this);
  var n = eCe(Y$e(this), 0, 3) === "Big" ? K$e(e) : +e;
  return q$e(W$e, this, n, r > 1 ? arguments[1] : void 0, r > 2 ? arguments[2] : void 0)
}, tCe);
var lV = Le,
  rCe = Yf,
  nCe = lV.aTypedArrayConstructor,
  iCe = lV.getTypedArrayConstructor,
  yb = function (t) {
    return nCe(rCe(t, iCe(t)))
  },
  aCe = v$,
  sCe = yb,
  oCe = function (t, e) {
    return aCe(sCe(t), e)
  },
  cV = Le,
  lCe = or.filter,
  cCe = oCe,
  uCe = cV.aTypedArray,
  fCe = cV.exportTypedArrayMethod;
fCe("filter", function (e) {
  var r = lCe(uCe(this), e, arguments.length > 1 ? arguments[1] : void 0);
  return cCe(this, r)
});
var uV = Le,
  dCe = or.find,
  hCe = uV.aTypedArray,
  pCe = uV.exportTypedArrayMethod;
pCe("find", function (e) {
  return dCe(hCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var fV = Le,
  gCe = or.findIndex,
  mCe = fV.aTypedArray,
  vCe = fV.exportTypedArrayMethod;
vCe("findIndex", function (e) {
  return gCe(mCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var dV = Le,
  yCe = Gx.findLast,
  xCe = dV.aTypedArray,
  bCe = dV.exportTypedArrayMethod;
bCe("findLast", function (e) {
  return yCe(xCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var hV = Le,
  ECe = Gx.findLastIndex,
  SCe = hV.aTypedArray,
  _Ce = hV.exportTypedArrayMethod;
_Ce("findLastIndex", function (e) {
  return ECe(SCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var pV = Le,
  TCe = or.forEach,
  wCe = pV.aTypedArray,
  RCe = pV.exportTypedArrayMethod;
RCe("forEach", function (e) {
  TCe(wCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var ACe = cC,
  ICe = Le.exportTypedArrayStaticMethod,
  $Ce = qG;
ICe("from", $Ce, ACe);
var gV = Le,
  CCe = wp.includes,
  kCe = gV.aTypedArray,
  OCe = gV.exportTypedArrayMethod;
OCe("includes", function (e) {
  return CCe(kCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var mV = Le,
  LCe = wp.indexOf,
  PCe = mV.aTypedArray,
  NCe = mV.exportTypedArrayMethod;
NCe("indexOf", function (e) {
  return LCe(PCe(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var DCe = he,
  MCe = re,
  dC = ie,
  vV = Le,
  hC = $H,
  FCe = Fe,
  pC = FCe("iterator"),
  r8 = DCe.Uint8Array,
  BCe = dC(hC.values),
  UCe = dC(hC.keys),
  jCe = dC(hC.entries),
  gC = vV.aTypedArray,
  xb = vV.exportTypedArrayMethod,
  nu = r8 && r8.prototype,
  bb = !MCe(function () {
    nu[pC].call([1])
  }),
  yV = !!nu && nu.values && nu[pC] === nu.values && nu.values.name === "values",
  xV = function () {
    return BCe(gC(this))
  };
xb("entries", function () {
  return jCe(gC(this))
}, bb);
xb("keys", function () {
  return UCe(gC(this))
}, bb);
xb("values", xV, bb || !yV, {
  name: "values"
});
xb(pC, xV, bb || !yV, {
  name: "values"
});
var bV = Le,
  HCe = ie,
  zCe = bV.aTypedArray,
  GCe = bV.exportTypedArrayMethod,
  VCe = HCe([].join);
GCe("join", function (e) {
  return VCe(zCe(this), e)
});
var EV = Le,
  WCe = ai,
  KCe = kH,
  YCe = EV.aTypedArray,
  qCe = EV.exportTypedArrayMethod;
qCe("lastIndexOf", function (e) {
  var r = arguments.length;
  return WCe(KCe, YCe(this), r > 1 ? [e, arguments[1]] : [e])
});
var SV = Le,
  XCe = or.map,
  QCe = yb,
  ZCe = SV.aTypedArray,
  JCe = SV.exportTypedArrayMethod;
JCe("map", function (e) {
  return XCe(ZCe(this), e, arguments.length > 1 ? arguments[1] : void 0, function (r, n) {
    return new(QCe(r))(n)
  })
});
var _V = Le,
  eke = cC,
  tke = _V.aTypedArrayConstructor,
  rke = _V.exportTypedArrayStaticMethod;
rke("of", function () {
  for (var e = 0, r = arguments.length, n = new(tke(this))(r); r > e;) n[e] = arguments[e++];
  return n
}, eke);
var TV = Le,
  nke = Kx.left,
  ike = TV.aTypedArray,
  ake = TV.exportTypedArrayMethod;
ake("reduce", function (e) {
  var r = arguments.length;
  return nke(ike(this), e, r, r > 1 ? arguments[1] : void 0)
});
var wV = Le,
  ske = Kx.right,
  oke = wV.aTypedArray,
  lke = wV.exportTypedArrayMethod;
lke("reduceRight", function (e) {
  var r = arguments.length;
  return ske(oke(this), e, r, r > 1 ? arguments[1] : void 0)
});
var RV = Le,
  cke = RV.aTypedArray,
  uke = RV.exportTypedArrayMethod,
  fke = Math.floor;
uke("reverse", function () {
  for (var e = this, r = cke(e).length, n = fke(r / 2), i = 0, a; i < n;) a = e[i], e[i++] = e[--r], e[r] = a;
  return e
});
var AV = he,
  IV = $e,
  mC = Le,
  dke = Ye,
  hke = KG,
  pke = We,
  $V = re,
  gke = AV.RangeError,
  eR = AV.Int8Array,
  n8 = eR && eR.prototype,
  CV = n8 && n8.set,
  mke = mC.aTypedArray,
  vke = mC.exportTypedArrayMethod,
  tR = !$V(function () {
    var t = new Uint8ClampedArray(2);
    return IV(CV, t, {
      length: 1,
      0: 3
    }, 1), t[1] !== 3
  }),
  yke = tR && mC.NATIVE_ARRAY_BUFFER_VIEWS && $V(function () {
    var t = new eR(2);
    return t.set(1), t.set("2", 1), t[0] !== 0 || t[1] !== 2
  });
vke("set", function (e) {
  mke(this);
  var r = hke(arguments.length > 1 ? arguments[1] : void 0, 1),
    n = pke(e);
  if (tR) return IV(CV, this, n, r);
  var i = this.length,
    a = dke(n),
    s = 0;
  if (a + r > i) throw gke("Wrong length");
  for (; s < a;) this[r + s] = n[s++]
}, !tR || yke);
var kV = Le,
  xke = yb,
  bke = re,
  Eke = fc,
  Ske = kV.aTypedArray,
  _ke = kV.exportTypedArrayMethod,
  Tke = bke(function () {
    new Int8Array(1).slice()
  });
_ke("slice", function (e, r) {
  for (var n = Eke(Ske(this), e, r), i = xke(this), a = 0, s = n.length, o = new i(s); s > a;) o[a] = n[a++];
  return o
}, Tke);
var OV = Le,
  wke = or.some,
  Rke = OV.aTypedArray,
  Ake = OV.exportTypedArrayMethod;
Ake("some", function (e) {
  return wke(Rke(this), e, arguments.length > 1 ? arguments[1] : void 0)
});
var Ike = he,
  $ke = zo,
  rR = re,
  Cke = It,
  kke = p$,
  LV = Le,
  i8 = LH,
  Oke = PH,
  a8 = ps,
  s8 = g$,
  Lke = LV.aTypedArray,
  Pke = LV.exportTypedArrayMethod,
  E0 = Ike.Uint16Array,
  Cu = E0 && $ke(E0.prototype.sort),
  Nke = !!Cu && !(rR(function () {
    Cu(new E0(2), null)
  }) && rR(function () {
    Cu(new E0(2), {})
  })),
  o8 = !!Cu && !rR(function () {
    if (a8) return a8 < 74;
    if (i8) return i8 < 67;
    if (Oke) return !0;
    if (s8) return s8 < 602;
    var t = new E0(516),
      e = Array(516),
      r, n;
    for (r = 0; r < 516; r++) n = r % 4, t[r] = 515 - r, e[r] = r - 2 * n + 3;
    for (Cu(t, function (i, a) {
        return (i / 4 | 0) - (a / 4 | 0)
      }), r = 0; r < 516; r++)
      if (t[r] !== e[r]) return !0
  }),
  Dke = function (t) {
    return function (e, r) {
      return t !== void 0 ? +t(e, r) || 0 : r !== r ? -1 : e !== e ? 1 : e === 0 && r === 0 ? 1 / e > 0 && 1 / r < 0 ? 1 : -1 : e > r
    }
  };
Pke("sort", function (e) {
  return e !== void 0 && Cke(e), o8 ? Cu(this, e) : kke(Lke(this), Dke(e))
}, !o8 || Nke);
var PV = Le,
  Mke = Tn,
  l8 = ba,
  Fke = yb,
  Bke = PV.aTypedArray,
  Uke = PV.exportTypedArrayMethod;
Uke("subarray", function (e, r) {
  var n = Bke(this),
    i = n.length,
    a = l8(e, i),
    s = Fke(n);
  return new s(n.buffer, n.byteOffset + a * n.BYTES_PER_ELEMENT, Mke((r === void 0 ? i : l8(r, i)) - a))
});
var jke = he,
  Hke = ai,
  NV = Le,
  nR = re,
  c8 = fc,
  Cy = jke.Int8Array,
  u8 = NV.aTypedArray,
  zke = NV.exportTypedArrayMethod,
  DV = [].toLocaleString,
  Gke = !!Cy && nR(function () {
    DV.call(new Cy(1))
  }),
  Vke = nR(function () {
    return [1, 2].toLocaleString() != new Cy([1, 2]).toLocaleString()
  }) || !nR(function () {
    Cy.prototype.toLocaleString.call([1, 2])
  });
zke("toLocaleString", function () {
  return Hke(DV, Gke ? c8(u8(this)) : u8(this), c8(arguments))
}, Vke);
var Wke = MH,
  vC = Le,
  Kke = vC.aTypedArray,
  Yke = vC.exportTypedArrayMethod,
  qke = vC.getTypedArrayConstructor;
Yke("toReversed", function () {
  return Wke(Kke(this), qke(this))
});
var Eb = Le,
  Xke = ie,
  Qke = It,
  Zke = v$,
  Jke = Eb.aTypedArray,
  eOe = Eb.getTypedArrayConstructor,
  tOe = Eb.exportTypedArrayMethod,
  rOe = Xke(Eb.TypedArrayPrototype.sort);
tOe("toSorted", function (e) {
  e !== void 0 && Qke(e);
  var r = Jke(this),
    n = Zke(eOe(r), r);
  return rOe(n, e)
});
var nOe = Le.exportTypedArrayMethod,
  iOe = re,
  aOe = he,
  sOe = ie,
  f8 = aOe.Uint8Array,
  oOe = f8 && f8.prototype || {},
  ky = [].toString,
  lOe = sOe([].join);
iOe(function () {
  ky.call({})
}) && (ky = function () {
  return lOe(this)
});
var cOe = oOe.toString != ky;
nOe("toString", ky, cOe);
var uOe = FH,
  yC = Le,
  fOe = YG,
  dOe = $t,
  hOe = uC,
  pOe = yC.aTypedArray,
  gOe = yC.getTypedArrayConstructor,
  mOe = yC.exportTypedArrayMethod,
  vOe = !! function () {
    try {
      new Int8Array(1).with(2, {
        valueOf: function () {
          throw 8
        }
      })
    } catch (t) {
      return t === 8
    }
  }();
mOe("with", function (t, e) {
  var r = pOe(this),
    n = dOe(t),
    i = fOe(r) ? hOe(e) : +e;
  return uOe(r, gOe(r), n, i)
}, !vOe);
var yOe = j,
  xC = ie,
  xOe = Ce,
  d8 = String.fromCharCode,
  h8 = xC("".charAt),
  p8 = xC(/./.exec),
  g8 = xC("".slice),
  bOe = /^[\da-f]{2}$/i,
  EOe = /^[\da-f]{4}$/i;
yOe({
  global: !0
}, {
  unescape: function (e) {
    for (var r = xOe(e), n = "", i = r.length, a = 0, s, o; a < i;) {
      if (s = h8(r, a++), s === "%") {
        if (h8(r, a) === "u") {
          if (o = g8(r, a + 1, a + 5), p8(EOe, o)) {
            n += d8(parseInt(o, 16)), a += 5;
            continue
          }
        } else if (o = g8(r, a, a + 2), p8(bOe, o)) {
          n += d8(parseInt(o, 16)), a += 2;
          continue
        }
      }
      n += s
    }
    return n
  }
});
var SOe = ie,
  m8 = Fp,
  cm = os.getWeakData,
  _Oe = wa,
  TOe = Ie,
  wOe = on,
  c_ = Me,
  ROe = Ta,
  MV = or,
  v8 = He,
  FV = Mt,
  AOe = FV.set,
  IOe = FV.getterFor,
  $Oe = MV.find,
  COe = MV.findIndex,
  kOe = SOe([].splice),
  OOe = 0,
  um = function (t) {
    return t.frozen || (t.frozen = new BV)
  },
  BV = function () {
    this.entries = []
  },
  u_ = function (t, e) {
    return $Oe(t.entries, function (r) {
      return r[0] === e
    })
  };
BV.prototype = {
  get: function (t) {
    var e = u_(this, t);
    if (e) return e[1]
  },
  has: function (t) {
    return !!u_(this, t)
  },
  set: function (t, e) {
    var r = u_(this, t);
    r ? r[1] = e : this.entries.push([t, e])
  },
  delete: function (t) {
    var e = COe(this.entries, function (r) {
      return r[0] === t
    });
    return ~e && kOe(this.entries, e, 1), !!~e
  }
};
var UV = {
    getConstructor: function (t, e, r, n) {
      var i = t(function (c, l) {
          _Oe(c, a), AOe(c, {
            type: e,
            id: OOe++,
            frozen: void 0
          }), wOe(l) || ROe(l, c[n], {
            that: c,
            AS_ENTRIES: r
          })
        }),
        a = i.prototype,
        s = IOe(e),
        o = function (c, l, u) {
          var f = s(c),
            d = cm(TOe(l), !0);
          return d === !0 ? um(f).set(l, u) : d[f.id] = u, c
        };
      return m8(a, {
        delete: function (c) {
          var l = s(this);
          if (!c_(c)) return !1;
          var u = cm(c);
          return u === !0 ? um(l).delete(c) : u && v8(u, l.id) && delete u[l.id]
        },
        has: function (l) {
          var u = s(this);
          if (!c_(l)) return !1;
          var f = cm(l);
          return f === !0 ? um(u).has(l) : f && v8(f, u.id)
        }
      }), m8(a, r ? {
        get: function (l) {
          var u = s(this);
          if (c_(l)) {
            var f = cm(l);
            return f === !0 ? um(u).get(l) : f ? f[u.id] : void 0
          }
        },
        set: function (l, u) {
          return o(this, l, u)
        }
      } : {
        add: function (l) {
          return o(this, l, !0)
        }
      }), i
    }
  },
  LOe = qf,
  y8 = he,
  Cv = ie,
  x8 = Fp,
  POe = os,
  NOe = eb,
  jV = UV,
  fm = Me,
  dm = Mt.enforce,
  DOe = re,
  MOe = mj,
  Kp = Object,
  FOe = Array.isArray,
  hm = Kp.isExtensible,
  HV = Kp.isFrozen,
  BOe = Kp.isSealed,
  zV = Kp.freeze,
  UOe = Kp.seal,
  b8 = {},
  E8 = {},
  jOe = !y8.ActiveXObject && "ActiveXObject" in y8,
  Dd, GV = function (t) {
    return function () {
      return t(this, arguments.length ? arguments[0] : void 0)
    }
  },
  VV = NOe("WeakMap", GV, jV),
  iu = VV.prototype,
  kv = Cv(iu.set),
  HOe = function () {
    return LOe && DOe(function () {
      var t = zV([]);
      return kv(new VV, t, 1), !HV(t)
    })
  };
if (MOe)
  if (jOe) {
    Dd = jV.getConstructor(GV, "WeakMap", !0), POe.enable();
    var S8 = Cv(iu.delete),
      pm = Cv(iu.has),
      _8 = Cv(iu.get);
    x8(iu, {
      delete: function (t) {
        if (fm(t) && !hm(t)) {
          var e = dm(this);
          return e.frozen || (e.frozen = new Dd), S8(this, t) || e.frozen.delete(t)
        }
        return S8(this, t)
      },
      has: function (e) {
        if (fm(e) && !hm(e)) {
          var r = dm(this);
          return r.frozen || (r.frozen = new Dd), pm(this, e) || r.frozen.has(e)
        }
        return pm(this, e)
      },
      get: function (e) {
        if (fm(e) && !hm(e)) {
          var r = dm(this);
          return r.frozen || (r.frozen = new Dd), pm(this, e) ? _8(this, e) : r.frozen.get(e)
        }
        return _8(this, e)
      },
      set: function (e, r) {
        if (fm(e) && !hm(e)) {
          var n = dm(this);
          n.frozen || (n.frozen = new Dd), pm(this, e) ? kv(this, e, r) : n.frozen.set(e, r)
        } else kv(this, e, r);
        return this
      }
    })
  } else HOe() && x8(iu, {
    set: function (e, r) {
      var n;
      return FOe(e) && (HV(e) ? n = b8 : BOe(e) && (n = E8)), kv(this, e, r), n == b8 && zV(e), n == E8 && UOe(e), this
    }
  });
var zOe = eb,
  GOe = UV;
zOe("WeakSet", function (t) {
  return function () {
    return t(this, arguments.length ? arguments[0] : void 0)
  }
}, GOe);
var WV = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  KV = {};
for (var gm = 0; gm < 66; gm++) KV[WV.charAt(gm)] = gm;
var YV = {
    itoc: WV,
    ctoi: KV
  },
  VOe = j,
  WOe = he,
  qV = ht,
  bC = ie,
  KOe = $e,
  EC = re,
  YOe = Ce,
  qOe = He,
  XOe = Es,
  f_ = YV.ctoi,
  XV = /[^\d+/a-z]/i,
  QOe = /[\t\n\f\r ]+/g,
  ZOe = /[=]{1,2}$/,
  Yp = qV("atob"),
  JOe = String.fromCharCode,
  eLe = bC("".charAt),
  T8 = bC("".replace),
  tLe = bC(XV.exec),
  SC = EC(function () {
    return Yp(" ") !== ""
  }),
  _C = !EC(function () {
    Yp("a")
  }),
  w8 = !SC && !_C && !EC(function () {
    Yp()
  }),
  R8 = !SC && !_C && Yp.length !== 1;
VOe({
  global: !0,
  bind: !0,
  enumerable: !0,
  forced: SC || _C || w8 || R8
}, {
  atob: function (e) {
    if (XOe(arguments.length, 1), w8 || R8) return KOe(Yp, WOe, e);
    var r = T8(YOe(e), QOe, ""),
      n = "",
      i = 0,
      a = 0,
      s, o;
    if (r.length % 4 == 0 && (r = T8(r, ZOe, "")), r.length % 4 == 1 || tLe(XV, r)) throw new(qV("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
    for (; s = eLe(r, i++);) qOe(f_, s) && (o = a % 4 ? o * 64 + f_[s] : f_[s], a++ % 4 && (n += JOe(255 & o >> (-2 * a & 6))));
    return n
  }
});
var rLe = j,
  nLe = he,
  QV = ht,
  ZV = ie,
  iLe = $e,
  JV = re,
  A8 = Ce,
  aLe = Es,
  sLe = YV.itoc,
  Kl = QV("btoa"),
  I8 = ZV("".charAt),
  oLe = ZV("".charCodeAt),
  $8 = !!Kl && !JV(function () {
    Kl()
  }),
  C8 = !!Kl && JV(function () {
    return Kl(null) !== "bnVsbA=="
  }),
  k8 = !!Kl && Kl.length !== 1;
rLe({
  global: !0,
  bind: !0,
  enumerable: !0,
  forced: $8 || C8 || k8
}, {
  btoa: function (e) {
    if (aLe(arguments.length, 1), $8 || C8 || k8) return iLe(Kl, nLe, A8(e));
    for (var r = A8(e), n = "", i = 0, a = sLe, s, o; I8(r, i) || (a = "=", i % 1);) {
      if (o = oLe(r, i += 3 / 4), o > 255) throw new(QV("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
      s = s << 8 | o, n += I8(a, 63 & s >> 8 - i % 1 * 8)
    }
    return n
  }
});
var eW = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  },
  lLe = Ox,
  d_ = lLe("span").classList,
  O8 = d_ && d_.constructor && d_.constructor.prototype,
  tW = O8 === Object.prototype ? void 0 : O8,
  L8 = he,
  P8 = eW,
  cLe = tW,
  h_ = yH,
  uLe = Pr,
  rW = function (t) {
    if (t && t.forEach !== h_) try {
      uLe(t, "forEach", h_)
    } catch {
      t.forEach = h_
    }
  };
for (var p_ in P8) P8[p_] && rW(L8[p_] && L8[p_].prototype);
rW(cLe);
var N8 = he,
  nW = eW,
  fLe = tW,
  gh = $H,
  g_ = Pr,
  iW = Fe,
  m_ = iW("iterator"),
  D8 = iW("toStringTag"),
  v_ = gh.values,
  aW = function (t, e) {
    if (t) {
      if (t[m_] !== v_) try {
        g_(t, m_, v_)
      } catch {
        t[m_] = v_
      }
      if (t[D8] || g_(t, D8, e), nW[e]) {
        for (var r in gh)
          if (t[r] !== gh[r]) try {
            g_(t, r, gh[r])
          } catch {
            t[r] = gh[r]
          }
      }
    }
  };
for (var y_ in nW) aW(N8[y_] && N8[y_].prototype, y_);
aW(fLe, "DOMTokenList");
var dLe = xs,
  hLe = function (t) {
    try {
      if (dLe) return Function('return require("' + t + '")')()
    } catch {}
  },
  sW = {
    IndexSizeError: {
      s: "INDEX_SIZE_ERR",
      c: 1,
      m: 1
    },
    DOMStringSizeError: {
      s: "DOMSTRING_SIZE_ERR",
      c: 2,
      m: 0
    },
    HierarchyRequestError: {
      s: "HIERARCHY_REQUEST_ERR",
      c: 3,
      m: 1
    },
    WrongDocumentError: {
      s: "WRONG_DOCUMENT_ERR",
      c: 4,
      m: 1
    },
    InvalidCharacterError: {
      s: "INVALID_CHARACTER_ERR",
      c: 5,
      m: 1
    },
    NoDataAllowedError: {
      s: "NO_DATA_ALLOWED_ERR",
      c: 6,
      m: 0
    },
    NoModificationAllowedError: {
      s: "NO_MODIFICATION_ALLOWED_ERR",
      c: 7,
      m: 1
    },
    NotFoundError: {
      s: "NOT_FOUND_ERR",
      c: 8,
      m: 1
    },
    NotSupportedError: {
      s: "NOT_SUPPORTED_ERR",
      c: 9,
      m: 1
    },
    InUseAttributeError: {
      s: "INUSE_ATTRIBUTE_ERR",
      c: 10,
      m: 1
    },
    InvalidStateError: {
      s: "INVALID_STATE_ERR",
      c: 11,
      m: 1
    },
    SyntaxError: {
      s: "SYNTAX_ERR",
      c: 12,
      m: 1
    },
    InvalidModificationError: {
      s: "INVALID_MODIFICATION_ERR",
      c: 13,
      m: 1
    },
    NamespaceError: {
      s: "NAMESPACE_ERR",
      c: 14,
      m: 1
    },
    InvalidAccessError: {
      s: "INVALID_ACCESS_ERR",
      c: 15,
      m: 1
    },
    ValidationError: {
      s: "VALIDATION_ERR",
      c: 16,
      m: 0
    },
    TypeMismatchError: {
      s: "TYPE_MISMATCH_ERR",
      c: 17,
      m: 1
    },
    SecurityError: {
      s: "SECURITY_ERR",
      c: 18,
      m: 1
    },
    NetworkError: {
      s: "NETWORK_ERR",
      c: 19,
      m: 1
    },
    AbortError: {
      s: "ABORT_ERR",
      c: 20,
      m: 1
    },
    URLMismatchError: {
      s: "URL_MISMATCH_ERR",
      c: 21,
      m: 1
    },
    QuotaExceededError: {
      s: "QUOTA_EXCEEDED_ERR",
      c: 22,
      m: 1
    },
    TimeoutError: {
      s: "TIMEOUT_ERR",
      c: 23,
      m: 1
    },
    InvalidNodeTypeError: {
      s: "INVALID_NODE_TYPE_ERR",
      c: 24,
      m: 1
    },
    DataCloneError: {
      s: "DATA_CLONE_ERR",
      c: 25,
      m: 1
    }
  },
  pLe = j,
  gLe = hLe,
  Oy = ht,
  TC = re,
  mLe = ii,
  wC = ri,
  Ly = pt.f,
  vLe = _t,
  Ov = sr,
  Lv = He,
  yLe = wa,
  xLe = Ie,
  oW = cH,
  M8 = Pp,
  ku = sW,
  bLe = i$,
  lW = Mt,
  RC = _e,
  cf = "DOMException",
  iR = "DATA_CLONE_ERR",
  Sb = Oy("Error"),
  cs = Oy(cf) || function () {
    try {
      var t = Oy("MessageChannel") || gLe("worker_threads").MessageChannel;
      new t().port1.postMessage(new WeakMap)
    } catch (e) {
      if (e.name == iR && e.code == 25) return e.constructor
    }
  }(),
  ELe = cs && cs.prototype,
  cW = Sb.prototype,
  SLe = lW.set,
  _Le = lW.getterFor(cf),
  TLe = "stack" in Sb(cf),
  uW = function (t) {
    return Lv(ku, t) && ku[t].m ? ku[t].c : 0
  },
  AC = function () {
    yLe(this, Nh);
    var e = arguments.length,
      r = M8(e < 1 ? void 0 : arguments[0]),
      n = M8(e < 2 ? void 0 : arguments[1], "Error"),
      i = uW(n);
    if (SLe(this, {
        type: cf,
        name: n,
        message: r,
        code: i
      }), RC || (this.name = n, this.message = r, this.code = i), TLe) {
      var a = Sb(r);
      a.name = cf, Ly(this, "stack", wC(1, bLe(a.stack, 1)))
    }
  },
  Nh = AC.prototype = mLe(cW),
  fW = function (t) {
    return {
      enumerable: !0,
      configurable: !0,
      get: t
    }
  },
  x_ = function (t) {
    return fW(function () {
      return _Le(this)[t]
    })
  };
RC && (Ov(Nh, "code", x_("code")), Ov(Nh, "message", x_("message")), Ov(Nh, "name", x_("name")));
Ly(Nh, "constructor", wC(1, AC));
var _b = TC(function () {
    return !(new cs instanceof Sb)
  }),
  wLe = _b || TC(function () {
    return cW.toString !== oW || String(new cs(1, 2)) !== "2: 1"
  }),
  RLe = _b || TC(function () {
    return new cs(1, "DataCloneError").code !== 25
  });
_b || cs[iR] !== 25 || ELe[iR];
var F8 = _b;
pLe({
  global: !0,
  constructor: !0,
  forced: F8
}, {
  DOMException: F8 ? AC : cs
});
var S0 = Oy(cf),
  Py = S0.prototype;
wLe && cs === S0 && vLe(Py, "toString", oW);
RLe && RC && cs === S0 && Ov(Py, "code", fW(function () {
  return uW(xLe(this).name)
}));
for (var B8 in ku)
  if (Lv(ku, B8)) {
    var U8 = ku[B8],
      mm = U8.s,
      j8 = wC(6, U8.c);
    Lv(S0, mm) || Ly(S0, mm, j8), Lv(Py, mm) || Ly(Py, mm, j8)
  } var ALe = j,
  ILe = he,
  IC = ht,
  aR = ri,
  sR = pt.f,
  H8 = He,
  $Le = wa,
  CLe = Gf,
  z8 = Pp,
  b_ = sW,
  kLe = i$,
  OLe = _e,
  qp = "DOMException",
  dW = IC("Error"),
  Xp = IC(qp),
  $C = function () {
    $Le(this, LLe);
    var e = arguments.length,
      r = z8(e < 1 ? void 0 : arguments[0]),
      n = z8(e < 2 ? void 0 : arguments[1], "Error"),
      i = new Xp(r, n),
      a = dW(r);
    return a.name = qp, sR(i, "stack", aR(1, kLe(a.stack, 1))), CLe(i, this, $C), i
  },
  LLe = $C.prototype = Xp.prototype,
  PLe = "stack" in dW(qp),
  NLe = "stack" in new Xp(1, 2),
  E_ = Xp && OLe && Object.getOwnPropertyDescriptor(ILe, qp),
  DLe = !!E_ && !(E_.writable && E_.configurable),
  G8 = PLe && !DLe && !NLe;
ALe({
  global: !0,
  constructor: !0,
  forced: G8
}, {
  DOMException: G8 ? $C : Xp
});
var mh = IC(qp),
  V8 = mh.prototype;
if (V8.constructor !== mh) {
  sR(V8, "constructor", aR(1, mh));
  for (var W8 in b_)
    if (H8(b_, W8)) {
      var K8 = b_[W8],
        Y8 = K8.s;
      H8(mh, Y8) || sR(mh, Y8, aR(6, K8.c))
    }
}
var MLe = ht,
  FLe = wn,
  q8 = "DOMException";
FLe(MLe(q8), q8);
var BLe = j,
  ULe = he,
  X8 = lb.clear;
BLe({
  global: !0,
  bind: !0,
  enumerable: !0,
  forced: ULe.clearImmediate !== X8
}, {
  clearImmediate: X8
});
var jLe = typeof Bun == "function" && Bun && typeof Bun.version == "string",
  hW = he,
  HLe = ai,
  zLe = De,
  GLe = jLe,
  VLe = hs,
  WLe = fc,
  KLe = Es,
  YLe = hW.Function,
  qLe = /MSIE .\./.test(VLe) || GLe && function () {
    var t = hW.Bun.version.split(".");
    return t.length < 3 || t[0] == 0 && (t[1] < 3 || t[1] == 3 && t[2] == 0)
  }(),
  CC = function (t, e) {
    var r = e ? 2 : 1;
    return qLe ? function (n, i) {
      var a = KLe(arguments.length, 1) > r,
        s = zLe(n) ? n : YLe(n),
        o = a ? WLe(arguments, r) : [],
        c = a ? function () {
          HLe(s, this, o)
        } : s;
      return e ? t(c, i) : t(c)
    } : t
  },
  XLe = j,
  pW = he,
  Q8 = lb.set,
  QLe = CC,
  Z8 = pW.setImmediate ? QLe(Q8, !1) : Q8;
XLe({
  global: !0,
  bind: !0,
  enumerable: !0,
  forced: pW.setImmediate !== Z8
}, {
  setImmediate: Z8
});
var ZLe = j,
  JLe = he,
  ePe = Vz,
  tPe = It,
  rPe = Es,
  nPe = xs,
  iPe = JLe.process;
ZLe({
  global: !0,
  enumerable: !0,
  dontCallGetSet: !0
}, {
  queueMicrotask: function (e) {
    rPe(arguments.length, 1), tPe(e);
    var r = nPe && iPe.domain;
    ePe(r ? r.bind(e) : e)
  }
});
var aPe = j,
  Us = he,
  sPe = sr,
  oPe = _e,
  lPe = TypeError,
  cPe = Object.defineProperty,
  J8 = Us.self !== Us;
try {
  if (oPe) {
    var S_ = Object.getOwnPropertyDescriptor(Us, "self");
    (J8 || !S_ || !S_.get || !S_.enumerable) && sPe(Us, "self", {
      get: function () {
        return Us
      },
      set: function (e) {
        if (this !== Us) throw lPe("Illegal invocation");
        cPe(Us, "self", {
          value: e,
          writable: !0,
          configurable: !0,
          enumerable: !0
        })
      },
      configurable: !0,
      enumerable: !0
    })
  } else aPe({
    global: !0,
    simple: !0,
    forced: J8
  }, {
    self: Us
  })
} catch {}
var vm = ie,
  Md = Map.prototype,
  uPe = {
    Map,
    set: vm(Md.set),
    get: vm(Md.get),
    has: vm(Md.has),
    remove: vm(Md.delete),
    proto: Md
  },
  __ = ie,
  ym = Set.prototype,
  fPe = {
    Set,
    add: __(ym.add),
    has: __(ym.has),
    remove: __(ym.delete),
    proto: ym
  },
  dPe = he,
  hPe = re,
  T_ = ps,
  pPe = Wz,
  gPe = z$,
  mPe = xs,
  eM = dPe.structuredClone,
  vPe = !!eM && !hPe(function () {
    if (gPe && T_ > 92 || mPe && T_ > 94 || pPe && T_ > 97) return !1;
    var t = new ArrayBuffer(8),
      e = eM(t, {
        transfer: [t]
      });
    return t.byteLength != 0 || e.byteLength != 8
  }),
  yPe = j,
  yt = he,
  kC = ht,
  Qp = ie,
  OC = re,
  xPe = jf,
  Pv = De,
  bPe = zf,
  EPe = on,
  oR = Me,
  SPe = cc,
  _Pe = Ta,
  gW = Ie,
  mW = Ea,
  TPe = He,
  wPe = vs,
  w_ = Pr,
  Nv = Ye,
  RPe = Es,
  APe = Gp,
  Tb = uPe,
  vW = fPe,
  IPe = iH,
  yW = vPe,
  vh = yt.Object,
  $Pe = yt.Array,
  xW = yt.Date,
  Zp = yt.Error,
  CPe = yt.EvalError,
  kPe = yt.RangeError,
  OPe = yt.ReferenceError,
  LPe = yt.SyntaxError,
  bW = yt.TypeError,
  PPe = yt.URIError,
  NPe = yt.PerformanceMark,
  uf = yt.WebAssembly,
  DPe = uf && uf.CompileError || Zp,
  MPe = uf && uf.LinkError || Zp,
  FPe = uf && uf.RuntimeError || Zp,
  Yl = kC("DOMException"),
  lR = Tb.Map,
  EW = Tb.has,
  BPe = Tb.get,
  Ny = Tb.set,
  UPe = vW.Set,
  jPe = vW.add,
  HPe = kC("Object", "keys"),
  zPe = Qp([].push),
  GPe = Qp((!0).valueOf),
  VPe = Qp(1.valueOf),
  WPe = Qp("".valueOf),
  KPe = Qp(xW.prototype.getTime),
  cR = xPe("structuredClone"),
  _0 = "DataCloneError",
  xm = "Transferring",
  SW = function (t) {
    return !OC(function () {
      var e = new yt.Set([7]),
        r = t(e),
        n = t(vh(7));
      return r == e || !r.has(7) || typeof n != "object" || n != 7
    }) && t
  },
  tM = function (t, e) {
    return !OC(function () {
      var r = new e,
        n = t({
          a: r,
          b: r
        });
      return !(n && n.a === n.b && n.a instanceof e && n.a.stack === r.stack)
    })
  },
  YPe = function (t) {
    return !OC(function () {
      var e = t(new yt.AggregateError([1], cR, {
        cause: 3
      }));
      return e.name != "AggregateError" || e.errors[0] != 1 || e.message != cR || e.cause != 3
    })
  },
  Ou = yt.structuredClone,
  qPe = !tM(Ou, Zp) || !tM(Ou, Yl) || !YPe(Ou),
  XPe = !Ou && SW(function (t) {
    return new NPe(cR, {
      detail: t
    }).detail
  }),
  Ls = SW(Ou) || XPe,
  R_ = function (t) {
    throw new Yl("Uncloneable type: " + t, _0)
  },
  dr = function (t, e) {
    throw new Yl((e || "Cloning") + " of " + t + " cannot be properly polyfilled in this engine", _0)
  },
  QPe = function () {
    var t;
    try {
      t = new yt.DataTransfer
    } catch {
      try {
        t = new yt.ClipboardEvent("").clipboardData
      } catch {}
    }
    return t && t.items && t.files ? t : null
  },
  fr = function (t, e) {
    if (SPe(t) && R_("Symbol"), !oR(t)) return t;
    if (e) {
      if (EW(e, t)) return BPe(e, t)
    } else e = new lR;
    var r = mW(t),
      n = !1,
      i, a, s, o, c, l, u, f, d, h, p;
    switch (r) {
      case "Array":
        s = $Pe(Nv(t)), n = !0;
        break;
      case "Object":
        s = {}, n = !0;
        break;
      case "Map":
        s = new lR, n = !0;
        break;
      case "Set":
        s = new UPe, n = !0;
        break;
      case "RegExp":
        s = new RegExp(t.source, APe(t));
        break;
      case "Error":
        switch (a = t.name, a) {
          case "AggregateError":
            s = kC("AggregateError")([]);
            break;
          case "EvalError":
            s = CPe();
            break;
          case "RangeError":
            s = kPe();
            break;
          case "ReferenceError":
            s = OPe();
            break;
          case "SyntaxError":
            s = LPe();
            break;
          case "TypeError":
            s = bW();
            break;
          case "URIError":
            s = PPe();
            break;
          case "CompileError":
            s = DPe();
            break;
          case "LinkError":
            s = MPe();
            break;
          case "RuntimeError":
            s = FPe();
            break;
          default:
            s = Zp()
        }
        n = !0;
        break;
      case "DOMException":
        s = new Yl(t.message, t.name), n = !0;
        break;
      case "DataView":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        i = yt[r], oR(i) || dr(r), s = new i(fr(t.buffer, e), t.byteOffset, r === "DataView" ? t.byteLength : t.length);
        break;
      case "DOMQuad":
        try {
          s = new DOMQuad(fr(t.p1, e), fr(t.p2, e), fr(t.p3, e), fr(t.p4, e))
        } catch {
          Ls ? s = Ls(t) : dr(r)
        }
        break;
      case "FileList":
        if (o = QPe(), o) {
          for (c = 0, l = Nv(t); c < l; c++) o.items.add(fr(t[c], e));
          s = o.files
        } else Ls ? s = Ls(t) : dr(r);
        break;
      case "ImageData":
        try {
          s = new ImageData(fr(t.data, e), t.width, t.height, {
            colorSpace: t.colorSpace
          })
        } catch {
          Ls ? s = Ls(t) : dr(r)
        }
        break;
      default:
        if (Ls) s = Ls(t);
        else switch (r) {
          case "BigInt":
            s = vh(t.valueOf());
            break;
          case "Boolean":
            s = vh(GPe(t));
            break;
          case "Number":
            s = vh(VPe(t));
            break;
          case "String":
            s = vh(WPe(t));
            break;
          case "Date":
            s = new xW(KPe(t));
            break;
          case "ArrayBuffer":
            i = yt.DataView, !i && typeof t.slice != "function" && dr(r);
            try {
              if (typeof t.slice == "function" && !t.resizable) s = t.slice(0);
              else
                for (l = t.byteLength, p = ("maxByteLength" in t) ? {
                    maxByteLength: t.maxByteLength
                  } : void 0, s = new ArrayBuffer(l, p), d = new i(t), h = new i(s), c = 0; c < l; c++) h.setUint8(c, d.getUint8(c))
            } catch {
              throw new Yl("ArrayBuffer is detached", _0)
            }
            break;
          case "SharedArrayBuffer":
            s = t;
            break;
          case "Blob":
            try {
              s = t.slice(0, t.size, t.type)
            } catch {
              dr(r)
            }
            break;
          case "DOMPoint":
          case "DOMPointReadOnly":
            i = yt[r];
            try {
              s = i.fromPoint ? i.fromPoint(t) : new i(t.x, t.y, t.z, t.w)
            } catch {
              dr(r)
            }
            break;
          case "DOMRect":
          case "DOMRectReadOnly":
            i = yt[r];
            try {
              s = i.fromRect ? i.fromRect(t) : new i(t.x, t.y, t.width, t.height)
            } catch {
              dr(r)
            }
            break;
          case "DOMMatrix":
          case "DOMMatrixReadOnly":
            i = yt[r];
            try {
              s = i.fromMatrix ? i.fromMatrix(t) : new i(t)
            } catch {
              dr(r)
            }
            break;
          case "AudioData":
          case "VideoFrame":
            Pv(t.clone) || dr(r);
            try {
              s = t.clone()
            } catch {
              R_(r)
            }
            break;
          case "File":
            try {
              s = new File([t], t.name, t)
            } catch {
              dr(r)
            }
            break;
          case "CropTarget":
          case "CryptoKey":
          case "FileSystemDirectoryHandle":
          case "FileSystemFileHandle":
          case "FileSystemHandle":
          case "GPUCompilationInfo":
          case "GPUCompilationMessage":
          case "ImageBitmap":
          case "RTCCertificate":
          case "WebAssembly.Module":
            dr(r);
          default:
            R_(r)
        }
    }
    if (Ny(e, t, s), n) switch (r) {
      case "Array":
      case "Object":
        for (u = HPe(t), c = 0, l = Nv(u); c < l; c++) f = u[c], wPe(s, f, fr(t[f], e));
        break;
      case "Map":
        t.forEach(function (v, g) {
          Ny(s, fr(g, e), fr(v, e))
        });
        break;
      case "Set":
        t.forEach(function (v) {
          jPe(s, fr(v, e))
        });
        break;
      case "Error":
        w_(s, "message", fr(t.message, e)), TPe(t, "cause") && w_(s, "cause", fr(t.cause, e)), a == "AggregateError" && (s.errors = fr(t.errors, e));
      case "DOMException":
        IPe && w_(s, "stack", fr(t.stack, e))
    }
    return s
  },
  ZPe = function (t, e) {
    if (!oR(t)) throw bW("Transfer option cannot be converted to a sequence");
    var r = [];
    _Pe(t, function (d) {
      zPe(r, gW(d))
    });
    var n = 0,
      i = Nv(r),
      a, s, o, c, l, u, f;
    if (yW)
      for (c = Ou(r, {
          transfer: r
        }); n < i;) Ny(e, r[n], c[n++]);
    else
      for (; n < i;) {
        if (a = r[n++], EW(e, a)) throw new Yl("Duplicate transferable", _0);
        switch (s = mW(a), s) {
          case "ImageBitmap":
            o = yt.OffscreenCanvas, bPe(o) || dr(s, xm);
            try {
              u = new o(a.width, a.height), f = u.getContext("bitmaprenderer"), f.transferFromImageBitmap(a), l = u.transferToImageBitmap()
            } catch {}
            break;
          case "AudioData":
          case "VideoFrame":
            (!Pv(a.clone) || !Pv(a.close)) && dr(s, xm);
            try {
              l = a.clone(), a.close()
            } catch {}
            break;
          case "ArrayBuffer":
            Pv(a.transfer) || dr(s, xm), l = a.transfer();
            break;
          case "MediaSourceHandle":
          case "MessagePort":
          case "OffscreenCanvas":
          case "ReadableStream":
          case "TransformStream":
          case "WritableStream":
            dr(s, xm)
        }
        if (l === void 0) throw new Yl("This object cannot be transferred: " + s, _0);
        Ny(e, a, l)
      }
  };
yPe({
  global: !0,
  enumerable: !0,
  sham: !yW,
  forced: qPe
}, {
  structuredClone: function (e) {
    var r = RPe(arguments.length, 1) > 1 && !EPe(arguments[1]) ? gW(arguments[1]) : void 0,
      n = r ? r.transfer : void 0,
      i;
    return n !== void 0 && (i = new lR, ZPe(n, i)), fr(e, i)
  }
});
var JPe = j,
  _W = he,
  eNe = CC,
  rM = eNe(_W.setInterval, !0);
JPe({
  global: !0,
  bind: !0,
  forced: _W.setInterval !== rM
}, {
  setInterval: rM
});
var tNe = j,
  TW = he,
  rNe = CC,
  nM = rNe(TW.setTimeout, !0);
tNe({
  global: !0,
  bind: !0,
  forced: TW.setTimeout !== nM
}, {
  setTimeout: nM
});
var nNe = re,
  iNe = Fe,
  aNe = _e,
  iM = jI,
  sNe = iNe("iterator"),
  LC = !nNe(function () {
    var t = new URL("b?a=1&b=2&c=3", "http://a"),
      e = t.searchParams,
      r = "";
    return t.pathname = "c%20d", e.forEach(function (n, i) {
      e.delete("b"), r += i + n
    }), iM && !t.toJSON || !e.size && (iM || !aNe) || !e.sort || t.href !== "http://a/c%20d?a=1&c=3" || e.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !e[sNe] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://ÑÐµÑÑ").host !== "xn--e1aybc" || new URL("http://a#Ð±").hash !== "#%D0%B1" || r !== "a1c3" || new URL("http://x", void 0).host !== "x"
  }),
  hc = ie,
  A_ = 2147483647,
  Dh = 36,
  wW = 1,
  uR = 26,
  oNe = 38,
  lNe = 700,
  cNe = 72,
  uNe = 128,
  fNe = "-",
  dNe = /[^\0-\u007E]/,
  RW = /[.\u3002\uFF0E\uFF61]/g,
  aM = "Overflow: input needs wider integers to process",
  I_ = Dh - wW,
  sM = RangeError,
  hNe = hc(RW.exec),
  gu = Math.floor,
  $_ = String.fromCharCode,
  oM = hc("".charCodeAt),
  AW = hc([].join),
  Zs = hc([].push),
  pNe = hc("".replace),
  gNe = hc("".split),
  mNe = hc("".toLowerCase),
  vNe = function (t) {
    for (var e = [], r = 0, n = t.length; r < n;) {
      var i = oM(t, r++);
      if (i >= 55296 && i <= 56319 && r < n) {
        var a = oM(t, r++);
        (a & 64512) == 56320 ? Zs(e, ((i & 1023) << 10) + (a & 1023) + 65536) : (Zs(e, i), r--)
      } else Zs(e, i)
    }
    return e
  },
  lM = function (t) {
    return t + 22 + 75 * (t < 26)
  },
  yNe = function (t, e, r) {
    var n = 0;
    for (t = r ? gu(t / lNe) : t >> 1, t += gu(t / e); t > I_ * uR >> 1;) t = gu(t / I_), n += Dh;
    return gu(n + (I_ + 1) * t / (t + oNe))
  },
  xNe = function (t) {
    var e = [];
    t = vNe(t);
    var r = t.length,
      n = uNe,
      i = 0,
      a = cNe,
      s, o;
    for (s = 0; s < t.length; s++) o = t[s], o < 128 && Zs(e, $_(o));
    var c = e.length,
      l = c;
    for (c && Zs(e, fNe); l < r;) {
      var u = A_;
      for (s = 0; s < t.length; s++) o = t[s], o >= n && o < u && (u = o);
      var f = l + 1;
      if (u - n > gu((A_ - i) / f)) throw sM(aM);
      for (i += (u - n) * f, n = u, s = 0; s < t.length; s++) {
        if (o = t[s], o < n && ++i > A_) throw sM(aM);
        if (o == n) {
          for (var d = i, h = Dh;;) {
            var p = h <= a ? wW : h >= a + uR ? uR : h - a;
            if (d < p) break;
            var v = d - p,
              g = Dh - p;
            Zs(e, $_(lM(p + v % g))), d = gu(v / g), h += Dh
          }
          Zs(e, $_(lM(d))), a = yNe(i, f, l == c), i = 0, l++
        }
      }
      i++, n++
    }
    return AW(e, "")
  },
  bNe = function (t) {
    var e = [],
      r = gNe(pNe(mNe(t), RW, "."), "."),
      n, i;
    for (n = 0; n < r.length; n++) i = r[n], Zs(e, hNe(dNe, i) ? "xn--" + xNe(i) : i);
    return AW(e, ".")
  },
  fR = j,
  ff = he,
  bm = $e,
  pa = ie,
  Lu = _e,
  IW = LC,
  $W = _t,
  ENe = sr,
  SNe = Fp,
  _Ne = wn,
  TNe = u$,
  PC = Mt,
  CW = wa,
  C_ = De,
  wNe = He,
  RNe = Ni,
  ANe = Ea,
  INe = Ie,
  kW = Me,
  vn = Ce,
  $Ne = ii,
  cM = ri,
  dR = Hx,
  CNe = Dp,
  Fc = Es,
  kNe = Fe,
  ONe = p$,
  LNe = kNe("iterator"),
  Jp = "URLSearchParams",
  OW = Jp + "Iterator",
  LW = PC.set,
  Un = PC.getterFor(Jp),
  PNe = PC.getterFor(OW),
  NNe = Object.getOwnPropertyDescriptor,
  NC = function (t) {
    if (!Lu) return ff[t];
    var e = NNe(ff, t);
    return e && e.value
  },
  uM = NC("fetch"),
  Dy = NC("Request"),
  Mh = NC("Headers"),
  k_ = Dy && Dy.prototype,
  fM = Mh && Mh.prototype,
  DNe = ff.RegExp,
  MNe = ff.TypeError,
  PW = ff.decodeURIComponent,
  FNe = ff.encodeURIComponent,
  BNe = pa("".charAt),
  dM = pa([].join),
  Rl = pa([].push),
  hR = pa("".replace),
  UNe = pa([].shift),
  hM = pa([].splice),
  pM = pa("".split),
  jNe = pa("".slice),
  HNe = /\+/g,
  gM = Array(4),
  zNe = function (t) {
    return gM[t - 1] || (gM[t - 1] = DNe("((?:%[\\da-f]{2}){" + t + "})", "gi"))
  },
  GNe = function (t) {
    try {
      return PW(t)
    } catch {
      return t
    }
  },
  mM = function (t) {
    var e = hR(t, HNe, " "),
      r = 4;
    try {
      return PW(e)
    } catch {
      for (; r;) e = hR(e, zNe(r--), GNe);
      return e
    }
  },
  VNe = /[!'()~]|%20/g,
  WNe = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+"
  },
  KNe = function (t) {
    return WNe[t]
  },
  vM = function (t) {
    return hR(FNe(t), VNe, KNe)
  },
  O_ = TNe(function (e, r) {
    LW(this, {
      type: OW,
      iterator: dR(Un(e).entries),
      kind: r
    })
  }, "Iterator", function () {
    var e = PNe(this),
      r = e.kind,
      n = e.iterator.next(),
      i = n.value;
    return n.done || (n.value = r === "keys" ? i.key : r === "values" ? i.value : [i.key, i.value]), n
  }, !0),
  NW = function (t) {
    this.entries = [], this.url = null, t !== void 0 && (kW(t) ? this.parseObject(t) : this.parseQuery(typeof t == "string" ? BNe(t, 0) === "?" ? jNe(t, 1) : t : vn(t)))
  };
NW.prototype = {
  type: Jp,
  bindURL: function (t) {
    this.url = t, this.update()
  },
  parseObject: function (t) {
    var e = CNe(t),
      r, n, i, a, s, o, c;
    if (e)
      for (r = dR(t, e), n = r.next; !(i = bm(n, r)).done;) {
        if (a = dR(INe(i.value)), s = a.next, (o = bm(s, a)).done || (c = bm(s, a)).done || !bm(s, a).done) throw MNe("Expected sequence with length 2");
        Rl(this.entries, {
          key: vn(o.value),
          value: vn(c.value)
        })
      } else
        for (var l in t) wNe(t, l) && Rl(this.entries, {
          key: l,
          value: vn(t[l])
        })
  },
  parseQuery: function (t) {
    if (t)
      for (var e = pM(t, "&"), r = 0, n, i; r < e.length;) n = e[r++], n.length && (i = pM(n, "="), Rl(this.entries, {
        key: mM(UNe(i)),
        value: mM(dM(i, "="))
      }))
  },
  serialize: function () {
    for (var t = this.entries, e = [], r = 0, n; r < t.length;) n = t[r++], Rl(e, vM(n.key) + "=" + vM(n.value));
    return dM(e, "&")
  },
  update: function () {
    this.entries.length = 0, this.parseQuery(this.url.query)
  },
  updateURL: function () {
    this.url && this.url.update()
  }
};
var wb = function () {
    CW(this, df);
    var e = arguments.length > 0 ? arguments[0] : void 0,
      r = LW(this, new NW(e));
    Lu || (this.length = r.entries.length)
  },
  df = wb.prototype;
SNe(df, {
  append: function (e, r) {
    Fc(arguments.length, 2);
    var n = Un(this);
    Rl(n.entries, {
      key: vn(e),
      value: vn(r)
    }), Lu || this.length++, n.updateURL()
  },
  delete: function (t) {
    Fc(arguments.length, 1);
    for (var e = Un(this), r = e.entries, n = vn(t), i = 0; i < r.length;) r[i].key === n ? hM(r, i, 1) : i++;
    Lu || (this.length = r.length), e.updateURL()
  },
  get: function (e) {
    Fc(arguments.length, 1);
    for (var r = Un(this).entries, n = vn(e), i = 0; i < r.length; i++)
      if (r[i].key === n) return r[i].value;
    return null
  },
  getAll: function (e) {
    Fc(arguments.length, 1);
    for (var r = Un(this).entries, n = vn(e), i = [], a = 0; a < r.length; a++) r[a].key === n && Rl(i, r[a].value);
    return i
  },
  has: function (e) {
    Fc(arguments.length, 1);
    for (var r = Un(this).entries, n = vn(e), i = 0; i < r.length;)
      if (r[i++].key === n) return !0;
    return !1
  },
  set: function (e, r) {
    Fc(arguments.length, 1);
    for (var n = Un(this), i = n.entries, a = !1, s = vn(e), o = vn(r), c = 0, l; c < i.length; c++) l = i[c], l.key === s && (a ? hM(i, c--, 1) : (a = !0, l.value = o));
    a || Rl(i, {
      key: s,
      value: o
    }), Lu || (this.length = i.length), n.updateURL()
  },
  sort: function () {
    var e = Un(this);
    ONe(e.entries, function (r, n) {
      return r.key > n.key ? 1 : -1
    }), e.updateURL()
  },
  forEach: function (e) {
    for (var r = Un(this).entries, n = RNe(e, arguments.length > 1 ? arguments[1] : void 0), i = 0, a; i < r.length;) a = r[i++], n(a.value, a.key, this)
  },
  keys: function () {
    return new O_(this, "keys")
  },
  values: function () {
    return new O_(this, "values")
  },
  entries: function () {
    return new O_(this, "entries")
  }
}, {
  enumerable: !0
});
$W(df, LNe, df.entries, {
  name: "entries"
});
$W(df, "toString", function () {
  return Un(this).serialize()
}, {
  enumerable: !0
});
Lu && ENe(df, "size", {
  get: function () {
    return Un(this).entries.length
  },
  configurable: !0,
  enumerable: !0
});
_Ne(wb, Jp);
fR({
  global: !0,
  constructor: !0,
  forced: !IW
}, {
  URLSearchParams: wb
});
if (!IW && C_(Mh)) {
  var YNe = pa(fM.has),
    qNe = pa(fM.set),
    yM = function (t) {
      if (kW(t)) {
        var e = t.body,
          r;
        if (ANe(e) === Jp) return r = t.headers ? new Mh(t.headers) : new Mh, YNe(r, "content-type") || qNe(r, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), $Ne(t, {
          body: cM(0, vn(e)),
          headers: cM(0, r)
        })
      }
      return t
    };
  if (C_(uM) && fR({
      global: !0,
      enumerable: !0,
      dontCallGetSet: !0,
      forced: !0
    }, {
      fetch: function (e) {
        return uM(e, arguments.length > 1 ? yM(arguments[1]) : {})
      }
    }), C_(Dy)) {
    var L_ = function (e) {
      return CW(this, k_), new Dy(e, arguments.length > 1 ? yM(arguments[1]) : {})
    };
    k_.constructor = L_, L_.prototype = k_, fR({
      global: !0,
      constructor: !0,
      dontCallGetSet: !0,
      forced: !0
    }, {
      Request: L_
    })
  }
}
var XNe = {
    URLSearchParams: wb,
    getState: Un
  },
  QNe = j,
  DC = _e,
  ZNe = LC,
  MC = he,
  xM = Ni,
  oi = ie,
  My = _t,
  Ln = sr,
  JNe = wa,
  pR = He,
  FC = kz,
  Bc = xH,
  gi = Cp,
  eDe = pb.codeAt,
  tDe = bNe,
  Da = Ce,
  rDe = wn,
  nDe = Es,
  DW = XNe,
  MW = Mt,
  iDe = MW.set,
  Fy = MW.getterFor("URL"),
  aDe = DW.URLSearchParams,
  sDe = DW.getState,
  Fd = MC.URL,
  gR = MC.TypeError,
  By = MC.parseInt,
  oDe = Math.floor,
  bM = Math.pow,
  Hn = oi("".charAt),
  _i = oi(/./.exec),
  yh = oi([].join),
  lDe = oi(1.toString),
  cDe = oi([].pop),
  au = oi([].push),
  P_ = oi("".replace),
  uDe = oi([].shift),
  fDe = oi("".split),
  Fh = oi("".slice),
  Uy = oi("".toLowerCase),
  dDe = oi([].unshift),
  hDe = "Invalid authority",
  N_ = "Invalid scheme",
  fl = "Invalid host",
  EM = "Invalid port",
  FW = /[a-z]/i,
  pDe = /[\d+-.a-z]/i,
  mR = /\d/,
  gDe = /^0x/i,
  mDe = /^[0-7]+$/,
  vDe = /^\d+$/,
  BW = /^[\da-f]+$/i,
  yDe = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
  xDe = /[\0\t\n\r #/:<>?@[\\\]^|]/,
  bDe = /^[\u0000-\u0020]+/,
  EDe = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/,
  SDe = /[\t\n\r]/g,
  Pn, _De = function (t) {
    var e = fDe(t, "."),
      r, n, i, a, s, o, c;
    if (e.length && e[e.length - 1] == "" && e.length--, r = e.length, r > 4) return t;
    for (n = [], i = 0; i < r; i++) {
      if (a = e[i], a == "") return t;
      if (s = 10, a.length > 1 && Hn(a, 0) == "0" && (s = _i(gDe, a) ? 16 : 8, a = Fh(a, s == 8 ? 1 : 2)), a === "") o = 0;
      else {
        if (!_i(s == 10 ? vDe : s == 8 ? mDe : BW, a)) return t;
        o = By(a, s)
      }
      au(n, o)
    }
    for (i = 0; i < r; i++)
      if (o = n[i], i == r - 1) {
        if (o >= bM(256, 5 - r)) return null
      } else if (o > 255) return null;
    for (c = cDe(n), i = 0; i < n.length; i++) c += n[i] * bM(256, 3 - i);
    return c
  },
  TDe = function (t) {
    var e = [0, 0, 0, 0, 0, 0, 0, 0],
      r = 0,
      n = null,
      i = 0,
      a, s, o, c, l, u, f, d = function () {
        return Hn(t, i)
      };
    if (d() == ":") {
      if (Hn(t, 1) != ":") return;
      i += 2, r++, n = r
    }
    for (; d();) {
      if (r == 8) return;
      if (d() == ":") {
        if (n !== null) return;
        i++, r++, n = r;
        continue
      }
      for (a = s = 0; s < 4 && _i(BW, d());) a = a * 16 + By(d(), 16), i++, s++;
      if (d() == ".") {
        if (s == 0 || (i -= s, r > 6)) return;
        for (o = 0; d();) {
          if (c = null, o > 0)
            if (d() == "." && o < 4) i++;
            else return;
          if (!_i(mR, d())) return;
          for (; _i(mR, d());) {
            if (l = By(d(), 10), c === null) c = l;
            else {
              if (c == 0) return;
              c = c * 10 + l
            }
            if (c > 255) return;
            i++
          }
          e[r] = e[r] * 256 + c, o++, (o == 2 || o == 4) && r++
        }
        if (o != 4) return;
        break
      } else if (d() == ":") {
        if (i++, !d()) return
      } else if (d()) return;
      e[r++] = a
    }
    if (n !== null)
      for (u = r - n, r = 7; r != 0 && u > 0;) f = e[r], e[r--] = e[n + u - 1], e[n + --u] = f;
    else if (r != 8) return;
    return e
  },
  wDe = function (t) {
    for (var e = null, r = 1, n = null, i = 0, a = 0; a < 8; a++) t[a] !== 0 ? (i > r && (e = n, r = i), n = null, i = 0) : (n === null && (n = a), ++i);
    return i > r && (e = n, r = i), e
  },
  Bd = function (t) {
    var e, r, n, i;
    if (typeof t == "number") {
      for (e = [], r = 0; r < 4; r++) dDe(e, t % 256), t = oDe(t / 256);
      return yh(e, ".")
    } else if (typeof t == "object") {
      for (e = "", n = wDe(t), r = 0; r < 8; r++) i && t[r] === 0 || (i && (i = !1), n === r ? (e += r ? ":" : "::", i = !0) : (e += lDe(t[r], 16), r < 7 && (e += ":")));
      return "[" + e + "]"
    }
    return t
  },
  Dv = {},
  UW = FC({}, Dv, {
    " ": 1,
    '"': 1,
    "<": 1,
    ">": 1,
    "`": 1
  }),
  jW = FC({}, UW, {
    "#": 1,
    "?": 1,
    "{": 1,
    "}": 1
  }),
  D_ = FC({}, jW, {
    "/": 1,
    ":": 1,
    ";": 1,
    "=": 1,
    "@": 1,
    "[": 1,
    "\\": 1,
    "]": 1,
    "^": 1,
    "|": 1
  }),
  Ps = function (t, e) {
    var r = eDe(t, 0);
    return r > 32 && r < 127 && !pR(e, t) ? t : encodeURIComponent(t)
  },
  Em = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  },
  xh = function (t, e) {
    var r;
    return t.length == 2 && _i(FW, Hn(t, 0)) && ((r = Hn(t, 1)) == ":" || !e && r == "|")
  },
  SM = function (t) {
    var e;
    return t.length > 1 && xh(Fh(t, 0, 2)) && (t.length == 2 || (e = Hn(t, 2)) === "/" || e === "\\" || e === "?" || e === "#")
  },
  RDe = function (t) {
    return t === "." || Uy(t) === "%2e"
  },
  ADe = function (t) {
    return t = Uy(t), t === ".." || t === "%2e." || t === ".%2e" || t === "%2e%2e"
  },
  M_ = {},
  _M = {},
  F_ = {},
  TM = {},
  wM = {},
  B_ = {},
  RM = {},
  AM = {},
  Sm = {},
  _m = {},
  U_ = {},
  j_ = {},
  H_ = {},
  z_ = {},
  IM = {},
  G_ = {},
  Uc = {},
  Ki = {},
  $M = {},
  dl = {},
  Ca = {},
  BC = function (t, e, r) {
    var n = Da(t),
      i, a, s;
    if (e) {
      if (a = this.parse(n), a) throw gR(a);
      this.searchParams = null
    } else {
      if (r !== void 0 && (i = new BC(r, !0)), a = this.parse(n, null, i), a) throw gR(a);
      s = sDe(new aDe), s.bindURL(this), this.searchParams = s
    }
  };
BC.prototype = {
  type: "URL",
  parse: function (t, e, r) {
    var n = this,
      i = e || M_,
      a = 0,
      s = "",
      o = !1,
      c = !1,
      l = !1,
      u, f, d, h;
    for (t = Da(t), e || (n.scheme = "", n.username = "", n.password = "", n.host = null, n.port = null, n.path = [], n.query = null, n.fragment = null, n.cannotBeABaseURL = !1, t = P_(t, bDe, ""), t = P_(t, EDe, "$1")), t = P_(t, SDe, ""), u = Bc(t); a <= u.length;) {
      switch (f = u[a], i) {
        case M_:
          if (f && _i(FW, f)) s += Uy(f), i = _M;
          else {
            if (e) return N_;
            i = F_;
            continue
          }
          break;
        case _M:
          if (f && (_i(pDe, f) || f == "+" || f == "-" || f == ".")) s += Uy(f);
          else if (f == ":") {
            if (e && (n.isSpecial() != pR(Em, s) || s == "file" && (n.includesCredentials() || n.port !== null) || n.scheme == "file" && !n.host)) return;
            if (n.scheme = s, e) {
              n.isSpecial() && Em[n.scheme] == n.port && (n.port = null);
              return
            }
            s = "", n.scheme == "file" ? i = z_ : n.isSpecial() && r && r.scheme == n.scheme ? i = TM : n.isSpecial() ? i = AM : u[a + 1] == "/" ? (i = wM, a++) : (n.cannotBeABaseURL = !0, au(n.path, ""), i = $M)
          } else {
            if (e) return N_;
            s = "", i = F_, a = 0;
            continue
          }
          break;
        case F_:
          if (!r || r.cannotBeABaseURL && f != "#") return N_;
          if (r.cannotBeABaseURL && f == "#") {
            n.scheme = r.scheme, n.path = gi(r.path), n.query = r.query, n.fragment = "", n.cannotBeABaseURL = !0, i = Ca;
            break
          }
          i = r.scheme == "file" ? z_ : B_;
          continue;
        case TM:
          if (f == "/" && u[a + 1] == "/") i = Sm, a++;
          else {
            i = B_;
            continue
          }
          break;
        case wM:
          if (f == "/") {
            i = _m;
            break
          } else {
            i = Ki;
            continue
          }
          case B_:
            if (n.scheme = r.scheme, f == Pn) n.username = r.username, n.password = r.password, n.host = r.host, n.port = r.port, n.path = gi(r.path), n.query = r.query;
            else if (f == "/" || f == "\\" && n.isSpecial()) i = RM;
            else if (f == "?") n.username = r.username, n.password = r.password, n.host = r.host, n.port = r.port, n.path = gi(r.path), n.query = "", i = dl;
            else if (f == "#") n.username = r.username, n.password = r.password, n.host = r.host, n.port = r.port, n.path = gi(r.path), n.query = r.query, n.fragment = "", i = Ca;
            else {
              n.username = r.username, n.password = r.password, n.host = r.host, n.port = r.port, n.path = gi(r.path), n.path.length--, i = Ki;
              continue
            }
            break;
          case RM:
            if (n.isSpecial() && (f == "/" || f == "\\")) i = Sm;
            else if (f == "/") i = _m;
            else {
              n.username = r.username, n.password = r.password, n.host = r.host, n.port = r.port, i = Ki;
              continue
            }
            break;
          case AM:
            if (i = Sm, f != "/" || Hn(s, a + 1) != "/") continue;
            a++;
            break;
          case Sm:
            if (f != "/" && f != "\\") {
              i = _m;
              continue
            }
            break;
          case _m:
            if (f == "@") {
              o && (s = "%40" + s), o = !0, d = Bc(s);
              for (var p = 0; p < d.length; p++) {
                var v = d[p];
                if (v == ":" && !l) {
                  l = !0;
                  continue
                }
                var g = Ps(v, D_);
                l ? n.password += g : n.username += g
              }
              s = ""
            } else if (f == Pn || f == "/" || f == "?" || f == "#" || f == "\\" && n.isSpecial()) {
              if (o && s == "") return hDe;
              a -= Bc(s).length + 1, s = "", i = U_
            } else s += f;
            break;
          case U_:
          case j_:
            if (e && n.scheme == "file") {
              i = G_;
              continue
            } else if (f == ":" && !c) {
              if (s == "") return fl;
              if (h = n.parseHost(s), h) return h;
              if (s = "", i = H_, e == j_) return
            } else if (f == Pn || f == "/" || f == "?" || f == "#" || f == "\\" && n.isSpecial()) {
              if (n.isSpecial() && s == "") return fl;
              if (e && s == "" && (n.includesCredentials() || n.port !== null)) return;
              if (h = n.parseHost(s), h) return h;
              if (s = "", i = Uc, e) return;
              continue
            } else f == "[" ? c = !0 : f == "]" && (c = !1), s += f;
            break;
          case H_:
            if (_i(mR, f)) s += f;
            else if (f == Pn || f == "/" || f == "?" || f == "#" || f == "\\" && n.isSpecial() || e) {
              if (s != "") {
                var m = By(s, 10);
                if (m > 65535) return EM;
                n.port = n.isSpecial() && m === Em[n.scheme] ? null : m, s = ""
              }
              if (e) return;
              i = Uc;
              continue
            } else return EM;
            break;
          case z_:
            if (n.scheme = "file", f == "/" || f == "\\") i = IM;
            else if (r && r.scheme == "file")
              if (f == Pn) n.host = r.host, n.path = gi(r.path), n.query = r.query;
              else if (f == "?") n.host = r.host, n.path = gi(r.path), n.query = "", i = dl;
            else if (f == "#") n.host = r.host, n.path = gi(r.path), n.query = r.query, n.fragment = "", i = Ca;
            else {
              SM(yh(gi(u, a), "")) || (n.host = r.host, n.path = gi(r.path), n.shortenPath()), i = Ki;
              continue
            } else {
              i = Ki;
              continue
            }
            break;
          case IM:
            if (f == "/" || f == "\\") {
              i = G_;
              break
            }
            r && r.scheme == "file" && !SM(yh(gi(u, a), "")) && (xh(r.path[0], !0) ? au(n.path, r.path[0]) : n.host = r.host), i = Ki;
            continue;
          case G_:
            if (f == Pn || f == "/" || f == "\\" || f == "?" || f == "#") {
              if (!e && xh(s)) i = Ki;
              else if (s == "") {
                if (n.host = "", e) return;
                i = Uc
              } else {
                if (h = n.parseHost(s), h) return h;
                if (n.host == "localhost" && (n.host = ""), e) return;
                s = "", i = Uc
              }
              continue
            } else s += f;
            break;
          case Uc:
            if (n.isSpecial()) {
              if (i = Ki, f != "/" && f != "\\") continue
            } else if (!e && f == "?") n.query = "", i = dl;
            else if (!e && f == "#") n.fragment = "", i = Ca;
            else if (f != Pn && (i = Ki, f != "/")) continue;
            break;
          case Ki:
            if (f == Pn || f == "/" || f == "\\" && n.isSpecial() || !e && (f == "?" || f == "#")) {
              if (ADe(s) ? (n.shortenPath(), f != "/" && !(f == "\\" && n.isSpecial()) && au(n.path, "")) : RDe(s) ? f != "/" && !(f == "\\" && n.isSpecial()) && au(n.path, "") : (n.scheme == "file" && !n.path.length && xh(s) && (n.host && (n.host = ""), s = Hn(s, 0) + ":"), au(n.path, s)), s = "", n.scheme == "file" && (f == Pn || f == "?" || f == "#"))
                for (; n.path.length > 1 && n.path[0] === "";) uDe(n.path);
              f == "?" ? (n.query = "", i = dl) : f == "#" && (n.fragment = "", i = Ca)
            } else s += Ps(f, jW);
            break;
          case $M:
            f == "?" ? (n.query = "", i = dl) : f == "#" ? (n.fragment = "", i = Ca) : f != Pn && (n.path[0] += Ps(f, Dv));
            break;
          case dl:
            !e && f == "#" ? (n.fragment = "", i = Ca) : f != Pn && (f == "'" && n.isSpecial() ? n.query += "%27" : f == "#" ? n.query += "%23" : n.query += Ps(f, Dv));
            break;
          case Ca:
            f != Pn && (n.fragment += Ps(f, UW));
            break
      }
      a++
    }
  },
  parseHost: function (t) {
    var e, r, n;
    if (Hn(t, 0) == "[") {
      if (Hn(t, t.length - 1) != "]" || (e = TDe(Fh(t, 1, -1)), !e)) return fl;
      this.host = e
    } else if (this.isSpecial()) {
      if (t = tDe(t), _i(yDe, t) || (e = _De(t), e === null)) return fl;
      this.host = e
    } else {
      if (_i(xDe, t)) return fl;
      for (e = "", r = Bc(t), n = 0; n < r.length; n++) e += Ps(r[n], Dv);
      this.host = e
    }
  },
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme == "file"
  },
  includesCredentials: function () {
    return this.username != "" || this.password != ""
  },
  isSpecial: function () {
    return pR(Em, this.scheme)
  },
  shortenPath: function () {
    var t = this.path,
      e = t.length;
    e && (this.scheme != "file" || e != 1 || !xh(t[0], !0)) && t.length--
  },
  serialize: function () {
    var t = this,
      e = t.scheme,
      r = t.username,
      n = t.password,
      i = t.host,
      a = t.port,
      s = t.path,
      o = t.query,
      c = t.fragment,
      l = e + ":";
    return i !== null ? (l += "//", t.includesCredentials() && (l += r + (n ? ":" + n : "") + "@"), l += Bd(i), a !== null && (l += ":" + a)) : e == "file" && (l += "//"), l += t.cannotBeABaseURL ? s[0] : s.length ? "/" + yh(s, "/") : "", o !== null && (l += "?" + o), c !== null && (l += "#" + c), l
  },
  setHref: function (t) {
    var e = this.parse(t);
    if (e) throw gR(e);
    this.searchParams.update()
  },
  getOrigin: function () {
    var t = this.scheme,
      e = this.port;
    if (t == "blob") try {
      return new hf(t.path[0]).origin
    } catch {
      return "null"
    }
    return t == "file" || !this.isSpecial() ? "null" : t + "://" + Bd(this.host) + (e !== null ? ":" + e : "")
  },
  getProtocol: function () {
    return this.scheme + ":"
  },
  setProtocol: function (t) {
    this.parse(Da(t) + ":", M_)
  },
  getUsername: function () {
    return this.username
  },
  setUsername: function (t) {
    var e = Bc(Da(t));
    if (!this.cannotHaveUsernamePasswordPort()) {
      this.username = "";
      for (var r = 0; r < e.length; r++) this.username += Ps(e[r], D_)
    }
  },
  getPassword: function () {
    return this.password
  },
  setPassword: function (t) {
    var e = Bc(Da(t));
    if (!this.cannotHaveUsernamePasswordPort()) {
      this.password = "";
      for (var r = 0; r < e.length; r++) this.password += Ps(e[r], D_)
    }
  },
  getHost: function () {
    var t = this.host,
      e = this.port;
    return t === null ? "" : e === null ? Bd(t) : Bd(t) + ":" + e
  },
  setHost: function (t) {
    this.cannotBeABaseURL || this.parse(t, U_)
  },
  getHostname: function () {
    var t = this.host;
    return t === null ? "" : Bd(t)
  },
  setHostname: function (t) {
    this.cannotBeABaseURL || this.parse(t, j_)
  },
  getPort: function () {
    var t = this.port;
    return t === null ? "" : Da(t)
  },
  setPort: function (t) {
    this.cannotHaveUsernamePasswordPort() || (t = Da(t), t == "" ? this.port = null : this.parse(t, H_))
  },
  getPathname: function () {
    var t = this.path;
    return this.cannotBeABaseURL ? t[0] : t.length ? "/" + yh(t, "/") : ""
  },
  setPathname: function (t) {
    this.cannotBeABaseURL || (this.path = [], this.parse(t, Uc))
  },
  getSearch: function () {
    var t = this.query;
    return t ? "?" + t : ""
  },
  setSearch: function (t) {
    t = Da(t), t == "" ? this.query = null : (Hn(t, 0) == "?" && (t = Fh(t, 1)), this.query = "", this.parse(t, dl)), this.searchParams.update()
  },
  getSearchParams: function () {
    return this.searchParams.facade
  },
  getHash: function () {
    var t = this.fragment;
    return t ? "#" + t : ""
  },
  setHash: function (t) {
    if (t = Da(t), t == "") {
      this.fragment = null;
      return
    }
    Hn(t, 0) == "#" && (t = Fh(t, 1)), this.fragment = "", this.parse(t, Ca)
  },
  update: function () {
    this.query = this.searchParams.serialize() || null
  }
};
var hf = function (e) {
    var r = JNe(this, Sr),
      n = nDe(arguments.length, 1) > 1 ? arguments[1] : void 0,
      i = iDe(r, new BC(e, !1, n));
    DC || (r.href = i.serialize(), r.origin = i.getOrigin(), r.protocol = i.getProtocol(), r.username = i.getUsername(), r.password = i.getPassword(), r.host = i.getHost(), r.hostname = i.getHostname(), r.port = i.getPort(), r.pathname = i.getPathname(), r.search = i.getSearch(), r.searchParams = i.getSearchParams(), r.hash = i.getHash())
  },
  Sr = hf.prototype,
  Nn = function (t, e) {
    return {
      get: function () {
        return Fy(this)[t]()
      },
      set: e && function (r) {
        return Fy(this)[e](r)
      },
      configurable: !0,
      enumerable: !0
    }
  };
DC && (Ln(Sr, "href", Nn("serialize", "setHref")), Ln(Sr, "origin", Nn("getOrigin")), Ln(Sr, "protocol", Nn("getProtocol", "setProtocol")), Ln(Sr, "username", Nn("getUsername", "setUsername")), Ln(Sr, "password", Nn("getPassword", "setPassword")), Ln(Sr, "host", Nn("getHost", "setHost")), Ln(Sr, "hostname", Nn("getHostname", "setHostname")), Ln(Sr, "port", Nn("getPort", "setPort")), Ln(Sr, "pathname", Nn("getPathname", "setPathname")), Ln(Sr, "search", Nn("getSearch", "setSearch")), Ln(Sr, "searchParams", Nn("getSearchParams")), Ln(Sr, "hash", Nn("getHash", "setHash")));
My(Sr, "toJSON", function () {
  return Fy(this).serialize()
}, {
  enumerable: !0
});
My(Sr, "toString", function () {
  return Fy(this).serialize()
}, {
  enumerable: !0
});
if (Fd) {
  var CM = Fd.createObjectURL,
    kM = Fd.revokeObjectURL;
  CM && My(hf, "createObjectURL", xM(CM, Fd)), kM && My(hf, "revokeObjectURL", xM(kM, Fd))
}
rDe(hf, "URL");
QNe({
  global: !0,
  constructor: !0,
  forced: !ZNe,
  sham: !DC
}, {
  URL: hf
});
var IDe = j,
  $De = ht,
  CDe = re,
  kDe = Es,
  OM = Ce,
  ODe = LC,
  HW = $De("URL"),
  LDe = ODe && CDe(function () {
    HW.canParse()
  });
IDe({
  target: "URL",
  stat: !0,
  forced: !LDe
}, {
  canParse: function (e) {
    var r = kDe(arguments.length, 1),
      n = OM(e),
      i = r < 2 || arguments[1] === void 0 ? void 0 : OM(arguments[1]);
    try {
      return !!new HW(n, i)
    } catch {
      return !1
    }
  }
});
var PDe = j,
  NDe = $e;
PDe({
  target: "URL",
  proto: !0,
  enumerable: !0
}, {
  toJSON: function () {
    return NDe(URL.prototype.toString, this)
  }
});
var DDe = _e,
  MDe = ie,
  FDe = sr,
  vR = URLSearchParams.prototype,
  BDe = MDe(vR.forEach);
DDe && !("size" in vR) && FDe(vR, "size", {
  get: function () {
    var e = 0;
    return BDe(this, function () {
      e++
    }), e
  },
  configurable: !0,
  enumerable: !0
});
(function (t) {
  t.exports = QI
})(Wee);
var ql = {},
  UDe = {
    get exports() {
      return ql
    },
    set exports(t) {
      ql = t
    }
  },
  li = {},
  yR = {},
  jDe = {
    get exports() {
      return yR
    },
    set exports(t) {
      yR = t
    }
  },
  zW = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (t) {
  var e, r, n, i;
  if (typeof performance == "object" && typeof performance.now == "function") {
    var a = performance;
    t.unstable_now = function () {
      return a.now()
    }
  } else {
    var s = Date,
      o = s.now();
    t.unstable_now = function () {
      return s.now() - o
    }
  }
  if (typeof window > "u" || typeof MessageChannel != "function") {
    var c = null,
      l = null,
      u = function () {
        if (c !== null) try {
          var k = t.unstable_now();
          c(!0, k), c = null
        } catch (O) {
          throw setTimeout(u, 0), O
        }
      };
    e = function (k) {
      c !== null ? setTimeout(e, 0, k) : (c = k, setTimeout(u, 0))
    }, r = function (k, O) {
      l = setTimeout(k, O)
    }, n = function () {
      clearTimeout(l)
    }, t.unstable_shouldYield = function () {
      return !1
    }, i = t.unstable_forceFrameRate = function () {}
  } else {
    var f = window.setTimeout,
      d = window.clearTimeout;
    if (typeof console < "u") {
      var h = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof h != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")
    }
    var p = !1,
      v = null,
      g = -1,
      m = 5,
      y = 0;
    t.unstable_shouldYield = function () {
      return t.unstable_now() >= y
    }, i = function () {}, t.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : m = 0 < k ? Math.floor(1e3 / k) : 5
    };
    var x = new MessageChannel,
      b = x.port2;
    x.port1.onmessage = function () {
      if (v !== null) {
        var k = t.unstable_now();
        y = k + m;
        try {
          v(!0, k) ? b.postMessage(null) : (p = !1, v = null)
        } catch (O) {
          throw b.postMessage(null), O
        }
      } else p = !1
    }, e = function (k) {
      v = k, p || (p = !0, b.postMessage(null))
    }, r = function (k, O) {
      g = f(function () {
        k(t.unstable_now())
      }, O)
    }, n = function () {
      d(g), g = -1
    }
  }

  function _(k, O) {
    var F = k.length;
    k.push(O);
    e: for (;;) {
      var D = F - 1 >>> 1,
        Q = k[D];
      if (Q !== void 0 && 0 < R(Q, O)) k[D] = O, k[F] = Q, F = D;
      else break e
    }
  }

  function S(k) {
    return k = k[0], k === void 0 ? null : k
  }

  function T(k) {
    var O = k[0];
    if (O !== void 0) {
      var F = k.pop();
      if (F !== O) {
        k[0] = F;
        e: for (var D = 0, Q = k.length; D < Q;) {
          var ee = 2 * (D + 1) - 1,
            de = k[ee],
            oe = ee + 1,
            rt = k[oe];
          if (de !== void 0 && 0 > R(de, F)) rt !== void 0 && 0 > R(rt, de) ? (k[D] = rt, k[oe] = F, D = oe) : (k[D] = de, k[ee] = F, D = ee);
          else if (rt !== void 0 && 0 > R(rt, F)) k[D] = rt, k[oe] = F, D = oe;
          else break e
        }
      }
      return O
    }
    return null
  }

  function R(k, O) {
    var F = k.sortIndex - O.sortIndex;
    return F !== 0 ? F : k.id - O.id
  }
  var I = [],
    w = [],
    C = 1,
    L = null,
    H = 3,
    N = !1,
    P = !1,
    B = !1;

  function V(k) {
    for (var O = S(w); O !== null;) {
      if (O.callback === null) T(w);
      else if (O.startTime <= k) T(w), O.sortIndex = O.expirationTime, _(I, O);
      else break;
      O = S(w)
    }
  }

  function M(k) {
    if (B = !1, V(k), !P)
      if (S(I) !== null) P = !0, e(U);
      else {
        var O = S(w);
        O !== null && r(M, O.startTime - k)
      }
  }

  function U(k, O) {
    P = !1, B && (B = !1, n()), N = !0;
    var F = H;
    try {
      for (V(O), L = S(I); L !== null && (!(L.expirationTime > O) || k && !t.unstable_shouldYield());) {
        var D = L.callback;
        if (typeof D == "function") {
          L.callback = null, H = L.priorityLevel;
          var Q = D(L.expirationTime <= O);
          O = t.unstable_now(), typeof Q == "function" ? L.callback = Q : L === S(I) && T(I), V(O)
        } else T(I);
        L = S(I)
      }
      if (L !== null) var ee = !0;
      else {
        var de = S(w);
        de !== null && r(M, de.startTime - O), ee = !1
      }
      return ee
    } finally {
      L = null, H = F, N = !1
    }
  }
  var W = i;
  t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (k) {
    k.callback = null
  }, t.unstable_continueExecution = function () {
    P || N || (P = !0, e(U))
  }, t.unstable_getCurrentPriorityLevel = function () {
    return H
  }, t.unstable_getFirstCallbackNode = function () {
    return S(I)
  }, t.unstable_next = function (k) {
    switch (H) {
      case 1:
      case 2:
      case 3:
        var O = 3;
        break;
      default:
        O = H
    }
    var F = H;
    H = O;
    try {
      return k()
    } finally {
      H = F
    }
  }, t.unstable_pauseExecution = function () {}, t.unstable_requestPaint = W, t.unstable_runWithPriority = function (k, O) {
    switch (k) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        k = 3
    }
    var F = H;
    H = k;
    try {
      return O()
    } finally {
      H = F
    }
  }, t.unstable_scheduleCallback = function (k, O, F) {
    var D = t.unstable_now();
    switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? D + F : D) : F = D, k) {
      case 1:
        var Q = -1;
        break;
      case 2:
        Q = 250;
        break;
      case 5:
        Q = 1073741823;
        break;
      case 4:
        Q = 1e4;
        break;
      default:
        Q = 5e3
    }
    return Q = F + Q, k = {
      id: C++,
      callback: O,
      priorityLevel: k,
      startTime: F,
      expirationTime: Q,
      sortIndex: -1
    }, F > D ? (k.sortIndex = F, _(w, k), S(I) === null && k === S(w) && (B ? n() : B = !0, r(M, F - D))) : (k.sortIndex = Q, _(I, k), P || N || (P = !0, e(U))), k
  }, t.unstable_wrapCallback = function (k) {
    var O = H;
    return function () {
      var F = H;
      H = O;
      try {
        return k.apply(this, arguments)
      } finally {
        H = F
      }
    }
  }
})(zW);
(function (t) {
  t.exports = zW
})(jDe);
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rb = A,
  ft = NI,
  Yt = yR;

function te(t) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++) e += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
if (!Rb) throw Error(te(227));
var GW = new Set,
  T0 = {};

function pc(t, e) {
  pf(t, e), pf(t + "Capture", e)
}

function pf(t, e) {
  for (T0[t] = e, t = 0; t < e.length; t++) GW.add(e[t])
}
var us = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
  HDe = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  LM = Object.prototype.hasOwnProperty,
  PM = {},
  NM = {};

function zDe(t) {
  return LM.call(NM, t) ? !0 : LM.call(PM, t) ? !1 : HDe.test(t) ? NM[t] = !0 : (PM[t] = !0, !1)
}

function GDe(t, e, r, n) {
  if (r !== null && r.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return n ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
    default:
      return !1
  }
}

function VDe(t, e, r, n) {
  if (e === null || typeof e > "u" || GDe(t, e, r, n)) return !0;
  if (n) return !1;
  if (r !== null) switch (r.type) {
    case 3:
      return !e;
    case 4:
      return e === !1;
    case 5:
      return isNaN(e);
    case 6:
      return isNaN(e) || 1 > e
  }
  return !1
}

function Nr(t, e, r, n, i, a, s) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = t, this.type = e, this.sanitizeURL = a, this.removeEmptyString = s
}
var nr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) {
  nr[t] = new Nr(t, 0, !1, t, null, !1, !1)
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function (t) {
  var e = t[0];
  nr[e] = new Nr(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  nr[t] = new Nr(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) {
  nr[t] = new Nr(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) {
  nr[t] = new Nr(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  nr[t] = new Nr(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function (t) {
  nr[t] = new Nr(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function (t) {
  nr[t] = new Nr(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function (t) {
  nr[t] = new Nr(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var UC = /[\-:]([a-z])/g;

function jC(t) {
  return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) {
  var e = t.replace(UC, jC);
  nr[e] = new Nr(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) {
  var e = t.replace(UC, jC);
  nr[e] = new Nr(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(UC, jC);
  nr[e] = new Nr(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  nr[t] = new Nr(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
nr.xlinkHref = new Nr("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (t) {
  nr[t] = new Nr(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function HC(t, e, r, n) {
  var i = nr.hasOwnProperty(e) ? nr[e] : null,
    a = i !== null ? i.type === 0 : n ? !1 : !(!(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N");
  a || (VDe(e, r, i, n) && (r = null), n || i === null ? zDe(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : i.mustUseProperty ? t[i.propertyName] = r === null ? i.type === 3 ? !1 : "" : r : (e = i.attributeName, n = i.attributeNamespace, r === null ? t.removeAttribute(e) : (i = i.type, r = i === 3 || i === 4 && r === !0 ? "" : "" + r, n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))))
}
var gc = Rb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  bh = 60103,
  Al = 60106,
  Ks = 60107,
  zC = 60108,
  Bh = 60114,
  GC = 60109,
  VC = 60110,
  Ab = 60112,
  Uh = 60113,
  jy = 60120,
  Ib = 60115,
  WC = 60116,
  KC = 60121,
  YC = 60128,
  VW = 60129,
  qC = 60130,
  xR = 60131;
if (typeof Symbol == "function" && Symbol.for) {
  var jt = Symbol.for;
  bh = jt("react.element"), Al = jt("react.portal"), Ks = jt("react.fragment"), zC = jt("react.strict_mode"), Bh = jt("react.profiler"), GC = jt("react.provider"), VC = jt("react.context"), Ab = jt("react.forward_ref"), Uh = jt("react.suspense"), jy = jt("react.suspense_list"), Ib = jt("react.memo"), WC = jt("react.lazy"), KC = jt("react.block"), jt("react.scope"), YC = jt("react.opaque.id"), VW = jt("react.debug_trace_mode"), qC = jt("react.offscreen"), xR = jt("react.legacy_hidden")
}
var DM = typeof Symbol == "function" && Symbol.iterator;

function Ud(t) {
  return t === null || typeof t != "object" ? null : (t = DM && t[DM] || t["@@iterator"], typeof t == "function" ? t : null)
}
var V_;

function Eh(t) {
  if (V_ === void 0) try {
    throw Error()
  } catch (r) {
    var e = r.stack.trim().match(/\n( *(at )?)/);
    V_ = e && e[1] || ""
  }
  return `
` + V_ + t
}
var W_ = !1;

function Tm(t, e) {
  if (!t || W_) return "";
  W_ = !0;
  var r = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (e = function () {
          throw Error()
        }, Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error()
          }
        }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(e, [])
        } catch (c) {
          var n = c
        }
        Reflect.construct(t, [], e)
      } else {
        try {
          e.call()
        } catch (c) {
          n = c
        }
        t.call(e.prototype)
      }
    else {
      try {
        throw Error()
      } catch (c) {
        n = c
      }
      t()
    }
  } catch (c) {
    if (c && n && typeof c.stack == "string") {
      for (var i = c.stack.split(`
`), a = n.stack.split(`
`), s = i.length - 1, o = a.length - 1; 1 <= s && 0 <= o && i[s] !== a[o];) o--;
      for (; 1 <= s && 0 <= o; s--, o--)
        if (i[s] !== a[o]) {
          if (s !== 1 || o !== 1)
            do
              if (s--, o--, 0 > o || i[s] !== a[o]) return `
` + i[s].replace(" at new ", " at "); while (1 <= s && 0 <= o);
          break
        }
    }
  } finally {
    W_ = !1, Error.prepareStackTrace = r
  }
  return (t = t ? t.displayName || t.name : "") ? Eh(t) : ""
}

function WDe(t) {
  switch (t.tag) {
    case 5:
      return Eh(t.type);
    case 16:
      return Eh("Lazy");
    case 13:
      return Eh("Suspense");
    case 19:
      return Eh("SuspenseList");
    case 0:
    case 2:
    case 15:
      return t = Tm(t.type, !1), t;
    case 11:
      return t = Tm(t.type.render, !1), t;
    case 22:
      return t = Tm(t.type._render, !1), t;
    case 1:
      return t = Tm(t.type, !0), t;
    default:
      return ""
  }
}

function Pu(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Ks:
      return "Fragment";
    case Al:
      return "Portal";
    case Bh:
      return "Profiler";
    case zC:
      return "StrictMode";
    case Uh:
      return "Suspense";
    case jy:
      return "SuspenseList"
  }
  if (typeof t == "object") switch (t.$$typeof) {
    case VC:
      return (t.displayName || "Context") + ".Consumer";
    case GC:
      return (t._context.displayName || "Context") + ".Provider";
    case Ab:
      var e = t.render;
      return e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case Ib:
      return Pu(t.type);
    case KC:
      return Pu(t._render);
    case WC:
      e = t._payload, t = t._init;
      try {
        return Pu(t(e))
      } catch {}
  }
  return null
}

function Io(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return t;
    default:
      return ""
  }
}

function WW(t) {
  var e = t.type;
  return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function KDe(t) {
  var e = WW(t) ? "checked" : "value",
    r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    n = "" + t[e];
  if (!t.hasOwnProperty(e) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
    var i = r.get,
      a = r.set;
    return Object.defineProperty(t, e, {
      configurable: !0,
      get: function () {
        return i.call(this)
      },
      set: function (s) {
        n = "" + s, a.call(this, s)
      }
    }), Object.defineProperty(t, e, {
      enumerable: r.enumerable
    }), {
      getValue: function () {
        return n
      },
      setValue: function (s) {
        n = "" + s
      },
      stopTracking: function () {
        t._valueTracker = null, delete t[e]
      }
    }
  }
}

function wm(t) {
  t._valueTracker || (t._valueTracker = KDe(t))
}

function KW(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var r = e.getValue(),
    n = "";
  return t && (n = WW(t) ? t.checked ? "true" : "false" : t.value), t = n, t !== r ? (e.setValue(t), !0) : !1
}

function Hy(t) {
  if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
  try {
    return t.activeElement || t.body
  } catch {
    return t.body
  }
}

function bR(t, e) {
  var r = e.checked;
  return ft({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: r ? ? t._wrapperState.initialChecked
  })
}

function MM(t, e) {
  var r = e.defaultValue == null ? "" : e.defaultValue,
    n = e.checked != null ? e.checked : e.defaultChecked;
  r = Io(e.value != null ? e.value : r), t._wrapperState = {
    initialChecked: n,
    initialValue: r,
    controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
  }
}

function YW(t, e) {
  e = e.checked, e != null && HC(t, "checked", e, !1)
}

function ER(t, e) {
  YW(t, e);
  var r = Io(e.value),
    n = e.type;
  if (r != null) n === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
  else if (n === "submit" || n === "reset") {
    t.removeAttribute("value");
    return
  }
  e.hasOwnProperty("value") ? SR(t, e.type, r) : e.hasOwnProperty("defaultValue") && SR(t, e.type, Io(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function FM(t, e, r) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var n = e.type;
    if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null)) return;
    e = "" + t._wrapperState.initialValue, r || e === t.value || (t.value = e), t.defaultValue = e
  }
  r = t.name, r !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, r !== "" && (t.name = r)
}

function SR(t, e, r) {
  (e !== "number" || Hy(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}

function YDe(t) {
  var e = "";
  return Rb.Children.forEach(t, function (r) {
    r != null && (e += r)
  }), e
}

function _R(t, e) {
  return t = ft({
    children: void 0
  }, e), (e = YDe(e.children)) && (t.children = e), t
}

function Nu(t, e, r, n) {
  if (t = t.options, e) {
    e = {};
    for (var i = 0; i < r.length; i++) e["$" + r[i]] = !0;
    for (r = 0; r < t.length; r++) i = e.hasOwnProperty("$" + t[r].value), t[r].selected !== i && (t[r].selected = i), i && n && (t[r].defaultSelected = !0)
  } else {
    for (r = "" + Io(r), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === r) {
        t[i].selected = !0, n && (t[i].defaultSelected = !0);
        return
      }
      e !== null || t[i].disabled || (e = t[i])
    }
    e !== null && (e.selected = !0)
  }
}

function TR(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(te(91));
  return ft({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue
  })
}

function BM(t, e) {
  var r = e.value;
  if (r == null) {
    if (r = e.children, e = e.defaultValue, r != null) {
      if (e != null) throw Error(te(92));
      if (Array.isArray(r)) {
        if (!(1 >= r.length)) throw Error(te(93));
        r = r[0]
      }
      e = r
    }
    e == null && (e = ""), r = e
  }
  t._wrapperState = {
    initialValue: Io(r)
  }
}

function qW(t, e) {
  var r = Io(e.value),
    n = Io(e.defaultValue);
  r != null && (r = "" + r, r !== t.value && (t.value = r), e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)), n != null && (t.defaultValue = "" + n)
}

function UM(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
var wR = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg"
};

function XW(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}

function RR(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml" ? XW(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Rm, QW = function (t) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, r, n, i) {
    MSApp.execUnsafeLocalFunction(function () {
      return t(e, r, n, i)
    })
  } : t
}(function (t, e) {
  if (t.namespaceURI !== wR.svg || "innerHTML" in t) t.innerHTML = e;
  else {
    for (Rm = Rm || document.createElement("div"), Rm.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Rm.firstChild; t.firstChild;) t.removeChild(t.firstChild);
    for (; e.firstChild;) t.appendChild(e.firstChild)
  }
});

function w0(t, e) {
  if (e) {
    var r = t.firstChild;
    if (r && r === t.lastChild && r.nodeType === 3) {
      r.nodeValue = e;
      return
    }
  }
  t.textContent = e
}
var jh = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  qDe = ["Webkit", "ms", "Moz", "O"];
Object.keys(jh).forEach(function (t) {
  qDe.forEach(function (e) {
    e = e + t.charAt(0).toUpperCase() + t.substring(1), jh[e] = jh[t]
  })
});

function ZW(t, e, r) {
  return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || jh.hasOwnProperty(t) && jh[t] ? ("" + e).trim() : e + "px"
}

function JW(t, e) {
  t = t.style;
  for (var r in e)
    if (e.hasOwnProperty(r)) {
      var n = r.indexOf("--") === 0,
        i = ZW(r, e[r], n);
      r === "float" && (r = "cssFloat"), n ? t.setProperty(r, i) : t[r] = i
    }
}
var XDe = ft({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function AR(t, e) {
  if (e) {
    if (XDe[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(te(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(te(60));
      if (!(typeof e.dangerouslySetInnerHTML == "object" && "__html" in e.dangerouslySetInnerHTML)) throw Error(te(61))
    }
    if (e.style != null && typeof e.style != "object") throw Error(te(62))
  }
}

function IR(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0
  }
}

function XC(t) {
  return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var $R = null,
  Du = null,
  Mu = null;

function jM(t) {
  if (t = tg(t)) {
    if (typeof $R != "function") throw Error(te(280));
    var e = t.stateNode;
    e && (e = Pb(e), $R(t.stateNode, t.type, e))
  }
}

function eK(t) {
  Du ? Mu ? Mu.push(t) : Mu = [t] : Du = t
}

function tK() {
  if (Du) {
    var t = Du,
      e = Mu;
    if (Mu = Du = null, jM(t), e)
      for (t = 0; t < e.length; t++) jM(e[t])
  }
}

function QC(t, e) {
  return t(e)
}

function rK(t, e, r, n, i) {
  return t(e, r, n, i)
}

function ZC() {}
var nK = QC,
  Il = !1,
  K_ = !1;

function JC() {
  (Du !== null || Mu !== null) && (ZC(), tK())
}

function QDe(t, e, r) {
  if (K_) return t(e, r);
  K_ = !0;
  try {
    return nK(t, e, r)
  } finally {
    K_ = !1, JC()
  }
}

function R0(t, e) {
  var r = t.stateNode;
  if (r === null) return null;
  var n = Pb(r);
  if (n === null) return null;
  r = n[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (n = !n.disabled) || (t = t.type, n = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !n;
      break e;
    default:
      t = !1
  }
  if (t) return null;
  if (r && typeof r != "function") throw Error(te(231, e, typeof r));
  return r
}
var CR = !1;
if (us) try {
  var jd = {};
  Object.defineProperty(jd, "passive", {
    get: function () {
      CR = !0
    }
  }), window.addEventListener("test", jd, jd), window.removeEventListener("test", jd, jd)
} catch {
  CR = !1
}

function ZDe(t, e, r, n, i, a, s, o, c) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(r, l)
  } catch (u) {
    this.onError(u)
  }
}
var Hh = !1,
  zy = null,
  Gy = !1,
  kR = null,
  JDe = {
    onError: function (t) {
      Hh = !0, zy = t
    }
  };

function e3e(t, e, r, n, i, a, s, o, c) {
  Hh = !1, zy = null, ZDe.apply(JDe, arguments)
}

function t3e(t, e, r, n, i, a, s, o, c) {
  if (e3e.apply(this, arguments), Hh) {
    if (Hh) {
      var l = zy;
      Hh = !1, zy = null
    } else throw Error(te(198));
    Gy || (Gy = !0, kR = l)
  }
}

function mc(t) {
  var e = t,
    r = t;
  if (t.alternate)
    for (; e.return;) e = e.return;
  else {
    t = e;
    do e = t, e.flags & 1026 && (r = e.return), t = e.return; while (t)
  }
  return e.tag === 3 ? r : null
}

function iK(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
  }
  return null
}

function HM(t) {
  if (mc(t) !== t) throw Error(te(188))
}

function r3e(t) {
  var e = t.alternate;
  if (!e) {
    if (e = mc(t), e === null) throw Error(te(188));
    return e !== t ? null : t
  }
  for (var r = t, n = e;;) {
    var i = r.return;
    if (i === null) break;
    var a = i.alternate;
    if (a === null) {
      if (n = i.return, n !== null) {
        r = n;
        continue
      }
      break
    }
    if (i.child === a.child) {
      for (a = i.child; a;) {
        if (a === r) return HM(i), t;
        if (a === n) return HM(i), e;
        a = a.sibling
      }
      throw Error(te(188))
    }
    if (r.return !== n.return) r = i, n = a;
    else {
      for (var s = !1, o = i.child; o;) {
        if (o === r) {
          s = !0, r = i, n = a;
          break
        }
        if (o === n) {
          s = !0, n = i, r = a;
          break
        }
        o = o.sibling
      }
      if (!s) {
        for (o = a.child; o;) {
          if (o === r) {
            s = !0, r = a, n = i;
            break
          }
          if (o === n) {
            s = !0, n = a, r = i;
            break
          }
          o = o.sibling
        }
        if (!s) throw Error(te(189))
      }
    }
    if (r.alternate !== n) throw Error(te(190))
  }
  if (r.tag !== 3) throw Error(te(188));
  return r.stateNode.current === r ? t : e
}

function aK(t) {
  if (t = r3e(t), !t) return null;
  for (var e = t;;) {
    if (e.tag === 5 || e.tag === 6) return e;
    if (e.child) e.child.return = e, e = e.child;
    else {
      if (e === t) break;
      for (; !e.sibling;) {
        if (!e.return || e.return === t) return null;
        e = e.return
      }
      e.sibling.return = e.return, e = e.sibling
    }
  }
  return null
}

function zM(t, e) {
  for (var r = t.alternate; e !== null;) {
    if (e === t || e === r) return !0;
    e = e.return
  }
  return !1
}
var sK, ek, oK, lK, OR = !1,
  aa = [],
  lo = null,
  co = null,
  uo = null,
  A0 = new Map,
  I0 = new Map,
  Hd = [],
  GM = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function LR(t, e, r, n, i) {
  return {
    blockedOn: t,
    domEventName: e,
    eventSystemFlags: r | 16,
    nativeEvent: i,
    targetContainers: [n]
  }
}

function VM(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      lo = null;
      break;
    case "dragenter":
    case "dragleave":
      co = null;
      break;
    case "mouseover":
    case "mouseout":
      uo = null;
      break;
    case "pointerover":
    case "pointerout":
      A0.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      I0.delete(e.pointerId)
  }
}

function zd(t, e, r, n, i, a) {
  return t === null || t.nativeEvent !== a ? (t = LR(e, r, n, i, a), e !== null && (e = tg(e), e !== null && ek(e)), t) : (t.eventSystemFlags |= n, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
}

function n3e(t, e, r, n, i) {
  switch (e) {
    case "focusin":
      return lo = zd(lo, t, e, r, n, i), !0;
    case "dragenter":
      return co = zd(co, t, e, r, n, i), !0;
    case "mouseover":
      return uo = zd(uo, t, e, r, n, i), !0;
    case "pointerover":
      var a = i.pointerId;
      return A0.set(a, zd(A0.get(a) || null, t, e, r, n, i)), !0;
    case "gotpointercapture":
      return a = i.pointerId, I0.set(a, zd(I0.get(a) || null, t, e, r, n, i)), !0
  }
  return !1
}

function i3e(t) {
  var e = $l(t.target);
  if (e !== null) {
    var r = mc(e);
    if (r !== null) {
      if (e = r.tag, e === 13) {
        if (e = iK(r), e !== null) {
          t.blockedOn = e, lK(t.lanePriority, function () {
            Yt.unstable_runWithPriority(t.priority, function () {
              oK(r)
            })
          });
          return
        }
      } else if (e === 3 && r.stateNode.hydrate) {
        t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
        return
      }
    }
  }
  t.blockedOn = null
}

function Mv(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length;) {
    var r = ik(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (r !== null) return e = tg(r), e !== null && ek(e), t.blockedOn = r, !1;
    e.shift()
  }
  return !0
}

function WM(t, e, r) {
  Mv(t) && r.delete(e)
}

function a3e() {
  for (OR = !1; 0 < aa.length;) {
    var t = aa[0];
    if (t.blockedOn !== null) {
      t = tg(t.blockedOn), t !== null && sK(t);
      break
    }
    for (var e = t.targetContainers; 0 < e.length;) {
      var r = ik(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
      if (r !== null) {
        t.blockedOn = r;
        break
      }
      e.shift()
    }
    t.blockedOn === null && aa.shift()
  }
  lo !== null && Mv(lo) && (lo = null), co !== null && Mv(co) && (co = null), uo !== null && Mv(uo) && (uo = null), A0.forEach(WM), I0.forEach(WM)
}

function Gd(t, e) {
  t.blockedOn === e && (t.blockedOn = null, OR || (OR = !0, Yt.unstable_scheduleCallback(Yt.unstable_NormalPriority, a3e)))
}

function cK(t) {
  function e(i) {
    return Gd(i, t)
  }
  if (0 < aa.length) {
    Gd(aa[0], t);
    for (var r = 1; r < aa.length; r++) {
      var n = aa[r];
      n.blockedOn === t && (n.blockedOn = null)
    }
  }
  for (lo !== null && Gd(lo, t), co !== null && Gd(co, t), uo !== null && Gd(uo, t), A0.forEach(e), I0.forEach(e), r = 0; r < Hd.length; r++) n = Hd[r], n.blockedOn === t && (n.blockedOn = null);
  for (; 0 < Hd.length && (r = Hd[0], r.blockedOn === null);) i3e(r), r.blockedOn === null && Hd.shift()
}

function Am(t, e) {
  var r = {};
  return r[t.toLowerCase()] = e.toLowerCase(), r["Webkit" + t] = "webkit" + e, r["Moz" + t] = "moz" + e, r
}
var mu = {
    animationend: Am("Animation", "AnimationEnd"),
    animationiteration: Am("Animation", "AnimationIteration"),
    animationstart: Am("Animation", "AnimationStart"),
    transitionend: Am("Transition", "TransitionEnd")
  },
  Y_ = {},
  uK = {};
us && (uK = document.createElement("div").style, "AnimationEvent" in window || (delete mu.animationend.animation, delete mu.animationiteration.animation, delete mu.animationstart.animation), "TransitionEvent" in window || delete mu.transitionend.transition);

function $b(t) {
  if (Y_[t]) return Y_[t];
  if (!mu[t]) return t;
  var e = mu[t],
    r;
  for (r in e)
    if (e.hasOwnProperty(r) && r in uK) return Y_[t] = e[r];
  return t
}
var fK = $b("animationend"),
  dK = $b("animationiteration"),
  hK = $b("animationstart"),
  pK = $b("transitionend"),
  gK = new Map,
  tk = new Map,
  s3e = ["abort", "abort", fK, "animationEnd", dK, "animationIteration", hK, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", pK, "transitionEnd", "waiting", "waiting"];

function rk(t, e) {
  for (var r = 0; r < t.length; r += 2) {
    var n = t[r],
      i = t[r + 1];
    i = "on" + (i[0].toUpperCase() + i.slice(1)), tk.set(n, e), gK.set(n, i), pc(i, [n])
  }
}
var o3e = Yt.unstable_now;
o3e();
var tt = 8;

function su(t) {
  if (1 & t) return tt = 15, 1;
  if (2 & t) return tt = 14, 2;
  if (4 & t) return tt = 13, 4;
  var e = 24 & t;
  return e !== 0 ? (tt = 12, e) : t & 32 ? (tt = 11, 32) : (e = 192 & t, e !== 0 ? (tt = 10, e) : t & 256 ? (tt = 9, 256) : (e = 3584 & t, e !== 0 ? (tt = 8, e) : t & 4096 ? (tt = 7, 4096) : (e = 4186112 & t, e !== 0 ? (tt = 6, e) : (e = 62914560 & t, e !== 0 ? (tt = 5, e) : t & 67108864 ? (tt = 4, 67108864) : t & 134217728 ? (tt = 3, 134217728) : (e = 805306368 & t, e !== 0 ? (tt = 2, e) : 1073741824 & t ? (tt = 1, 1073741824) : (tt = 8, t))))))
}

function l3e(t) {
  switch (t) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0
  }
}

function c3e(t) {
  switch (t) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(te(358, t))
  }
}

function $0(t, e) {
  var r = t.pendingLanes;
  if (r === 0) return tt = 0;
  var n = 0,
    i = 0,
    a = t.expiredLanes,
    s = t.suspendedLanes,
    o = t.pingedLanes;
  if (a !== 0) n = a, i = tt = 15;
  else if (a = r & 134217727, a !== 0) {
    var c = a & ~s;
    c !== 0 ? (n = su(c), i = tt) : (o &= a, o !== 0 && (n = su(o), i = tt))
  } else a = r & ~s, a !== 0 ? (n = su(a), i = tt) : o !== 0 && (n = su(o), i = tt);
  if (n === 0) return 0;
  if (n = 31 - $o(n), n = r & ((0 > n ? 0 : 1 << n) << 1) - 1, e !== 0 && e !== n && !(e & s)) {
    if (su(e), i <= tt) return e;
    tt = i
  }
  if (e = t.entangledLanes, e !== 0)
    for (t = t.entanglements, e &= n; 0 < e;) r = 31 - $o(e), i = 1 << r, n |= t[r], e &= ~i;
  return n
}

function mK(t) {
  return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function Vy(t, e) {
  switch (t) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return t = ou(24 & ~e), t === 0 ? Vy(10, e) : t;
    case 10:
      return t = ou(192 & ~e), t === 0 ? Vy(8, e) : t;
    case 8:
      return t = ou(3584 & ~e), t === 0 && (t = ou(4186112 & ~e), t === 0 && (t = 512)), t;
    case 2:
      return e = ou(805306368 & ~e), e === 0 && (e = 268435456), e
  }
  throw Error(te(358, t))
}

function ou(t) {
  return t & -t
}

function q_(t) {
  for (var e = [], r = 0; 31 > r; r++) e.push(t);
  return e
}

function Cb(t, e, r) {
  t.pendingLanes |= e;
  var n = e - 1;
  t.suspendedLanes &= n, t.pingedLanes &= n, t = t.eventTimes, e = 31 - $o(e), t[e] = r
}
var $o = Math.clz32 ? Math.clz32 : d3e,
  u3e = Math.log,
  f3e = Math.LN2;

function d3e(t) {
  return t === 0 ? 32 : 31 - (u3e(t) / f3e | 0) | 0
}
var h3e = Yt.unstable_UserBlockingPriority,
  p3e = Yt.unstable_runWithPriority,
  Fv = !0;

function g3e(t, e, r, n) {
  Il || ZC();
  var i = nk,
    a = Il;
  Il = !0;
  try {
    rK(i, t, e, r, n)
  } finally {
    (Il = a) || JC()
  }
}

function m3e(t, e, r, n) {
  p3e(h3e, nk.bind(null, t, e, r, n))
}

function nk(t, e, r, n) {
  if (Fv) {
    var i;
    if ((i = (e & 4) === 0) && 0 < aa.length && -1 < GM.indexOf(t)) t = LR(null, t, e, r, n), aa.push(t);
    else {
      var a = ik(t, e, r, n);
      if (a === null) i && VM(t, n);
      else {
        if (i) {
          if (-1 < GM.indexOf(t)) {
            t = LR(a, t, e, r, n), aa.push(t);
            return
          }
          if (n3e(a, t, e, r, n)) return;
          VM(t, n)
        }
        $K(t, e, n, null, r)
      }
    }
  }
}

function ik(t, e, r, n) {
  var i = XC(n);
  if (i = $l(i), i !== null) {
    var a = mc(i);
    if (a === null) i = null;
    else {
      var s = a.tag;
      if (s === 13) {
        if (i = iK(a), i !== null) return i;
        i = null
      } else if (s === 3) {
        if (a.stateNode.hydrate) return a.tag === 3 ? a.stateNode.containerInfo : null;
        i = null
      } else a !== i && (i = null)
    }
  }
  return $K(t, e, n, i, r), null
}
var Js = null,
  ak = null,
  Bv = null;

function vK() {
  if (Bv) return Bv;
  var t, e = ak,
    r = e.length,
    n, i = "value" in Js ? Js.value : Js.textContent,
    a = i.length;
  for (t = 0; t < r && e[t] === i[t]; t++);
  var s = r - t;
  for (n = 1; n <= s && e[r - n] === i[a - n]; n++);
  return Bv = i.slice(t, 1 < n ? 1 - n : void 0)
}

function Uv(t) {
  var e = t.keyCode;
  return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function Im() {
  return !0
}

function KM() {
  return !1
}

function In(t) {
  function e(r, n, i, a, s) {
    this._reactName = r, this._targetInst = i, this.type = n, this.nativeEvent = a, this.target = s, this.currentTarget = null;
    for (var o in t) t.hasOwnProperty(o) && (r = t[o], this[o] = r ? r(a) : a[o]);
    return this.isDefaultPrevented = (a.defaultPrevented != null ? a.defaultPrevented : a.returnValue === !1) ? Im : KM, this.isPropagationStopped = KM, this
  }
  return ft(e.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var r = this.nativeEvent;
      r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = Im)
    },
    stopPropagation: function () {
      var r = this.nativeEvent;
      r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = Im)
    },
    persist: function () {},
    isPersistent: Im
  }), e
}
var Zf = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  sk = In(Zf),
  eg = ft({}, Zf, {
    view: 0,
    detail: 0
  }),
  v3e = In(eg),
  X_, Q_, Vd, kb = ft({}, eg, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ok,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function (t) {
      return "movementX" in t ? t.movementX : (t !== Vd && (Vd && t.type === "mousemove" ? (X_ = t.screenX - Vd.screenX, Q_ = t.screenY - Vd.screenY) : Q_ = X_ = 0, Vd = t), X_)
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : Q_
    }
  }),
  YM = In(kb),
  y3e = ft({}, kb, {
    dataTransfer: 0
  }),
  x3e = In(y3e),
  b3e = ft({}, eg, {
    relatedTarget: 0
  }),
  Z_ = In(b3e),
  E3e = ft({}, Zf, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  S3e = In(E3e),
  _3e = ft({}, Zf, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData
    }
  }),
  T3e = In(_3e),
  w3e = ft({}, Zf, {
    data: 0
  }),
  qM = In(w3e),
  R3e = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  A3e = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  I3e = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };

function $3e(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = I3e[t]) ? !!e[t] : !1
}

function ok() {
  return $3e
}
var C3e = ft({}, eg, {
    key: function (t) {
      if (t.key) {
        var e = R3e[t.key] || t.key;
        if (e !== "Unidentified") return e
      }
      return t.type === "keypress" ? (t = Uv(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? A3e[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ok,
    charCode: function (t) {
      return t.type === "keypress" ? Uv(t) : 0
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function (t) {
      return t.type === "keypress" ? Uv(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
  }),
  k3e = In(C3e),
  O3e = ft({}, kb, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  XM = In(O3e),
  L3e = ft({}, eg, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ok
  }),
  P3e = In(L3e),
  N3e = ft({}, Zf, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  D3e = In(N3e),
  M3e = ft({}, kb, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
    },
    deltaY: function (t) {
      return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  F3e = In(M3e),
  B3e = [9, 13, 27, 32],
  lk = us && "CompositionEvent" in window,
  zh = null;
us && "documentMode" in document && (zh = document.documentMode);
var U3e = us && "TextEvent" in window && !zh,
  yK = us && (!lk || zh && 8 < zh && 11 >= zh),
  QM = String.fromCharCode(32),
  ZM = !1;

function xK(t, e) {
  switch (t) {
    case "keyup":
      return B3e.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1
  }
}

function bK(t) {
  return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var vu = !1;

function j3e(t, e) {
  switch (t) {
    case "compositionend":
      return bK(e);
    case "keypress":
      return e.which !== 32 ? null : (ZM = !0, QM);
    case "textInput":
      return t = e.data, t === QM && ZM ? null : t;
    default:
      return null
  }
}

function H3e(t, e) {
  if (vu) return t === "compositionend" || !lk && xK(t, e) ? (t = vK(), Bv = ak = Js = null, vu = !1, t) : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which)
      }
      return null;
    case "compositionend":
      return yK && e.locale !== "ko" ? null : e.data;
    default:
      return null
  }
}
var z3e = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function JM(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!z3e[t.type] : e === "textarea"
}

function EK(t, e, r, n) {
  eK(n), e = Wy(e, "onChange"), 0 < e.length && (r = new sk("onChange", "change", null, r, n), t.push({
    event: r,
    listeners: e
  }))
}
var Gh = null,
  C0 = null;

function G3e(t) {
  RK(t, 0)
}

function Ob(t) {
  var e = xu(t);
  if (KW(e)) return t
}

function V3e(t, e) {
  if (t === "change") return e
}
var SK = !1;
if (us) {
  var J_;
  if (us) {
    var eT = "oninput" in document;
    if (!eT) {
      var eF = document.createElement("div");
      eF.setAttribute("oninput", "return;"), eT = typeof eF.oninput == "function"
    }
    J_ = eT
  } else J_ = !1;
  SK = J_ && (!document.documentMode || 9 < document.documentMode)
}

function tF() {
  Gh && (Gh.detachEvent("onpropertychange", _K), C0 = Gh = null)
}

function _K(t) {
  if (t.propertyName === "value" && Ob(C0)) {
    var e = [];
    if (EK(e, C0, t, XC(t)), t = G3e, Il) t(e);
    else {
      Il = !0;
      try {
        QC(t, e)
      } finally {
        Il = !1, JC()
      }
    }
  }
}

function W3e(t, e, r) {
  t === "focusin" ? (tF(), Gh = e, C0 = r, Gh.attachEvent("onpropertychange", _K)) : t === "focusout" && tF()
}

function K3e(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown") return Ob(C0)
}

function Y3e(t, e) {
  if (t === "click") return Ob(e)
}

function q3e(t, e) {
  if (t === "input" || t === "change") return Ob(e)
}

function X3e(t, e) {
  return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Vn = typeof Object.is == "function" ? Object.is : X3e,
  Q3e = Object.prototype.hasOwnProperty;

function k0(t, e) {
  if (Vn(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
  var r = Object.keys(t),
    n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (n = 0; n < r.length; n++)
    if (!Q3e.call(e, r[n]) || !Vn(t[r[n]], e[r[n]])) return !1;
  return !0
}

function rF(t) {
  for (; t && t.firstChild;) t = t.firstChild;
  return t
}

function nF(t, e) {
  var r = rF(t);
  t = 0;
  for (var n; r;) {
    if (r.nodeType === 3) {
      if (n = t + r.textContent.length, t <= e && n >= e) return {
        node: r,
        offset: e - t
      };
      t = n
    }
    e: {
      for (; r;) {
        if (r.nextSibling) {
          r = r.nextSibling;
          break e
        }
        r = r.parentNode
      }
      r = void 0
    }
    r = rF(r)
  }
}

function TK(t, e) {
  return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? TK(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function iF() {
  for (var t = window, e = Hy(); e instanceof t.HTMLIFrameElement;) {
    try {
      var r = typeof e.contentWindow.location.href == "string"
    } catch {
      r = !1
    }
    if (r) t = e.contentWindow;
    else break;
    e = Hy(t.document)
  }
  return e
}

function PR(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
var Z3e = us && "documentMode" in document && 11 >= document.documentMode,
  yu = null,
  NR = null,
  Vh = null,
  DR = !1;

function aF(t, e, r) {
  var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
  DR || yu == null || yu !== Hy(n) || (n = yu, "selectionStart" in n && PR(n) ? n = {
    start: n.selectionStart,
    end: n.selectionEnd
  } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = {
    anchorNode: n.anchorNode,
    anchorOffset: n.anchorOffset,
    focusNode: n.focusNode,
    focusOffset: n.focusOffset
  }), Vh && k0(Vh, n) || (Vh = n, n = Wy(NR, "onSelect"), 0 < n.length && (e = new sk("onSelect", "select", null, e, r), t.push({
    event: e,
    listeners: n
  }), e.target = yu)))
}
rk("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
rk("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
rk(s3e, 2);
for (var sF = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), tT = 0; tT < sF.length; tT++) tk.set(sF[tT], 0);
pf("onMouseEnter", ["mouseout", "mouseover"]);
pf("onMouseLeave", ["mouseout", "mouseover"]);
pf("onPointerEnter", ["pointerout", "pointerover"]);
pf("onPointerLeave", ["pointerout", "pointerover"]);
pc("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
pc("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
pc("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
pc("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
pc("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
pc("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Sh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  wK = new Set("cancel close invalid load scroll toggle".split(" ").concat(Sh));

function oF(t, e, r) {
  var n = t.type || "unknown-event";
  t.currentTarget = r, t3e(n, e, void 0, t), t.currentTarget = null
}

function RK(t, e) {
  e = (e & 4) !== 0;
  for (var r = 0; r < t.length; r++) {
    var n = t[r],
      i = n.event;
    n = n.listeners;
    e: {
      var a = void 0;
      if (e)
        for (var s = n.length - 1; 0 <= s; s--) {
          var o = n[s],
            c = o.instance,
            l = o.currentTarget;
          if (o = o.listener, c !== a && i.isPropagationStopped()) break e;
          oF(i, o, l), a = c
        } else
          for (s = 0; s < n.length; s++) {
            if (o = n[s], c = o.instance, l = o.currentTarget, o = o.listener, c !== a && i.isPropagationStopped()) break e;
            oF(i, o, l), a = c
          }
    }
  }
  if (Gy) throw t = kR, Gy = !1, kR = null, t
}

function nt(t, e) {
  var r = kK(e),
    n = t + "__bubble";
  r.has(n) || (IK(e, t, 2, !1), r.add(n))
}
var lF = "_reactListening" + Math.random().toString(36).slice(2);

function AK(t) {
  t[lF] || (t[lF] = !0, GW.forEach(function (e) {
    wK.has(e) || cF(e, !1, t, null), cF(e, !0, t, null)
  }))
}

function cF(t, e, r, n) {
  var i = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0,
    a = r;
  if (t === "selectionchange" && r.nodeType !== 9 && (a = r.ownerDocument), n !== null && !e && wK.has(t)) {
    if (t !== "scroll") return;
    i |= 2, a = n
  }
  var s = kK(a),
    o = t + "__" + (e ? "capture" : "bubble");
  s.has(o) || (e && (i |= 4), IK(a, t, i, e), s.add(o))
}

function IK(t, e, r, n) {
  var i = tk.get(e);
  switch (i === void 0 ? 2 : i) {
    case 0:
      i = g3e;
      break;
    case 1:
      i = m3e;
      break;
    default:
      i = nk
  }
  r = i.bind(null, e, r, t), i = void 0, !CR || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), n ? i !== void 0 ? t.addEventListener(e, r, {
    capture: !0,
    passive: i
  }) : t.addEventListener(e, r, !0) : i !== void 0 ? t.addEventListener(e, r, {
    passive: i
  }) : t.addEventListener(e, r, !1)
}

function $K(t, e, r, n, i) {
  var a = n;
  if (!(e & 1) && !(e & 2) && n !== null) e: for (;;) {
    if (n === null) return;
    var s = n.tag;
    if (s === 3 || s === 4) {
      var o = n.stateNode.containerInfo;
      if (o === i || o.nodeType === 8 && o.parentNode === i) break;
      if (s === 4)
        for (s = n.return; s !== null;) {
          var c = s.tag;
          if ((c === 3 || c === 4) && (c = s.stateNode.containerInfo, c === i || c.nodeType === 8 && c.parentNode === i)) return;
          s = s.return
        }
      for (; o !== null;) {
        if (s = $l(o), s === null) return;
        if (c = s.tag, c === 5 || c === 6) {
          n = a = s;
          continue e
        }
        o = o.parentNode
      }
    }
    n = n.return
  }
  QDe(function () {
    var l = a,
      u = XC(r),
      f = [];
    e: {
      var d = gK.get(t);
      if (d !== void 0) {
        var h = sk,
          p = t;
        switch (t) {
          case "keypress":
            if (Uv(r) === 0) break e;
          case "keydown":
          case "keyup":
            h = k3e;
            break;
          case "focusin":
            p = "focus", h = Z_;
            break;
          case "focusout":
            p = "blur", h = Z_;
            break;
          case "beforeblur":
          case "afterblur":
            h = Z_;
            break;
          case "click":
            if (r.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            h = YM;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            h = x3e;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            h = P3e;
            break;
          case fK:
          case dK:
          case hK:
            h = S3e;
            break;
          case pK:
            h = D3e;
            break;
          case "scroll":
            h = v3e;
            break;
          case "wheel":
            h = F3e;
            break;
          case "copy":
          case "cut":
          case "paste":
            h = T3e;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            h = XM
        }
        var v = (e & 4) !== 0,
          g = !v && t === "scroll",
          m = v ? d !== null ? d + "Capture" : null : d;
        v = [];
        for (var y = l, x; y !== null;) {
          x = y;
          var b = x.stateNode;
          if (x.tag === 5 && b !== null && (x = b, m !== null && (b = R0(y, m), b != null && v.push(O0(y, b, x)))), g) break;
          y = y.return
        }
        0 < v.length && (d = new h(d, p, null, r, u), f.push({
          event: d,
          listeners: v
        }))
      }
    }
    if (!(e & 7)) {
      e: {
        if (d = t === "mouseover" || t === "pointerover", h = t === "mouseout" || t === "pointerout", d && !(e & 16) && (p = r.relatedTarget || r.fromElement) && ($l(p) || p[Jf])) break e;
        if ((h || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window, h ? (p = r.relatedTarget || r.toElement, h = l, p = p ? $l(p) : null, p !== null && (g = mc(p), p !== g || p.tag !== 5 && p.tag !== 6) && (p = null)) : (h = null, p = l), h !== p)) {
          if (v = YM, b = "onMouseLeave", m = "onMouseEnter", y = "mouse", (t === "pointerout" || t === "pointerover") && (v = XM, b = "onPointerLeave", m = "onPointerEnter", y = "pointer"), g = h == null ? d : xu(h), x = p == null ? d : xu(p), d = new v(b, y + "leave", h, r, u), d.target = g, d.relatedTarget = x, b = null, $l(u) === l && (v = new v(m, y + "enter", p, r, u), v.target = x, v.relatedTarget = g, b = v), g = b, h && p) t: {
            for (v = h, m = p, y = 0, x = v; x; x = jc(x)) y++;
            for (x = 0, b = m; b; b = jc(b)) x++;
            for (; 0 < y - x;) v = jc(v),
            y--;
            for (; 0 < x - y;) m = jc(m),
            x--;
            for (; y--;) {
              if (v === m || m !== null && v === m.alternate) break t;
              v = jc(v), m = jc(m)
            }
            v = null
          }
          else v = null;
          h !== null && uF(f, d, h, v, !1), p !== null && g !== null && uF(f, g, p, v, !0)
        }
      }
      e: {
        if (d = l ? xu(l) : window, h = d.nodeName && d.nodeName.toLowerCase(), h === "select" || h === "input" && d.type === "file") var _ = V3e;
        else if (JM(d))
          if (SK) _ = q3e;
          else {
            _ = K3e;
            var S = W3e
          }
        else(h = d.nodeName) && h.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (_ = Y3e);
        if (_ && (_ = _(t, l))) {
          EK(f, _, r, u);
          break e
        }
        S && S(t, d, l),
        t === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && SR(d, "number", d.value)
      }
      switch (S = l ? xu(l) : window, t) {
        case "focusin":
          (JM(S) || S.contentEditable === "true") && (yu = S, NR = l, Vh = null);
          break;
        case "focusout":
          Vh = NR = yu = null;
          break;
        case "mousedown":
          DR = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          DR = !1, aF(f, r, u);
          break;
        case "selectionchange":
          if (Z3e) break;
        case "keydown":
        case "keyup":
          aF(f, r, u)
      }
      var T;
      if (lk) e: {
        switch (t) {
          case "compositionstart":
            var R = "onCompositionStart";
            break e;
          case "compositionend":
            R = "onCompositionEnd";
            break e;
          case "compositionupdate":
            R = "onCompositionUpdate";
            break e
        }
        R = void 0
      }
      else vu ? xK(t, r) && (R = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (R = "onCompositionStart");R && (yK && r.locale !== "ko" && (vu || R !== "onCompositionStart" ? R === "onCompositionEnd" && vu && (T = vK()) : (Js = u, ak = "value" in Js ? Js.value : Js.textContent, vu = !0)), S = Wy(l, R), 0 < S.length && (R = new qM(R, t, null, r, u), f.push({
        event: R,
        listeners: S
      }), T ? R.data = T : (T = bK(r), T !== null && (R.data = T)))),
      (T = U3e ? j3e(t, r) : H3e(t, r)) && (l = Wy(l, "onBeforeInput"), 0 < l.length && (u = new qM("onBeforeInput", "beforeinput", null, r, u), f.push({
        event: u,
        listeners: l
      }), u.data = T))
    }
    RK(f, e)
  })
}

function O0(t, e, r) {
  return {
    instance: t,
    listener: e,
    currentTarget: r
  }
}

function Wy(t, e) {
  for (var r = e + "Capture", n = []; t !== null;) {
    var i = t,
      a = i.stateNode;
    i.tag === 5 && a !== null && (i = a, a = R0(t, r), a != null && n.unshift(O0(t, a, i)), a = R0(t, e), a != null && n.push(O0(t, a, i))), t = t.return
  }
  return n
}

function jc(t) {
  if (t === null) return null;
  do t = t.return; while (t && t.tag !== 5);
  return t || null
}

function uF(t, e, r, n, i) {
  for (var a = e._reactName, s = []; r !== null && r !== n;) {
    var o = r,
      c = o.alternate,
      l = o.stateNode;
    if (c !== null && c === n) break;
    o.tag === 5 && l !== null && (o = l, i ? (c = R0(r, a), c != null && s.unshift(O0(r, c, o))) : i || (c = R0(r, a), c != null && s.push(O0(r, c, o)))), r = r.return
  }
  s.length !== 0 && t.push({
    event: e,
    listeners: s
  })
}

function Ky() {}
var rT = null,
  nT = null;

function CK(t, e) {
  switch (t) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!e.autoFocus
  }
  return !1
}

function MR(t, e) {
  return t === "textarea" || t === "option" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var fF = typeof setTimeout == "function" ? setTimeout : void 0,
  J3e = typeof clearTimeout == "function" ? clearTimeout : void 0;

function ck(t) {
  t.nodeType === 1 ? t.textContent = "" : t.nodeType === 9 && (t = t.body, t != null && (t.textContent = ""))
}

function Fu(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break
  }
  return t
}

function dF(t) {
  t = t.previousSibling;
  for (var e = 0; t;) {
    if (t.nodeType === 8) {
      var r = t.data;
      if (r === "$" || r === "$!" || r === "$?") {
        if (e === 0) return t;
        e--
      } else r === "/$" && e++
    }
    t = t.previousSibling
  }
  return null
}
var iT = 0;

function e4e(t) {
  return {
    $$typeof: YC,
    toString: t,
    valueOf: t
  }
}
var Lb = Math.random().toString(36).slice(2),
  eo = "__reactFiber$" + Lb,
  Yy = "__reactProps$" + Lb,
  Jf = "__reactContainer$" + Lb,
  hF = "__reactEvents$" + Lb;

function $l(t) {
  var e = t[eo];
  if (e) return e;
  for (var r = t.parentNode; r;) {
    if (e = r[Jf] || r[eo]) {
      if (r = e.alternate, e.child !== null || r !== null && r.child !== null)
        for (t = dF(t); t !== null;) {
          if (r = t[eo]) return r;
          t = dF(t)
        }
      return e
    }
    t = r, r = t.parentNode
  }
  return null
}

function tg(t) {
  return t = t[eo] || t[Jf], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function xu(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(te(33))
}

function Pb(t) {
  return t[Yy] || null
}

function kK(t) {
  var e = t[hF];
  return e === void 0 && (e = t[hF] = new Set), e
}
var FR = [],
  bu = -1;

function Ko(t) {
  return {
    current: t
  }
}

function at(t) {
  0 > bu || (t.current = FR[bu], FR[bu] = null, bu--)
}

function St(t, e) {
  bu++, FR[bu] = t.current, t.current = e
}
var Co = {},
  xr = Ko(Co),
  en = Ko(!1),
  Xl = Co;

function gf(t, e) {
  var r = t.type.contextTypes;
  if (!r) return Co;
  var n = t.stateNode;
  if (n && n.__reactInternalMemoizedUnmaskedChildContext === e) return n.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    a;
  for (a in r) i[a] = e[a];
  return n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
}

function tn(t) {
  return t = t.childContextTypes, t != null
}

function qy() {
  at(en), at(xr)
}

function pF(t, e, r) {
  if (xr.current !== Co) throw Error(te(168));
  St(xr, e), St(en, r)
}

function OK(t, e, r) {
  var n = t.stateNode;
  if (t = e.childContextTypes, typeof n.getChildContext != "function") return r;
  n = n.getChildContext();
  for (var i in n)
    if (!(i in t)) throw Error(te(108, Pu(e) || "Unknown", i));
  return ft({}, r, n)
}

function jv(t) {
  return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Co, Xl = xr.current, St(xr, t), St(en, en.current), !0
}

function gF(t, e, r) {
  var n = t.stateNode;
  if (!n) throw Error(te(169));
  r ? (t = OK(t, e, Xl), n.__reactInternalMemoizedMergedChildContext = t, at(en), at(xr), St(xr, t)) : at(en), St(en, r)
}
var uk = null,
  Bl = null,
  t4e = Yt.unstable_runWithPriority,
  fk = Yt.unstable_scheduleCallback,
  BR = Yt.unstable_cancelCallback,
  r4e = Yt.unstable_shouldYield,
  mF = Yt.unstable_requestPaint,
  UR = Yt.unstable_now,
  n4e = Yt.unstable_getCurrentPriorityLevel,
  Nb = Yt.unstable_ImmediatePriority,
  LK = Yt.unstable_UserBlockingPriority,
  PK = Yt.unstable_NormalPriority,
  NK = Yt.unstable_LowPriority,
  DK = Yt.unstable_IdlePriority,
  aT = {},
  i4e = mF !== void 0 ? mF : function () {},
  Ga = null,
  Hv = null,
  sT = !1,
  vF = UR(),
  gr = 1e4 > vF ? UR : function () {
    return UR() - vF
  };

function mf() {
  switch (n4e()) {
    case Nb:
      return 99;
    case LK:
      return 98;
    case PK:
      return 97;
    case NK:
      return 96;
    case DK:
      return 95;
    default:
      throw Error(te(332))
  }
}

function MK(t) {
  switch (t) {
    case 99:
      return Nb;
    case 98:
      return LK;
    case 97:
      return PK;
    case 96:
      return NK;
    case 95:
      return DK;
    default:
      throw Error(te(332))
  }
}

function Ql(t, e) {
  return t = MK(t), t4e(t, e)
}

function L0(t, e, r) {
  return t = MK(t), fk(t, e, r)
}

function Ra() {
  if (Hv !== null) {
    var t = Hv;
    Hv = null, BR(t)
  }
  FK()
}

function FK() {
  if (!sT && Ga !== null) {
    sT = !0;
    var t = 0;
    try {
      var e = Ga;
      Ql(99, function () {
        for (; t < e.length; t++) {
          var r = e[t];
          do r = r(!0); while (r !== null)
        }
      }), Ga = null
    } catch (r) {
      throw Ga !== null && (Ga = Ga.slice(t + 1)), fk(Nb, Ra), r
    } finally {
      sT = !1
    }
  }
}
var a4e = gc.ReactCurrentBatchConfig;

function xi(t, e) {
  if (t && t.defaultProps) {
    e = ft({}, e), t = t.defaultProps;
    for (var r in t) e[r] === void 0 && (e[r] = t[r]);
    return e
  }
  return e
}
var Xy = Ko(null),
  Qy = null,
  Eu = null,
  Zy = null;

function dk() {
  Zy = Eu = Qy = null
}

function hk(t) {
  var e = Xy.current;
  at(Xy), t.type._context._currentValue = e
}

function BK(t, e) {
  for (; t !== null;) {
    var r = t.alternate;
    if ((t.childLanes & e) === e) {
      if (r === null || (r.childLanes & e) === e) break;
      r.childLanes |= e
    } else t.childLanes |= e, r !== null && (r.childLanes |= e);
    t = t.return
  }
}

function Bu(t, e) {
  Qy = t, Zy = Eu = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Ri = !0), t.firstContext = null)
}

function Qn(t, e) {
  if (Zy !== t && e !== !1 && e !== 0)
    if ((typeof e != "number" || e === 1073741823) && (Zy = t, e = 1073741823), e = {
        context: t,
        observedBits: e,
        next: null
      }, Eu === null) {
      if (Qy === null) throw Error(te(308));
      Eu = e, Qy.dependencies = {
        lanes: 0,
        firstContext: e,
        responders: null
      }
    } else Eu = Eu.next = e;
  return t._currentValue
}
var js = !1;

function pk(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  }
}

function UK(t, e) {
  t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
    baseState: t.baseState,
    firstBaseUpdate: t.firstBaseUpdate,
    lastBaseUpdate: t.lastBaseUpdate,
    shared: t.shared,
    effects: t.effects
  })
}

function fo(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  }
}

function ho(t, e) {
  if (t = t.updateQueue, t !== null) {
    t = t.shared;
    var r = t.pending;
    r === null ? e.next = e : (e.next = r.next, r.next = e), t.pending = e
  }
}

function yF(t, e) {
  var r = t.updateQueue,
    n = t.alternate;
  if (n !== null && (n = n.updateQueue, r === n)) {
    var i = null,
      a = null;
    if (r = r.firstBaseUpdate, r !== null) {
      do {
        var s = {
          eventTime: r.eventTime,
          lane: r.lane,
          tag: r.tag,
          payload: r.payload,
          callback: r.callback,
          next: null
        };
        a === null ? i = a = s : a = a.next = s, r = r.next
      } while (r !== null);
      a === null ? i = a = e : a = a.next = e
    } else i = a = e;
    r = {
      baseState: n.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: a,
      shared: n.shared,
      effects: n.effects
    }, t.updateQueue = r;
    return
  }
  t = r.lastBaseUpdate, t === null ? r.firstBaseUpdate = e : t.next = e, r.lastBaseUpdate = e
}

function P0(t, e, r, n) {
  var i = t.updateQueue;
  js = !1;
  var a = i.firstBaseUpdate,
    s = i.lastBaseUpdate,
    o = i.shared.pending;
  if (o !== null) {
    i.shared.pending = null;
    var c = o,
      l = c.next;
    c.next = null, s === null ? a = l : s.next = l, s = c;
    var u = t.alternate;
    if (u !== null) {
      u = u.updateQueue;
      var f = u.lastBaseUpdate;
      f !== s && (f === null ? u.firstBaseUpdate = l : f.next = l, u.lastBaseUpdate = c)
    }
  }
  if (a !== null) {
    f = i.baseState, s = 0, u = l = c = null;
    do {
      o = a.lane;
      var d = a.eventTime;
      if ((n & o) === o) {
        u !== null && (u = u.next = {
          eventTime: d,
          lane: 0,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        });
        e: {
          var h = t,
            p = a;
          switch (o = e, d = r, p.tag) {
            case 1:
              if (h = p.payload, typeof h == "function") {
                f = h.call(d, f, o);
                break e
              }
              f = h;
              break e;
            case 3:
              h.flags = h.flags & -4097 | 64;
            case 0:
              if (h = p.payload, o = typeof h == "function" ? h.call(d, f, o) : h, o == null) break e;
              f = ft({}, f, o);
              break e;
            case 2:
              js = !0
          }
        }
        a.callback !== null && (t.flags |= 32, o = i.effects, o === null ? i.effects = [a] : o.push(a))
      } else d = {
        eventTime: d,
        lane: o,
        tag: a.tag,
        payload: a.payload,
        callback: a.callback,
        next: null
      }, u === null ? (l = u = d, c = f) : u = u.next = d, s |= o;
      if (a = a.next, a === null) {
        if (o = i.shared.pending, o === null) break;
        a = o.next, o.next = null, i.lastBaseUpdate = o, i.shared.pending = null
      }
    } while (1);
    u === null && (c = f), i.baseState = c, i.firstBaseUpdate = l, i.lastBaseUpdate = u, ng |= s, t.lanes = s, t.memoizedState = f
  }
}

function xF(t, e, r) {
  if (t = e.effects, e.effects = null, t !== null)
    for (e = 0; e < t.length; e++) {
      var n = t[e],
        i = n.callback;
      if (i !== null) {
        if (n.callback = null, n = r, typeof i != "function") throw Error(te(191, i));
        i.call(n)
      }
    }
}
var jK = new Rb.Component().refs;

function Jy(t, e, r, n) {
  e = t.memoizedState, r = r(n, e), r = r == null ? e : ft({}, e, r), t.memoizedState = r, t.lanes === 0 && (t.updateQueue.baseState = r)
}
var Db = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? mc(t) === t : !1
  },
  enqueueSetState: function (t, e, r) {
    t = t._reactInternals;
    var n = _n(),
      i = po(t),
      a = fo(n, i);
    a.payload = e, r != null && (a.callback = r), ho(t, a), go(t, i, n)
  },
  enqueueReplaceState: function (t, e, r) {
    t = t._reactInternals;
    var n = _n(),
      i = po(t),
      a = fo(n, i);
    a.tag = 1, a.payload = e, r != null && (a.callback = r), ho(t, a), go(t, i, n)
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var r = _n(),
      n = po(t),
      i = fo(r, n);
    i.tag = 2, e != null && (i.callback = e), ho(t, i), go(t, n, r)
  }
};

function bF(t, e, r, n, i, a, s) {
  return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, a, s) : e.prototype && e.prototype.isPureReactComponent ? !k0(r, n) || !k0(i, a) : !0
}

function HK(t, e, r) {
  var n = !1,
    i = Co,
    a = e.contextType;
  return typeof a == "object" && a !== null ? a = Qn(a) : (i = tn(e) ? Xl : xr.current, n = e.contextTypes, a = (n = n != null) ? gf(t, i) : Co), e = new e(r, a), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Db, t.stateNode = e, e._reactInternals = t, n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = a), e
}

function EF(t, e, r, n) {
  t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, n), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, n), e.state !== t && Db.enqueueReplaceState(e, e.state, null)
}

function jR(t, e, r, n) {
  var i = t.stateNode;
  i.props = r, i.state = t.memoizedState, i.refs = jK, pk(t);
  var a = e.contextType;
  typeof a == "object" && a !== null ? i.context = Qn(a) : (a = tn(e) ? Xl : xr.current, i.context = gf(t, a)), P0(t, r, i, n), i.state = t.memoizedState, a = e.getDerivedStateFromProps, typeof a == "function" && (Jy(t, e, a, r), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Db.enqueueReplaceState(i, i.state, null), P0(t, r, i, n), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4)
}
var $m = Array.isArray;

function Wd(t, e, r) {
  if (t = r.ref, t !== null && typeof t != "function" && typeof t != "object") {
    if (r._owner) {
      if (r = r._owner, r) {
        if (r.tag !== 1) throw Error(te(309));
        var n = r.stateNode
      }
      if (!n) throw Error(te(147, t));
      var i = "" + t;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function (a) {
        var s = n.refs;
        s === jK && (s = n.refs = {}), a === null ? delete s[i] : s[i] = a
      }, e._stringRef = i, e)
    }
    if (typeof t != "string") throw Error(te(284));
    if (!r._owner) throw Error(te(290, t))
  }
  return t
}

function Cm(t, e) {
  if (t.type !== "textarea") throw Error(te(31, Object.prototype.toString.call(e) === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : e))
}

function zK(t) {
  function e(g, m) {
    if (t) {
      var y = g.lastEffect;
      y !== null ? (y.nextEffect = m, g.lastEffect = m) : g.firstEffect = g.lastEffect = m, m.nextEffect = null, m.flags = 8
    }
  }

  function r(g, m) {
    if (!t) return null;
    for (; m !== null;) e(g, m), m = m.sibling;
    return null
  }

  function n(g, m) {
    for (g = new Map; m !== null;) m.key !== null ? g.set(m.key, m) : g.set(m.index, m), m = m.sibling;
    return g
  }

  function i(g, m) {
    return g = Oo(g, m), g.index = 0, g.sibling = null, g
  }

  function a(g, m, y) {
    return g.index = y, t ? (y = g.alternate, y !== null ? (y = y.index, y < m ? (g.flags = 2, m) : y) : (g.flags = 2, m)) : m
  }

  function s(g) {
    return t && g.alternate === null && (g.flags = 2), g
  }

  function o(g, m, y, x) {
    return m === null || m.tag !== 6 ? (m = fT(y, g.mode, x), m.return = g, m) : (m = i(m, y), m.return = g, m)
  }

  function c(g, m, y, x) {
    return m !== null && m.elementType === y.type ? (x = i(m, y.props), x.ref = Wd(g, m, y), x.return = g, x) : (x = Wv(y.type, y.key, y.props, null, g.mode, x), x.ref = Wd(g, m, y), x.return = g, x)
  }

  function l(g, m, y, x) {
    return m === null || m.tag !== 4 || m.stateNode.containerInfo !== y.containerInfo || m.stateNode.implementation !== y.implementation ? (m = dT(y, g.mode, x), m.return = g, m) : (m = i(m, y.children || []), m.return = g, m)
  }

  function u(g, m, y, x, b) {
    return m === null || m.tag !== 7 ? (m = zu(y, g.mode, x, b), m.return = g, m) : (m = i(m, y), m.return = g, m)
  }

  function f(g, m, y) {
    if (typeof m == "string" || typeof m == "number") return m = fT("" + m, g.mode, y), m.return = g, m;
    if (typeof m == "object" && m !== null) {
      switch (m.$$typeof) {
        case bh:
          return y = Wv(m.type, m.key, m.props, null, g.mode, y), y.ref = Wd(g, null, m), y.return = g, y;
        case Al:
          return m = dT(m, g.mode, y), m.return = g, m
      }
      if ($m(m) || Ud(m)) return m = zu(m, g.mode, y, null), m.return = g, m;
      Cm(g, m)
    }
    return null
  }

  function d(g, m, y, x) {
    var b = m !== null ? m.key : null;
    if (typeof y == "string" || typeof y == "number") return b !== null ? null : o(g, m, "" + y, x);
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case bh:
          return y.key === b ? y.type === Ks ? u(g, m, y.props.children, x, b) : c(g, m, y, x) : null;
        case Al:
          return y.key === b ? l(g, m, y, x) : null
      }
      if ($m(y) || Ud(y)) return b !== null ? null : u(g, m, y, x, null);
      Cm(g, y)
    }
    return null
  }

  function h(g, m, y, x, b) {
    if (typeof x == "string" || typeof x == "number") return g = g.get(y) || null, o(m, g, "" + x, b);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case bh:
          return g = g.get(x.key === null ? y : x.key) || null, x.type === Ks ? u(m, g, x.props.children, b, x.key) : c(m, g, x, b);
        case Al:
          return g = g.get(x.key === null ? y : x.key) || null, l(m, g, x, b)
      }
      if ($m(x) || Ud(x)) return g = g.get(y) || null, u(m, g, x, b, null);
      Cm(m, x)
    }
    return null
  }

  function p(g, m, y, x) {
    for (var b = null, _ = null, S = m, T = m = 0, R = null; S !== null && T < y.length; T++) {
      S.index > T ? (R = S, S = null) : R = S.sibling;
      var I = d(g, S, y[T], x);
      if (I === null) {
        S === null && (S = R);
        break
      }
      t && S && I.alternate === null && e(g, S), m = a(I, m, T), _ === null ? b = I : _.sibling = I, _ = I, S = R
    }
    if (T === y.length) return r(g, S), b;
    if (S === null) {
      for (; T < y.length; T++) S = f(g, y[T], x), S !== null && (m = a(S, m, T), _ === null ? b = S : _.sibling = S, _ = S);
      return b
    }
    for (S = n(g, S); T < y.length; T++) R = h(S, g, T, y[T], x), R !== null && (t && R.alternate !== null && S.delete(R.key === null ? T : R.key), m = a(R, m, T), _ === null ? b = R : _.sibling = R, _ = R);
    return t && S.forEach(function (w) {
      return e(g, w)
    }), b
  }

  function v(g, m, y, x) {
    var b = Ud(y);
    if (typeof b != "function") throw Error(te(150));
    if (y = b.call(y), y == null) throw Error(te(151));
    for (var _ = b = null, S = m, T = m = 0, R = null, I = y.next(); S !== null && !I.done; T++, I = y.next()) {
      S.index > T ? (R = S, S = null) : R = S.sibling;
      var w = d(g, S, I.value, x);
      if (w === null) {
        S === null && (S = R);
        break
      }
      t && S && w.alternate === null && e(g, S), m = a(w, m, T), _ === null ? b = w : _.sibling = w, _ = w, S = R
    }
    if (I.done) return r(g, S), b;
    if (S === null) {
      for (; !I.done; T++, I = y.next()) I = f(g, I.value, x), I !== null && (m = a(I, m, T), _ === null ? b = I : _.sibling = I, _ = I);
      return b
    }
    for (S = n(g, S); !I.done; T++, I = y.next()) I = h(S, g, T, I.value, x), I !== null && (t && I.alternate !== null && S.delete(I.key === null ? T : I.key), m = a(I, m, T), _ === null ? b = I : _.sibling = I, _ = I);
    return t && S.forEach(function (C) {
      return e(g, C)
    }), b
  }
  return function (g, m, y, x) {
    var b = typeof y == "object" && y !== null && y.type === Ks && y.key === null;
    b && (y = y.props.children);
    var _ = typeof y == "object" && y !== null;
    if (_) switch (y.$$typeof) {
      case bh:
        e: {
          for (_ = y.key, b = m; b !== null;) {
            if (b.key === _) {
              switch (b.tag) {
                case 7:
                  if (y.type === Ks) {
                    r(g, b.sibling), m = i(b, y.props.children), m.return = g, g = m;
                    break e
                  }
                  break;
                default:
                  if (b.elementType === y.type) {
                    r(g, b.sibling), m = i(b, y.props), m.ref = Wd(g, b, y), m.return = g, g = m;
                    break e
                  }
              }
              r(g, b);
              break
            } else e(g, b);
            b = b.sibling
          }
          y.type === Ks ? (m = zu(y.props.children, g.mode, x, y.key), m.return = g, g = m) : (x = Wv(y.type, y.key, y.props, null, g.mode, x), x.ref = Wd(g, m, y), x.return = g, g = x)
        }
        return s(g);
      case Al:
        e: {
          for (b = y.key; m !== null;) {
            if (m.key === b)
              if (m.tag === 4 && m.stateNode.containerInfo === y.containerInfo && m.stateNode.implementation === y.implementation) {
                r(g, m.sibling), m = i(m, y.children || []), m.return = g, g = m;
                break e
              } else {
                r(g, m);
                break
              }
            else e(g, m);
            m = m.sibling
          }
          m = dT(y, g.mode, x),
          m.return = g,
          g = m
        }
        return s(g)
    }
    if (typeof y == "string" || typeof y == "number") return y = "" + y, m !== null && m.tag === 6 ? (r(g, m.sibling), m = i(m, y), m.return = g, g = m) : (r(g, m), m = fT(y, g.mode, x), m.return = g, g = m), s(g);
    if ($m(y)) return p(g, m, y, x);
    if (Ud(y)) return v(g, m, y, x);
    if (_ && Cm(g, y), typeof y > "u" && !b) switch (g.tag) {
      case 1:
      case 22:
      case 0:
      case 11:
      case 15:
        throw Error(te(152, Pu(g.type) || "Component"))
    }
    return r(g, m)
  }
}
var e1 = zK(!0),
  GK = zK(!1),
  rg = {},
  ca = Ko(rg),
  N0 = Ko(rg),
  D0 = Ko(rg);

function Cl(t) {
  if (t === rg) throw Error(te(174));
  return t
}

function HR(t, e) {
  switch (St(D0, e), St(N0, t), St(ca, rg), t = e.nodeType, t) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : RR(null, "");
      break;
    default:
      t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = RR(e, t)
  }
  at(ca), St(ca, e)
}

function vf() {
  at(ca), at(N0), at(D0)
}

function SF(t) {
  Cl(D0.current);
  var e = Cl(ca.current),
    r = RR(e, t.type);
  e !== r && (St(N0, t), St(ca, r))
}

function gk(t) {
  N0.current === t && (at(ca), at(N0))
}
var Et = Ko(0);

function t1(t) {
  for (var e = t; e !== null;) {
    if (e.tag === 13) {
      var r = e.memoizedState;
      if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return e
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 64) return e
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue
    }
    if (e === t) break;
    for (; e.sibling === null;) {
      if (e.return === null || e.return === t) return null;
      e = e.return
    }
    e.sibling.return = e.return, e = e.sibling
  }
  return null
}
var Ya = null,
  to = null,
  ua = !1;

function VK(t, e) {
  var r = Wn(5, null, null, 0);
  r.elementType = "DELETED", r.type = "DELETED", r.stateNode = e, r.return = t, r.flags = 8, t.lastEffect !== null ? (t.lastEffect.nextEffect = r, t.lastEffect = r) : t.firstEffect = t.lastEffect = r
}

function _F(t, e) {
  switch (t.tag) {
    case 5:
      var r = t.type;
      return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, !0) : !1;
    case 6:
      return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, !0) : !1;
    case 13:
      return !1;
    default:
      return !1
  }
}

function zR(t) {
  if (ua) {
    var e = to;
    if (e) {
      var r = e;
      if (!_F(t, e)) {
        if (e = Fu(r.nextSibling), !e || !_F(t, e)) {
          t.flags = t.flags & -1025 | 2, ua = !1, Ya = t;
          return
        }
        VK(Ya, r)
      }
      Ya = t, to = Fu(e.firstChild)
    } else t.flags = t.flags & -1025 | 2, ua = !1, Ya = t
  }
}

function TF(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
  Ya = t
}

function km(t) {
  if (t !== Ya) return !1;
  if (!ua) return TF(t), ua = !0, !1;
  var e = t.type;
  if (t.tag !== 5 || e !== "head" && e !== "body" && !MR(e, t.memoizedProps))
    for (e = to; e;) VK(t, e), e = Fu(e.nextSibling);
  if (TF(t), t.tag === 13) {
    if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(te(317));
    e: {
      for (t = t.nextSibling, e = 0; t;) {
        if (t.nodeType === 8) {
          var r = t.data;
          if (r === "/$") {
            if (e === 0) {
              to = Fu(t.nextSibling);
              break e
            }
            e--
          } else r !== "$" && r !== "$!" && r !== "$?" || e++
        }
        t = t.nextSibling
      }
      to = null
    }
  } else to = Ya ? Fu(t.stateNode.nextSibling) : null;
  return !0
}

function oT() {
  to = Ya = null, ua = !1
}
var Uu = [];

function mk() {
  for (var t = 0; t < Uu.length; t++) Uu[t]._workInProgressVersionPrimary = null;
  Uu.length = 0
}
var Wh = gc.ReactCurrentDispatcher,
  Xn = gc.ReactCurrentBatchConfig,
  M0 = 0,
  At = null,
  hr = null,
  er = null,
  r1 = !1,
  Kh = !1;

function Mr() {
  throw Error(te(321))
}

function vk(t, e) {
  if (e === null) return !1;
  for (var r = 0; r < e.length && r < t.length; r++)
    if (!Vn(t[r], e[r])) return !1;
  return !0
}

function yk(t, e, r, n, i, a) {
  if (M0 = a, At = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Wh.current = t === null || t.memoizedState === null ? o4e : l4e, t = r(n, i), Kh) {
    a = 0;
    do {
      if (Kh = !1, !(25 > a)) throw Error(te(301));
      a += 1, er = hr = null, e.updateQueue = null, Wh.current = c4e, t = r(n, i)
    } while (Kh)
  }
  if (Wh.current = s1, e = hr !== null && hr.next !== null, M0 = 0, er = hr = At = null, r1 = !1, e) throw Error(te(300));
  return t
}

function kl() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  return er === null ? At.memoizedState = er = t : er = er.next = t, er
}

function vc() {
  if (hr === null) {
    var t = At.alternate;
    t = t !== null ? t.memoizedState : null
  } else t = hr.next;
  var e = er === null ? At.memoizedState : er.next;
  if (e !== null) er = e, hr = t;
  else {
    if (t === null) throw Error(te(310));
    hr = t, t = {
      memoizedState: hr.memoizedState,
      baseState: hr.baseState,
      baseQueue: hr.baseQueue,
      queue: hr.queue,
      next: null
    }, er === null ? At.memoizedState = er = t : er = er.next = t
  }
  return er
}

function sa(t, e) {
  return typeof e == "function" ? e(t) : e
}

function Kd(t) {
  var e = vc(),
    r = e.queue;
  if (r === null) throw Error(te(311));
  r.lastRenderedReducer = t;
  var n = hr,
    i = n.baseQueue,
    a = r.pending;
  if (a !== null) {
    if (i !== null) {
      var s = i.next;
      i.next = a.next, a.next = s
    }
    n.baseQueue = i = a, r.pending = null
  }
  if (i !== null) {
    i = i.next, n = n.baseState;
    var o = s = a = null,
      c = i;
    do {
      var l = c.lane;
      if ((M0 & l) === l) o !== null && (o = o.next = {
        lane: 0,
        action: c.action,
        eagerReducer: c.eagerReducer,
        eagerState: c.eagerState,
        next: null
      }), n = c.eagerReducer === t ? c.eagerState : t(n, c.action);
      else {
        var u = {
          lane: l,
          action: c.action,
          eagerReducer: c.eagerReducer,
          eagerState: c.eagerState,
          next: null
        };
        o === null ? (s = o = u, a = n) : o = o.next = u, At.lanes |= l, ng |= l
      }
      c = c.next
    } while (c !== null && c !== i);
    o === null ? a = n : o.next = s, Vn(n, e.memoizedState) || (Ri = !0), e.memoizedState = n, e.baseState = a, e.baseQueue = o, r.lastRenderedState = n
  }
  return [e.memoizedState, r.dispatch]
}

function Yd(t) {
  var e = vc(),
    r = e.queue;
  if (r === null) throw Error(te(311));
  r.lastRenderedReducer = t;
  var n = r.dispatch,
    i = r.pending,
    a = e.memoizedState;
  if (i !== null) {
    r.pending = null;
    var s = i = i.next;
    do a = t(a, s.action), s = s.next; while (s !== i);
    Vn(a, e.memoizedState) || (Ri = !0), e.memoizedState = a, e.baseQueue === null && (e.baseState = a), r.lastRenderedState = a
  }
  return [a, n]
}

function wF(t, e, r) {
  var n = e._getVersion;
  n = n(e._source);
  var i = e._workInProgressVersionPrimary;
  if (i !== null ? t = i === n : (t = t.mutableReadLanes, (t = (M0 & t) === t) && (e._workInProgressVersionPrimary = n, Uu.push(e))), t) return r(e._source);
  throw Uu.push(e), Error(te(350))
}

function WK(t, e, r, n) {
  var i = $r;
  if (i === null) throw Error(te(349));
  var a = e._getVersion,
    s = a(e._source),
    o = Wh.current,
    c = o.useState(function () {
      return wF(i, e, r)
    }),
    l = c[1],
    u = c[0];
  c = er;
  var f = t.memoizedState,
    d = f.refs,
    h = d.getSnapshot,
    p = f.source;
  f = f.subscribe;
  var v = At;
  return t.memoizedState = {
    refs: d,
    source: e,
    subscribe: n
  }, o.useEffect(function () {
    d.getSnapshot = r, d.setSnapshot = l;
    var g = a(e._source);
    if (!Vn(s, g)) {
      g = r(e._source), Vn(u, g) || (l(g), g = po(v), i.mutableReadLanes |= g & i.pendingLanes), g = i.mutableReadLanes, i.entangledLanes |= g;
      for (var m = i.entanglements, y = g; 0 < y;) {
        var x = 31 - $o(y),
          b = 1 << x;
        m[x] |= g, y &= ~b
      }
    }
  }, [r, e, n]), o.useEffect(function () {
    return n(e._source, function () {
      var g = d.getSnapshot,
        m = d.setSnapshot;
      try {
        m(g(e._source));
        var y = po(v);
        i.mutableReadLanes |= y & i.pendingLanes
      } catch (x) {
        m(function () {
          throw x
        })
      }
    })
  }, [e, n]), Vn(h, r) && Vn(p, e) && Vn(f, n) || (t = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: sa,
    lastRenderedState: u
  }, t.dispatch = l = Ek.bind(null, At, t), c.queue = t, c.baseQueue = null, u = wF(i, e, r), c.memoizedState = c.baseState = u), u
}

function KK(t, e, r) {
  var n = vc();
  return WK(n, t, e, r)
}

function qd(t) {
  var e = kl();
  return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = e.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: sa,
    lastRenderedState: t
  }, t = t.dispatch = Ek.bind(null, At, t), [e.memoizedState, t]
}

function n1(t, e, r, n) {
  return t = {
    tag: t,
    create: e,
    destroy: r,
    deps: n,
    next: null
  }, e = At.updateQueue, e === null ? (e = {
    lastEffect: null
  }, At.updateQueue = e, e.lastEffect = t.next = t) : (r = e.lastEffect, r === null ? e.lastEffect = t.next = t : (n = r.next, r.next = t, t.next = n, e.lastEffect = t)), t
}

function RF(t) {
  var e = kl();
  return t = {
    current: t
  }, e.memoizedState = t
}

function i1() {
  return vc().memoizedState
}

function GR(t, e, r, n) {
  var i = kl();
  At.flags |= t, i.memoizedState = n1(1 | e, r, void 0, n === void 0 ? null : n)
}

function xk(t, e, r, n) {
  var i = vc();
  n = n === void 0 ? null : n;
  var a = void 0;
  if (hr !== null) {
    var s = hr.memoizedState;
    if (a = s.destroy, n !== null && vk(n, s.deps)) {
      n1(e, r, a, n);
      return
    }
  }
  At.flags |= t, i.memoizedState = n1(1 | e, r, a, n)
}

function AF(t, e) {
  return GR(516, 4, t, e)
}

function a1(t, e) {
  return xk(516, 4, t, e)
}

function YK(t, e) {
  return xk(4, 2, t, e)
}

function qK(t, e) {
  if (typeof e == "function") return t = t(), e(t),
    function () {
      e(null)
    };
  if (e != null) return t = t(), e.current = t,
    function () {
      e.current = null
    }
}

function XK(t, e, r) {
  return r = r != null ? r.concat([t]) : null, xk(4, 2, qK.bind(null, e, t), r)
}

function bk() {}

function QK(t, e) {
  var r = vc();
  e = e === void 0 ? null : e;
  var n = r.memoizedState;
  return n !== null && e !== null && vk(e, n[1]) ? n[0] : (r.memoizedState = [t, e], t)
}

function ZK(t, e) {
  var r = vc();
  e = e === void 0 ? null : e;
  var n = r.memoizedState;
  return n !== null && e !== null && vk(e, n[1]) ? n[0] : (t = t(), r.memoizedState = [t, e], t)
}

function s4e(t, e) {
  var r = mf();
  Ql(98 > r ? 98 : r, function () {
    t(!0)
  }), Ql(97 < r ? 97 : r, function () {
    var n = Xn.transition;
    Xn.transition = 1;
    try {
      t(!1), e()
    } finally {
      Xn.transition = n
    }
  })
}

function Ek(t, e, r) {
  var n = _n(),
    i = po(t),
    a = {
      lane: i,
      action: r,
      eagerReducer: null,
      eagerState: null,
      next: null
    },
    s = e.pending;
  if (s === null ? a.next = a : (a.next = s.next, s.next = a), e.pending = a, s = t.alternate, t === At || s !== null && s === At) Kh = r1 = !0;
  else {
    if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
      var o = e.lastRenderedState,
        c = s(o, r);
      if (a.eagerReducer = s, a.eagerState = c, Vn(c, o)) return
    } catch {} finally {}
    go(t, i, n)
  }
}
var s1 = {
    readContext: Qn,
    useCallback: Mr,
    useContext: Mr,
    useEffect: Mr,
    useImperativeHandle: Mr,
    useLayoutEffect: Mr,
    useMemo: Mr,
    useReducer: Mr,
    useRef: Mr,
    useState: Mr,
    useDebugValue: Mr,
    useDeferredValue: Mr,
    useTransition: Mr,
    useMutableSource: Mr,
    useOpaqueIdentifier: Mr,
    unstable_isNewReconciler: !1
  },
  o4e = {
    readContext: Qn,
    useCallback: function (t, e) {
      return kl().memoizedState = [t, e === void 0 ? null : e], t
    },
    useContext: Qn,
    useEffect: AF,
    useImperativeHandle: function (t, e, r) {
      return r = r != null ? r.concat([t]) : null, GR(4, 2, qK.bind(null, e, t), r)
    },
    useLayoutEffect: function (t, e) {
      return GR(4, 2, t, e)
    },
    useMemo: function (t, e) {
      var r = kl();
      return e = e === void 0 ? null : e, t = t(), r.memoizedState = [t, e], t
    },
    useReducer: function (t, e, r) {
      var n = kl();
      return e = r !== void 0 ? r(e) : e, n.memoizedState = n.baseState = e, t = n.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: e
      }, t = t.dispatch = Ek.bind(null, At, t), [n.memoizedState, t]
    },
    useRef: RF,
    useState: qd,
    useDebugValue: bk,
    useDeferredValue: function (t) {
      var e = qd(t),
        r = e[0],
        n = e[1];
      return AF(function () {
        var i = Xn.transition;
        Xn.transition = 1;
        try {
          n(t)
        } finally {
          Xn.transition = i
        }
      }, [t]), r
    },
    useTransition: function () {
      var t = qd(!1),
        e = t[0];
      return t = s4e.bind(null, t[1]), RF(t), [t, e]
    },
    useMutableSource: function (t, e, r) {
      var n = kl();
      return n.memoizedState = {
        refs: {
          getSnapshot: e,
          setSnapshot: null
        },
        source: t,
        subscribe: r
      }, WK(n, t, e, r)
    },
    useOpaqueIdentifier: function () {
      if (ua) {
        var t = !1,
          e = e4e(function () {
            throw t || (t = !0, r("r:" + (iT++).toString(36))), Error(te(355))
          }),
          r = qd(e)[1];
        return !(At.mode & 2) && (At.flags |= 516, n1(5, function () {
          r("r:" + (iT++).toString(36))
        }, void 0, null)), e
      }
      return e = "r:" + (iT++).toString(36), qd(e), e
    },
    unstable_isNewReconciler: !1
  },
  l4e = {
    readContext: Qn,
    useCallback: QK,
    useContext: Qn,
    useEffect: a1,
    useImperativeHandle: XK,
    useLayoutEffect: YK,
    useMemo: ZK,
    useReducer: Kd,
    useRef: i1,
    useState: function () {
      return Kd(sa)
    },
    useDebugValue: bk,
    useDeferredValue: function (t) {
      var e = Kd(sa),
        r = e[0],
        n = e[1];
      return a1(function () {
        var i = Xn.transition;
        Xn.transition = 1;
        try {
          n(t)
        } finally {
          Xn.transition = i
        }
      }, [t]), r
    },
    useTransition: function () {
      var t = Kd(sa)[0];
      return [i1().current, t]
    },
    useMutableSource: KK,
    useOpaqueIdentifier: function () {
      return Kd(sa)[0]
    },
    unstable_isNewReconciler: !1
  },
  c4e = {
    readContext: Qn,
    useCallback: QK,
    useContext: Qn,
    useEffect: a1,
    useImperativeHandle: XK,
    useLayoutEffect: YK,
    useMemo: ZK,
    useReducer: Yd,
    useRef: i1,
    useState: function () {
      return Yd(sa)
    },
    useDebugValue: bk,
    useDeferredValue: function (t) {
      var e = Yd(sa),
        r = e[0],
        n = e[1];
      return a1(function () {
        var i = Xn.transition;
        Xn.transition = 1;
        try {
          n(t)
        } finally {
          Xn.transition = i
        }
      }, [t]), r
    },
    useTransition: function () {
      var t = Yd(sa)[0];
      return [i1().current, t]
    },
    useMutableSource: KK,
    useOpaqueIdentifier: function () {
      return Yd(sa)[0]
    },
    unstable_isNewReconciler: !1
  },
  u4e = gc.ReactCurrentOwner,
  Ri = !1;

function Gr(t, e, r, n) {
  e.child = t === null ? GK(e, null, r, n) : e1(e, t.child, r, n)
}

function IF(t, e, r, n, i) {
  r = r.render;
  var a = e.ref;
  return Bu(e, i), n = yk(t, e, r, n, a, i), t !== null && !Ri ? (e.updateQueue = t.updateQueue, e.flags &= -517, t.lanes &= ~i, qa(t, e, i)) : (e.flags |= 1, Gr(t, e, n, i), e.child)
}

function $F(t, e, r, n, i, a) {
  if (t === null) {
    var s = r.type;
    return typeof s == "function" && !Ak(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15, e.type = s, JK(t, e, s, n, i, a)) : (t = Wv(r.type, null, n, e, e.mode, a), t.ref = e.ref, t.return = e, e.child = t)
  }
  return s = t.child, !(i & a) && (i = s.memoizedProps, r = r.compare, r = r !== null ? r : k0, r(i, n) && t.ref === e.ref) ? qa(t, e, a) : (e.flags |= 1, t = Oo(s, n), t.ref = e.ref, t.return = e, e.child = t)
}

function JK(t, e, r, n, i, a) {
  if (t !== null && k0(t.memoizedProps, n) && t.ref === e.ref)
    if (Ri = !1, (a & i) !== 0) t.flags & 16384 && (Ri = !0);
    else return e.lanes = t.lanes, qa(t, e, a);
  return VR(t, e, r, n, a)
}

function lT(t, e, r) {
  var n = e.pendingProps,
    i = n.children,
    a = t !== null ? t.memoizedState : null;
  if (n.mode === "hidden" || n.mode === "unstable-defer-without-hiding")
    if (!(e.mode & 4)) e.memoizedState = {
      baseLanes: 0
    }, Lm(e, r);
    else if (r & 1073741824) e.memoizedState = {
    baseLanes: 0
  }, Lm(e, a !== null ? a.baseLanes : r);
  else return t = a !== null ? a.baseLanes | r : r, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
    baseLanes: t
  }, Lm(e, t), null;
  else a !== null ? (n = a.baseLanes | r, e.memoizedState = null) : n = r, Lm(e, n);
  return Gr(t, e, i, r), e.child
}

function eY(t, e) {
  var r = e.ref;
  (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 128)
}

function VR(t, e, r, n, i) {
  var a = tn(r) ? Xl : xr.current;
  return a = gf(e, a), Bu(e, i), r = yk(t, e, r, n, a, i), t !== null && !Ri ? (e.updateQueue = t.updateQueue, e.flags &= -517, t.lanes &= ~i, qa(t, e, i)) : (e.flags |= 1, Gr(t, e, r, i), e.child)
}

function CF(t, e, r, n, i) {
  if (tn(r)) {
    var a = !0;
    jv(e)
  } else a = !1;
  if (Bu(e, i), e.stateNode === null) t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), HK(e, r, n), jR(e, r, n, i), n = !0;
  else if (t === null) {
    var s = e.stateNode,
      o = e.memoizedProps;
    s.props = o;
    var c = s.context,
      l = r.contextType;
    typeof l == "object" && l !== null ? l = Qn(l) : (l = tn(r) ? Xl : xr.current, l = gf(e, l));
    var u = r.getDerivedStateFromProps,
      f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
    f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (o !== n || c !== l) && EF(e, s, n, l), js = !1;
    var d = e.memoizedState;
    s.state = d, P0(e, n, s, i), c = e.memoizedState, o !== n || d !== c || en.current || js ? (typeof u == "function" && (Jy(e, r, u, n), c = e.memoizedState), (o = js || bF(e, r, o, n, d, c, l)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4)) : (typeof s.componentDidMount == "function" && (e.flags |= 4), e.memoizedProps = n, e.memoizedState = c), s.props = n, s.state = c, s.context = l, n = o) : (typeof s.componentDidMount == "function" && (e.flags |= 4), n = !1)
  } else {
    s = e.stateNode, UK(t, e), o = e.memoizedProps, l = e.type === e.elementType ? o : xi(e.type, o), s.props = l, f = e.pendingProps, d = s.context, c = r.contextType, typeof c == "object" && c !== null ? c = Qn(c) : (c = tn(r) ? Xl : xr.current, c = gf(e, c));
    var h = r.getDerivedStateFromProps;
    (u = typeof h == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (o !== f || d !== c) && EF(e, s, n, c), js = !1, d = e.memoizedState, s.state = d, P0(e, n, s, i);
    var p = e.memoizedState;
    o !== f || d !== p || en.current || js ? (typeof h == "function" && (Jy(e, r, h, n), p = e.memoizedState), (l = js || bF(e, r, l, n, d, p, c)) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(n, p, c), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(n, p, c)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 256)) : (typeof s.componentDidUpdate != "function" || o === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && d === t.memoizedState || (e.flags |= 256), e.memoizedProps = n, e.memoizedState = p), s.props = n, s.state = p, s.context = c, n = l) : (typeof s.componentDidUpdate != "function" || o === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && d === t.memoizedState || (e.flags |= 256), n = !1)
  }
  return WR(t, e, r, n, a, i)
}

function WR(t, e, r, n, i, a) {
  eY(t, e);
  var s = (e.flags & 64) !== 0;
  if (!n && !s) return i && gF(e, r, !1), qa(t, e, a);
  n = e.stateNode, u4e.current = e;
  var o = s && typeof r.getDerivedStateFromError != "function" ? null : n.render();
  return e.flags |= 1, t !== null && s ? (e.child = e1(e, t.child, null, a), e.child = e1(e, null, o, a)) : Gr(t, e, o, a), e.memoizedState = n.state, i && gF(e, r, !0), e.child
}

function kF(t) {
  var e = t.stateNode;
  e.pendingContext ? pF(t, e.pendingContext, e.pendingContext !== e.context) : e.context && pF(t, e.context, !1), HR(t, e.containerInfo)
}
var Om = {
  dehydrated: null,
  retryLane: 0
};

function OF(t, e, r) {
  var n = e.pendingProps,
    i = Et.current,
    a = !1,
    s;
  return (s = (e.flags & 64) !== 0) || (s = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), s ? (a = !0, e.flags &= -65) : t !== null && t.memoizedState === null || n.fallback === void 0 || n.unstable_avoidThisFallback === !0 || (i |= 1), St(Et, i & 1), t === null ? (n.fallback !== void 0 && zR(e), t = n.children, i = n.fallback, a ? (t = LF(e, t, i, r), e.child.memoizedState = {
    baseLanes: r
  }, e.memoizedState = Om, t) : typeof n.unstable_expectedLoadTime == "number" ? (t = LF(e, t, i, r), e.child.memoizedState = {
    baseLanes: r
  }, e.memoizedState = Om, e.lanes = 33554432, t) : (r = Ik({
    mode: "visible",
    children: t
  }, e.mode, r, null), r.return = e, e.child = r)) : t.memoizedState !== null ? a ? (n = NF(t, e, n.children, n.fallback, r), a = e.child, i = t.child.memoizedState, a.memoizedState = i === null ? {
    baseLanes: r
  } : {
    baseLanes: i.baseLanes | r
  }, a.childLanes = t.childLanes & ~r, e.memoizedState = Om, n) : (r = PF(t, e, n.children, r), e.memoizedState = null, r) : a ? (n = NF(t, e, n.children, n.fallback, r), a = e.child, i = t.child.memoizedState, a.memoizedState = i === null ? {
    baseLanes: r
  } : {
    baseLanes: i.baseLanes | r
  }, a.childLanes = t.childLanes & ~r, e.memoizedState = Om, n) : (r = PF(t, e, n.children, r), e.memoizedState = null, r)
}

function LF(t, e, r, n) {
  var i = t.mode,
    a = t.child;
  return e = {
    mode: "hidden",
    children: e
  }, !(i & 2) && a !== null ? (a.childLanes = 0, a.pendingProps = e) : a = Ik(e, i, 0, null), r = zu(r, i, n, null), a.return = t, r.return = t, a.sibling = r, t.child = a, r
}

function PF(t, e, r, n) {
  var i = t.child;
  return t = i.sibling, r = Oo(i, {
    mode: "visible",
    children: r
  }), !(e.mode & 2) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (t.nextEffect = null, t.flags = 8, e.firstEffect = e.lastEffect = t), e.child = r
}

function NF(t, e, r, n, i) {
  var a = e.mode,
    s = t.child;
  t = s.sibling;
  var o = {
    mode: "hidden",
    children: r
  };
  return !(a & 2) && e.child !== s ? (r = e.child, r.childLanes = 0, r.pendingProps = o, s = r.lastEffect, s !== null ? (e.firstEffect = r.firstEffect, e.lastEffect = s, s.nextEffect = null) : e.firstEffect = e.lastEffect = null) : r = Oo(s, o), t !== null ? n = Oo(t, n) : (n = zu(n, a, i, null), n.flags |= 2), n.return = e, r.return = e, r.sibling = n, e.child = r, n
}

function DF(t, e) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), BK(t.return, e)
}

function cT(t, e, r, n, i, a) {
  var s = t.memoizedState;
  s === null ? t.memoizedState = {
    isBackwards: e,
    rendering: null,
    renderingStartTime: 0,
    last: n,
    tail: r,
    tailMode: i,
    lastEffect: a
  } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = r, s.tailMode = i, s.lastEffect = a)
}

function MF(t, e, r) {
  var n = e.pendingProps,
    i = n.revealOrder,
    a = n.tail;
  if (Gr(t, e, n.children, r), n = Et.current, n & 2) n = n & 1 | 2, e.flags |= 64;
  else {
    if (t !== null && t.flags & 64) e: for (t = e.child; t !== null;) {
      if (t.tag === 13) t.memoizedState !== null && DF(t, r);
      else if (t.tag === 19) DF(t, r);
      else if (t.child !== null) {
        t.child.return = t, t = t.child;
        continue
      }
      if (t === e) break e;
      for (; t.sibling === null;) {
        if (t.return === null || t.return === e) break e;
        t = t.return
      }
      t.sibling.return = t.return, t = t.sibling
    }
    n &= 1
  }
  if (St(Et, n), !(e.mode & 2)) e.memoizedState = null;
  else switch (i) {
    case "forwards":
      for (r = e.child, i = null; r !== null;) t = r.alternate, t !== null && t1(t) === null && (i = r), r = r.sibling;
      r = i, r === null ? (i = e.child, e.child = null) : (i = r.sibling, r.sibling = null), cT(e, !1, i, r, a, e.lastEffect);
      break;
    case "backwards":
      for (r = null, i = e.child, e.child = null; i !== null;) {
        if (t = i.alternate, t !== null && t1(t) === null) {
          e.child = i;
          break
        }
        t = i.sibling, i.sibling = r, r = i, i = t
      }
      cT(e, !0, r, null, a, e.lastEffect);
      break;
    case "together":
      cT(e, !1, null, null, void 0, e.lastEffect);
      break;
    default:
      e.memoizedState = null
  }
  return e.child
}

function qa(t, e, r) {
  if (t !== null && (e.dependencies = t.dependencies), ng |= e.lanes, r & e.childLanes) {
    if (t !== null && e.child !== t.child) throw Error(te(153));
    if (e.child !== null) {
      for (t = e.child, r = Oo(t, t.pendingProps), e.child = r, r.return = e; t.sibling !== null;) t = t.sibling, r = r.sibling = Oo(t, t.pendingProps), r.return = e;
      r.sibling = null
    }
    return e.child
  }
  return null
}
var tY, KR, rY, nY;
tY = function (t, e) {
  for (var r = e.child; r !== null;) {
    if (r.tag === 5 || r.tag === 6) t.appendChild(r.stateNode);
    else if (r.tag !== 4 && r.child !== null) {
      r.child.return = r, r = r.child;
      continue
    }
    if (r === e) break;
    for (; r.sibling === null;) {
      if (r.return === null || r.return === e) return;
      r = r.return
    }
    r.sibling.return = r.return, r = r.sibling
  }
};
KR = function () {};
rY = function (t, e, r, n) {
  var i = t.memoizedProps;
  if (i !== n) {
    t = e.stateNode, Cl(ca.current);
    var a = null;
    switch (r) {
      case "input":
        i = bR(t, i), n = bR(t, n), a = [];
        break;
      case "option":
        i = _R(t, i), n = _R(t, n), a = [];
        break;
      case "select":
        i = ft({}, i, {
          value: void 0
        }), n = ft({}, n, {
          value: void 0
        }), a = [];
        break;
      case "textarea":
        i = TR(t, i), n = TR(t, n), a = [];
        break;
      default:
        typeof i.onClick != "function" && typeof n.onClick == "function" && (t.onclick = Ky)
    }
    AR(r, n);
    var s;
    r = null;
    for (l in i)
      if (!n.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null)
        if (l === "style") {
          var o = i[l];
          for (s in o) o.hasOwnProperty(s) && (r || (r = {}), r[s] = "")
        } else l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (T0.hasOwnProperty(l) ? a || (a = []) : (a = a || []).push(l, null));
    for (l in n) {
      var c = n[l];
      if (o = i != null ? i[l] : void 0, n.hasOwnProperty(l) && c !== o && (c != null || o != null))
        if (l === "style")
          if (o) {
            for (s in o) !o.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (r || (r = {}), r[s] = "");
            for (s in c) c.hasOwnProperty(s) && o[s] !== c[s] && (r || (r = {}), r[s] = c[s])
          } else r || (a || (a = []), a.push(l, r)), r = c;
      else l === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, o = o ? o.__html : void 0, c != null && o !== c && (a = a || []).push(l, c)) : l === "children" ? typeof c != "string" && typeof c != "number" || (a = a || []).push(l, "" + c) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (T0.hasOwnProperty(l) ? (c != null && l === "onScroll" && nt("scroll", t), a || o === c || (a = [])) : typeof c == "object" && c !== null && c.$$typeof === YC ? c.toString() : (a = a || []).push(l, c))
    }
    r && (a = a || []).push("style", r);
    var l = a;
    (e.updateQueue = l) && (e.flags |= 4)
  }
};
nY = function (t, e, r, n) {
  r !== n && (e.flags |= 4)
};

function Xd(t, e) {
  if (!ua) switch (t.tailMode) {
    case "hidden":
      e = t.tail;
      for (var r = null; e !== null;) e.alternate !== null && (r = e), e = e.sibling;
      r === null ? t.tail = null : r.sibling = null;
      break;
    case "collapsed":
      r = t.tail;
      for (var n = null; r !== null;) r.alternate !== null && (n = r), r = r.sibling;
      n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null
  }
}

function f4e(t, e, r) {
  var n = e.pendingProps;
  switch (e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return tn(e.type) && qy(), null;
    case 3:
      return vf(), at(en), at(xr), mk(), n = e.stateNode, n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (t === null || t.child === null) && (km(e) ? e.flags |= 4 : n.hydrate || (e.flags |= 256)), KR(e), null;
    case 5:
      gk(e);
      var i = Cl(D0.current);
      if (r = e.type, t !== null && e.stateNode != null) rY(t, e, r, n, i), t.ref !== e.ref && (e.flags |= 128);
      else {
        if (!n) {
          if (e.stateNode === null) throw Error(te(166));
          return null
        }
        if (t = Cl(ca.current), km(e)) {
          n = e.stateNode, r = e.type;
          var a = e.memoizedProps;
          switch (n[eo] = e, n[Yy] = a, r) {
            case "dialog":
              nt("cancel", n), nt("close", n);
              break;
            case "iframe":
            case "object":
            case "embed":
              nt("load", n);
              break;
            case "video":
            case "audio":
              for (t = 0; t < Sh.length; t++) nt(Sh[t], n);
              break;
            case "source":
              nt("error", n);
              break;
            case "img":
            case "image":
            case "link":
              nt("error", n), nt("load", n);
              break;
            case "details":
              nt("toggle", n);
              break;
            case "input":
              MM(n, a), nt("invalid", n);
              break;
            case "select":
              n._wrapperState = {
                wasMultiple: !!a.multiple
              }, nt("invalid", n);
              break;
            case "textarea":
              BM(n, a), nt("invalid", n)
          }
          AR(r, a), t = null;
          for (var s in a) a.hasOwnProperty(s) && (i = a[s], s === "children" ? typeof i == "string" ? n.textContent !== i && (t = ["children", i]) : typeof i == "number" && n.textContent !== "" + i && (t = ["children", "" + i]) : T0.hasOwnProperty(s) && i != null && s === "onScroll" && nt("scroll", n));
          switch (r) {
            case "input":
              wm(n), FM(n, a, !0);
              break;
            case "textarea":
              wm(n), UM(n);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof a.onClick == "function" && (n.onclick = Ky)
          }
          n = t, e.updateQueue = n, n !== null && (e.flags |= 4)
        } else {
          switch (s = i.nodeType === 9 ? i : i.ownerDocument, t === wR.html && (t = XW(r)), t === wR.html ? r === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = s.createElement(r, {
            is: n.is
          }) : (t = s.createElement(r), r === "select" && (s = t, n.multiple ? s.multiple = !0 : n.size && (s.size = n.size))) : t = s.createElementNS(t, r), t[eo] = e, t[Yy] = n, tY(t, e, !1, !1), e.stateNode = t, s = IR(r, n), r) {
            case "dialog":
              nt("cancel", t), nt("close", t), i = n;
              break;
            case "iframe":
            case "object":
            case "embed":
              nt("load", t), i = n;
              break;
            case "video":
            case "audio":
              for (i = 0; i < Sh.length; i++) nt(Sh[i], t);
              i = n;
              break;
            case "source":
              nt("error", t), i = n;
              break;
            case "img":
            case "image":
            case "link":
              nt("error", t), nt("load", t), i = n;
              break;
            case "details":
              nt("toggle", t), i = n;
              break;
            case "input":
              MM(t, n), i = bR(t, n), nt("invalid", t);
              break;
            case "option":
              i = _R(t, n);
              break;
            case "select":
              t._wrapperState = {
                wasMultiple: !!n.multiple
              }, i = ft({}, n, {
                value: void 0
              }), nt("invalid", t);
              break;
            case "textarea":
              BM(t, n), i = TR(t, n), nt("invalid", t);
              break;
            default:
              i = n
          }
          AR(r, i);
          var o = i;
          for (a in o)
            if (o.hasOwnProperty(a)) {
              var c = o[a];
              a === "style" ? JW(t, c) : a === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && QW(t, c)) : a === "children" ? typeof c == "string" ? (r !== "textarea" || c !== "") && w0(t, c) : typeof c == "number" && w0(t, "" + c) : a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && a !== "autoFocus" && (T0.hasOwnProperty(a) ? c != null && a === "onScroll" && nt("scroll", t) : c != null && HC(t, a, c, s))
            } switch (r) {
            case "input":
              wm(t), FM(t, n, !1);
              break;
            case "textarea":
              wm(t), UM(t);
              break;
            case "option":
              n.value != null && t.setAttribute("value", "" + Io(n.value));
              break;
            case "select":
              t.multiple = !!n.multiple, a = n.value, a != null ? Nu(t, !!n.multiple, a, !1) : n.defaultValue != null && Nu(t, !!n.multiple, n.defaultValue, !0);
              break;
            default:
              typeof i.onClick == "function" && (t.onclick = Ky)
          }
          CK(r, n) && (e.flags |= 4)
        }
        e.ref !== null && (e.flags |= 128)
      }
      return null;
    case 6:
      if (t && e.stateNode != null) nY(t, e, t.memoizedProps, n);
      else {
        if (typeof n != "string" && e.stateNode === null) throw Error(te(166));
        r = Cl(D0.current), Cl(ca.current), km(e) ? (n = e.stateNode, r = e.memoizedProps, n[eo] = e, n.nodeValue !== r && (e.flags |= 4)) : (n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[eo] = e, e.stateNode = n)
      }
      return null;
    case 13:
      return at(Et), n = e.memoizedState, e.flags & 64 ? (e.lanes = r, e) : (n = n !== null, r = !1, t === null ? e.memoizedProps.fallback !== void 0 && km(e) : r = t.memoizedState !== null, n && !r && e.mode & 2 && (t === null && e.memoizedProps.unstable_avoidThisFallback !== !0 || Et.current & 1 ? tr === 0 && (tr = 3) : ((tr === 0 || tr === 3) && (tr = 4), $r === null || !(ng & 134217727) && !(td & 134217727) || ju($r, vr))), (n || r) && (e.flags |= 4), null);
    case 4:
      return vf(), KR(e), t === null && AK(e.stateNode.containerInfo), null;
    case 10:
      return hk(e), null;
    case 17:
      return tn(e.type) && qy(), null;
    case 19:
      if (at(Et), n = e.memoizedState, n === null) return null;
      if (a = (e.flags & 64) !== 0, s = n.rendering, s === null)
        if (a) Xd(n, !1);
        else {
          if (tr !== 0 || t !== null && t.flags & 64)
            for (t = e.child; t !== null;) {
              if (s = t1(t), s !== null) {
                for (e.flags |= 64, Xd(n, !1), a = s.updateQueue, a !== null && (e.updateQueue = a, e.flags |= 4), n.lastEffect === null && (e.firstEffect = null), e.lastEffect = n.lastEffect, n = r, r = e.child; r !== null;) a = r, t = n, a.flags &= 2, a.nextEffect = null, a.firstEffect = null, a.lastEffect = null, s = a.alternate, s === null ? (a.childLanes = 0, a.lanes = t, a.child = null, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = s.childLanes, a.lanes = s.lanes, a.child = s.child, a.memoizedProps = s.memoizedProps, a.memoizedState = s.memoizedState, a.updateQueue = s.updateQueue, a.type = s.type, t = s.dependencies, a.dependencies = t === null ? null : {
                  lanes: t.lanes,
                  firstContext: t.firstContext
                }), r = r.sibling;
                return St(Et, Et.current & 1 | 2), e.child
              }
              t = t.sibling
            }
          n.tail !== null && gr() > JR && (e.flags |= 64, a = !0, Xd(n, !1), e.lanes = 33554432)
        }
      else {
        if (!a)
          if (t = t1(s), t !== null) {
            if (e.flags |= 64, a = !0, r = t.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), Xd(n, !0), n.tail === null && n.tailMode === "hidden" && !s.alternate && !ua) return e = e.lastEffect = n.lastEffect, e !== null && (e.nextEffect = null), null
          } else 2 * gr() - n.renderingStartTime > JR && r !== 1073741824 && (e.flags |= 64, a = !0, Xd(n, !1), e.lanes = 33554432);
        n.isBackwards ? (s.sibling = e.child, e.child = s) : (r = n.last, r !== null ? r.sibling = s : e.child = s, n.last = s)
      }
      return n.tail !== null ? (r = n.tail, n.rendering = r, n.tail = r.sibling, n.lastEffect = e.lastEffect, n.renderingStartTime = gr(), r.sibling = null, e = Et.current, St(Et, a ? e & 1 | 2 : e & 1), r) : null;
    case 23:
    case 24:
      return Rk(), t !== null && t.memoizedState !== null != (e.memoizedState !== null) && n.mode !== "unstable-defer-without-hiding" && (e.flags |= 4), null
  }
  throw Error(te(156, e.tag))
}

function d4e(t) {
  switch (t.tag) {
    case 1:
      tn(t.type) && qy();
      var e = t.flags;
      return e & 4096 ? (t.flags = e & -4097 | 64, t) : null;
    case 3:
      if (vf(), at(en), at(xr), mk(), e = t.flags, e & 64) throw Error(te(285));
      return t.flags = e & -4097 | 64, t;
    case 5:
      return gk(t), null;
    case 13:
      return at(Et), e = t.flags, e & 4096 ? (t.flags = e & -4097 | 64, t) : null;
    case 19:
      return at(Et), null;
    case 4:
      return vf(), null;
    case 10:
      return hk(t), null;
    case 23:
    case 24:
      return Rk(), null;
    default:
      return null
  }
}

function Sk(t, e) {
  try {
    var r = "",
      n = e;
    do r += WDe(n), n = n.return; while (n);
    var i = r
  } catch (a) {
    i = `
Error generating stack: ` + a.message + `
` + a.stack
  }
  return {
    value: t,
    source: e,
    stack: i
  }
}

function YR(t, e) {
  try {
    console.error(e.value)
  } catch (r) {
    setTimeout(function () {
      throw r
    })
  }
}
var h4e = typeof WeakMap == "function" ? WeakMap : Map;

function iY(t, e, r) {
  r = fo(-1, r), r.tag = 3, r.payload = {
    element: null
  };
  var n = e.value;
  return r.callback = function () {
    l1 || (l1 = !0, eA = n), YR(t, e)
  }, r
}

function aY(t, e, r) {
  r = fo(-1, r), r.tag = 3;
  var n = t.type.getDerivedStateFromError;
  if (typeof n == "function") {
    var i = e.value;
    r.payload = function () {
      return YR(t, e), n(i)
    }
  }
  var a = t.stateNode;
  return a !== null && typeof a.componentDidCatch == "function" && (r.callback = function () {
    typeof n != "function" && (oa === null ? oa = new Set([this]) : oa.add(this), YR(t, e));
    var s = e.stack;
    this.componentDidCatch(e.value, {
      componentStack: s !== null ? s : ""
    })
  }), r
}
var p4e = typeof WeakSet == "function" ? WeakSet : Set;

function FF(t) {
  var e = t.ref;
  if (e !== null)
    if (typeof e == "function") try {
      e(null)
    } catch (r) {
      mo(t, r)
    } else e.current = null
}

function g4e(t, e) {
  switch (e.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (e.flags & 256 && t !== null) {
        var r = t.memoizedProps,
          n = t.memoizedState;
        t = e.stateNode, e = t.getSnapshotBeforeUpdate(e.elementType === e.type ? r : xi(e.type, r), n), t.__reactInternalSnapshotBeforeUpdate = e
      }
      return;
    case 3:
      e.flags & 256 && ck(e.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return
  }
  throw Error(te(163))
}

function m4e(t, e, r) {
  switch (r.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      if (e = r.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        t = e = e.next;
        do {
          if ((t.tag & 3) === 3) {
            var n = t.create;
            t.destroy = n()
          }
          t = t.next
        } while (t !== e)
      }
      if (e = r.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        t = e = e.next;
        do {
          var i = t;
          n = i.next, i = i.tag, i & 4 && i & 1 && (pY(r, t), T4e(r, t)), t = n
        } while (t !== e)
      }
      return;
    case 1:
      t = r.stateNode, r.flags & 4 && (e === null ? t.componentDidMount() : (n = r.elementType === r.type ? e.memoizedProps : xi(r.type, e.memoizedProps), t.componentDidUpdate(n, e.memoizedState, t.__reactInternalSnapshotBeforeUpdate))), e = r.updateQueue, e !== null && xF(r, e, t);
      return;
    case 3:
      if (e = r.updateQueue, e !== null) {
        if (t = null, r.child !== null) switch (r.child.tag) {
          case 5:
            t = r.child.stateNode;
            break;
          case 1:
            t = r.child.stateNode
        }
        xF(r, e, t)
      }
      return;
    case 5:
      t = r.stateNode, e === null && r.flags & 4 && CK(r.type, r.memoizedProps) && t.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      r.memoizedState === null && (r = r.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null && cK(r))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return
  }
  throw Error(te(163))
}

function BF(t, e) {
  for (var r = t;;) {
    if (r.tag === 5) {
      var n = r.stateNode;
      if (e) n = n.style, typeof n.setProperty == "function" ? n.setProperty("display", "none", "important") : n.display = "none";
      else {
        n = r.stateNode;
        var i = r.memoizedProps.style;
        i = i != null && i.hasOwnProperty("display") ? i.display : null, n.style.display = ZW("display", i)
      }
    } else if (r.tag === 6) r.stateNode.nodeValue = e ? "" : r.memoizedProps;
    else if ((r.tag !== 23 && r.tag !== 24 || r.memoizedState === null || r === t) && r.child !== null) {
      r.child.return = r, r = r.child;
      continue
    }
    if (r === t) break;
    for (; r.sibling === null;) {
      if (r.return === null || r.return === t) return;
      r = r.return
    }
    r.sibling.return = r.return, r = r.sibling
  }
}

function UF(t, e) {
  if (Bl && typeof Bl.onCommitFiberUnmount == "function") try {
    Bl.onCommitFiberUnmount(uk, e)
  } catch {}
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      if (t = e.updateQueue, t !== null && (t = t.lastEffect, t !== null)) {
        var r = t = t.next;
        do {
          var n = r,
            i = n.destroy;
          if (n = n.tag, i !== void 0)
            if (n & 4) pY(e, r);
            else {
              n = e;
              try {
                i()
              } catch (a) {
                mo(n, a)
              }
            } r = r.next
        } while (r !== t)
      }
      break;
    case 1:
      if (FF(e), t = e.stateNode, typeof t.componentWillUnmount == "function") try {
        t.props = e.memoizedProps, t.state = e.memoizedState, t.componentWillUnmount()
      } catch (a) {
        mo(e, a)
      }
      break;
    case 5:
      FF(e);
      break;
    case 4:
      sY(t, e)
  }
}

function jF(t) {
  t.alternate = null, t.child = null, t.dependencies = null, t.firstEffect = null, t.lastEffect = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.return = null, t.updateQueue = null
}

function HF(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function zF(t) {
  e: {
    for (var e = t.return; e !== null;) {
      if (HF(e)) break e;
      e = e.return
    }
    throw Error(te(160))
  }
  var r = e;
  switch (e = r.stateNode, r.tag) {
    case 5:
      var n = !1;
      break;
    case 3:
      e = e.containerInfo, n = !0;
      break;
    case 4:
      e = e.containerInfo, n = !0;
      break;
    default:
      throw Error(te(161))
  }
  r.flags & 16 && (w0(e, ""), r.flags &= -17);e: t: for (r = t;;) {
    for (; r.sibling === null;) {
      if (r.return === null || HF(r.return)) {
        r = null;
        break e
      }
      r = r.return
    }
    for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18;) {
      if (r.flags & 2 || r.child === null || r.tag === 4) continue t;
      r.child.return = r, r = r.child
    }
    if (!(r.flags & 2)) {
      r = r.stateNode;
      break e
    }
  }
  n ? qR(t, r, e) : XR(t, r, e)
}

function qR(t, e, r) {
  var n = t.tag,
    i = n === 5 || n === 6;
  if (i) t = i ? t.stateNode : t.stateNode.instance, e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode, e.insertBefore(t, r)) : (e = r, e.appendChild(t)), r = r._reactRootContainer, r != null || e.onclick !== null || (e.onclick = Ky));
  else if (n !== 4 && (t = t.child, t !== null))
    for (qR(t, e, r), t = t.sibling; t !== null;) qR(t, e, r), t = t.sibling
}

function XR(t, e, r) {
  var n = t.tag,
    i = n === 5 || n === 6;
  if (i) t = i ? t.stateNode : t.stateNode.instance, e ? r.insertBefore(t, e) : r.appendChild(t);
  else if (n !== 4 && (t = t.child, t !== null))
    for (XR(t, e, r), t = t.sibling; t !== null;) XR(t, e, r), t = t.sibling
}

function sY(t, e) {
  for (var r = e, n = !1, i, a;;) {
    if (!n) {
      n = r.return;
      e: for (;;) {
        if (n === null) throw Error(te(160));
        switch (i = n.stateNode, n.tag) {
          case 5:
            a = !1;
            break e;
          case 3:
            i = i.containerInfo, a = !0;
            break e;
          case 4:
            i = i.containerInfo, a = !0;
            break e
        }
        n = n.return
      }
      n = !0
    }
    if (r.tag === 5 || r.tag === 6) {
      e: for (var s = t, o = r, c = o;;)
        if (UF(s, c), c.child !== null && c.tag !== 4) c.child.return = c, c = c.child;
        else {
          if (c === o) break e;
          for (; c.sibling === null;) {
            if (c.return === null || c.return === o) break e;
            c = c.return
          }
          c.sibling.return = c.return, c = c.sibling
        }a ? (s = i, o = r.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(o) : s.removeChild(o)) : i.removeChild(r.stateNode)
    }
    else if (r.tag === 4) {
      if (r.child !== null) {
        i = r.stateNode.containerInfo, a = !0, r.child.return = r, r = r.child;
        continue
      }
    } else if (UF(t, r), r.child !== null) {
      r.child.return = r, r = r.child;
      continue
    }
    if (r === e) break;
    for (; r.sibling === null;) {
      if (r.return === null || r.return === e) return;
      r = r.return, r.tag === 4 && (n = !1)
    }
    r.sibling.return = r.return, r = r.sibling
  }
}

function uT(t, e) {
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var r = e.updateQueue;
      if (r = r !== null ? r.lastEffect : null, r !== null) {
        var n = r = r.next;
        do(n.tag & 3) === 3 && (t = n.destroy, n.destroy = void 0, t !== void 0 && t()), n = n.next; while (n !== r)
      }
      return;
    case 1:
      return;
    case 5:
      if (r = e.stateNode, r != null) {
        n = e.memoizedProps;
        var i = t !== null ? t.memoizedProps : n;
        t = e.type;
        var a = e.updateQueue;
        if (e.updateQueue = null, a !== null) {
          for (r[Yy] = n, t === "input" && n.type === "radio" && n.name != null && YW(r, n), IR(t, i), e = IR(t, n), i = 0; i < a.length; i += 2) {
            var s = a[i],
              o = a[i + 1];
            s === "style" ? JW(r, o) : s === "dangerouslySetInnerHTML" ? QW(r, o) : s === "children" ? w0(r, o) : HC(r, s, o, e)
          }
          switch (t) {
            case "input":
              ER(r, n);
              break;
            case "textarea":
              qW(r, n);
              break;
            case "select":
              t = r._wrapperState.wasMultiple, r._wrapperState.wasMultiple = !!n.multiple, a = n.value, a != null ? Nu(r, !!n.multiple, a, !1) : t !== !!n.multiple && (n.defaultValue != null ? Nu(r, !!n.multiple, n.defaultValue, !0) : Nu(r, !!n.multiple, n.multiple ? [] : "", !1))
          }
        }
      }
      return;
    case 6:
      if (e.stateNode === null) throw Error(te(162));
      e.stateNode.nodeValue = e.memoizedProps;
      return;
    case 3:
      r = e.stateNode, r.hydrate && (r.hydrate = !1, cK(r.containerInfo));
      return;
    case 12:
      return;
    case 13:
      e.memoizedState !== null && (wk = gr(), BF(e.child, !0)), GF(e);
      return;
    case 19:
      GF(e);
      return;
    case 17:
      return;
    case 23:
    case 24:
      BF(e, e.memoizedState !== null);
      return
  }
  throw Error(te(163))
}

function GF(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var r = t.stateNode;
    r === null && (r = t.stateNode = new p4e), e.forEach(function (n) {
      var i = A4e.bind(null, t, n);
      r.has(n) || (r.add(n), n.then(i, i))
    })
  }
}

function v4e(t, e) {
  return t !== null && (t = t.memoizedState, t === null || t.dehydrated !== null) ? (e = e.memoizedState, e !== null && e.dehydrated === null) : !1
}
var y4e = Math.ceil,
  o1 = gc.ReactCurrentDispatcher,
  _k = gc.ReactCurrentOwner,
  Se = 0,
  $r = null,
  Pt = null,
  vr = 0,
  Zl = 0,
  QR = Ko(0),
  tr = 0,
  Mb = null,
  ed = 0,
  ng = 0,
  td = 0,
  Tk = 0,
  ZR = null,
  wk = 0,
  JR = 1 / 0;

function rd() {
  JR = gr() + 500
}
var fe = null,
  l1 = !1,
  eA = null,
  oa = null,
  ko = !1,
  Yh = null,
  _h = 90,
  tA = [],
  rA = [],
  es = null,
  qh = 0,
  nA = null,
  zv = -1,
  Ka = 0,
  Gv = 0,
  Xh = null,
  Vv = !1;

function _n() {
  return Se & 48 ? gr() : zv !== -1 ? zv : zv = gr()
}

function po(t) {
  if (t = t.mode, !(t & 2)) return 1;
  if (!(t & 4)) return mf() === 99 ? 1 : 2;
  if (Ka === 0 && (Ka = ed), a4e.transition !== 0) {
    Gv !== 0 && (Gv = ZR !== null ? ZR.pendingLanes : 0), t = Ka;
    var e = 4186112 & ~Gv;
    return e &= -e, e === 0 && (t = 4186112 & ~t, e = t & -t, e === 0 && (e = 8192)), e
  }
  return t = mf(), Se & 4 && t === 98 ? t = Vy(12, Ka) : (t = l3e(t), t = Vy(t, Ka)), t
}

function go(t, e, r) {
  if (50 < qh) throw qh = 0, nA = null, Error(te(185));
  if (t = Fb(t, e), t === null) return null;
  Cb(t, e, r), t === $r && (td |= e, tr === 4 && ju(t, vr));
  var n = mf();
  e === 1 ? Se & 8 && !(Se & 48) ? iA(t) : (Zn(t, r), Se === 0 && (rd(), Ra())) : (!(Se & 4) || n !== 98 && n !== 99 || (es === null ? es = new Set([t]) : es.add(t)), Zn(t, r)), ZR = t
}

function Fb(t, e) {
  t.lanes |= e;
  var r = t.alternate;
  for (r !== null && (r.lanes |= e), r = t, t = t.return; t !== null;) t.childLanes |= e, r = t.alternate, r !== null && (r.childLanes |= e), r = t, t = t.return;
  return r.tag === 3 ? r.stateNode : null
}

function Zn(t, e) {
  for (var r = t.callbackNode, n = t.suspendedLanes, i = t.pingedLanes, a = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
    var o = 31 - $o(s),
      c = 1 << o,
      l = a[o];
    if (l === -1) {
      if (!(c & n) || c & i) {
        l = e, su(c);
        var u = tt;
        a[o] = 10 <= u ? l + 250 : 6 <= u ? l + 5e3 : -1
      }
    } else l <= e && (t.expiredLanes |= c);
    s &= ~c
  }
  if (n = $0(t, t === $r ? vr : 0), e = tt, n === 0) r !== null && (r !== aT && BR(r), t.callbackNode = null, t.callbackPriority = 0);
  else {
    if (r !== null) {
      if (t.callbackPriority === e) return;
      r !== aT && BR(r)
    }
    e === 15 ? (r = iA.bind(null, t), Ga === null ? (Ga = [r], Hv = fk(Nb, FK)) : Ga.push(r), r = aT) : e === 14 ? r = L0(99, iA.bind(null, t)) : (r = c3e(e), r = L0(r, oY.bind(null, t))), t.callbackPriority = e, t.callbackNode = r
  }
}

function oY(t) {
  if (zv = -1, Gv = Ka = 0, Se & 48) throw Error(te(327));
  var e = t.callbackNode;
  if (Yo() && t.callbackNode !== e) return null;
  var r = $0(t, t === $r ? vr : 0);
  if (r === 0) return null;
  var n = r,
    i = Se;
  Se |= 16;
  var a = fY();
  ($r !== t || vr !== n) && (rd(), Hu(t, n));
  do try {
    E4e();
    break
  } catch (o) {
    uY(t, o)
  }
  while (1);
  if (dk(), o1.current = a, Se = i, Pt !== null ? n = 0 : ($r = null, vr = 0, n = tr), ed & td) Hu(t, 0);
  else if (n !== 0) {
    if (n === 2 && (Se |= 64, t.hydrate && (t.hydrate = !1, ck(t.containerInfo)), r = mK(t), r !== 0 && (n = Th(t, r))), n === 1) throw e = Mb, Hu(t, 0), ju(t, r), Zn(t, gr()), e;
    switch (t.finishedWork = t.current.alternate, t.finishedLanes = r, n) {
      case 0:
      case 1:
        throw Error(te(345));
      case 2:
        ml(t);
        break;
      case 3:
        if (ju(t, r), (r & 62914560) === r && (n = wk + 500 - gr(), 10 < n)) {
          if ($0(t, 0) !== 0) break;
          if (i = t.suspendedLanes, (i & r) !== r) {
            _n(), t.pingedLanes |= t.suspendedLanes & i;
            break
          }
          t.timeoutHandle = fF(ml.bind(null, t), n);
          break
        }
        ml(t);
        break;
      case 4:
        if (ju(t, r), (r & 4186112) === r) break;
        for (n = t.eventTimes, i = -1; 0 < r;) {
          var s = 31 - $o(r);
          a = 1 << s, s = n[s], s > i && (i = s), r &= ~a
        }
        if (r = i, r = gr() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * y4e(r / 1960)) - r, 10 < r) {
          t.timeoutHandle = fF(ml.bind(null, t), r);
          break
        }
        ml(t);
        break;
      case 5:
        ml(t);
        break;
      default:
        throw Error(te(329))
    }
  }
  return Zn(t, gr()), t.callbackNode === e ? oY.bind(null, t) : null
}

function ju(t, e) {
  for (e &= ~Tk, e &= ~td, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
    var r = 31 - $o(e),
      n = 1 << r;
    t[r] = -1, e &= ~n
  }
}

function iA(t) {
  if (Se & 48) throw Error(te(327));
  if (Yo(), t === $r && t.expiredLanes & vr) {
    var e = vr,
      r = Th(t, e);
    ed & td && (e = $0(t, e), r = Th(t, e))
  } else e = $0(t, 0), r = Th(t, e);
  if (t.tag !== 0 && r === 2 && (Se |= 64, t.hydrate && (t.hydrate = !1, ck(t.containerInfo)), e = mK(t), e !== 0 && (r = Th(t, e))), r === 1) throw r = Mb, Hu(t, 0), ju(t, e), Zn(t, gr()), r;
  return t.finishedWork = t.current.alternate, t.finishedLanes = e, ml(t), Zn(t, gr()), null
}

function x4e() {
  if (es !== null) {
    var t = es;
    es = null, t.forEach(function (e) {
      e.expiredLanes |= 24 & e.pendingLanes, Zn(e, gr())
    })
  }
  Ra()
}

function lY(t, e) {
  var r = Se;
  Se |= 1;
  try {
    return t(e)
  } finally {
    Se = r, Se === 0 && (rd(), Ra())
  }
}

function cY(t, e) {
  var r = Se;
  Se &= -2, Se |= 8;
  try {
    return t(e)
  } finally {
    Se = r, Se === 0 && (rd(), Ra())
  }
}

function Lm(t, e) {
  St(QR, Zl), Zl |= e, ed |= e
}

function Rk() {
  Zl = QR.current, at(QR)
}

function Hu(t, e) {
  t.finishedWork = null, t.finishedLanes = 0;
  var r = t.timeoutHandle;
  if (r !== -1 && (t.timeoutHandle = -1, J3e(r)), Pt !== null)
    for (r = Pt.return; r !== null;) {
      var n = r;
      switch (n.tag) {
        case 1:
          n = n.type.childContextTypes, n != null && qy();
          break;
        case 3:
          vf(), at(en), at(xr), mk();
          break;
        case 5:
          gk(n);
          break;
        case 4:
          vf();
          break;
        case 13:
          at(Et);
          break;
        case 19:
          at(Et);
          break;
        case 10:
          hk(n);
          break;
        case 23:
        case 24:
          Rk()
      }
      r = r.return
    }
  $r = t, Pt = Oo(t.current, null), vr = Zl = ed = e, tr = 0, Mb = null, Tk = td = ng = 0
}

function uY(t, e) {
  do {
    var r = Pt;
    try {
      if (dk(), Wh.current = s1, r1) {
        for (var n = At.memoizedState; n !== null;) {
          var i = n.queue;
          i !== null && (i.pending = null), n = n.next
        }
        r1 = !1
      }
      if (M0 = 0, er = hr = At = null, Kh = !1, _k.current = null, r === null || r.return === null) {
        tr = 1, Mb = e, Pt = null;
        break
      }
      e: {
        var a = t,
          s = r.return,
          o = r,
          c = e;
        if (e = vr, o.flags |= 2048, o.firstEffect = o.lastEffect = null, c !== null && typeof c == "object" && typeof c.then == "function") {
          var l = c;
          if (!(o.mode & 2)) {
            var u = o.alternate;
            u ? (o.updateQueue = u.updateQueue, o.memoizedState = u.memoizedState, o.lanes = u.lanes) : (o.updateQueue = null, o.memoizedState = null)
          }
          var f = (Et.current & 1) !== 0,
            d = s;
          do {
            var h;
            if (h = d.tag === 13) {
              var p = d.memoizedState;
              if (p !== null) h = p.dehydrated !== null;
              else {
                var v = d.memoizedProps;
                h = v.fallback === void 0 ? !1 : v.unstable_avoidThisFallback !== !0 ? !0 : !f
              }
            }
            if (h) {
              var g = d.updateQueue;
              if (g === null) {
                var m = new Set;
                m.add(l), d.updateQueue = m
              } else g.add(l);
              if (!(d.mode & 2)) {
                if (d.flags |= 64, o.flags |= 16384, o.flags &= -2981, o.tag === 1)
                  if (o.alternate === null) o.tag = 17;
                  else {
                    var y = fo(-1, 1);
                    y.tag = 2, ho(o, y)
                  } o.lanes |= 1;
                break e
              }
              c = void 0, o = e;
              var x = a.pingCache;
              if (x === null ? (x = a.pingCache = new h4e, c = new Set, x.set(l, c)) : (c = x.get(l), c === void 0 && (c = new Set, x.set(l, c))), !c.has(o)) {
                c.add(o);
                var b = R4e.bind(null, a, l, o);
                l.then(b, b)
              }
              d.flags |= 4096, d.lanes = e;
              break e
            }
            d = d.return
          } while (d !== null);
          c = Error((Pu(o.type) || "A React component") + ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`)
        }
        tr !== 5 && (tr = 2),
        c = Sk(c, o),
        d = s;do {
          switch (d.tag) {
            case 3:
              a = c, d.flags |= 4096, e &= -e, d.lanes |= e;
              var _ = iY(d, a, e);
              yF(d, _);
              break e;
            case 1:
              a = c;
              var S = d.type,
                T = d.stateNode;
              if (!(d.flags & 64) && (typeof S.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (oa === null || !oa.has(T)))) {
                d.flags |= 4096, e &= -e, d.lanes |= e;
                var R = aY(d, a, e);
                yF(d, R);
                break e
              }
          }
          d = d.return
        } while (d !== null)
      }
      hY(r)
    } catch (I) {
      e = I, Pt === r && r !== null && (Pt = r = r.return);
      continue
    }
    break
  } while (1)
}

function fY() {
  var t = o1.current;
  return o1.current = s1, t === null ? s1 : t
}

function Th(t, e) {
  var r = Se;
  Se |= 16;
  var n = fY();
  $r === t && vr === e || Hu(t, e);
  do try {
    b4e();
    break
  } catch (i) {
    uY(t, i)
  }
  while (1);
  if (dk(), Se = r, o1.current = n, Pt !== null) throw Error(te(261));
  return $r = null, vr = 0, tr
}

function b4e() {
  for (; Pt !== null;) dY(Pt)
}

function E4e() {
  for (; Pt !== null && !r4e();) dY(Pt)
}

function dY(t) {
  var e = gY(t.alternate, t, Zl);
  t.memoizedProps = t.pendingProps, e === null ? hY(t) : Pt = e, _k.current = null
}

function hY(t) {
  var e = t;
  do {
    var r = e.alternate;
    if (t = e.return, e.flags & 2048) {
      if (r = d4e(e), r !== null) {
        r.flags &= 2047, Pt = r;
        return
      }
      t !== null && (t.firstEffect = t.lastEffect = null, t.flags |= 2048)
    } else {
      if (r = f4e(r, e, Zl), r !== null) {
        Pt = r;
        return
      }
      if (r = e, r.tag !== 24 && r.tag !== 23 || r.memoizedState === null || Zl & 1073741824 || !(r.mode & 4)) {
        for (var n = 0, i = r.child; i !== null;) n |= i.lanes | i.childLanes, i = i.sibling;
        r.childLanes = n
      }
      t !== null && !(t.flags & 2048) && (t.firstEffect === null && (t.firstEffect = e.firstEffect), e.lastEffect !== null && (t.lastEffect !== null && (t.lastEffect.nextEffect = e.firstEffect), t.lastEffect = e.lastEffect), 1 < e.flags && (t.lastEffect !== null ? t.lastEffect.nextEffect = e : t.firstEffect = e, t.lastEffect = e))
    }
    if (e = e.sibling, e !== null) {
      Pt = e;
      return
    }
    Pt = e = t
  } while (e !== null);
  tr === 0 && (tr = 5)
}

function ml(t) {
  var e = mf();
  return Ql(99, S4e.bind(null, t, e)), null
}

function S4e(t, e) {
  do Yo(); while (Yh !== null);
  if (Se & 48) throw Error(te(327));
  var r = t.finishedWork;
  if (r === null) return null;
  if (t.finishedWork = null, t.finishedLanes = 0, r === t.current) throw Error(te(177));
  t.callbackNode = null;
  var n = r.lanes | r.childLanes,
    i = n,
    a = t.pendingLanes & ~i;
  t.pendingLanes = i, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= i, t.mutableReadLanes &= i, t.entangledLanes &= i, i = t.entanglements;
  for (var s = t.eventTimes, o = t.expirationTimes; 0 < a;) {
    var c = 31 - $o(a),
      l = 1 << c;
    i[c] = 0, s[c] = -1, o[c] = -1, a &= ~l
  }
  if (es !== null && !(n & 24) && es.has(t) && es.delete(t), t === $r && (Pt = $r = null, vr = 0), 1 < r.flags ? r.lastEffect !== null ? (r.lastEffect.nextEffect = r, n = r.firstEffect) : n = r : n = r.firstEffect, n !== null) {
    if (i = Se, Se |= 32, _k.current = null, rT = Fv, s = iF(), PR(s)) {
      if ("selectionStart" in s) o = {
        start: s.selectionStart,
        end: s.selectionEnd
      };
      else e: if (o = (o = s.ownerDocument) && o.defaultView || window, (l = o.getSelection && o.getSelection()) && l.rangeCount !== 0) {
        o = l.anchorNode, a = l.anchorOffset, c = l.focusNode, l = l.focusOffset;
        try {
          o.nodeType, c.nodeType
        } catch {
          o = null;
          break e
        }
        var u = 0,
          f = -1,
          d = -1,
          h = 0,
          p = 0,
          v = s,
          g = null;
        t: for (;;) {
          for (var m; v !== o || a !== 0 && v.nodeType !== 3 || (f = u + a), v !== c || l !== 0 && v.nodeType !== 3 || (d = u + l), v.nodeType === 3 && (u += v.nodeValue.length), (m = v.firstChild) !== null;) g = v, v = m;
          for (;;) {
            if (v === s) break t;
            if (g === o && ++h === a && (f = u), g === c && ++p === l && (d = u), (m = v.nextSibling) !== null) break;
            v = g, g = v.parentNode
          }
          v = m
        }
        o = f === -1 || d === -1 ? null : {
          start: f,
          end: d
        }
      } else o = null;
      o = o || {
        start: 0,
        end: 0
      }
    } else o = null;
    nT = {
      focusedElem: s,
      selectionRange: o
    }, Fv = !1, Xh = null, Vv = !1, fe = n;
    do try {
      _4e()
    } catch (I) {
      if (fe === null) throw Error(te(330));
      mo(fe, I), fe = fe.nextEffect
    }
    while (fe !== null);
    Xh = null, fe = n;
    do try {
      for (s = t; fe !== null;) {
        var y = fe.flags;
        if (y & 16 && w0(fe.stateNode, ""), y & 128) {
          var x = fe.alternate;
          if (x !== null) {
            var b = x.ref;
            b !== null && (typeof b == "function" ? b(null) : b.current = null)
          }
        }
        switch (y & 1038) {
          case 2:
            zF(fe), fe.flags &= -3;
            break;
          case 6:
            zF(fe), fe.flags &= -3, uT(fe.alternate, fe);
            break;
          case 1024:
            fe.flags &= -1025;
            break;
          case 1028:
            fe.flags &= -1025, uT(fe.alternate, fe);
            break;
          case 4:
            uT(fe.alternate, fe);
            break;
          case 8:
            o = fe, sY(s, o);
            var _ = o.alternate;
            jF(o), _ !== null && jF(_)
        }
        fe = fe.nextEffect
      }
    } catch (I) {
      if (fe === null) throw Error(te(330));
      mo(fe, I), fe = fe.nextEffect
    }
    while (fe !== null);
    if (b = nT, x = iF(), y = b.focusedElem, s = b.selectionRange, x !== y && y && y.ownerDocument && TK(y.ownerDocument.documentElement, y)) {
      for (s !== null && PR(y) && (x = s.start, b = s.end, b === void 0 && (b = x), "selectionStart" in y ? (y.selectionStart = x, y.selectionEnd = Math.min(b, y.value.length)) : (b = (x = y.ownerDocument || document) && x.defaultView || window, b.getSelection && (b = b.getSelection(), o = y.textContent.length, _ = Math.min(s.start, o), s = s.end === void 0 ? _ : Math.min(s.end, o), !b.extend && _ > s && (o = s, s = _, _ = o), o = nF(y, _), a = nF(y, s), o && a && (b.rangeCount !== 1 || b.anchorNode !== o.node || b.anchorOffset !== o.offset || b.focusNode !== a.node || b.focusOffset !== a.offset) && (x = x.createRange(), x.setStart(o.node, o.offset), b.removeAllRanges(), _ > s ? (b.addRange(x), b.extend(a.node, a.offset)) : (x.setEnd(a.node, a.offset), b.addRange(x)))))), x = [], b = y; b = b.parentNode;) b.nodeType === 1 && x.push({
        element: b,
        left: b.scrollLeft,
        top: b.scrollTop
      });
      for (typeof y.focus == "function" && y.focus(), y = 0; y < x.length; y++) b = x[y], b.element.scrollLeft = b.left, b.element.scrollTop = b.top
    }
    Fv = !!rT, nT = rT = null, t.current = r, fe = n;
    do try {
      for (y = t; fe !== null;) {
        var S = fe.flags;
        if (S & 36 && m4e(y, fe.alternate, fe), S & 128) {
          x = void 0;
          var T = fe.ref;
          if (T !== null) {
            var R = fe.stateNode;
            switch (fe.tag) {
              case 5:
                x = R;
                break;
              default:
                x = R
            }
            typeof T == "function" ? T(x) : T.current = x
          }
        }
        fe = fe.nextEffect
      }
    } catch (I) {
      if (fe === null) throw Error(te(330));
      mo(fe, I), fe = fe.nextEffect
    }
    while (fe !== null);
    fe = null, i4e(), Se = i
  } else t.current = r;
  if (ko) ko = !1, Yh = t, _h = e;
  else
    for (fe = n; fe !== null;) e = fe.nextEffect, fe.nextEffect = null, fe.flags & 8 && (S = fe, S.sibling = null, S.stateNode = null), fe = e;
  if (n = t.pendingLanes, n === 0 && (oa = null), n === 1 ? t === nA ? qh++ : (qh = 0, nA = t) : qh = 0, r = r.stateNode, Bl && typeof Bl.onCommitFiberRoot == "function") try {
    Bl.onCommitFiberRoot(uk, r, void 0, (r.current.flags & 64) === 64)
  } catch {}
  if (Zn(t, gr()), l1) throw l1 = !1, t = eA, eA = null, t;
  return Se & 8 || Ra(), null
}

function _4e() {
  for (; fe !== null;) {
    var t = fe.alternate;
    Vv || Xh === null || (fe.flags & 8 ? zM(fe, Xh) && (Vv = !0) : fe.tag === 13 && v4e(t, fe) && zM(fe, Xh) && (Vv = !0));
    var e = fe.flags;
    e & 256 && g4e(t, fe), !(e & 512) || ko || (ko = !0, L0(97, function () {
      return Yo(), null
    })), fe = fe.nextEffect
  }
}

function Yo() {
  if (_h !== 90) {
    var t = 97 < _h ? 97 : _h;
    return _h = 90, Ql(t, w4e)
  }
  return !1
}

function T4e(t, e) {
  tA.push(e, t), ko || (ko = !0, L0(97, function () {
    return Yo(), null
  }))
}

function pY(t, e) {
  rA.push(e, t), ko || (ko = !0, L0(97, function () {
    return Yo(), null
  }))
}

function w4e() {
  if (Yh === null) return !1;
  var t = Yh;
  if (Yh = null, Se & 48) throw Error(te(331));
  var e = Se;
  Se |= 32;
  var r = rA;
  rA = [];
  for (var n = 0; n < r.length; n += 2) {
    var i = r[n],
      a = r[n + 1],
      s = i.destroy;
    if (i.destroy = void 0, typeof s == "function") try {
      s()
    } catch (c) {
      if (a === null) throw Error(te(330));
      mo(a, c)
    }
  }
  for (r = tA, tA = [], n = 0; n < r.length; n += 2) {
    i = r[n], a = r[n + 1];
    try {
      var o = i.create;
      i.destroy = o()
    } catch (c) {
      if (a === null) throw Error(te(330));
      mo(a, c)
    }
  }
  for (o = t.current.firstEffect; o !== null;) t = o.nextEffect, o.nextEffect = null, o.flags & 8 && (o.sibling = null, o.stateNode = null), o = t;
  return Se = e, Ra(), !0
}

function VF(t, e, r) {
  e = Sk(r, e), e = iY(t, e, 1), ho(t, e), e = _n(), t = Fb(t, 1), t !== null && (Cb(t, 1, e), Zn(t, e))
}

function mo(t, e) {
  if (t.tag === 3) VF(t, t, e);
  else
    for (var r = t.return; r !== null;) {
      if (r.tag === 3) {
        VF(r, t, e);
        break
      } else if (r.tag === 1) {
        var n = r.stateNode;
        if (typeof r.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (oa === null || !oa.has(n))) {
          t = Sk(e, t);
          var i = aY(r, t, 1);
          if (ho(r, i), i = _n(), r = Fb(r, 1), r !== null) Cb(r, 1, i), Zn(r, i);
          else if (typeof n.componentDidCatch == "function" && (oa === null || !oa.has(n))) try {
            n.componentDidCatch(e, t)
          } catch {}
          break
        }
      }
      r = r.return
    }
}

function R4e(t, e, r) {
  var n = t.pingCache;
  n !== null && n.delete(e), e = _n(), t.pingedLanes |= t.suspendedLanes & r, $r === t && (vr & r) === r && (tr === 4 || tr === 3 && (vr & 62914560) === vr && 500 > gr() - wk ? Hu(t, 0) : Tk |= r), Zn(t, e)
}

function A4e(t, e) {
  var r = t.stateNode;
  r !== null && r.delete(e), e = 0, e === 0 && (e = t.mode, e & 2 ? e & 4 ? (Ka === 0 && (Ka = ed), e = ou(62914560 & ~Ka), e === 0 && (e = 4194304)) : e = mf() === 99 ? 1 : 2 : e = 1), r = _n(), t = Fb(t, e), t !== null && (Cb(t, e, r), Zn(t, r))
}
var gY;
gY = function (t, e, r) {
  var n = e.lanes;
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || en.current) Ri = !0;
    else if (r & n) Ri = !!(t.flags & 16384);
  else {
    switch (Ri = !1, e.tag) {
      case 3:
        kF(e), oT();
        break;
      case 5:
        SF(e);
        break;
      case 1:
        tn(e.type) && jv(e);
        break;
      case 4:
        HR(e, e.stateNode.containerInfo);
        break;
      case 10:
        n = e.memoizedProps.value;
        var i = e.type._context;
        St(Xy, i._currentValue), i._currentValue = n;
        break;
      case 13:
        if (e.memoizedState !== null) return r & e.child.childLanes ? OF(t, e, r) : (St(Et, Et.current & 1), e = qa(t, e, r), e !== null ? e.sibling : null);
        St(Et, Et.current & 1);
        break;
      case 19:
        if (n = (r & e.childLanes) !== 0, t.flags & 64) {
          if (n) return MF(t, e, r);
          e.flags |= 64
        }
        if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), St(Et, Et.current), n) break;
        return null;
      case 23:
      case 24:
        return e.lanes = 0, lT(t, e, r)
    }
    return qa(t, e, r)
  } else Ri = !1;
  switch (e.lanes = 0, e.tag) {
    case 2:
      if (n = e.type, t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps, i = gf(e, xr.current), Bu(e, r), i = yk(null, e, n, t, i, r), e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0) {
        if (e.tag = 1, e.memoizedState = null, e.updateQueue = null, tn(n)) {
          var a = !0;
          jv(e)
        } else a = !1;
        e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, pk(e);
        var s = n.getDerivedStateFromProps;
        typeof s == "function" && Jy(e, n, s, t), i.updater = Db, e.stateNode = i, i._reactInternals = e, jR(e, n, t, r), e = WR(null, e, n, !0, a, r)
      } else e.tag = 0, Gr(null, e, i, r), e = e.child;
      return e;
    case 16:
      i = e.elementType;
      e: {
        switch (t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps, a = i._init, i = a(i._payload), e.type = i, a = e.tag = $4e(i), t = xi(i, t), a) {
          case 0:
            e = VR(null, e, i, t, r);
            break e;
          case 1:
            e = CF(null, e, i, t, r);
            break e;
          case 11:
            e = IF(null, e, i, t, r);
            break e;
          case 14:
            e = $F(null, e, i, xi(i.type, t), n, r);
            break e
        }
        throw Error(te(306, i, ""))
      }
      return e;
    case 0:
      return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : xi(n, i), VR(t, e, n, i, r);
    case 1:
      return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : xi(n, i), CF(t, e, n, i, r);
    case 3:
      if (kF(e), n = e.updateQueue, t === null || n === null) throw Error(te(282));
      if (n = e.pendingProps, i = e.memoizedState, i = i !== null ? i.element : null, UK(t, e), P0(e, n, null, r), n = e.memoizedState.element, n === i) oT(), e = qa(t, e, r);
      else {
        if (i = e.stateNode, (a = i.hydrate) && (to = Fu(e.stateNode.containerInfo.firstChild), Ya = e, a = ua = !0), a) {
          if (t = i.mutableSourceEagerHydrationData, t != null)
            for (i = 0; i < t.length; i += 2) a = t[i], a._workInProgressVersionPrimary = t[i + 1], Uu.push(a);
          for (r = GK(e, null, n, r), e.child = r; r;) r.flags = r.flags & -3 | 1024, r = r.sibling
        } else Gr(t, e, n, r), oT();
        e = e.child
      }
      return e;
    case 5:
      return SF(e), t === null && zR(e), n = e.type, i = e.pendingProps, a = t !== null ? t.memoizedProps : null, s = i.children, MR(n, i) ? s = null : a !== null && MR(n, a) && (e.flags |= 16), eY(t, e), Gr(t, e, s, r), e.child;
    case 6:
      return t === null && zR(e), null;
    case 13:
      return OF(t, e, r);
    case 4:
      return HR(e, e.stateNode.containerInfo), n = e.pendingProps, t === null ? e.child = e1(e, null, n, r) : Gr(t, e, n, r), e.child;
    case 11:
      return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : xi(n, i), IF(t, e, n, i, r);
    case 7:
      return Gr(t, e, e.pendingProps, r), e.child;
    case 8:
      return Gr(t, e, e.pendingProps.children, r), e.child;
    case 12:
      return Gr(t, e, e.pendingProps.children, r), e.child;
    case 10:
      e: {
        n = e.type._context,
        i = e.pendingProps,
        s = e.memoizedProps,
        a = i.value;
        var o = e.type._context;
        if (St(Xy, o._currentValue), o._currentValue = a, s !== null)
          if (o = s.value, a = Vn(o, a) ? 0 : (typeof n._calculateChangedBits == "function" ? n._calculateChangedBits(o, a) : 1073741823) | 0, a === 0) {
            if (s.children === i.children && !en.current) {
              e = qa(t, e, r);
              break e
            }
          } else
            for (o = e.child, o !== null && (o.return = e); o !== null;) {
              var c = o.dependencies;
              if (c !== null) {
                s = o.child;
                for (var l = c.firstContext; l !== null;) {
                  if (l.context === n && l.observedBits & a) {
                    o.tag === 1 && (l = fo(-1, r & -r), l.tag = 2, ho(o, l)), o.lanes |= r, l = o.alternate, l !== null && (l.lanes |= r), BK(o.return, r), c.lanes |= r;
                    break
                  }
                  l = l.next
                }
              } else s = o.tag === 10 && o.type === e.type ? null : o.child;
              if (s !== null) s.return = o;
              else
                for (s = o; s !== null;) {
                  if (s === e) {
                    s = null;
                    break
                  }
                  if (o = s.sibling, o !== null) {
                    o.return = s.return, s = o;
                    break
                  }
                  s = s.return
                }
              o = s
            }
        Gr(t, e, i.children, r),
        e = e.child
      }
      return e;
    case 9:
      return i = e.type, a = e.pendingProps, n = a.children, Bu(e, r), i = Qn(i, a.unstable_observedBits), n = n(i), e.flags |= 1, Gr(t, e, n, r), e.child;
    case 14:
      return i = e.type, a = xi(i, e.pendingProps), a = xi(i.type, a), $F(t, e, i, a, n, r);
    case 15:
      return JK(t, e, e.type, e.pendingProps, n, r);
    case 17:
      return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : xi(n, i), t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), e.tag = 1, tn(n) ? (t = !0, jv(e)) : t = !1, Bu(e, r), HK(e, n, i), jR(e, n, i, r), WR(null, e, n, !0, t, r);
    case 19:
      return MF(t, e, r);
    case 23:
      return lT(t, e, r);
    case 24:
      return lT(t, e, r)
  }
  throw Error(te(156, e.tag))
};

function I4e(t, e, r, n) {
  this.tag = t, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Wn(t, e, r, n) {
  return new I4e(t, e, r, n)
}

function Ak(t) {
  return t = t.prototype, !(!t || !t.isReactComponent)
}

function $4e(t) {
  if (typeof t == "function") return Ak(t) ? 1 : 0;
  if (t != null) {
    if (t = t.$$typeof, t === Ab) return 11;
    if (t === Ib) return 14
  }
  return 2
}

function Oo(t, e) {
  var r = t.alternate;
  return r === null ? (r = Wn(t.tag, e, t.key, t.mode), r.elementType = t.elementType, r.type = t.type, r.stateNode = t.stateNode, r.alternate = t, t.alternate = r) : (r.pendingProps = e, r.type = t.type, r.flags = 0, r.nextEffect = null, r.firstEffect = null, r.lastEffect = null), r.childLanes = t.childLanes, r.lanes = t.lanes, r.child = t.child, r.memoizedProps = t.memoizedProps, r.memoizedState = t.memoizedState, r.updateQueue = t.updateQueue, e = t.dependencies, r.dependencies = e === null ? null : {
    lanes: e.lanes,
    firstContext: e.firstContext
  }, r.sibling = t.sibling, r.index = t.index, r.ref = t.ref, r
}

function Wv(t, e, r, n, i, a) {
  var s = 2;
  if (n = t, typeof t == "function") Ak(t) && (s = 1);
  else if (typeof t == "string") s = 5;
  else e: switch (t) {
    case Ks:
      return zu(r.children, i, a, e);
    case VW:
      s = 8, i |= 16;
      break;
    case zC:
      s = 8, i |= 1;
      break;
    case Bh:
      return t = Wn(12, r, e, i | 8), t.elementType = Bh, t.type = Bh, t.lanes = a, t;
    case Uh:
      return t = Wn(13, r, e, i), t.type = Uh, t.elementType = Uh, t.lanes = a, t;
    case jy:
      return t = Wn(19, r, e, i), t.elementType = jy, t.lanes = a, t;
    case qC:
      return Ik(r, i, a, e);
    case xR:
      return t = Wn(24, r, e, i), t.elementType = xR, t.lanes = a, t;
    default:
      if (typeof t == "object" && t !== null) switch (t.$$typeof) {
        case GC:
          s = 10;
          break e;
        case VC:
          s = 9;
          break e;
        case Ab:
          s = 11;
          break e;
        case Ib:
          s = 14;
          break e;
        case WC:
          s = 16, n = null;
          break e;
        case KC:
          s = 22;
          break e
      }
      throw Error(te(130, t == null ? t : typeof t, ""))
  }
  return e = Wn(s, r, e, i), e.elementType = t, e.type = n, e.lanes = a, e
}

function zu(t, e, r, n) {
  return t = Wn(7, t, n, e), t.lanes = r, t
}

function Ik(t, e, r, n) {
  return t = Wn(23, t, n, e), t.elementType = qC, t.lanes = r, t
}

function fT(t, e, r) {
  return t = Wn(6, t, null, e), t.lanes = r, t
}

function dT(t, e, r) {
  return e = Wn(4, t.children !== null ? t.children : [], t.key, e), e.lanes = r, e.stateNode = {
    containerInfo: t.containerInfo,
    pendingChildren: null,
    implementation: t.implementation
  }, e
}

function C4e(t, e, r) {
  this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = r, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = q_(0), this.expirationTimes = q_(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = q_(0), this.mutableSourceEagerHydrationData = null
}

function k4e(t, e, r) {
  var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Al,
    key: n == null ? null : "" + n,
    children: t,
    containerInfo: e,
    implementation: r
  }
}

function c1(t, e, r, n) {
  var i = e.current,
    a = _n(),
    s = po(i);
  e: if (r) {
    r = r._reactInternals;
    t: {
      if (mc(r) !== r || r.tag !== 1) throw Error(te(170));
      var o = r;do {
        switch (o.tag) {
          case 3:
            o = o.stateNode.context;
            break t;
          case 1:
            if (tn(o.type)) {
              o = o.stateNode.__reactInternalMemoizedMergedChildContext;
              break t
            }
        }
        o = o.return
      } while (o !== null);
      throw Error(te(171))
    }
    if (r.tag === 1) {
      var c = r.type;
      if (tn(c)) {
        r = OK(r, c, o);
        break e
      }
    }
    r = o
  } else r = Co;
  return e.context === null ? e.context = r : e.pendingContext = r, e = fo(a, s), e.payload = {
    element: t
  }, n = n === void 0 ? null : n, n !== null && (e.callback = n), ho(i, e), go(i, s, a), s
}

function hT(t) {
  if (t = t.current, !t.child) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode
  }
}

function WF(t, e) {
  if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
    var r = t.retryLane;
    t.retryLane = r !== 0 && r < e ? r : e
  }
}

function $k(t, e) {
  WF(t, e), (t = t.alternate) && WF(t, e)
}

function O4e() {
  return null
}

function Ck(t, e, r) {
  var n = r != null && r.hydrationOptions != null && r.hydrationOptions.mutableSources || null;
  if (r = new C4e(t, e, r != null && r.hydrate === !0), e = Wn(3, null, null, e === 2 ? 7 : e === 1 ? 3 : 0), r.current = e, e.stateNode = r, pk(e), t[Jf] = r.current, AK(t.nodeType === 8 ? t.parentNode : t), n)
    for (t = 0; t < n.length; t++) {
      e = n[t];
      var i = e._getVersion;
      i = i(e._source), r.mutableSourceEagerHydrationData == null ? r.mutableSourceEagerHydrationData = [e, i] : r.mutableSourceEagerHydrationData.push(e, i)
    }
  this._internalRoot = r
}
Ck.prototype.render = function (t) {
  c1(t, this._internalRoot, null, null)
};
Ck.prototype.unmount = function () {
  var t = this._internalRoot,
    e = t.containerInfo;
  c1(null, t, null, function () {
    e[Jf] = null
  })
};

function ig(t) {
  return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function L4e(t, e) {
  if (e || (e = t ? t.nodeType === 9 ? t.documentElement : t.firstChild : null, e = !(!e || e.nodeType !== 1 || !e.hasAttribute("data-reactroot"))), !e)
    for (var r; r = t.lastChild;) t.removeChild(r);
  return new Ck(t, 0, e ? {
    hydrate: !0
  } : void 0)
}

function Bb(t, e, r, n, i) {
  var a = r._reactRootContainer;
  if (a) {
    var s = a._internalRoot;
    if (typeof i == "function") {
      var o = i;
      i = function () {
        var l = hT(s);
        o.call(l)
      }
    }
    c1(e, s, t, i)
  } else {
    if (a = r._reactRootContainer = L4e(r, n), s = a._internalRoot, typeof i == "function") {
      var c = i;
      i = function () {
        var l = hT(s);
        c.call(l)
      }
    }
    cY(function () {
      c1(e, s, t, i)
    })
  }
  return hT(s)
}
sK = function (t) {
  if (t.tag === 13) {
    var e = _n();
    go(t, 4, e), $k(t, 4)
  }
};
ek = function (t) {
  if (t.tag === 13) {
    var e = _n();
    go(t, 67108864, e), $k(t, 67108864)
  }
};
oK = function (t) {
  if (t.tag === 13) {
    var e = _n(),
      r = po(t);
    go(t, r, e), $k(t, r)
  }
};
lK = function (t, e) {
  return e()
};
$R = function (t, e, r) {
  switch (e) {
    case "input":
      if (ER(t, r), e = r.name, r.type === "radio" && e != null) {
        for (r = t; r.parentNode;) r = r.parentNode;
        for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < r.length; e++) {
          var n = r[e];
          if (n !== t && n.form === t.form) {
            var i = Pb(n);
            if (!i) throw Error(te(90));
            KW(n), ER(n, i)
          }
        }
      }
      break;
    case "textarea":
      qW(t, r);
      break;
    case "select":
      e = r.value, e != null && Nu(t, !!r.multiple, e, !1)
  }
};
QC = lY;
rK = function (t, e, r, n, i) {
  var a = Se;
  Se |= 4;
  try {
    return Ql(98, t.bind(null, e, r, n, i))
  } finally {
    Se = a, Se === 0 && (rd(), Ra())
  }
};
ZC = function () {
  !(Se & 49) && (x4e(), Yo())
};
nK = function (t, e) {
  var r = Se;
  Se |= 2;
  try {
    return t(e)
  } finally {
    Se = r, Se === 0 && (rd(), Ra())
  }
};

function mY(t, e) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ig(e)) throw Error(te(200));
  return k4e(t, e, null, r)
}
var P4e = {
    Events: [tg, xu, Pb, eK, tK, Yo, {
      current: !1
    }]
  },
  Qd = {
    findFiberByHostInstance: $l,
    bundleType: 0,
    version: "17.0.2",
    rendererPackageName: "react-dom"
  },
  N4e = {
    bundleType: Qd.bundleType,
    version: Qd.version,
    rendererPackageName: Qd.rendererPackageName,
    rendererConfig: Qd.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: gc.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return t = aK(t), t === null ? null : t.stateNode
    },
    findFiberByHostInstance: Qd.findFiberByHostInstance || O4e,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Pm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Pm.isDisabled && Pm.supportsFiber) try {
    uk = Pm.inject(N4e), Bl = Pm
  } catch {}
}
li.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = P4e;
li.createPortal = mY;
li.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0) throw typeof t.render == "function" ? Error(te(188)) : Error(te(268, Object.keys(t)));
  return t = aK(e), t = t === null ? null : t.stateNode, t
};
li.flushSync = function (t, e) {
  var r = Se;
  if (r & 48) return t(e);
  Se |= 1;
  try {
    if (t) return Ql(99, t.bind(null, e))
  } finally {
    Se = r, Ra()
  }
};
li.hydrate = function (t, e, r) {
  if (!ig(e)) throw Error(te(200));
  return Bb(null, t, e, !0, r)
};
li.render = function (t, e, r) {
  if (!ig(e)) throw Error(te(200));
  return Bb(null, t, e, !1, r)
};
li.unmountComponentAtNode = function (t) {
  if (!ig(t)) throw Error(te(40));
  return t._reactRootContainer ? (cY(function () {
    Bb(null, null, t, !1, function () {
      t._reactRootContainer = null, t[Jf] = null
    })
  }), !0) : !1
};
li.unstable_batchedUpdates = lY;
li.unstable_createPortal = function (t, e) {
  return mY(t, e, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null)
};
li.unstable_renderSubtreeIntoContainer = function (t, e, r, n) {
  if (!ig(r)) throw Error(te(200));
  if (t == null || t._reactInternals === void 0) throw Error(te(38));
  return Bb(t, e, r, !1, n)
};
li.version = "17.0.2";
(function (t) {
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
    } catch (r) {
      console.error(r)
    }
  }
  e(), t.exports = li
})(UDe);
const D4e = PI(ql);

function u1(t, e) {
  return u1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, i) {
    return n.__proto__ = i, n
  }, u1(t, e)
}

function ga(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, u1(t, e)
}
var be = {},
  M4e = {
    get exports() {
      return be
    },
    set exports(t) {
      be = t
    }
  },
  F4e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  B4e = F4e,
  U4e = B4e;

function vY() {}

function yY() {}
yY.resetWarningCache = vY;
var j4e = function () {
  function t(n, i, a, s, o, c) {
    if (c !== U4e) {
      var l = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      throw l.name = "Invariant Violation", l
    }
  }
  t.isRequired = t;

  function e() {
    return t
  }
  var r = {
    array: t,
    bigint: t,
    bool: t,
    func: t,
    number: t,
    object: t,
    string: t,
    symbol: t,
    any: t,
    arrayOf: e,
    element: t,
    elementType: t,
    instanceOf: e,
    node: t,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: yY,
    resetWarningCache: vY
  };
  return r.PropTypes = r, r
};
M4e.exports = j4e();

function ir() {
  return ir = Object.assign ? Object.assign.bind() : function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
    }
    return t
  }, ir.apply(this, arguments)
}

function Nm(t) {
  return t.charAt(0) === "/"
}

function pT(t, e) {
  for (var r = e, n = r + 1, i = t.length; n < i; r += 1, n += 1) t[r] = t[n];
  t.pop()
}

function H4e(t, e) {
  e === void 0 && (e = "");
  var r = t && t.split("/") || [],
    n = e && e.split("/") || [],
    i = t && Nm(t),
    a = e && Nm(e),
    s = i || a;
  if (t && Nm(t) ? n = r : r.length && (n.pop(), n = n.concat(r)), !n.length) return "/";
  var o;
  if (n.length) {
    var c = n[n.length - 1];
    o = c === "." || c === ".." || c === ""
  } else o = !1;
  for (var l = 0, u = n.length; u >= 0; u--) {
    var f = n[u];
    f === "." ? pT(n, u) : f === ".." ? (pT(n, u), l++) : l && (pT(n, u), l--)
  }
  if (!s)
    for (; l--; l) n.unshift("..");
  s && n[0] !== "" && (!n[0] || !Nm(n[0])) && n.unshift("");
  var d = n.join("/");
  return o && d.substr(-1) !== "/" && (d += "/"), d
}

function KF(t) {
  return t.valueOf ? t.valueOf() : Object.prototype.valueOf.call(t)
}

function Kv(t, e) {
  if (t === e) return !0;
  if (t == null || e == null) return !1;
  if (Array.isArray(t)) return Array.isArray(e) && t.length === e.length && t.every(function (i, a) {
    return Kv(i, e[a])
  });
  if (typeof t == "object" || typeof e == "object") {
    var r = KF(t),
      n = KF(e);
    return r !== t || n !== e ? Kv(r, n) : Object.keys(Object.assign({}, t, e)).every(function (i) {
      return Kv(t[i], e[i])
    })
  }
  return !1
}
var z4e = !0,
  gT = "Invariant failed";

function qo(t, e) {
  if (!t) {
    if (z4e) throw new Error(gT);
    var r = typeof e == "function" ? e() : e,
      n = r ? "".concat(gT, ": ").concat(r) : gT;
    throw new Error(n)
  }
}

function Qh(t) {
  return t.charAt(0) === "/" ? t : "/" + t
}

function YF(t) {
  return t.charAt(0) === "/" ? t.substr(1) : t
}

function G4e(t, e) {
  return t.toLowerCase().indexOf(e.toLowerCase()) === 0 && "/?#".indexOf(t.charAt(e.length)) !== -1
}

function xY(t, e) {
  return G4e(t, e) ? t.substr(e.length) : t
}

function bY(t) {
  return t.charAt(t.length - 1) === "/" ? t.slice(0, -1) : t
}

function V4e(t) {
  var e = t || "/",
    r = "",
    n = "",
    i = e.indexOf("#");
  i !== -1 && (n = e.substr(i), e = e.substr(0, i));
  var a = e.indexOf("?");
  return a !== -1 && (r = e.substr(a), e = e.substr(0, a)), {
    pathname: e,
    search: r === "?" ? "" : r,
    hash: n === "#" ? "" : n
  }
}

function Vr(t) {
  var e = t.pathname,
    r = t.search,
    n = t.hash,
    i = e || "/";
  return r && r !== "?" && (i += r.charAt(0) === "?" ? r : "?" + r), n && n !== "#" && (i += n.charAt(0) === "#" ? n : "#" + n), i
}

function Rr(t, e, r, n) {
  var i;
  typeof t == "string" ? (i = V4e(t), i.state = e) : (i = ir({}, t), i.pathname === void 0 && (i.pathname = ""), i.search ? i.search.charAt(0) !== "?" && (i.search = "?" + i.search) : i.search = "", i.hash ? i.hash.charAt(0) !== "#" && (i.hash = "#" + i.hash) : i.hash = "", e !== void 0 && i.state === void 0 && (i.state = e));
  try {
    i.pathname = decodeURI(i.pathname)
  } catch (a) {
    throw a instanceof URIError ? new URIError('Pathname "' + i.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : a
  }
  return r && (i.key = r), n ? i.pathname ? i.pathname.charAt(0) !== "/" && (i.pathname = H4e(i.pathname, n.pathname)) : i.pathname = n.pathname : i.pathname || (i.pathname = "/"), i
}

function W4e(t, e) {
  return t.pathname === e.pathname && t.search === e.search && t.hash === e.hash && t.key === e.key && Kv(t.state, e.state)
}

function kk() {
  var t = null;

  function e(s) {
    return t = s,
      function () {
        t === s && (t = null)
      }
  }

  function r(s, o, c, l) {
    if (t != null) {
      var u = typeof t == "function" ? t(s, o) : t;
      typeof u == "string" ? typeof c == "function" ? c(u, l) : l(!0) : l(u !== !1)
    } else l(!0)
  }
  var n = [];

  function i(s) {
    var o = !0;

    function c() {
      o && s.apply(void 0, arguments)
    }
    return n.push(c),
      function () {
        o = !1, n = n.filter(function (l) {
          return l !== c
        })
      }
  }

  function a() {
    for (var s = arguments.length, o = new Array(s), c = 0; c < s; c++) o[c] = arguments[c];
    n.forEach(function (l) {
      return l.apply(void 0, o)
    })
  }
  return {
    setPrompt: e,
    confirmTransitionTo: r,
    appendListener: i,
    notifyListeners: a
  }
}
var EY = !!(typeof window < "u" && window.document && window.document.createElement);

function SY(t, e) {
  e(window.confirm(t))
}

function K4e() {
  var t = window.navigator.userAgent;
  return (t.indexOf("Android 2.") !== -1 || t.indexOf("Android 4.0") !== -1) && t.indexOf("Mobile Safari") !== -1 && t.indexOf("Chrome") === -1 && t.indexOf("Windows Phone") === -1 ? !1 : window.history && "pushState" in window.history
}

function Y4e() {
  return window.navigator.userAgent.indexOf("Trident") === -1
}

function q4e() {
  return window.navigator.userAgent.indexOf("Firefox") === -1
}

function X4e(t) {
  return t.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1
}
var qF = "popstate",
  XF = "hashchange";

function QF() {
  try {
    return window.history.state || {}
  } catch {
    return {}
  }
}

function Q4e(t) {
  t === void 0 && (t = {}), EY || qo(!1);
  var e = window.history,
    r = K4e(),
    n = !Y4e(),
    i = t,
    a = i.forceRefresh,
    s = a === void 0 ? !1 : a,
    o = i.getUserConfirmation,
    c = o === void 0 ? SY : o,
    l = i.keyLength,
    u = l === void 0 ? 6 : l,
    f = t.basename ? bY(Qh(t.basename)) : "";

  function d(U) {
    var W = U || {},
      k = W.key,
      O = W.state,
      F = window.location,
      D = F.pathname,
      Q = F.search,
      ee = F.hash,
      de = D + Q + ee;
    return f && (de = xY(de, f)), Rr(de, O, k)
  }

  function h() {
    return Math.random().toString(36).substr(2, u)
  }
  var p = kk();

  function v(U) {
    ir(M, U), M.length = e.length, p.notifyListeners(M.location, M.action)
  }

  function g(U) {
    X4e(U) || x(d(U.state))
  }

  function m() {
    x(d(QF()))
  }
  var y = !1;

  function x(U) {
    if (y) y = !1, v();
    else {
      var W = "POP";
      p.confirmTransitionTo(U, W, c, function (k) {
        k ? v({
          action: W,
          location: U
        }) : b(U)
      })
    }
  }

  function b(U) {
    var W = M.location,
      k = S.indexOf(W.key);
    k === -1 && (k = 0);
    var O = S.indexOf(U.key);
    O === -1 && (O = 0);
    var F = k - O;
    F && (y = !0, w(F))
  }
  var _ = d(QF()),
    S = [_.key];

  function T(U) {
    return f + Vr(U)
  }

  function R(U, W) {
    var k = "PUSH",
      O = Rr(U, W, h(), M.location);
    p.confirmTransitionTo(O, k, c, function (F) {
      if (F) {
        var D = T(O),
          Q = O.key,
          ee = O.state;
        if (r)
          if (e.pushState({
              key: Q,
              state: ee
            }, null, D), s) window.location.href = D;
          else {
            var de = S.indexOf(M.location.key),
              oe = S.slice(0, de + 1);
            oe.push(O.key), S = oe, v({
              action: k,
              location: O
            })
          }
        else window.location.href = D
      }
    })
  }

  function I(U, W) {
    var k = "REPLACE",
      O = Rr(U, W, h(), M.location);
    p.confirmTransitionTo(O, k, c, function (F) {
      if (F) {
        var D = T(O),
          Q = O.key,
          ee = O.state;
        if (r)
          if (e.replaceState({
              key: Q,
              state: ee
            }, null, D), s) window.location.replace(D);
          else {
            var de = S.indexOf(M.location.key);
            de !== -1 && (S[de] = O.key), v({
              action: k,
              location: O
            })
          }
        else window.location.replace(D)
      }
    })
  }

  function w(U) {
    e.go(U)
  }

  function C() {
    w(-1)
  }

  function L() {
    w(1)
  }
  var H = 0;

  function N(U) {
    H += U, H === 1 && U === 1 ? (window.addEventListener(qF, g), n && window.addEventListener(XF, m)) : H === 0 && (window.removeEventListener(qF, g), n && window.removeEventListener(XF, m))
  }
  var P = !1;

  function B(U) {
    U === void 0 && (U = !1);
    var W = p.setPrompt(U);
    return P || (N(1), P = !0),
      function () {
        return P && (P = !1, N(-1)), W()
      }
  }

  function V(U) {
    var W = p.appendListener(U);
    return N(1),
      function () {
        N(-1), W()
      }
  }
  var M = {
    length: e.length,
    action: "POP",
    location: _,
    createHref: T,
    push: R,
    replace: I,
    go: w,
    goBack: C,
    goForward: L,
    block: B,
    listen: V
  };
  return M
}
var ZF = "hashchange",
  Z4e = {
    hashbang: {
      encodePath: function (e) {
        return e.charAt(0) === "!" ? e : "!/" + YF(e)
      },
      decodePath: function (e) {
        return e.charAt(0) === "!" ? e.substr(1) : e
      }
    },
    noslash: {
      encodePath: YF,
      decodePath: Qh
    },
    slash: {
      encodePath: Qh,
      decodePath: Qh
    }
  };

function _Y(t) {
  var e = t.indexOf("#");
  return e === -1 ? t : t.slice(0, e)
}

function Zd() {
  var t = window.location.href,
    e = t.indexOf("#");
  return e === -1 ? "" : t.substring(e + 1)
}

function J4e(t) {
  window.location.hash = t
}

function mT(t) {
  window.location.replace(_Y(window.location.href) + "#" + t)
}

function e8e(t) {
  t === void 0 && (t = {}), EY || qo(!1);
  var e = window.history;
  q4e();
  var r = t,
    n = r.getUserConfirmation,
    i = n === void 0 ? SY : n,
    a = r.hashType,
    s = a === void 0 ? "slash" : a,
    o = t.basename ? bY(Qh(t.basename)) : "",
    c = Z4e[s],
    l = c.encodePath,
    u = c.decodePath;

  function f() {
    var W = u(Zd());
    return o && (W = xY(W, o)), Rr(W)
  }
  var d = kk();

  function h(W) {
    ir(U, W), U.length = e.length, d.notifyListeners(U.location, U.action)
  }
  var p = !1,
    v = null;

  function g(W, k) {
    return W.pathname === k.pathname && W.search === k.search && W.hash === k.hash
  }

  function m() {
    var W = Zd(),
      k = l(W);
    if (W !== k) mT(k);
    else {
      var O = f(),
        F = U.location;
      if (!p && g(F, O) || v === Vr(O)) return;
      v = null, y(O)
    }
  }

  function y(W) {
    if (p) p = !1, h();
    else {
      var k = "POP";
      d.confirmTransitionTo(W, k, i, function (O) {
        O ? h({
          action: k,
          location: W
        }) : x(W)
      })
    }
  }

  function x(W) {
    var k = U.location,
      O = T.lastIndexOf(Vr(k));
    O === -1 && (O = 0);
    var F = T.lastIndexOf(Vr(W));
    F === -1 && (F = 0);
    var D = O - F;
    D && (p = !0, C(D))
  }
  var b = Zd(),
    _ = l(b);
  b !== _ && mT(_);
  var S = f(),
    T = [Vr(S)];

  function R(W) {
    var k = document.querySelector("base"),
      O = "";
    return k && k.getAttribute("href") && (O = _Y(window.location.href)), O + "#" + l(o + Vr(W))
  }

  function I(W, k) {
    var O = "PUSH",
      F = Rr(W, void 0, void 0, U.location);
    d.confirmTransitionTo(F, O, i, function (D) {
      if (D) {
        var Q = Vr(F),
          ee = l(o + Q),
          de = Zd() !== ee;
        if (de) {
          v = Q, J4e(ee);
          var oe = T.lastIndexOf(Vr(U.location)),
            rt = T.slice(0, oe + 1);
          rt.push(Q), T = rt, h({
            action: O,
            location: F
          })
        } else h()
      }
    })
  }

  function w(W, k) {
    var O = "REPLACE",
      F = Rr(W, void 0, void 0, U.location);
    d.confirmTransitionTo(F, O, i, function (D) {
      if (D) {
        var Q = Vr(F),
          ee = l(o + Q),
          de = Zd() !== ee;
        de && (v = Q, mT(ee));
        var oe = T.indexOf(Vr(U.location));
        oe !== -1 && (T[oe] = Q), h({
          action: O,
          location: F
        })
      }
    })
  }

  function C(W) {
    e.go(W)
  }

  function L() {
    C(-1)
  }

  function H() {
    C(1)
  }
  var N = 0;

  function P(W) {
    N += W, N === 1 && W === 1 ? window.addEventListener(ZF, m) : N === 0 && window.removeEventListener(ZF, m)
  }
  var B = !1;

  function V(W) {
    W === void 0 && (W = !1);
    var k = d.setPrompt(W);
    return B || (P(1), B = !0),
      function () {
        return B && (B = !1, P(-1)), k()
      }
  }

  function M(W) {
    var k = d.appendListener(W);
    return P(1),
      function () {
        P(-1), k()
      }
  }
  var U = {
    length: e.length,
    action: "POP",
    location: S,
    createHref: R,
    push: I,
    replace: w,
    go: C,
    goBack: L,
    goForward: H,
    block: V,
    listen: M
  };
  return U
}

function JF(t, e, r) {
  return Math.min(Math.max(t, e), r)
}

function t8e(t) {
  t === void 0 && (t = {});
  var e = t,
    r = e.getUserConfirmation,
    n = e.initialEntries,
    i = n === void 0 ? ["/"] : n,
    a = e.initialIndex,
    s = a === void 0 ? 0 : a,
    o = e.keyLength,
    c = o === void 0 ? 6 : o,
    l = kk();

  function u(R) {
    ir(T, R), T.length = T.entries.length, l.notifyListeners(T.location, T.action)
  }

  function f() {
    return Math.random().toString(36).substr(2, c)
  }
  var d = JF(s, 0, i.length - 1),
    h = i.map(function (R) {
      return typeof R == "string" ? Rr(R, void 0, f()) : Rr(R, void 0, R.key || f())
    }),
    p = Vr;

  function v(R, I) {
    var w = "PUSH",
      C = Rr(R, I, f(), T.location);
    l.confirmTransitionTo(C, w, r, function (L) {
      if (L) {
        var H = T.index,
          N = H + 1,
          P = T.entries.slice(0);
        P.length > N ? P.splice(N, P.length - N, C) : P.push(C), u({
          action: w,
          location: C,
          index: N,
          entries: P
        })
      }
    })
  }

  function g(R, I) {
    var w = "REPLACE",
      C = Rr(R, I, f(), T.location);
    l.confirmTransitionTo(C, w, r, function (L) {
      L && (T.entries[T.index] = C, u({
        action: w,
        location: C
      }))
    })
  }

  function m(R) {
    var I = JF(T.index + R, 0, T.entries.length - 1),
      w = "POP",
      C = T.entries[I];
    l.confirmTransitionTo(C, w, r, function (L) {
      L ? u({
        action: w,
        location: C,
        index: I
      }) : u()
    })
  }

  function y() {
    m(-1)
  }

  function x() {
    m(1)
  }

  function b(R) {
    var I = T.index + R;
    return I >= 0 && I < T.entries.length
  }

  function _(R) {
    return R === void 0 && (R = !1), l.setPrompt(R)
  }

  function S(R) {
    return l.appendListener(R)
  }
  var T = {
    length: h.length,
    action: "POP",
    location: h[d],
    index: d,
    entries: h,
    createHref: p,
    push: v,
    replace: g,
    go: m,
    goBack: y,
    goForward: x,
    canGo: b,
    block: _,
    listen: S
  };
  return T
}
var Lo = {},
  r8e = {
    get exports() {
      return Lo
    },
    set exports(t) {
      Lo = t
    }
  },
  n8e = Array.isArray || function (t) {
    return Object.prototype.toString.call(t) == "[object Array]"
  },
  f1 = n8e;
r8e.exports = RY;
Lo.parse = Ok;
Lo.compile = a8e;
Lo.tokensToFunction = TY;
Lo.tokensToRegExp = wY;
var i8e = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"), "g");

function Ok(t, e) {
  for (var r = [], n = 0, i = 0, a = "", s = e && e.delimiter || "/", o;
    (o = i8e.exec(t)) != null;) {
    var c = o[0],
      l = o[1],
      u = o.index;
    if (a += t.slice(i, u), i = u + c.length, l) {
      a += l[1];
      continue
    }
    var f = t[i],
      d = o[2],
      h = o[3],
      p = o[4],
      v = o[5],
      g = o[6],
      m = o[7];
    a && (r.push(a), a = "");
    var y = d != null && f != null && f !== d,
      x = g === "+" || g === "*",
      b = g === "?" || g === "*",
      _ = o[2] || s,
      S = p || v;
    r.push({
      name: h || n++,
      prefix: d || "",
      delimiter: _,
      optional: b,
      repeat: x,
      partial: y,
      asterisk: !!m,
      pattern: S ? l8e(S) : m ? ".*" : "[^" + Yv(_) + "]+?"
    })
  }
  return i < t.length && (a += t.substr(i)), a && r.push(a), r
}

function a8e(t, e) {
  return TY(Ok(t, e), e)
}

function s8e(t) {
  return encodeURI(t).replace(/[\/?#]/g, function (e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase()
  })
}

function o8e(t) {
  return encodeURI(t).replace(/[?#]/g, function (e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase()
  })
}

function TY(t, e) {
  for (var r = new Array(t.length), n = 0; n < t.length; n++) typeof t[n] == "object" && (r[n] = new RegExp("^(?:" + t[n].pattern + ")$", Pk(e)));
  return function (i, a) {
    for (var s = "", o = i || {}, c = a || {}, l = c.pretty ? s8e : encodeURIComponent, u = 0; u < t.length; u++) {
      var f = t[u];
      if (typeof f == "string") {
        s += f;
        continue
      }
      var d = o[f.name],
        h;
      if (d == null)
        if (f.optional) {
          f.partial && (s += f.prefix);
          continue
        } else throw new TypeError('Expected "' + f.name + '" to be defined');
      if (f1(d)) {
        if (!f.repeat) throw new TypeError('Expected "' + f.name + '" to not repeat, but received `' + JSON.stringify(d) + "`");
        if (d.length === 0) {
          if (f.optional) continue;
          throw new TypeError('Expected "' + f.name + '" to not be empty')
        }
        for (var p = 0; p < d.length; p++) {
          if (h = l(d[p]), !r[u].test(h)) throw new TypeError('Expected all "' + f.name + '" to match "' + f.pattern + '", but received `' + JSON.stringify(h) + "`");
          s += (p === 0 ? f.prefix : f.delimiter) + h
        }
        continue
      }
      if (h = f.asterisk ? o8e(d) : l(d), !r[u].test(h)) throw new TypeError('Expected "' + f.name + '" to match "' + f.pattern + '", but received "' + h + '"');
      s += f.prefix + h
    }
    return s
  }
}

function Yv(t) {
  return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
}

function l8e(t) {
  return t.replace(/([=!:$\/()])/g, "\\$1")
}

function Lk(t, e) {
  return t.keys = e, t
}

function Pk(t) {
  return t && t.sensitive ? "" : "i"
}

function c8e(t, e) {
  var r = t.source.match(/\((?!\?)/g);
  if (r)
    for (var n = 0; n < r.length; n++) e.push({
      name: n,
      prefix: null,
      delimiter: null,
      optional: !1,
      repeat: !1,
      partial: !1,
      asterisk: !1,
      pattern: null
    });
  return Lk(t, e)
}

function u8e(t, e, r) {
  for (var n = [], i = 0; i < t.length; i++) n.push(RY(t[i], e, r).source);
  var a = new RegExp("(?:" + n.join("|") + ")", Pk(r));
  return Lk(a, e)
}

function f8e(t, e, r) {
  return wY(Ok(t, r), e, r)
}

function wY(t, e, r) {
  f1(e) || (r = e || r, e = []), r = r || {};
  for (var n = r.strict, i = r.end !== !1, a = "", s = 0; s < t.length; s++) {
    var o = t[s];
    if (typeof o == "string") a += Yv(o);
    else {
      var c = Yv(o.prefix),
        l = "(?:" + o.pattern + ")";
      e.push(o), o.repeat && (l += "(?:" + c + l + ")*"), o.optional ? o.partial ? l = c + "(" + l + ")?" : l = "(?:" + c + "(" + l + "))?" : l = c + "(" + l + ")", a += l
    }
  }
  var u = Yv(r.delimiter || "/"),
    f = a.slice(-u.length) === u;
  return n || (a = (f ? a.slice(0, -u.length) : a) + "(?:" + u + "(?=$))?"), i ? a += "$" : a += n && f ? "" : "(?=" + u + "|$)", Lk(new RegExp("^" + a, Pk(r)), e)
}

function RY(t, e, r) {
  return f1(e) || (r = e || r, e = []), r = r || {}, t instanceof RegExp ? c8e(t, e) : f1(t) ? u8e(t, e, r) : f8e(t, e, r)
}
var aA = {},
  d8e = {
    get exports() {
      return aA
    },
    set exports(t) {
      aA = t
    }
  },
  qe = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xt = typeof Symbol == "function" && Symbol.for,
  Nk = Xt ? Symbol.for("react.element") : 60103,
  Dk = Xt ? Symbol.for("react.portal") : 60106,
  Ub = Xt ? Symbol.for("react.fragment") : 60107,
  jb = Xt ? Symbol.for("react.strict_mode") : 60108,
  Hb = Xt ? Symbol.for("react.profiler") : 60114,
  zb = Xt ? Symbol.for("react.provider") : 60109,
  Gb = Xt ? Symbol.for("react.context") : 60110,
  Mk = Xt ? Symbol.for("react.async_mode") : 60111,
  Vb = Xt ? Symbol.for("react.concurrent_mode") : 60111,
  Wb = Xt ? Symbol.for("react.forward_ref") : 60112,
  Kb = Xt ? Symbol.for("react.suspense") : 60113,
  h8e = Xt ? Symbol.for("react.suspense_list") : 60120,
  Yb = Xt ? Symbol.for("react.memo") : 60115,
  qb = Xt ? Symbol.for("react.lazy") : 60116,
  p8e = Xt ? Symbol.for("react.block") : 60121,
  g8e = Xt ? Symbol.for("react.fundamental") : 60117,
  m8e = Xt ? Symbol.for("react.responder") : 60118,
  v8e = Xt ? Symbol.for("react.scope") : 60119;

function $n(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case Nk:
        switch (t = t.type, t) {
          case Mk:
          case Vb:
          case Ub:
          case Hb:
          case jb:
          case Kb:
            return t;
          default:
            switch (t = t && t.$$typeof, t) {
              case Gb:
              case Wb:
              case qb:
              case Yb:
              case zb:
                return t;
              default:
                return e
            }
        }
        case Dk:
          return e
    }
  }
}

function AY(t) {
  return $n(t) === Vb
}
qe.AsyncMode = Mk;
qe.ConcurrentMode = Vb;
qe.ContextConsumer = Gb;
qe.ContextProvider = zb;
qe.Element = Nk;
qe.ForwardRef = Wb;
qe.Fragment = Ub;
qe.Lazy = qb;
qe.Memo = Yb;
qe.Portal = Dk;
qe.Profiler = Hb;
qe.StrictMode = jb;
qe.Suspense = Kb;
qe.isAsyncMode = function (t) {
  return AY(t) || $n(t) === Mk
};
qe.isConcurrentMode = AY;
qe.isContextConsumer = function (t) {
  return $n(t) === Gb
};
qe.isContextProvider = function (t) {
  return $n(t) === zb
};
qe.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === Nk
};
qe.isForwardRef = function (t) {
  return $n(t) === Wb
};
qe.isFragment = function (t) {
  return $n(t) === Ub
};
qe.isLazy = function (t) {
  return $n(t) === qb
};
qe.isMemo = function (t) {
  return $n(t) === Yb
};
qe.isPortal = function (t) {
  return $n(t) === Dk
};
qe.isProfiler = function (t) {
  return $n(t) === Hb
};
qe.isStrictMode = function (t) {
  return $n(t) === jb
};
qe.isSuspense = function (t) {
  return $n(t) === Kb
};
qe.isValidElementType = function (t) {
  return typeof t == "string" || typeof t == "function" || t === Ub || t === Vb || t === Hb || t === jb || t === Kb || t === h8e || typeof t == "object" && t !== null && (t.$$typeof === qb || t.$$typeof === Yb || t.$$typeof === zb || t.$$typeof === Gb || t.$$typeof === Wb || t.$$typeof === g8e || t.$$typeof === m8e || t.$$typeof === v8e || t.$$typeof === p8e)
};
qe.typeOf = $n;
(function (t) {
  t.exports = qe
})(d8e);

function ag(t, e) {
  if (t == null) return {};
  var r = {},
    n = Object.keys(t),
    i, a;
  for (a = 0; a < n.length; a++) i = n[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r
}
var IY = aA,
  y8e = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  },
  x8e = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  },
  $Y = {};
$Y[IY.ForwardRef] = y8e;
$Y[IY.Memo] = x8e;
var vT = 1073741823,
  e6 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {};

function b8e() {
  var t = "__global_unique_id__";
  return e6[t] = (e6[t] || 0) + 1
}

function E8e(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e
}

function S8e(t) {
  var e = [];
  return {
    on: function (n) {
      e.push(n)
    },
    off: function (n) {
      e = e.filter(function (i) {
        return i !== n
      })
    },
    get: function () {
      return t
    },
    set: function (n, i) {
      t = n, e.forEach(function (a) {
        return a(t, i)
      })
    }
  }
}

function _8e(t) {
  return Array.isArray(t) ? t[0] : t
}

function T8e(t, e) {
  var r, n, i = "__create-react-context-" + b8e() + "__",
    a = function (o) {
      ga(c, o);

      function c() {
        for (var u, f = arguments.length, d = new Array(f), h = 0; h < f; h++) d[h] = arguments[h];
        return u = o.call.apply(o, [this].concat(d)) || this, u.emitter = S8e(u.props.value), u
      }
      var l = c.prototype;
      return l.getChildContext = function () {
        var f;
        return f = {}, f[i] = this.emitter, f
      }, l.componentWillReceiveProps = function (f) {
        if (this.props.value !== f.value) {
          var d = this.props.value,
            h = f.value,
            p;
          E8e(d, h) ? p = 0 : (p = typeof e == "function" ? e(d, h) : vT, p |= 0, p !== 0 && this.emitter.set(f.value, p))
        }
      }, l.render = function () {
        return this.props.children
      }, c
    }(ce.Component);
  a.childContextTypes = (r = {}, r[i] = be.object.isRequired, r);
  var s = function (o) {
    ga(c, o);

    function c() {
      for (var u, f = arguments.length, d = new Array(f), h = 0; h < f; h++) d[h] = arguments[h];
      return u = o.call.apply(o, [this].concat(d)) || this, u.observedBits = void 0, u.state = {
        value: u.getValue()
      }, u.onUpdate = function (p, v) {
        var g = u.observedBits | 0;
        g & v && u.setState({
          value: u.getValue()
        })
      }, u
    }
    var l = c.prototype;
    return l.componentWillReceiveProps = function (f) {
      var d = f.observedBits;
      this.observedBits = d ? ? vT
    }, l.componentDidMount = function () {
      this.context[i] && this.context[i].on(this.onUpdate);
      var f = this.props.observedBits;
      this.observedBits = f ? ? vT
    }, l.componentWillUnmount = function () {
      this.context[i] && this.context[i].off(this.onUpdate)
    }, l.getValue = function () {
      return this.context[i] ? this.context[i].get() : t
    }, l.render = function () {
      return _8e(this.props.children)(this.state.value)
    }, c
  }(ce.Component);
  return s.contextTypes = (n = {}, n[i] = be.object, n), {
    Provider: a,
    Consumer: s
  }
}
var w8e = ce.createContext || T8e,
  CY = function (e) {
    var r = w8e();
    return r.displayName = e, r
  },
  kY = CY("Router-History"),
  ma = CY("Router"),
  Xb = function (t) {
    ga(e, t), e.computeRootMatch = function (i) {
      return {
        path: "/",
        url: "/",
        params: {},
        isExact: i === "/"
      }
    };

    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.state = {
        location: n.history.location
      }, i._isMounted = !1, i._pendingLocation = null, n.staticContext || (i.unlisten = n.history.listen(function (a) {
        i._pendingLocation = a
      })), i
    }
    var r = e.prototype;
    return r.componentDidMount = function () {
      var i = this;
      this._isMounted = !0, this.unlisten && this.unlisten(), this.props.staticContext || (this.unlisten = this.props.history.listen(function (a) {
        i._isMounted && i.setState({
          location: a
        })
      })), this._pendingLocation && this.setState({
        location: this._pendingLocation
      })
    }, r.componentWillUnmount = function () {
      this.unlisten && (this.unlisten(), this._isMounted = !1, this._pendingLocation = null)
    }, r.render = function () {
      return ce.createElement(ma.Provider, {
        value: {
          history: this.props.history,
          location: this.state.location,
          match: e.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        }
      }, ce.createElement(kY.Provider, {
        children: this.props.children || null,
        value: this.props.history
      }))
    }, e
  }(ce.Component);
ce.Component;
var R8e = function (t) {
    ga(e, t);

    function e() {
      return t.apply(this, arguments) || this
    }
    var r = e.prototype;
    return r.componentDidMount = function () {
      this.props.onMount && this.props.onMount.call(this, this)
    }, r.componentDidUpdate = function (i) {
      this.props.onUpdate && this.props.onUpdate.call(this, this, i)
    }, r.componentWillUnmount = function () {
      this.props.onUnmount && this.props.onUnmount.call(this, this)
    }, r.render = function () {
      return null
    }, e
  }(ce.Component),
  yT = {},
  A8e = 1e4,
  t6 = 0;

function I8e(t) {
  if (yT[t]) return yT[t];
  var e = Lo.compile(t);
  return t6 < A8e && (yT[t] = e, t6++), e
}

function d1(t, e) {
  return t === void 0 && (t = "/"), e === void 0 && (e = {}), t === "/" ? t : I8e(t)(e, {
    pretty: !0
  })
}

function $8e(t) {
  var e = t.computedMatch,
    r = t.to,
    n = t.push,
    i = n === void 0 ? !1 : n;
  return ce.createElement(ma.Consumer, null, function (a) {
    a || qo(!1);
    var s = a.history,
      o = a.staticContext,
      c = i ? s.push : s.replace,
      l = Rr(e ? typeof r == "string" ? d1(r, e.params) : ir({}, r, {
        pathname: d1(r.pathname, e.params)
      }) : r);
    return o ? (c(l), null) : ce.createElement(R8e, {
      onMount: function () {
        c(l)
      },
      onUpdate: function (f, d) {
        var h = Rr(d.to);
        W4e(h, ir({}, l, {
          key: h.key
        })) || c(l)
      },
      to: r
    })
  })
}
var r6 = {},
  C8e = 1e4,
  n6 = 0;

function k8e(t, e) {
  var r = "" + e.end + e.strict + e.sensitive,
    n = r6[r] || (r6[r] = {});
  if (n[t]) return n[t];
  var i = [],
    a = Lo(t, i, e),
    s = {
      regexp: a,
      keys: i
    };
  return n6 < C8e && (n[t] = s, n6++), s
}

function Qb(t, e) {
  e === void 0 && (e = {}), (typeof e == "string" || Array.isArray(e)) && (e = {
    path: e
  });
  var r = e,
    n = r.path,
    i = r.exact,
    a = i === void 0 ? !1 : i,
    s = r.strict,
    o = s === void 0 ? !1 : s,
    c = r.sensitive,
    l = c === void 0 ? !1 : c,
    u = [].concat(n);
  return u.reduce(function (f, d) {
    if (!d && d !== "") return null;
    if (f) return f;
    var h = k8e(d, {
        end: a,
        strict: o,
        sensitive: l
      }),
      p = h.regexp,
      v = h.keys,
      g = p.exec(t);
    if (!g) return null;
    var m = g[0],
      y = g.slice(1),
      x = t === m;
    return a && !x ? null : {
      path: d,
      url: d === "/" && m === "" ? "/" : m,
      isExact: x,
      params: v.reduce(function (b, _, S) {
        return b[_.name] = y[S], b
      }, {})
    }
  }, null)
}

function O8e(t) {
  return ce.Children.count(t) === 0
}
var Ns = function (t) {
  ga(e, t);

  function e() {
    return t.apply(this, arguments) || this
  }
  var r = e.prototype;
  return r.render = function () {
    var i = this;
    return ce.createElement(ma.Consumer, null, function (a) {
      a || qo(!1);
      var s = i.props.location || a.location,
        o = i.props.computedMatch ? i.props.computedMatch : i.props.path ? Qb(s.pathname, i.props) : a.match,
        c = ir({}, a, {
          location: s,
          match: o
        }),
        l = i.props,
        u = l.children,
        f = l.component,
        d = l.render;
      return Array.isArray(u) && O8e(u) && (u = null), ce.createElement(ma.Provider, {
        value: c
      }, c.match ? u ? typeof u == "function" ? u(c) : u : f ? ce.createElement(f, c) : d ? d(c) : null : typeof u == "function" ? u(c) : null)
    })
  }, e
}(ce.Component);

function Fk(t) {
  return t.charAt(0) === "/" ? t : "/" + t
}

function L8e(t, e) {
  return t ? ir({}, e, {
    pathname: Fk(t) + e.pathname
  }) : e
}

function P8e(t, e) {
  if (!t) return e;
  var r = Fk(t);
  return e.pathname.indexOf(r) !== 0 ? e : ir({}, e, {
    pathname: e.pathname.substr(r.length)
  })
}

function i6(t) {
  return typeof t == "string" ? t : Vr(t)
}

function xT(t) {
  return function () {
    qo(!1)
  }
}

function a6() {}
ce.Component;
var N8e = function (t) {
    ga(e, t);

    function e() {
      return t.apply(this, arguments) || this
    }
    var r = e.prototype;
    return r.render = function () {
      var i = this;
      return ce.createElement(ma.Consumer, null, function (a) {
        a || qo(!1);
        var s = i.props.location || a.location,
          o, c;
        return ce.Children.forEach(i.props.children, function (l) {
          if (c == null && ce.isValidElement(l)) {
            o = l;
            var u = l.props.path || l.props.from;
            c = u ? Qb(s.pathname, ir({}, l.props, {
              path: u
            })) : a.match
          }
        }), c ? ce.cloneElement(o, {
          location: s,
          computedMatch: c
        }) : null
      })
    }, e
  }(ce.Component),
  Zb = ce.useContext;

function nd() {
  return Zb(kY)
}

function Bk() {
  return Zb(ma).location
}

function OY() {
  var t = Zb(ma).match;
  return t ? t.params : {}
}

function D8e(t) {
  var e = Bk(),
    r = Zb(ma).match;
  return t ? Qb(e.pathname, t) : r
}
var M8e = function (t) {
    ga(e, t);

    function e() {
      for (var n, i = arguments.length, a = new Array(i), s = 0; s < i; s++) a[s] = arguments[s];
      return n = t.call.apply(t, [this].concat(a)) || this, n.history = Q4e(n.props), n
    }
    var r = e.prototype;
    return r.render = function () {
      return ce.createElement(Xb, {
        history: this.history,
        children: this.props.children
      })
    }, e
  }(ce.Component),
  F8e = function (t) {
    ga(e, t);

    function e() {
      for (var n, i = arguments.length, a = new Array(i), s = 0; s < i; s++) a[s] = arguments[s];
      return n = t.call.apply(t, [this].concat(a)) || this, n.history = e8e(n.props), n
    }
    var r = e.prototype;
    return r.render = function () {
      return ce.createElement(Xb, {
        history: this.history,
        children: this.props.children
      })
    }, e
  }(ce.Component),
  sA = function (e, r) {
    return typeof e == "function" ? e(r) : e
  },
  oA = function (e, r) {
    return typeof e == "string" ? Rr(e, null, null, r) : e
  },
  Uk = function (e) {
    return e
  },
  yf = ce.forwardRef;
typeof yf > "u" && (yf = Uk);

function B8e(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}
var U8e = yf(function (t, e) {
    var r = t.innerRef,
      n = t.navigate,
      i = t.onClick,
      a = ag(t, ["innerRef", "navigate", "onClick"]),
      s = a.target,
      o = ir({}, a, {
        onClick: function (l) {
          try {
            i && i(l)
          } catch (u) {
            throw l.preventDefault(), u
          }!l.defaultPrevented && l.button === 0 && (!s || s === "_self") && !B8e(l) && (l.preventDefault(), n())
        }
      });
    return Uk !== yf ? o.ref = e || r : o.ref = r, ce.createElement("a", o)
  }),
  sg = yf(function (t, e) {
    var r = t.component,
      n = r === void 0 ? U8e : r,
      i = t.replace,
      a = t.to,
      s = t.innerRef,
      o = ag(t, ["component", "replace", "to", "innerRef"]);
    return ce.createElement(ma.Consumer, null, function (c) {
      c || qo(!1);
      var l = c.history,
        u = oA(sA(a, c.location), c.location),
        f = u ? l.createHref(u) : "",
        d = ir({}, o, {
          href: f,
          navigate: function () {
            var p = sA(a, c.location),
              v = Vr(c.location) === Vr(oA(p)),
              g = i || v ? l.replace : l.push;
            g(p)
          }
        });
      return Uk !== yf ? d.ref = e || s : d.innerRef = s, ce.createElement(n, d)
    })
  }),
  LY = function (e) {
    return e
  },
  h1 = ce.forwardRef;
typeof h1 > "u" && (h1 = LY);

function j8e() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
  return e.filter(function (n) {
    return n
  }).join(" ")
}
h1(function (t, e) {
  var r = t["aria-current"],
    n = r === void 0 ? "page" : r,
    i = t.activeClassName,
    a = i === void 0 ? "active" : i,
    s = t.activeStyle,
    o = t.className,
    c = t.exact,
    l = t.isActive,
    u = t.location,
    f = t.sensitive,
    d = t.strict,
    h = t.style,
    p = t.to,
    v = t.innerRef,
    g = ag(t, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return ce.createElement(ma.Consumer, null, function (m) {
    m || qo(!1);
    var y = u || m.location,
      x = oA(sA(p, y), y),
      b = x.pathname,
      _ = b && b.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1"),
      S = _ ? Qb(y.pathname, {
        path: _,
        exact: c,
        sensitive: f,
        strict: d
      }) : null,
      T = !!(l ? l(S, y) : S),
      R = typeof o == "function" ? o(T) : o,
      I = typeof h == "function" ? h(T) : h;
    T && (R = j8e(R, a), I = ir({}, I, s));
    var w = ir({
      "aria-current": T && n || null,
      className: R,
      style: I,
      to: x
    }, g);
    return LY !== h1 ? w.ref = e || v : w.innerRef = v, ce.createElement(sg, w)
  })
});
const H8e = "modulepreload",
  z8e = function (t) {
    return "/" + t
  },
  s6 = {},
  lA = function (e, r, n) {
    if (!r || r.length === 0) return e();
    const i = document.getElementsByTagName("link");
    return Promise.all(r.map(a => {
      if (a = z8e(a), a in s6) return;
      s6[a] = !0;
      const s = a.endsWith(".css"),
        o = s ? '[rel="stylesheet"]' : "";
      if (!!n)
        for (let u = i.length - 1; u >= 0; u--) {
          const f = i[u];
          if (f.href === a && (!s || f.rel === "stylesheet")) return
        } else if (document.querySelector(`link[href="${a}"]${o}`)) return;
      const l = document.createElement("link");
      if (l.rel = s ? "stylesheet" : H8e, s || (l.as = "script", l.crossOrigin = ""), l.href = a, document.head.appendChild(l), s) return new Promise((u, f) => {
        l.addEventListener("load", u), l.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${a}`)))
      })
    })).then(() => e())
  };

function G8e(t = {}) {
  const {
    immediate: e = !1,
    onNeedRefresh: r,
    onOfflineReady: n,
    onRegistered: i,
    onRegisteredSW: a,
    onRegisterError: s
  } = t;
  let o, c;
  const l = async (f = !0) => {
    await c
  };
  async function u() {
    if ("serviceWorker" in navigator) {
      const {
        Workbox: f
      } = await lA(() => import("./workbox-window.prod.es5-dc90f814.js"), []);
      o = new f("/sw.js", {
        scope: "/",
        type: "classic"
      }), o.addEventListener("activated", d => {
        (d.isUpdate || d.isExternal) && window.location.reload()
      }), o.addEventListener("installed", d => {
        d.isUpdate || n == null || n()
      }), o.register({
        immediate: e
      }).then(d => {
        a ? a("/sw.js", d) : i == null || i(d)
      }).catch(d => {
        s == null || s(d)
      })
    }
  }
  return c = u(), l
}

function Vt(t) {
  return Vt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
    return typeof e
  } : function (e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
  }, Vt(t)
}

function V8e(t, e) {
  if (Vt(t) !== "object" || t === null) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (Vt(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(t)
}

function PY(t) {
  var e = V8e(t, "string");
  return Vt(e) === "symbol" ? e : String(e)
}

function ci(t, e, r) {
  return e = PY(e), e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t
}

function jk(t, e) {
  if (t == null) return {};
  var r = ag(t, e),
    n, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    for (i = 0; i < a.length; i++) n = a[i], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n])
  }
  return r
}
var W8e = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  },
  K8e = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;

function o6(t) {
  var e = {
      type: "tag",
      name: "",
      voidElement: !1,
      attrs: {},
      children: []
    },
    r = t.match(/<\/?([^\s]+?)[/\s>]/);
  if (r && (e.name = r[1], (W8e[r[1]] || t.charAt(t.length - 2) === "/") && (e.voidElement = !0), e.name.startsWith("!--"))) {
    var n = t.indexOf("-->");
    return {
      type: "comment",
      comment: n !== -1 ? t.slice(4, n) : ""
    }
  }
  for (var i = new RegExp(K8e), a = null;
    (a = i.exec(t)) !== null;)
    if (a[0].trim())
      if (a[1]) {
        var s = a[1].trim(),
          o = [s, ""];
        s.indexOf("=") > -1 && (o = s.split("=")), e.attrs[o[0]] = o[1], i.lastIndex--
      } else a[2] && (e.attrs[a[2]] = a[3].trim().substring(1, a[3].length - 1));
  return e
}
var Y8e = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
  q8e = /^\s*$/,
  X8e = Object.create(null);

function NY(t, e) {
  switch (e.type) {
    case "text":
      return t + e.content;
    case "tag":
      return t += "<" + e.name + (e.attrs ? function (r) {
        var n = [];
        for (var i in r) n.push(i + '="' + r[i] + '"');
        return n.length ? " " + n.join(" ") : ""
      }(e.attrs) : "") + (e.voidElement ? "/>" : ">"), e.voidElement ? t : t + e.children.reduce(NY, "") + "</" + e.name + ">";
    case "comment":
      return t + "<!--" + e.comment + "-->"
  }
}
var Q8e = {
  parse: function (t, e) {
    e || (e = {}), e.components || (e.components = X8e);
    var r, n = [],
      i = [],
      a = -1,
      s = !1;
    if (t.indexOf("<") !== 0) {
      var o = t.indexOf("<");
      n.push({
        type: "text",
        content: o === -1 ? t : t.substring(0, o)
      })
    }
    return t.replace(Y8e, function (c, l) {
      if (s) {
        if (c !== "</" + r.name + ">") return;
        s = !1
      }
      var u, f = c.charAt(1) !== "/",
        d = c.startsWith("<!--"),
        h = l + c.length,
        p = t.charAt(h);
      if (d) {
        var v = o6(c);
        return a < 0 ? (n.push(v), n) : ((u = i[a]).children.push(v), n)
      }
      if (f && (a++, (r = o6(c)).type === "tag" && e.components[r.name] && (r.type = "component", s = !0), r.voidElement || s || !p || p === "<" || r.children.push({
          type: "text",
          content: t.slice(h, t.indexOf("<", h))
        }), a === 0 && n.push(r), (u = i[a - 1]) && u.children.push(r), i[a] = r), (!f || r.voidElement) && (a > -1 && (r.voidElement || r.name === c.slice(2, -1)) && (a--, r = a === -1 ? n : i[a]), !s && p !== "<" && p)) {
        u = a === -1 ? n : i[a].children;
        var g = t.indexOf("<", h),
          m = t.slice(h, g === -1 ? void 0 : g);
        q8e.test(m) && (m = " "), (g > -1 && a + u.length >= 0 || m !== " ") && u.push({
          type: "text",
          content: m
        })
      }
    }), n
  },
  stringify: function (t) {
    return t.reduce(function (e, r) {
      return e + NY("", r)
    }, "")
  }
};

function qv() {
  if (console && console.warn) {
    for (var t, e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];
    typeof r[0] == "string" && (r[0] = "react-i18next:: ".concat(r[0])), (t = console).warn.apply(t, r)
  }
}
var l6 = {};

function p1() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
  typeof e[0] == "string" && l6[e[0]] || (typeof e[0] == "string" && (l6[e[0]] = new Date), qv.apply(void 0, e))
}

function c6(t, e, r) {
  t.loadNamespaces(e, function () {
    if (t.isInitialized) r();
    else {
      var n = function i() {
        setTimeout(function () {
          t.off("initialized", i)
        }, 0), r()
      };
      t.on("initialized", n)
    }
  })
}

function Z8e(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    n = e.languages[0],
    i = e.options ? e.options.fallbackLng : !1,
    a = e.languages[e.languages.length - 1];
  if (n.toLowerCase() === "cimode") return !0;
  var s = function (c, l) {
    var u = e.services.backendConnector.state["".concat(c, "|").concat(l)];
    return u === -1 || u === 2
  };
  return r.bindI18n && r.bindI18n.indexOf("languageChanging") > -1 && e.services.backendConnector.backend && e.isLanguageChangingTo && !s(e.isLanguageChangingTo, t) ? !1 : !!(e.hasResourceBundle(n, t) || !e.services.backendConnector.backend || e.options.resources && !e.options.partialBundledLanguages || s(n, t) && (!i || s(a, t)))
}

function J8e(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!e.languages || !e.languages.length) return p1("i18n.languages were undefined or empty", e.languages), !0;
  var n = e.options.ignoreJSONStructure !== void 0;
  return n ? e.hasLoadedNamespace(t, {
    precheck: function (a, s) {
      if (r.bindI18n && r.bindI18n.indexOf("languageChanging") > -1 && a.services.backendConnector.backend && a.isLanguageChangingTo && !s(a.isLanguageChangingTo, t)) return !1
    }
  }) : Z8e(t, e, r)
}
var eMe = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
  tMe = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "Â©",
    "&#169;": "Â©",
    "&reg;": "Â®",
    "&#174;": "Â®",
    "&hellip;": "â¦",
    "&#8230;": "â¦",
    "&#x2F;": "/",
    "&#47;": "/"
  },
  rMe = function (e) {
    return tMe[e]
  },
  nMe = function (e) {
    return e.replace(eMe, rMe)
  };

function u6(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function f6(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? u6(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : u6(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}
var cA = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: nMe
};

function iMe() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  cA = f6(f6({}, cA), t)
}

function DY() {
  return cA
}
var MY;

function aMe(t) {
  MY = t
}

function Hk() {
  return MY
}
var sMe = ["format"],
  oMe = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];

function d6(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function Ot(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? d6(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : d6(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function bT(t, e) {
  if (!t) return !1;
  var r = t.props ? t.props.children : t.children;
  return e ? r.length > 0 : !!r
}

function ET(t) {
  return t ? t.props ? t.props.children : t.children : []
}

function lMe(t) {
  return Object.prototype.toString.call(t) !== "[object Array]" ? !1 : t.every(function (e) {
    return A.isValidElement(e)
  })
}

function wh(t) {
  return Array.isArray(t) ? t : [t]
}

function cMe(t, e) {
  var r = Ot({}, e);
  return r.props = Object.assign(t.props, e.props), r
}

function FY(t, e) {
  if (!t) return "";
  var r = "",
    n = wh(t),
    i = e.transSupportBasicHtmlNodes && e.transKeepBasicHtmlNodesFor ? e.transKeepBasicHtmlNodesFor : [];
  return n.forEach(function (a, s) {
    if (typeof a == "string") r += "".concat(a);
    else if (A.isValidElement(a)) {
      var o = Object.keys(a.props).length,
        c = i.indexOf(a.type) > -1,
        l = a.props.children;
      if (!l && c && o === 0) r += "<".concat(a.type, "/>");
      else if (!l && (!c || o !== 0)) r += "<".concat(s, "></").concat(s, ">");
      else if (a.props.i18nIsDynamicList) r += "<".concat(s, "></").concat(s, ">");
      else if (c && o === 1 && typeof l == "string") r += "<".concat(a.type, ">").concat(l, "</").concat(a.type, ">");
      else {
        var u = FY(l, e);
        r += "<".concat(s, ">").concat(u, "</").concat(s, ">")
      }
    } else if (a === null) qv("Trans: the passed in value is invalid - seems you passed in a null child.");
    else if (Vt(a) === "object") {
      var f = a.format,
        d = jk(a, sMe),
        h = Object.keys(d);
      if (h.length === 1) {
        var p = f ? "".concat(h[0], ", ").concat(f) : h[0];
        r += "{{".concat(p, "}}")
      } else qv("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", a)
    } else qv("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", a)
  }), r
}

function uMe(t, e, r, n, i, a) {
  if (e === "") return [];
  var s = n.transKeepBasicHtmlNodesFor || [],
    o = e && new RegExp(s.join("|")).test(e);
  if (!t && !o) return [e];
  var c = {};

  function l(g) {
    var m = wh(g);
    m.forEach(function (y) {
      typeof y != "string" && (bT(y) ? l(ET(y)) : Vt(y) === "object" && !A.isValidElement(y) && Object.assign(c, y))
    })
  }
  l(t);
  var u = Q8e.parse("<0>".concat(e, "</0>")),
    f = Ot(Ot({}, c), i);

  function d(g, m, y) {
    var x = ET(g),
      b = p(x, m.children, y);
    return lMe(x) && b.length === 0 ? x : b
  }

  function h(g, m, y, x, b) {
    g.dummy && (g.children = m), y.push(A.cloneElement(g, Ot(Ot({}, g.props), {}, {
      key: x
    }), b ? void 0 : m))
  }

  function p(g, m, y) {
    var x = wh(g),
      b = wh(m);
    return b.reduce(function (_, S, T) {
      var R = S.children && S.children[0] && S.children[0].content && r.services.interpolator.interpolate(S.children[0].content, f, r.language);
      if (S.type === "tag") {
        var I = x[parseInt(S.name, 10)];
        !I && y.length === 1 && y[0][S.name] && (I = y[0][S.name]), I || (I = {});
        var w = Object.keys(S.attrs).length !== 0 ? cMe({
            props: S.attrs
          }, I) : I,
          C = A.isValidElement(w),
          L = C && bT(S, !0) && !S.voidElement,
          H = o && Vt(w) === "object" && w.dummy && !C,
          N = Vt(t) === "object" && t !== null && Object.hasOwnProperty.call(t, S.name);
        if (typeof w == "string") {
          var P = r.services.interpolator.interpolate(w, f, r.language);
          _.push(P)
        } else if (bT(w) || L) {
          var B = d(w, S, y);
          h(w, B, _, T)
        } else if (H) {
          var V = p(x, S.children, y);
          _.push(A.cloneElement(w, Ot(Ot({}, w.props), {}, {
            key: T
          }), V))
        } else if (Number.isNaN(parseFloat(S.name)))
          if (N) {
            var M = d(w, S, y);
            h(w, M, _, T, S.voidElement)
          } else if (n.transSupportBasicHtmlNodes && s.indexOf(S.name) > -1)
          if (S.voidElement) _.push(A.createElement(S.name, {
            key: "".concat(S.name, "-").concat(T)
          }));
          else {
            var U = p(x, S.children, y);
            _.push(A.createElement(S.name, {
              key: "".concat(S.name, "-").concat(T)
            }, U))
          }
        else if (S.voidElement) _.push("<".concat(S.name, " />"));
        else {
          var W = p(x, S.children, y);
          _.push("<".concat(S.name, ">").concat(W, "</").concat(S.name, ">"))
        } else if (Vt(w) === "object" && !C) {
          var k = S.children[0] ? R : null;
          k && _.push(k)
        } else S.children.length === 1 && R ? _.push(A.cloneElement(w, Ot(Ot({}, w.props), {}, {
          key: T
        }), R)) : _.push(A.cloneElement(w, Ot(Ot({}, w.props), {}, {
          key: T
        })))
      } else if (S.type === "text") {
        var O = n.transWrapTextNodes,
          F = a ? n.unescape(r.services.interpolator.interpolate(S.content, f, r.language)) : r.services.interpolator.interpolate(S.content, f, r.language);
        O ? _.push(A.createElement(O, {
          key: "".concat(S.name, "-").concat(T)
        }, F)) : _.push(F)
      }
      return _
    }, [])
  }
  var v = p([{
    dummy: !0,
    children: t || []
  }], u, wh(t || []));
  return ET(v[0])
}

function fMe(t) {
  var e = t.children,
    r = t.count,
    n = t.parent,
    i = t.i18nKey,
    a = t.context,
    s = t.tOptions,
    o = s === void 0 ? {} : s,
    c = t.values,
    l = t.defaults,
    u = t.components,
    f = t.ns,
    d = t.i18n,
    h = t.t,
    p = t.shouldUnescape,
    v = jk(t, oMe),
    g = d || Hk();
  if (!g) return p1("You will need to pass in an i18next instance by using i18nextReactModule"), e;
  var m = h || g.t.bind(g) || function (L) {
    return L
  };
  a && (o.context = a);
  var y = Ot(Ot({}, DY()), g.options && g.options.react),
    x = f || m.ns || g.options && g.options.defaultNS;
  x = typeof x == "string" ? [x] : x || ["translation"];
  var b = l || FY(e, y) || y.transEmptyNodeValue || i,
    _ = y.hashTransKey,
    S = i || (_ ? _(b) : b),
    T = c ? o.interpolation : {
      interpolation: Ot(Ot({}, o.interpolation), {}, {
        prefix: "#$?",
        suffix: "?$#"
      })
    },
    R = Ot(Ot(Ot(Ot({}, o), {}, {
      count: r
    }, c), T), {}, {
      defaultValue: b,
      ns: x
    }),
    I = S ? m(S, R) : b,
    w = uMe(u || e, I, g, y, R, p),
    C = n !== void 0 ? n : y.defaultTransParent;
  return C ? A.createElement(C, v, w) : w
}

function Di(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function h6(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, PY(n.key), n)
  }
}

function Mi(t, e, r) {
  return e && h6(t.prototype, e), r && h6(t, r), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t
}
var dMe = {
    type: "3rdParty",
    init: function (e) {
      iMe(e.options.react), aMe(e)
    }
  },
  BY = A.createContext(),
  hMe = function () {
    function t() {
      Di(this, t), this.usedNamespaces = {}
    }
    return Mi(t, [{
      key: "addUsedNamespaces",
      value: function (r) {
        var n = this;
        r.forEach(function (i) {
          n.usedNamespaces[i] || (n.usedNamespaces[i] = !0)
        })
      }
    }, {
      key: "getUsedNamespaces",
      value: function () {
        return Object.keys(this.usedNamespaces)
      }
    }]), t
  }(),
  pMe = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];

function p6(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function gMe(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? p6(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : p6(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function zk(t) {
  var e = t.children,
    r = t.count,
    n = t.parent,
    i = t.i18nKey,
    a = t.context,
    s = t.tOptions,
    o = s === void 0 ? {} : s,
    c = t.values,
    l = t.defaults,
    u = t.components,
    f = t.ns,
    d = t.i18n,
    h = t.t,
    p = t.shouldUnescape,
    v = jk(t, pMe),
    g = A.useContext(BY) || {},
    m = g.i18n,
    y = g.defaultNS,
    x = d || m || Hk(),
    b = h || x && x.t.bind(x);
  return fMe(gMe({
    children: e,
    count: r,
    parent: n,
    i18nKey: i,
    context: a,
    tOptions: o,
    values: c,
    defaults: l,
    components: u,
    ns: f || b && b.ns || y || x && x.options && x.options.defaultNS,
    i18n: x,
    t: h,
    shouldUnescape: p
  }, v))
}

function UY(t) {
  if (Array.isArray(t)) return t
}

function mMe(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, i, a, s, o = [],
      c = !0,
      l = !1;
    try {
      if (a = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r) return;
        c = !1
      } else
        for (; !(c = (n = a.call(r)).done) && (o.push(n.value), o.length !== e); c = !0);
    } catch (u) {
      l = !0, i = u
    } finally {
      try {
        if (!c && r.return != null && (s = r.return(), Object(s) !== s)) return
      } finally {
        if (l) throw i
      }
    }
    return o
  }
}

function g6(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
  return n
}

function jY(t, e) {
  if (t) {
    if (typeof t == "string") return g6(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return g6(t, e)
  }
}

function HY() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function vMe(t, e) {
  return UY(t) || mMe(t, e) || jY(t, e) || HY()
}

function m6(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function ST(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? m6(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : m6(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}
var yMe = function (e, r) {
  var n = A.useRef();
  return A.useEffect(function () {
    n.current = r ? n.current : e
  }, [e, r]), n.current
};

function ke(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r = e.i18n,
    n = A.useContext(BY) || {},
    i = n.i18n,
    a = n.defaultNS,
    s = r || i || Hk();
  if (s && !s.reportNamespaces && (s.reportNamespaces = new hMe), !s) {
    p1("You will need to pass in an i18next instance by using initReactI18next");
    var o = function (I, w) {
        return typeof w == "string" ? w : w && Vt(w) === "object" && typeof w.defaultValue == "string" ? w.defaultValue : Array.isArray(I) ? I[I.length - 1] : I
      },
      c = [o, {}, !1];
    return c.t = o, c.i18n = {}, c.ready = !1, c
  }
  s.options.react && s.options.react.wait !== void 0 && p1("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var l = ST(ST(ST({}, DY()), s.options.react), e),
    u = l.useSuspense,
    f = l.keyPrefix,
    d = t || a || s.options && s.options.defaultNS;
  d = typeof d == "string" ? [d] : d || ["translation"], s.reportNamespaces.addUsedNamespaces && s.reportNamespaces.addUsedNamespaces(d);
  var h = (s.isInitialized || s.initializedStoreOnce) && d.every(function (R) {
    return J8e(R, s, l)
  });

  function p() {
    return s.getFixedT(null, l.nsMode === "fallback" ? d : d[0], f)
  }
  var v = A.useState(p),
    g = vMe(v, 2),
    m = g[0],
    y = g[1],
    x = d.join(),
    b = yMe(x),
    _ = A.useRef(!0);
  A.useEffect(function () {
    var R = l.bindI18n,
      I = l.bindI18nStore;
    _.current = !0, !h && !u && c6(s, d, function () {
      _.current && y(p)
    }), h && b && b !== x && _.current && y(p);

    function w() {
      _.current && y(p)
    }
    return R && s && s.on(R, w), I && s && s.store.on(I, w),
      function () {
        _.current = !1, R && s && R.split(" ").forEach(function (C) {
          return s.off(C, w)
        }), I && s && I.split(" ").forEach(function (C) {
          return s.store.off(C, w)
        })
      }
  }, [s, x]);
  var S = A.useRef(!0);
  A.useEffect(function () {
    _.current && !S.current && y(p), S.current = !1
  }, [s, f]);
  var T = [m, s, h];
  if (T.t = m, T.i18n = s, T.ready = h, h || !h && !u) return T;
  throw new Promise(function (R) {
    c6(s, d, function () {
      R()
    })
  })
}
var ue = (t => (t.SEARCH = "search", t.BOOKMARK = "bookmark", t.BOOKMARK_OUTLINE = "bookmark_outline", t.CLOCK = "clock", t.EYE_SLASH = "eyeSlash", t.ARROW_LEFT = "arrowLeft", t.ARROW_RIGHT = "arrowRight", t.CHEVRON_DOWN = "chevronDown", t.CHEVRON_RIGHT = "chevronRight", t.CHEVRON_LEFT = "chevronLeft", t.CLAPPER_BOARD = "clapperBoard", t.FILM = "film", t.DRAGON = "dragon", t.WARNING = "warning", t.MOVIE_WEB = "movieWeb", t.DISCORD = "discord", t.GITHUB = "github", t.PLAY = "play", t.PAUSE = "pause", t.EXPAND = "expand", t.COMPRESS = "compress", t.VOLUME = "volume", t.VOLUME_X = "volume_x", t.X = "x", t.EDIT = "edit", t.AIRPLAY = "airplay", t.EPISODES = "episodes", t.SKIP_FORWARD = "skip_forward", t.SKIP_BACKWARD = "skip_backward", t.FILE = "file", t.CAPTIONS = "captions", t.LINK = "link", t.CASTING = "casting", t.CIRCLE_EXCLAMATION = "circle_exclamation", t.DOWNLOAD = "download", t.GEAR = "gear", t.WATCH_PARTY = "watch_party", t.PICTURE_IN_PICTURE = "pictureInPicture", t.CHECKMARK = "checkmark", t.TACHOMETER = "tachometer", t))(ue || {});
const xMe = {
  search: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M500.3 443.7l-119.7-119.7c27.22-40.41 40.65-90.9 33.46-144.7C401.8 87.79 326.8 13.32 235.2 1.723C99.01-15.51-15.51 99.01 1.724 235.2c11.6 91.64 86.08 166.7 177.6 178.9c53.8 7.189 104.3-6.236 144.7-33.46l119.7 119.7c15.62 15.62 40.95 15.62 56.57 0C515.9 484.7 515.9 459.3 500.3 443.7zM79.1 208c0-70.58 57.42-128 128-128s128 57.42 128 128c0 70.58-57.42 128-128 128S79.1 278.6 79.1 208z"/></svg>',
  bookmark: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M384 48V512l-192-112L0 512V48C0 21.5 21.5 0 48 0h288C362.5 0 384 21.5 384 48z"/></svg>',
  clock: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"/></svg>',
  eyeSlash: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M150.7 92.77C195 58.27 251.8 32 320 32C400.8 32 465.5 68.84 512.6 112.6C559.4 156 590.7 207.1 605.5 243.7C608.8 251.6 608.8 260.4 605.5 268.3C592.1 300.6 565.2 346.1 525.6 386.7L630.8 469.1C641.2 477.3 643.1 492.4 634.9 502.8C626.7 513.2 611.6 515.1 601.2 506.9L9.196 42.89C-1.236 34.71-3.065 19.63 5.112 9.196C13.29-1.236 28.37-3.065 38.81 5.112L150.7 92.77zM223.1 149.5L313.4 220.3C317.6 211.8 320 202.2 320 191.1C320 180.5 316.1 169.7 311.6 160.4C314.4 160.1 317.2 159.1 320 159.1C373 159.1 416 202.1 416 255.1C416 269.7 413.1 282.7 407.1 294.5L446.6 324.7C457.7 304.3 464 280.9 464 255.1C464 176.5 399.5 111.1 320 111.1C282.7 111.1 248.6 126.2 223.1 149.5zM320 480C239.2 480 174.5 443.2 127.4 399.4C80.62 355.1 49.34 304 34.46 268.3C31.18 260.4 31.18 251.6 34.46 243.7C44 220.8 60.29 191.2 83.09 161.5L177.4 235.8C176.5 242.4 176 249.1 176 255.1C176 335.5 240.5 400 320 400C338.7 400 356.6 396.4 373 389.9L446.2 447.5C409.9 467.1 367.8 480 320 480H320z"/></svg>',
  arrowLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>',
  chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
  chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>',
  chevronLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"></polyline></svg>',
  clapperBoard: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M326.1 160l127.4-127.4C451.7 32.39 449.9 32 448 32h-86.06l-128 128H326.1zM166.1 160l128-128H201.9l-128 128H166.1zM497.7 56.19L393.9 160H512V96C512 80.87 506.5 67.15 497.7 56.19zM134.1 32H64C28.65 32 0 60.65 0 96v64h6.062L134.1 32zM0 416c0 35.35 28.65 64 64 64h384c35.35 0 64-28.65 64-64V192H0V416z"/></svg>',
  film: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M463.1 32h-416C21.49 32-.0001 53.49-.0001 80v352c0 26.51 21.49 48 47.1 48h416c26.51 0 48-21.49 48-48v-352C511.1 53.49 490.5 32 463.1 32zM111.1 408c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 408zM111.1 280c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM111.1 152c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 152zM351.1 400c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V400zM351.1 208c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V208zM463.1 408c0 4.418-3.582 8-8 8h-47.1c-4.418 0-7.1-3.582-7.1-8l0-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V408zM463.1 280c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM463.1 152c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8l0-48c0-4.418 3.582-8 7.1-8h47.1c4.418 0 8 3.582 8 8V152z"/></svg>',
  dragon: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M18.43 255.8L192 224L100.8 292.6C90.67 302.8 97.8 320 112 320h222.7c-9.499-26.5-14.75-54.5-14.75-83.38V194.2L200.3 106.8C176.5 90.88 145 92.75 123.3 111.2l-117.5 116.4C-6.562 238 2.436 258 18.43 255.8zM575.2 289.9l-100.7-50.25c-16.25-8.125-26.5-24.75-26.5-43V160h63.99l28.12 22.62C546.1 188.6 554.2 192 562.7 192h30.1c11.1 0 23.12-6.875 28.5-17.75l14.37-28.62c5.374-10.87 4.25-23.75-2.999-33.5l-74.49-99.37C552.1 4.75 543.5 0 533.5 0H296C288.9 0 285.4 8.625 290.4 13.62L351.1 64L292.4 88.75c-5.874 3-5.874 11.37 0 14.37L351.1 128l-.0011 108.6c0 72 35.99 139.4 95.99 179.4c-195.6 6.75-344.4 41-434.1 60.88c-8.124 1.75-13.87 9-13.87 17.38C.0463 504 8.045 512 17.79 512h499.1c63.24 0 119.6-47.5 122.1-110.8C642.3 354 617.1 310.9 575.2 289.9zM489.1 66.25l45.74 11.38c-2.75 11-12.5 18.88-24.12 18.25C497.7 95.25 484.8 83.38 489.1 66.25z"/></svg>',
  warning: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-triangle"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
  arrowRight: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>',
  movieWeb: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 20.927 20.927"><path d="M18.186,4.5V6.241H16.445V4.5H9.482V6.241H7.741V4.5H6V20.168H7.741V18.427H9.482v1.741h6.964V18.427h1.741v1.741h1.741V4.5Zm-8.7,12.186H7.741V14.945H9.482Zm0-3.482H7.741V11.464H9.482Zm0-3.482H7.741V7.982H9.482Zm8.7,6.964H16.445V14.945h1.741Zm0-3.482H16.445V11.464h1.741Zm0-3.482H16.445V7.982h1.741Z" transform="translate(10.018 -7.425) rotate(45)" fill="currentColor"/></svg>',
  discord: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"/></svg>',
  github: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 496 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>',
  play: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" style="transform: translateX(5%)" height="1em" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>',
  pause: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"/></svg>',
  expand: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M32 32C14.3 32 0 46.3 0 64v96c0 17.7 14.3 32 32 32s32-14.3 32-32V96h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H64V352zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V64c0-17.7-14.3-32-32-32H320zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V352z"/></svg>',
  compress: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V64zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32H96v64c0 17.7 14.3 32 32 32s32-14.3 32-32V352c0-17.7-14.3-32-32-32H32zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H352V64zM320 320c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32s32-14.3 32-32V384h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H320z"/></svg>',
  volume: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M533.6 32.5C598.5 85.3 640 165.8 640 256s-41.5 170.8-106.4 223.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C557.5 398.2 592 331.2 592 256s-34.5-142.2-88.7-186.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM473.1 107c43.2 35.2 70.9 88.9 70.9 149s-27.7 113.8-70.9 149c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C475.3 341.3 496 301.1 496 256s-20.7-85.3-53.2-111.8c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zm-60.5 74.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3z"/></svg>',
  volume_x: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 576 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM425 167l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0z"/></svg>',
  x: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M310.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L160 210.7 54.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L114.7 256 9.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 301.3 265.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L205.3 256 310.6 150.6z"/></svg>',
  edit: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z"/></svg>',
  bookmark_outline: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M336 0h-288C21.49 0 0 21.49 0 48v431.9c0 24.7 26.79 40.08 48.12 27.64L192 423.6l143.9 83.93C357.2 519.1 384 504.6 384 479.9V48C384 21.49 362.5 0 336 0zM336 452L192 368l-144 84V54C48 50.63 50.63 48 53.1 48h276C333.4 48 336 50.63 336 54V452z"/></svg>',
  airplay: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-airplay"><path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon fill="currentColor" points="12 15 17 21 7 21 12 15"></polygon></svg>',
  episodes: '<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3 4C1.34315 4 0 5.34314 0 7V13.9496C0 15.6065 1.34315 16.9496 3 16.9496H5.86645V14.9496H3C2.44772 14.9496 2 14.5019 2 13.9496V7C2 6.44771 2.44771 6 3 6H16.0327C16.585 6 17.0327 6.44772 17.0327 7V9.86645H19.0327V7C19.0327 5.34315 17.6896 4 16.0327 4H3Z" fill="currentColor"/><rect x="5.89929" y="10.5444" width="17" height="10" rx="2" stroke="currentColor" stroke-width="2"/></svg>',
  skip_forward: '<svg width="1em" height="1em" viewBox="0 0 26 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.3333 12.3333L16 7.66667M16 7.66667L11.3333 3M16 7.66667H6.66667C5.42899 7.66667 4.242 8.15833 3.36684 9.0335C2.49167 9.90867 2 11.0957 2 12.3333C2 13.571 2.49167 14.758 3.36684 15.6332C4.242 16.5083 5.42899 17 6.66667 17H9" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" /><path d="M16.5043 14.2727V23H14.6591V16.0241H14.608L12.6094 17.277V15.6406L14.7699 14.2727H16.5043ZM22.0004 23.1918C21.2674 23.1889 20.6367 23.0085 20.1083 22.6506C19.5827 22.2926 19.1779 21.7741 18.8938 21.0952C18.6126 20.4162 18.4734 19.5994 18.4762 18.6449C18.4762 17.6932 18.6168 16.8821 18.8981 16.2116C19.1822 15.5412 19.587 15.0312 20.1126 14.6818C20.641 14.3295 21.2702 14.1534 22.0004 14.1534C22.7305 14.1534 23.3583 14.3295 23.8839 14.6818C24.4123 15.0341 24.8185 15.5455 25.1026 16.2159C25.3867 16.8835 25.5273 17.6932 25.5245 18.6449C25.5245 19.6023 25.3825 20.4205 25.0984 21.0994C24.8171 21.7784 24.4137 22.2969 23.8881 22.6548C23.3626 23.0128 22.7333 23.1918 22.0004 23.1918ZM22.0004 21.6619C22.5004 21.6619 22.8995 21.4105 23.1978 20.9077C23.4961 20.4048 23.6438 19.6506 23.641 18.6449C23.641 17.983 23.5728 17.4318 23.4364 16.9915C23.3029 16.5511 23.1126 16.2202 22.8654 15.9986C22.6211 15.777 22.3327 15.6662 22.0004 15.6662C21.5032 15.6662 21.1055 15.9148 20.8072 16.4119C20.5089 16.9091 20.3583 17.6534 20.3555 18.6449C20.3555 19.3153 20.4222 19.875 20.5558 20.3239C20.6921 20.7699 20.8839 21.1051 21.131 21.3295C21.3782 21.5511 21.668 21.6619 22.0004 21.6619Z" fill="currentColor" /></svg>',
  skip_backward: '<svg width="1em" height="1em" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.6667 12.3333L9 7.66667M9 7.66667L13.6667 3M9 7.66667H18.3333C19.571 7.66667 20.758 8.15833 21.6332 9.0335C22.5083 9.90867 23 11.0957 23 12.3333C23 13.571 22.5083 14.758 21.6332 15.6332C20.758 16.5083 19.571 17 18.3333 17H16" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M4.50426 14.2727V23H2.65909V16.0241H2.60795L0.609375 17.277V15.6406L2.76989 14.2727H4.50426ZM10.0004 23.1918C9.2674 23.1889 8.63672 23.0085 8.10831 22.6506C7.58274 22.2926 7.17791 21.7741 6.89382 21.0952C6.61257 20.4162 6.47337 19.5994 6.47621 18.6449C6.47621 17.6932 6.61683 16.8821 6.89808 16.2116C7.18217 15.5412 7.587 15.0312 8.11257 14.6818C8.64098 14.3295 9.27024 14.1534 10.0004 14.1534C10.7305 14.1534 11.3583 14.3295 11.8839 14.6818C12.4123 15.0341 12.8185 15.5455 13.1026 16.2159C13.3867 16.8835 13.5273 17.6932 13.5245 18.6449C13.5245 19.6023 13.3825 20.4205 13.0984 21.0994C12.8171 21.7784 12.4137 22.2969 11.8881 22.6548C11.3626 23.0128 10.7333 23.1918 10.0004 23.1918ZM10.0004 21.6619C10.5004 21.6619 10.8995 21.4105 11.1978 20.9077C11.4961 20.4048 11.6438 19.6506 11.641 18.6449C11.641 17.983 11.5728 17.4318 11.4364 16.9915C11.3029 16.5511 11.1126 16.2202 10.8654 15.9986C10.6211 15.777 10.3327 15.6662 10.0004 15.6662C9.5032 15.6662 9.10547 15.9148 8.80717 16.4119C8.50888 16.9091 8.35831 17.6534 8.35547 18.6449C8.35547 19.3153 8.42223 19.875 8.55575 20.3239C8.69212 20.7699 8.88388 21.1051 9.13104 21.3295C9.3782 21.5511 9.66797 21.6619 10.0004 21.6619Z" fill="currentColor"/></svg>',
  file: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>',
  captions: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 25 20"><path transform="translate(-3 -6)" d="M25.5,6H5.5A2.507,2.507,0,0,0,3,8.5v15A2.507,2.507,0,0,0,5.5,26h20A2.507,2.507,0,0,0,28,23.5V8.5A2.507,2.507,0,0,0,25.5,6ZM5.5,16h5v2.5h-5ZM18,23.5H5.5V21H18Zm7.5,0h-5V21h5Zm0-5H13V16H25.5Z" fill="currentColor"/></svg>',
  link: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>',
  circle_exclamation: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"/></svg>',
  casting: "",
  download: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
  gear: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M481.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-30.9 28.1c-7.7 7.1-11.4 17.5-10.9 27.9c.1 2.9 .2 5.8 .2 8.8s-.1 5.9-.2 8.8c-.5 10.5 3.1 20.9 10.9 27.9l30.9 28.1c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-39.7-12.6c-10-3.2-20.8-1.1-29.7 4.6c-4.9 3.1-9.9 6.1-15.1 8.7c-9.3 4.8-16.5 13.2-18.8 23.4l-8.9 40.7c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-8.9-40.7c-2.2-10.2-9.5-18.6-18.8-23.4c-5.2-2.7-10.2-5.6-15.1-8.7c-8.8-5.7-19.7-7.8-29.7-4.6L69.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l30.9-28.1c7.7-7.1 11.4-17.5 10.9-27.9c-.1-2.9-.2-5.8-.2-8.8s.1-5.9 .2-8.8c.5-10.5-3.1-20.9-10.9-27.9L8.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l39.7 12.6c10 3.2 20.8 1.1 29.7-4.6c4.9-3.1 9.9-6.1 15.1-8.7c9.3-4.8 16.5-13.2 18.8-23.4l8.9-40.7c2-9.1 9-16.3 18.2-17.8C213.3 1.2 227.5 0 242 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l8.9 40.7c2.2 10.2 9.4 18.6 18.8 23.4c5.2 2.7 10.2 5.6 15.1 8.7c8.8 5.7 19.7 7.7 29.7 4.6l39.7-12.6c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM242 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"/></svg>',
  watch_party: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M319.4 372c48.5-31.3 80.6-85.9 80.6-148c0-97.2-78.8-176-176-176S48 126.8 48 224c0 62.1 32.1 116.6 80.6 148c1.2 17.3 4 38 7.2 57.1l.2 1C56 395.8 0 316.5 0 224C0 100.3 100.3 0 224 0S448 100.3 448 224c0 92.5-56 171.9-136 206.1l.2-1.1c3.1-19.2 6-39.8 7.2-57zm-2.3-38.1c-1.6-5.7-3.9-11.1-7-16.2c-5.8-9.7-13.5-17-21.9-22.4c19.5-17.6 31.8-43 31.8-71.3c0-53-43-96-96-96s-96 43-96 96c0 28.3 12.3 53.8 31.8 71.3c-8.4 5.4-16.1 12.7-21.9 22.4c-3.1 5.1-5.4 10.5-7 16.2C99.8 307.5 80 268 80 224c0-79.5 64.5-144 144-144s144 64.5 144 144c0 44-19.8 83.5-50.9 109.9zM224 312c32.9 0 64 8.6 64 43.8c0 33-12.9 104.1-20.6 132.9c-5.1 19-24.5 23.4-43.4 23.4s-38.2-4.4-43.4-23.4c-7.8-28.5-20.6-99.7-20.6-132.8c0-35.1 31.1-43.8 64-43.8zm0-144a56 56 0 1 1 0 112 56 56 0 1 1 0-112z"/></svg>',
  pictureInPicture: '<svg xmlns="http://www.w3.org/2000/svg" height="1em" width="1em" fill="currentColor" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"/></svg>',
  checkmark: '<svg xmlns="http://www.w3.org/2000/svg" height="1em" width="1em" fill="currentColor" viewBox="0 0 24 24"><path d="M9 22l-10-10.598 2.798-2.859 7.149 7.473 13.144-14.016 2.909 2.806z" /></svg>',
  tachometer: '<svg xmlns="http://www.w3.org/2000/svg" height="1em" width="1em" fill="currentColor" viewBox="0 0 576 512"><!-- Font Awesome Pro 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) --><path d="M128 288c-17.67 0-32 14.33-32 32s14.33 32 32 32 32-14.33 32-32-14.33-32-32-32zm154.65-97.08l16.24-48.71c1.16-3.45 3.18-6.35 4.92-9.43-4.73-2.76-9.94-4.78-15.81-4.78-17.67 0-32 14.33-32 32 0 15.78 11.63 28.29 26.65 30.92zM176 176c-17.67 0-32 14.33-32 32s14.33 32 32 32 32-14.33 32-32-14.33-32-32-32zM288 32C128.94 32 0 160.94 0 320c0 52.8 14.25 102.26 39.06 144.8 5.61 9.62 16.3 15.2 27.44 15.2h443c11.14 0 21.83-5.58 27.44-15.2C561.75 422.26 576 372.8 576 320c0-159.06-128.94-288-288-288zm212.27 400H75.73C57.56 397.63 48 359.12 48 320 48 187.66 155.66 80 288 80s240 107.66 240 240c0 39.12-9.56 77.63-27.73 112zM416 320c0 17.67 14.33 32 32 32s32-14.33 32-32-14.33-32-32-32-32 14.33-32 32zm-56.41-182.77c-12.72-4.23-26.16 2.62-30.38 15.17l-45.34 136.01C250.49 290.58 224 318.06 224 352c0 11.72 3.38 22.55 8.88 32h110.25c5.5-9.45 8.88-20.28 8.88-32 0-19.45-8.86-36.66-22.55-48.4l45.34-136.01c4.17-12.57-2.64-26.17-15.21-30.36zM432 208c0-15.8-11.66-28.33-26.72-30.93-.07.21-.07.43-.14.65l-19.5 58.49c4.37 2.24 9.11 3.8 14.36 3.8 17.67-.01 32-14.34 32-32.01z"/></svg>'
};

function bMe() {
  const t = A.useRef(null);
  return A.useEffect(() => {
    var r;
    const e = document.createElement("google-cast-launcher");
    e.setAttribute("id", "castbutton"), (r = t.current) == null || r.appendChild(e)
  }, []), E("div", {
    ref: t,
    className: "h-6"
  })
}
const Ve = A.memo(t => t.icon === "casting" ? E(bMe, {}) : E("span", {
  dangerouslySetInnerHTML: {
    __html: xMe[t.icon]
  },
  className: t.className
}));

function rn(t) {
  const e = t.clickable ? "cursor-pointer hover:scale-110 hover:bg-denim-600 hover:text-white active:scale-125" : "",
    r = t.transparent ? "bg-opacity-0 hover:bg-opacity-50" : "",
    n = t.active ? "border-bink-600 bg-bink-100 text-bink-600" : "";
  return E("div", {
    className: t.className || void 0,
    onClick: t.onClick,
    children: E("div", {
      className: `flex h-12 w-12 items-center justify-center rounded-full border-2 border-transparent bg-denim-500 transition-[background-color,color,transform,border-color] duration-75 ${r} ${e} ${n}`,
      children: E(Ve, {
        icon: t.icon
      })
    })
  })
}

function g1(t) {
  const e = !!t.url,
    r = !!t.to,
    n = E("span", {
      className: "cursor-pointer font-bold text-bink-600 hover:text-bink-700",
      children: t.children
    });
  return e ? E("a", {
    target: t.newTab ? "_blank" : void 0,
    rel: "noreferrer",
    href: t.url,
    children: n
  }) : r ? E(sg, {
    to: t.to,
    children: n
  }) : E("span", {
    onClick: () => t.onClick && t.onClick(),
    children: n
  })
}

function og(t) {
  return E("h1", {
    className: `text-2xl font-bold text-white sm:text-3xl md:text-4xl ${t.className??""}`,
    children: t.children
  })
}
const EMe = "3.0.15",
  SMe = "https://discord.gg/Jhqt4Xzpfb",
  _Me = "https://github.com/healer-op",
  TMe = "G-44YVXRL61C",
  wMe = "https://b267ab7d52674c23af4e4e6cf2956251@o4505053491167232.ingest.sentry.io/4505053495296000",
  RMe = {
    OMDB_API_KEY: "...",
    TMDB_API_KEY: "...",
    APP_VERSION: void 0,
    GITHUB_LINK: void 0,
    DISCORD_LINK: void 0,
    CORS_PROXY_URL: "https://healer.healerzee51.workers.dev",
    NORMAL_ROUTER: {}.VITE_NORMAL_ROUTER
  },
  v6 = [];

function Dm(t, e) {
  var i;
  let r = (i = window == null ? void 0 : window.__CONFIG__) == null ? void 0 : i[`VITE_${t}`];
  r !== void 0 && r.length === 0 && (r = void 0);
  const n = RMe[t] ? ? r ? ? void 0;
  return n === void 0 ? e || (v6.includes(t) || (window.alert(`Misconfigured instance, missing key: ${t}`), v6.push(t)), "") : n
}

function kr() {
  return {
    APP_VERSION: EMe,
    GITHUB_LINK: _Me,
    DISCORD_LINK: SMe,
    OMDB_API_KEY: Dm("OMDB_API_KEY"),
    TMDB_API_KEY: Dm("TMDB_API_KEY"),
    PROXY_URLS: Dm("CORS_PROXY_URL").split(",").map(t => t.trim()),
    NORMAL_ROUTER: Dm("NORMAL_ROUTER", "false") === "true"
  }
}

function AMe(t) {
  return Y("div", {
    className: "w-4xl mt-12 max-w-full rounded bg-denim-300 px-6 py-4",
    children: [Y("p", {
      className: "mb-1 break-words font-bold text-white",
      children: [t.error.name, " - ", t.error.description]
    }), E("p", {
      className: "break-words",
      children: t.error.path
    })]
  })
}

function Gk(t) {
  const {
    t: e
  } = ke();
  return Y("div", {
    className: `${t.localSize?"h-full":"min-h-screen"} flex w-full flex-col items-center justify-center px-4 py-12`,
    children: [Y("div", {
      className: "flex flex-col items-center justify-start text-center",
      children: [E(rn, {
        icon: ue.WARNING,
        className: "mb-6 text-red-400"
      }), E(og, {
        children: e("media.errors.genericTitle")
      }), t.children ? E("p", {
        className: "my-6 max-w-lg",
        children: t.children
      }) : E("p", {
        className: "my-6 max-w-lg",
        children: Y(zk, {
          i18nKey: "media.errors.videoFailed",
          children: [E(g1, {
            url: kr().DISCORD_LINK,
            newTab: !0
          }), E(g1, {
            url: kr().GITHUB_LINK,
            newTab: !0
          })]
        })
      })]
    }), t.error ? E(AMe, {
      error: t.error
    }) : null]
  })
}
class IMe extends A.Component {
  constructor(e) {
    super(e), this.state = {
      hasError: !1
    }
  }
  static getDerivedStateFromError() {
    return {
      hasError: !0
    }
  }
  componentDidCatch(e, r) {
    if (console.error("Render error caught", e, r), e instanceof Error) {
      const n = e;
      this.setState(i => ({
        ...i,
        hasError: !0,
        error: {
          name: n.name,
          description: n.message,
          path: r.componentStack.split(`
`)[1]
        }
      }))
    }
  }
  render() {
    return this.state.hasError ? E(Gk, {
      error: this.state.error
    }) : this.props.children
  }
}
var ae = (t => (t.MOVIE = "movie", t.SERIES = "series", t.ANIME = "anime", t))(ae || {}),
  m1 = function () {
    return m1 = Object.assign || function (e) {
      for (var r, n = 1, i = arguments.length; n < i; n++) {
        r = arguments[n];
        for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a])
      }
      return e
    }, m1.apply(this, arguments)
  };

function $Me() {
  var t = A.useRef(!1),
    e = A.useCallback(function () {
      return t.current
    }, []);
  return A.useEffect(function () {
    return t.current = !0,
      function () {
        t.current = !1
      }
  }, []), e
}

function CMe(t, e, r) {
  e === void 0 && (e = []), r === void 0 && (r = {
    loading: !1
  });
  var n = A.useRef(0),
    i = $Me(),
    a = A.useState(r),
    s = a[0],
    o = a[1],
    c = A.useCallback(function () {
      for (var l = [], u = 0; u < arguments.length; u++) l[u] = arguments[u];
      var f = ++n.current;
      return s.loading || o(function (d) {
        return m1(m1({}, d), {
          loading: !0
        })
      }), t.apply(void 0, l).then(function (d) {
        return i() && f === n.current && o({
          value: d,
          loading: !1
        }), d
      }, function (d) {
        return i() && f === n.current && o({
          error: d,
          loading: !1
        }), d
      })
    }, e);
  return [s, c]
}

function kMe(t, e) {
  e === void 0 && (e = []);
  var r = CMe(t, e, {
      loading: !0
    }),
    n = r[0],
    i = r[1];
  return A.useEffect(function () {
    i()
  }, [i]), n
}
var OMe = function () {},
  zY = typeof window < "u",
  LMe = zY ? A.useLayoutEffect : A.useEffect;
const PMe = LMe;
var GY = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};

function NMe() {
  var t = A.useState(null),
    e = t[0],
    r = t[1],
    n = A.useState(GY),
    i = n[0],
    a = n[1],
    s = A.useMemo(function () {
      return new window.ResizeObserver(function (o) {
        if (o[0]) {
          var c = o[0].contentRect,
            l = c.x,
            u = c.y,
            f = c.width,
            d = c.height,
            h = c.top,
            p = c.left,
            v = c.bottom,
            g = c.right;
          a({
            x: l,
            y: u,
            width: f,
            height: d,
            top: h,
            left: p,
            bottom: v,
            right: g
          })
        }
      })
    }, []);
  return PMe(function () {
    if (e) return s.observe(e),
      function () {
        s.disconnect()
      }
  }, [e]), [r, i]
}
const DMe = zY && typeof window.ResizeObserver < "u" ? NMe : function () {
    return [OMe, GY]
  },
  Vk = A.createContext(null);

function MMe(t) {
  const [e, r] = A.useState([]), n = A.useMemo(() => [e, r], [e]);
  return E(Vk.Provider, {
    value: n,
    children: t.children
  })
}

function FMe(t) {
  const [e, {
    height: r
  }] = DMe(), [n, i] = A.useContext(Vk);
  return A.useEffect(() => (i(a => [...a, {
    id: t,
    height: 0
  }]), i(a => {
    const s = a.find(o => o.id === t);
    return s && (s.height = r), a
  }), () => {
    i(a => a.filter(s => s.id !== t))
  }), [r, t, i]), [e]
}

function Jb() {
  const [t] = A.useContext(Vk);
  return t.reduce((e, r) => e + r.height, 0)
}

function BMe(t) {
  const [e] = FMe("internet"), r = {
    error: "bg-[#C93957] text-white"
  }, n = {
    error: ue.CIRCLE_EXCLAMATION
  };
  return E("div", {
    ref: e,
    children: E("div", {
      className: [r[t.type], "flex items-center justify-center p-1"].join(" "),
      children: Y("div", {
        className: "flex items-center space-x-3",
        children: [E(Ve, {
          icon: n[t.type]
        }), E("div", {
          children: t.children
        })]
      })
    })
  })
}

function UMe() {
  const [t, e] = A.useState(!0), r = A.useRef(!0);
  return A.useEffect(() => {
    let n = 0,
      i = null;
    const a = setInterval(() => {
      if (n += 1, r.current && n < 10) return;
      n = 0, i && i.abort(), i = new AbortController;
      const s = i.signal;
      fetch("/ping.txt", {
        signal: s
      }).then(() => {
        e(!0), r.current = !0
      }).catch(o => {
        o.name !== "AbortError" && (e(!1), r.current = !1)
      })
    }, 5e3);
    return () => {
      clearInterval(a), i && i.abort()
    }
  }, []), t
}

function jMe(t) {
  const {
    t: e
  } = ke(), r = UMe(), n = Jb();
  return Y("div", {
    children: [E("div", {
      className: "fixed inset-x-0 z-[1000]",
      children: r ? null : E(BMe, {
        type: "error",
        children: e("errors.offline")
      })
    }), E("div", {
      style: {
        paddingTop: `${n}px`
      },
      className: "flex min-h-screen flex-col",
      children: t.children
    })]
  })
}
const Ds = {},
  VY = {};
async function HMe() {
  var t, e;
  for (const [r, n] of Object.values(VY)) {
    const i = n.versions.sort((l, u) => l.version - u.version),
      a = r._raw(),
      s = a["--version"] && typeof a["--version"] == "number" ? a["--version"] : 0,
      o = i.filter(l => l.version >= s);
    let c = a;
    try {
      for (const l of o) l.migrate && (c = await l.migrate(c))
    } catch (l) {
      console.error(`FAILED TO MIGRATE STORE ${n.key}`, l), c = ((e = (t = o[o.length - 1]).create) == null ? void 0 : e.call(t)) ? ? {}
    }
    r.save(c)
  }
}

function zMe(t) {
  const e = t.key ? ? "",
    r = t.versions.sort((o, c) => c.version - o.version)[0];

  function n(o) {
    return Ds[e] || (Ds[e] = []), Ds[e].push(o), {
      destroy() {
        Ds[e] = Ds[e].filter(c => c === o)
      }
    }
  }

  function i() {
    var c;
    const o = ((c = r.create) == null ? void 0 : c.call(r)) ? ? {};
    return o["--version"] = r.version, o
  }

  function a() {
    const o = localStorage.getItem(e);
    if (!o) return i();
    try {
      return JSON.parse(o)
    } catch (c) {
      return console.error(`FAILED TO PARSE LOCALSTORAGE FOR KEY ${e}`, c), i()
    }
  }

  function s(o) {
    const c = {
      ...o
    };
    c["--version"] = r.version, localStorage.setItem(e, JSON.stringify(c)), Ds[e] || (Ds[e] = []), Ds[e].forEach(l => l(window.structuredClone(o)))
  }
  return {
    get() {
      const o = a();
      return delete o["--version"], o
    },
    _raw() {
      return a()
    },
    onChange: n,
    save: s
  }
}

function GMe(t) {
  var n;
  const e = t.versions.sort((i, a) => i.version - a.version);
  if (e.forEach((i, a, s) => {
      if (a !== 0 && i.version !== s[a - 1].version + 1) throw new Error("Version list of store is not incremental")
    }), e.forEach(i => {
      if (i.version < 0) throw new Error("Versions cannot be negative")
    }), ((n = e[0]) == null ? void 0 : n.version) !== 0) throw new Error("Version 0 doesn't exist in version list of store");
  if (!t.versions[t.versions.length - 1].create) throw new Error("Missing create function on latest version of store");
  if (!t.key) throw new Error("storage key not set in store");
  const r = [...e];
  r.pop(), r.forEach(i => {
    if (!i.migrate) throw new Error(`Migration missing on version ${i.version}`)
  })
}

function eE() {
  const t = {
    versions: [],
    key: null
  };
  return {
    setKey(e) {
      return t.key = e, this
    },
    addVersion(e) {
      return t.versions.push(e), this
    },
    build() {
      GMe(t);
      const e = zMe(t);
      return VY[t.key ? ? ""] = [e, t], e
    }
  }
}

function Wk(t) {
  const [e, r] = A.useState(t.get());
  A.useEffect(() => {
    const {
      destroy: i
    } = t.onChange(a => {
      r(a)
    });
    return () => {
      i()
    }
  }, [t]);

  function n(i) {
    const a = i(e);
    t.save(a)
  }
  return [e, n]
}
const VMe = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  WMe = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  KMe = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/;

function YMe(t, e) {
  if (t !== "__proto__" && !(t === "constructor" && e && typeof e == "object" && "prototype" in e)) return e
}

function qMe(t, e = {}) {
  if (typeof t != "string") return t;
  const r = t.toLowerCase().trim();
  if (r === "true") return !0;
  if (r === "false") return !1;
  if (r === "null") return null;
  if (r === "nan") return Number.NaN;
  if (r === "infinity") return Number.POSITIVE_INFINITY;
  if (r !== "undefined") {
    if (!KMe.test(t)) {
      if (e.strict) throw new SyntaxError("Invalid JSON");
      return t
    }
    try {
      return VMe.test(t) || WMe.test(t) ? JSON.parse(t, YMe) : JSON.parse(t)
    } catch (n) {
      if (e.strict) throw n;
      return t
    }
  }
}
const XMe = /#/g,
  QMe = /&/g,
  ZMe = /=/g,
  WY = /\+/g,
  JMe = /%5e/gi,
  eFe = /%60/gi,
  tFe = /%7c/gi,
  rFe = /%20/gi;

function nFe(t) {
  return encodeURI("" + t).replace(tFe, "|")
}

function uA(t) {
  return nFe(typeof t == "string" ? t : JSON.stringify(t)).replace(WY, "%2B").replace(rFe, "+").replace(XMe, "%23").replace(QMe, "%26").replace(eFe, "`").replace(JMe, "^")
}

function _T(t) {
  return uA(t).replace(ZMe, "%3D")
}

function KY(t = "") {
  try {
    return decodeURIComponent("" + t)
  } catch {
    return "" + t
  }
}

function iFe(t) {
  return KY(t.replace(WY, " "))
}

function aFe(t = "") {
  const e = {};
  t[0] === "?" && (t = t.slice(1));
  for (const r of t.split("&")) {
    const n = r.match(/([^=]+)=?(.*)/) || [];
    if (n.length < 2) continue;
    const i = KY(n[1]);
    if (i === "__proto__" || i === "constructor") continue;
    const a = iFe(n[2] || "");
    typeof e[i] < "u" ? Array.isArray(e[i]) ? e[i].push(a) : e[i] = [e[i], a] : e[i] = a
  }
  return e
}

function sFe(t, e) {
  return (typeof e == "number" || typeof e == "boolean") && (e = String(e)), e ? Array.isArray(e) ? e.map(r => `${_T(t)}=${uA(r)}`).join("&") : `${_T(t)}=${uA(e)}` : _T(t)
}

function oFe(t) {
  return Object.keys(t).filter(e => t[e] !== void 0).map(e => sFe(e, t[e])).join("&")
}
const lFe = /^\w{2,}:([/\\]{1,2})/,
  cFe = /^\w{2,}:([/\\]{2})?/,
  uFe = /^([/\\]\s*){2,}[^/\\]/;

function YY(t, e = {}) {
  return typeof e == "boolean" && (e = {
    acceptRelative: e
  }), e.strict ? lFe.test(t) : cFe.test(t) || (e.acceptRelative ? uFe.test(t) : !1)
}
const fFe = /\/$|\/\?/;

function fA(t = "", e = !1) {
  return e ? fFe.test(t) : t.endsWith("/")
}

function dFe(t = "", e = !1) {
  if (!e) return (fA(t) ? t.slice(0, -1) : t) || "/";
  if (!fA(t, !0)) return t || "/";
  const [r, ...n] = t.split("?");
  return (r.slice(0, -1) || "/") + (n.length > 0 ? `?${n.join("?")}` : "")
}

function hFe(t = "", e = !1) {
  if (!e) return t.endsWith("/") ? t : t + "/";
  if (fA(t, !0)) return t || "/";
  const [r, ...n] = t.split("?");
  return r + "/" + (n.length > 0 ? `?${n.join("?")}` : "")
}

function pFe(t = "") {
  return t.startsWith("/")
}

function gFe(t = "") {
  return (pFe(t) ? t.slice(1) : t) || "/"
}

function mFe(t, e) {
  if (yFe(e) || YY(t)) return t;
  const r = dFe(e);
  return t.startsWith(r) ? t : bFe(r, t)
}

function vFe(t, e) {
  const r = qY(t),
    n = {
      ...aFe(r.search),
      ...e
    };
  return r.search = oFe(n), EFe(r)
}

function yFe(t) {
  return !t || t === "/"
}

function xFe(t) {
  return t && t !== "/"
}

function bFe(t, ...e) {
  let r = t || "";
  for (const n of e.filter(i => xFe(i))) r = r ? hFe(r) + gFe(n) : n;
  return r
}

function qY(t = "", e) {
  if (!YY(t, {
      acceptRelative: !0
    })) return e ? qY(e + t) : y6(t);
  const [r = "", n, i = ""] = (t.replace(/\\/g, "/").match(/([^/:]+:)?\/\/([^/@]+@)?(.*)/) || []).splice(1), [a = "", s = ""] = (i.match(/([^#/?]*)(.*)?/) || []).splice(1), {
    pathname: o,
    search: c,
    hash: l
  } = y6(s.replace(/\/(?=[A-Za-z]:)/, ""));
  return {
    protocol: r,
    auth: n ? n.slice(0, Math.max(0, n.length - 1)) : "",
    host: a,
    pathname: o,
    search: c,
    hash: l
  }
}

function y6(t = "") {
  const [e = "", r = "", n = ""] = (t.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname: e,
    search: r,
    hash: n
  }
}

function EFe(t) {
  const e = t.pathname + (t.search ? (t.search.startsWith("?") ? "" : "?") + t.search : "") + t.hash;
  return t.protocol ? t.protocol + "//" + (t.auth ? t.auth + "@" : "") + t.host + e : e
}
let XY = class extends Error {
  constructor() {
    super(...arguments), this.name = "FetchError"
  }
};

function SFe(t, e, r) {
  let n = "";
  e && (n = e.message), t && r ? n = `${n} (${r.status} ${r.statusText} (${t.toString()}))` : t && (n = `${n} (${t.toString()})`);
  const i = new XY(n);
  return Object.defineProperty(i, "request", {
    get() {
      return t
    }
  }), Object.defineProperty(i, "response", {
    get() {
      return r
    }
  }), Object.defineProperty(i, "data", {
    get() {
      return r && r._data
    }
  }), Object.defineProperty(i, "status", {
    get() {
      return r && r.status
    }
  }), Object.defineProperty(i, "statusText", {
    get() {
      return r && r.statusText
    }
  }), Object.defineProperty(i, "statusCode", {
    get() {
      return r && r.status
    }
  }), Object.defineProperty(i, "statusMessage", {
    get() {
      return r && r.statusText
    }
  }), i
}
const _Fe = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function x6(t = "GET") {
  return _Fe.has(t.toUpperCase())
}

function TFe(t) {
  if (t === void 0) return !1;
  const e = typeof t;
  return e === "string" || e === "number" || e === "boolean" || e === null ? !0 : e !== "object" ? !1 : Array.isArray(t) ? !0 : t.constructor && t.constructor.name === "Object" || typeof t.toJSON == "function"
}
const wFe = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
  RFe = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function AFe(t = "") {
  if (!t) return "json";
  const e = t.split(";").shift() || "";
  return RFe.test(e) ? "json" : wFe.has(e) || e.startsWith("text/") ? "text" : "blob"
}
const IFe = new Set([408, 409, 425, 429, 500, 502, 503, 504]);

function QY(t) {
  const {
    fetch: e,
    Headers: r
  } = t;

  function n(s) {
    const o = s.error && s.error.name === "AbortError" || !1;
    if (s.options.retry !== !1 && !o) {
      let l;
      typeof s.options.retry == "number" ? l = s.options.retry : l = x6(s.options.method) ? 0 : 1;
      const u = s.response && s.response.status || 500;
      if (l > 0 && IFe.has(u)) return i(s.request, {
        ...s.options,
        retry: l - 1
      })
    }
    const c = SFe(s.request, s.error, s.response);
    throw Error.captureStackTrace && Error.captureStackTrace(c, i), c
  }
  const i = async function (o, c = {}) {
    const l = {
      request: o,
      options: {
        ...t.defaults,
        ...c
      },
      response: void 0,
      error: void 0
    };
    l.options.onRequest && await l.options.onRequest(l), typeof l.request == "string" && (l.options.baseURL && (l.request = mFe(l.request, l.options.baseURL)), (l.options.query || l.options.params) && (l.request = vFe(l.request, {
      ...l.options.params,
      ...l.options.query
    })), l.options.body && x6(l.options.method) && TFe(l.options.body) && (l.options.body = typeof l.options.body == "string" ? l.options.body : JSON.stringify(l.options.body), l.options.headers = new r(l.options.headers), l.options.headers.has("content-type") || l.options.headers.set("content-type", "application/json"), l.options.headers.has("accept") || l.options.headers.set("accept", "application/json"))), l.response = await e(l.request, l.options).catch(async f => (l.error = f, l.options.onRequestError && await l.options.onRequestError(l), n(l)));
    const u = (l.options.parseResponse ? "json" : l.options.responseType) || AFe(l.response.headers.get("content-type") || "");
    if (u === "json") {
      const f = await l.response.text(),
        d = l.options.parseResponse || qMe;
      l.response._data = d(f)
    } else u === "stream" ? l.response._data = l.response.body : l.response._data = await l.response[u]();
    return l.options.onResponse && await l.options.onResponse(l), l.response.status >= 400 && l.response.status < 600 ? (l.options.onResponseError && await l.options.onResponseError(l), n(l)) : l.response
  }, a = function (o, c) {
    return i(o, c).then(l => l._data)
  };
  return a.raw = i, a.native = e, a.create = (s = {}) => QY({
    ...t,
    defaults: {
      ...t.defaults,
      ...s
    }
  }), a
}
const ZY = function () {
    if (typeof globalThis < "u") return globalThis;
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object")
  }(),
  $Fe = ZY.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))),
  CFe = ZY.Headers,
  kFe = QY({
    fetch: $Fe,
    Headers: CFe
  }),
  dA = "https://apis.justwatch.com",
  OFe = "https://images.justwatch.com";

function Kk(t) {
  if (t === ae.MOVIE) return "movie";
  if (t === ae.SERIES) return "show";
  throw new Error("unsupported type")
}

function JY(t) {
  if (t === "movie") return ae.MOVIE;
  if (t === "show") return ae.SERIES;
  throw new Error("unsupported type")
}

function eq(t, e) {
  var i, a;
  const r = JY(t.object_type);
  let n;
  return r === ae.SERIES && (n = (i = t.seasons) == null ? void 0 : i.sort((s, o) => s.season_number - o.season_number).map(s => ({
    id: s.id.toString(),
    number: s.season_number,
    title: s.title
  }))), {
    title: t.title,
    id: t.id.toString(),
    year: (a = t.original_release_year) == null ? void 0 : a.toString(),
    poster: t.poster ? `${OFe}${t.poster.replace("{profile}","s166")}` : void 0,
    type: r,
    seasons: n,
    seasonData: e ? {
      id: e.id.toString(),
      number: e.season_number,
      title: e.title,
      episodes: e.episodes.sort((s, o) => s.episode_number - o.episode_number).map(s => ({
        id: s.id.toString(),
        number: s.episode_number,
        title: s.title
      }))
    } : void 0
  }
}

function LFe(t) {
  return ["JW", Kk(t.type), t.id].join("-")
}

function tq(t) {
  const [e, r, n] = t.split("-", 3);
  if (e !== "JW") return null;
  let i;
  try {
    i = JY(r)
  } catch {
    return null
  }
  return {
    type: i,
    id: n
  }
}
let TT = Math.floor(Math.random() * kr().PROXY_URLS.length);

function rq() {
  const t = kr().PROXY_URLS[TT];
  return TT = (TT + 1) % kr().PROXY_URLS.length, t
}
const Yk = kFe.create({
  retry: 0
});

function b6(t, e) {
  let r = t;
  return Object.entries(e).forEach(([n, i]) => {
    r = r.replace(`{${n}}`, encodeURIComponent(i))
  }), r
}

function Zh(t, e = {}) {
  return Yk(t, e)
}

function xe(t, e = {}) {
  let r = (e == null ? void 0 : e.baseURL) ? ? "";
  r.length > 0 && r.endsWith("/") && t.startsWith("/") ? r += t.slice(1) : r.length > 0 && !r.endsWith("/") && !t.startsWith("/") ? r += `/${t}` : r += t;
  const n = new URL(r);
  return Object.entries((e == null ? void 0 : e.params) ? ? {}).forEach(([i, a]) => {
    n.searchParams.set(i, a)
  }), Yk(rq(), {
    ...e,
    baseURL: void 0,
    params: {
      destination: n.toString()
    }
  })
}

function PFe(t, e = {}) {
  let r = (e == null ? void 0 : e.baseURL) ? ? "";
  r.length > 0 && r.endsWith("/") && t.startsWith("/") ? r += t.slice(1) : r.length > 0 && !r.endsWith("/") && !t.startsWith("/") ? r += `/${t}` : r += t;
  const n = new URL(r);
  return Object.entries((e == null ? void 0 : e.params) ? ? {}).forEach(([i, a]) => {
    n.searchParams.set(i, a)
  }), Yk.raw(rq(), {
    ...e,
    baseURL: void 0,
    params: {
      destination: n.toString()
    }
  })
}
async function v1(t, e, r) {
  var c, l, u, f, d;
  const n = Kk(t);
  let i;
  try {
    const h = b6("/content/titles/{type}/{id}/locale/en_US", {
      type: n,
      id: e
    });
    i = await xe(h, {
      baseURL: dA
    })
  } catch (h) {
    if (h instanceof XY && (h.statusCode === 400 || h.statusCode === 404)) return null;
    throw h
  }
  let a = (c = i.external_ids.find(h => h.provider === "imdb_latest")) == null ? void 0 : c.external_id;
  a || (a = (l = i.external_ids.find(h => h.provider === "imdb")) == null ? void 0 : l.external_id);
  let s = (u = i.external_ids.find(h => h.provider === "tmdb_latest")) == null ? void 0 : u.external_id;
  s || (s = (f = i.external_ids.find(h => h.provider === "tmdb")) == null ? void 0 : f.external_id);
  let o;
  if (i.object_type === "show") {
    const h = r ? ? ((d = i.seasons) == null ? void 0 : d[0].id.toString()) ? ? "",
      p = b6("/content/titles/show_season/{id}/locale/en_US", {
        id: h
      });
    o = await xe(p, {
      baseURL: dA
    })
  }
  return {
    meta: eq(i, o),
    imdbId: a,
    tmdbId: s
  }
}
class NFe {
  constructor() {
    this.INTERVAL_MS = 2 * 60 * 1e3, this._interval = null, this._compare = null, this._storage = []
  }
  initialize() {
    if (this._interval) throw new Error("cache is already initialized");
    this._interval = setInterval(() => {
      const e = new Date;
      this._storage.filter(r => !(r.expiry < e))
    }, this.INTERVAL_MS)
  }
  destroy() {
    this._interval && clearInterval(this._interval), this.clear()
  }
  setCompare(e) {
    this._compare = e
  }
  has(e) {
    return !!this.get(e)
  }
  get(e) {
    if (!this._compare) throw new Error("Compare function not set");
    const r = this._storage.find(n => this._compare && this._compare(n.key, e));
    if (r) return r.value
  }
  set(e, r, n) {
    if (!this._compare) throw new Error("Compare function not set");
    const i = this._storage.find(s => this._compare && this._compare(s.key, e)),
      a = new Date(new Date().getTime() + n * 1e3);
    if (i) {
      i.key = e, i.value = r, i.expiry = a;
      return
    }
    this._storage.push({
      key: e,
      value: r,
      expiry: a
    })
  }
  remove(e) {
    if (!this._compare) throw new Error("Compare function not set");
    this._storage.filter(r => !(this._compare && this._compare(r.key, e)))
  }
  clear() {
    this._storage = []
  }
}
const Jh = new NFe;
Jh.setCompare((t, e) => t.type === e.type && t.searchQuery.trim() === e.searchQuery.trim());
Jh.initialize();
async function nq(t) {
  if (Jh.has(t)) return Jh.get(t);
  const {
    searchQuery: e,
    type: r
  } = t, i = {
    content_types: [Kk(r)],
    page: 1,
    query: e,
    page_size: 40
  }, s = (await xe("/content/titles/en_US/popular", {
    baseURL: dA,
    params: {
      body: JSON.stringify(i)
    }
  })).items.map(o => eq(o));
  return Jh.set(t, s, 3600), s
}

function hA(t) {
  return t.trim().toLowerCase().replace(/['":]/g, "").replace(/[^a-zA-Z0-9]+/g, "_")
}

function qk(t, e) {
  return hA(t) === hA(e)
}
async function iq(t, e) {
  const r = (a, s) => Math.abs(a - s) <= 1,
    n = {},
    i = await Promise.all(Object.values(t).map(async a => {
      const s = Number(a.year.toString().split("-")[0]),
        c = (await nq({
          searchQuery: `${a.title} ${s}`,
          type: a.mediaType
        })).find(l => r(Number(l.year), s) && qk(l.title, a.title));
      if (!c) {
        console.error(`No item found for migration: ${a.title}`);
        return
      }
      return {
        id: a.mediaId,
        data: c
      }
    }));
  for (const a of i.filter(Boolean)) {
    if (!a) continue;
    let s = [
      ["0", "0"]
    ];
    if (a.data.type === "series") {
      const o = await v1(a.data.type, a.data.id);
      if (!o || !(o != null && o.meta.seasons)) return;
      s = [...new Set(e != null && e.items ? e.items.filter(u => u.mediaId === a.id).map(u => u.seasonId) : ["0"])].map(u => {
        var f, d;
        return {
          num: u,
          season: (d = (f = o.meta) == null ? void 0 : f.seasons) == null ? void 0 : d[Math.max(0, u - 1)]
        }
      }).map(u => {
        var f;
        return u ? [u.num, (f = u == null ? void 0 : u.season) == null ? void 0 : f.id] : []
      }).filter(u => u.length > 0)
    }
    n[a.id] || (n[a.id] = {}), await Promise.all(s.map(async ([o, c]) => {
      o && (n[a.id][o] = await v1(a.data.type, a.data.id, c === "0" || c === null ? void 0 : c))
    }))
  }
  return n
}
async function DFe(t) {
  const e = t;
  if (!e) return;
  const r = {};
  e.bookmarks.forEach(a => {
    r[a.mediaId] || (r[a.mediaId] = a)
  });
  const n = await iq(r);
  return n ? {
    bookmarks: Object.keys(n).map(a => n[a][0]).map(a => a == null ? void 0 : a.meta).filter(Boolean)
  } : void 0
}
async function MFe(t) {
  var s, o, c, l;
  const e = t;
  if (!e) return;
  const r = {};
  e.items.forEach(u => {
    r[u.mediaId] || (r[u.mediaId] = u)
  });
  const n = await iq(r, e);
  if (!n) return;
  const i = {
      ...e,
      items: []
    },
    a = Date.now();
  for (const u of e.items)
    if (u.mediaType === "movie") {
      if (!((s = n[u.mediaId][0]) != null && s.meta)) continue;
      const f = {
        item: {
          meta: (o = n[u.mediaId][0]) == null ? void 0 : o.meta
        },
        progress: u.progress,
        percentage: u.percentage,
        watchedAt: Date.now()
      };
      e.items = e.items.filter(d => JSON.stringify(d) !== JSON.stringify(u)), i.items.push(f)
    } else if (u.mediaType === "series") {
    if (!((c = n[u.mediaId][u.seasonId]) != null && c.meta)) continue;
    const f = (l = n[u.mediaId][u.seasonId]) == null ? void 0 : l.meta;
    if (f.type !== "series") return;
    const d = {
      item: {
        meta: f,
        series: {
          episode: Number(u.episodeId),
          season: Number(u.seasonId),
          seasonId: f.seasonData.id,
          episodeId: f.seasonData.episodes[Number(u.episodeId) - 1].id
        }
      },
      progress: u.progress,
      percentage: u.percentage,
      watchedAt: a + Number(u.seasonId) * 1e3 + Number(u.episodeId)
    };
    if (i.items.find(h => {
        var p, v;
        return h.item.meta.id === d.item.meta.id && ((p = h.item.series) == null ? void 0 : p.episodeId) === ((v = d.item.series) == null ? void 0 : v.episodeId)
      })) continue;
    e.items = e.items.filter(h => JSON.stringify(h) !== JSON.stringify(u)), i.items.push(d)
  }
  return i
}
const FFe = eE().setKey("mw-bookmarks").addVersion({
    version: 0,
    migrate(t) {
      return DFe(t)
    }
  }).addVersion({
    version: 1,
    create() {
      return {
        bookmarks: []
      }
    }
  }).build(),
  aq = A.createContext({
    setItemBookmark: () => {},
    getFilteredBookmarks: () => [],
    bookmarkStore: {
      bookmarks: []
    }
  });

function BFe(t, e) {
  return t.findIndex(n => n.id === e.id)
}

function UFe(t) {
  const [e, r] = Wk(FFe), n = A.useMemo(() => ({
    setItemBookmark(i, a) {
      r(s => {
        let o = [...s.bookmarks];
        return o = o.filter(c => c.id !== i.id), a && o.push({
          ...i
        }), {
          bookmarks: o
        }
      })
    },
    getFilteredBookmarks() {
      return [...e.bookmarks]
    },
    bookmarkStore: e
  }), [e, r]);
  return E(aq.Provider, {
    value: n,
    children: t.children
  })
}

function Xk() {
  return A.useContext(aq)
}

function sq(t, e) {
  return BFe(t, e) !== -1
}
const jFe = eE().setKey("mw-settings").addVersion({
    version: 0,
    create() {
      return {
        language: "en",
        captionSettings: {
          delay: 0,
          style: {
            color: "#ffffff",
            fontSize: 25,
            backgroundColor: "#00000096"
          }
        }
      }
    },
    migrate(t) {
      return {
        language: t.language,
        captionSettings: {
          language: "none",
          ...t.captionSettings
        }
      }
    }
  }).addVersion({
    version: 1,
    create() {
      return {
        language: "en",
        captionSettings: {
          delay: 0,
          language: "none",
          style: {
            color: "#ffffff",
            fontSize: 25,
            backgroundColor: "#00000096"
          }
        }
      }
    }
  }).build(),
  oq = A.createContext(null);

function HFe(t) {
  function e(a, s, o) {
    return Math.max(a, Math.min(s, o))
  }
  const [r, n] = Wk(jFe), i = A.useMemo(() => ({
    ...r,
    setLanguage(s) {
      n(o => ({
        ...o,
        language: s
      }))
    },
    setCaptionLanguage(s) {
      n(o => {
        const c = o.captionSettings;
        return c.language = s, o
      })
    },
    setCaptionDelay(s) {
      n(o => {
        const c = o.captionSettings;
        return c.delay = e(-10, s, 10), o
      })
    },
    setCaptionColor(s) {
      n(o => {
        const c = o.captionSettings.style;
        return c.color = s, o
      })
    },
    setCaptionFontSize(s) {
      n(o => {
        const c = o.captionSettings.style;
        return c.fontSize = e(10, s, 60), o
      })
    },
    setCaptionBackgroundColor(s) {
      n(o => {
        const c = o.captionSettings.style;
        return c.backgroundColor = `${c.backgroundColor.substring(0,7)}${s.toString(16).padStart(2,"0")}`, o
      })
    }
  }), [r, n]);
  return E(oq.Provider, {
    value: i,
    children: t.children
  })
}

function id() {
  return A.useContext(oq)
}
const zFe = eE().setKey("video-progress").addVersion({
    version: 0,
    migrate() {
      return {
        items: []
      }
    }
  }).addVersion({
    version: 1,
    async migrate(t) {
      return MFe(t)
    }
  }).addVersion({
    version: 2,
    create() {
      return {
        items: []
      }
    }
  }).build(),
  GFe = 15 * 60,
  VFe = 5 * 60;

function WFe(t, e, r) {
  const n = Math.max(0, e - t);
  return e < GFe ? !(t < 5 || n < 60) : !(t < 30 || n < VFe && !r)
}
const tE = A.createContext({
  updateProgress: () => {},
  getFilteredWatched: () => [],
  removeProgress: () => {},
  watched: {
    items: []
  }
});
tE.displayName = "WatchedContext";

function y1(t, e) {
  var r, n;
  return t.meta.id === e.meta.id && (!t.series || t.series.seasonId === ((r = e.series) == null ? void 0 : r.seasonId) && t.series.episodeId === ((n = e.series) == null ? void 0 : n.episodeId))
}

function KFe(t) {
  const [e, r] = Wk(zFe), n = A.useMemo(() => ({
    removeProgress(i) {
      r(a => {
        const s = {
          ...a
        };
        return s.items = s.items.filter(o => o.item.meta.id !== i), s
      })
    },
    updateProgress(i, a, s) {
      r(o => {
        const c = {
          ...o
        };
        let l = c.items.find(u => y1(i, u.item));
        return l || (l = {
          item: {
            ...i,
            meta: {
              ...i.meta
            },
            series: i.series ? {
              ...i.series
            } : void 0
          },
          progress: 0,
          percentage: 0,
          watchedAt: Date.now()
        }, c.items.push(l)), l.progress = a, l.percentage = Math.round(a / s * 100), l.watchedAt = Date.now(), WFe(a, s, !!i.series) || (c.items = o.items.filter(u => !y1(u.item, i))), c
      })
    },
    getFilteredWatched() {
      let i = e.items;
      const a = [];
      return i = i.sort((s, o) => o.watchedAt - s.watchedAt).filter(s => {
        const o = s.item.meta.id;
        return a.includes(o) ? !1 : (a.push(o), !0)
      }), i
    },
    watched: e
  }), [e, r]);
  return E(tE.Provider, {
    value: n,
    children: t.children
  })
}

function rE() {
  return A.useContext(tE)
}

function YFe(t, e, r) {
  return (e == null ? void 0 : e.meta.type) === ae.SERIES && r ? y1(t, {
    meta: e.meta,
    series: {
      season: 0,
      episode: 0,
      episodeId: r,
      seasonId: e.meta.seasonData.id
    }
  }) : e ? y1(t, {
    meta: e.meta
  }) : () => !1
}

function qFe(t, e) {
  const {
    watched: r,
    updateProgress: n
  } = A.useContext(tE), i = A.useMemo(() => r.items.find(o => YFe(o.item, t, e)), [r, t, e]), a = A.useRef([0, 0]);
  return {
    updateProgress: A.useCallback((o, c) => {
      var u;
      const l = a.current[0] !== o || a.current[1] !== c;
      if (t && l) {
        a.current = [o, c];
        const f = {
          meta: t.meta,
          series: t.meta.type === ae.SERIES && e ? {
            seasonId: t.meta.seasonData.id,
            episodeId: e,
            season: t.meta.seasonData.number,
            episode: ((u = t.meta.seasonData.episodes.find(d => d.id === e)) == null ? void 0 : u.number) || 0
          } : void 0
        };
        n(f, o, c)
      }
    }, [t, n, e]),
    watchedItem: i
  }
}

function XFe(t) {
  return t && typeof t == "object" && "default" in t ? t.default : t
}
var lq = A,
  QFe = XFe(lq);

function E6(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t
}

function ZFe(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
}
var JFe = !!(typeof window < "u" && window.document && window.document.createElement);

function e6e(t, e, r) {
  if (typeof t != "function") throw new Error("Expected reducePropsToState to be a function.");
  if (typeof e != "function") throw new Error("Expected handleStateChangeOnClient to be a function.");
  if (typeof r < "u" && typeof r != "function") throw new Error("Expected mapStateOnServer to either be undefined or a function.");

  function n(i) {
    return i.displayName || i.name || "Component"
  }
  return function (a) {
    if (typeof a != "function") throw new Error("Expected WrappedComponent to be a React component.");
    var s = [],
      o;

    function c() {
      o = t(s.map(function (u) {
        return u.props
      })), l.canUseDOM ? e(o) : r && (o = r(o))
    }
    var l = function (u) {
      ZFe(f, u);

      function f() {
        return u.apply(this, arguments) || this
      }
      f.peek = function () {
        return o
      }, f.rewind = function () {
        if (f.canUseDOM) throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        var p = o;
        return o = void 0, s = [], p
      };
      var d = f.prototype;
      return d.UNSAFE_componentWillMount = function () {
        s.push(this), c()
      }, d.componentDidUpdate = function () {
        c()
      }, d.componentWillUnmount = function () {
        var p = s.indexOf(this);
        s.splice(p, 1), c()
      }, d.render = function () {
        return QFe.createElement(a, this.props)
      }, f
    }(lq.PureComponent);
    return E6(l, "displayName", "SideEffect(" + n(a) + ")"), E6(l, "canUseDOM", JFe), l
  }
}
var t6e = e6e,
  r6e = typeof Element < "u",
  n6e = typeof Map == "function",
  i6e = typeof Set == "function",
  a6e = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;

function Xv(t, e) {
  if (t === e) return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor) return !1;
    var r, n, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != e.length) return !1;
      for (n = r; n-- !== 0;)
        if (!Xv(t[n], e[n])) return !1;
      return !0
    }
    var a;
    if (n6e && t instanceof Map && e instanceof Map) {
      if (t.size !== e.size) return !1;
      for (a = t.entries(); !(n = a.next()).done;)
        if (!e.has(n.value[0])) return !1;
      for (a = t.entries(); !(n = a.next()).done;)
        if (!Xv(n.value[1], e.get(n.value[0]))) return !1;
      return !0
    }
    if (i6e && t instanceof Set && e instanceof Set) {
      if (t.size !== e.size) return !1;
      for (a = t.entries(); !(n = a.next()).done;)
        if (!e.has(n.value[0])) return !1;
      return !0
    }
    if (a6e && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
      if (r = t.length, r != e.length) return !1;
      for (n = r; n-- !== 0;)
        if (t[n] !== e[n]) return !1;
      return !0
    }
    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function") return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function") return t.toString() === e.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(e).length) return !1;
    for (n = r; n-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(e, i[n])) return !1;
    if (r6e && t instanceof Element) return !1;
    for (n = r; n-- !== 0;)
      if (!((i[n] === "_owner" || i[n] === "__v" || i[n] === "__o") && t.$$typeof) && !Xv(t[i[n]], e[i[n]])) return !1;
    return !0
  }
  return t !== t && e !== e
}
var s6e = function (e, r) {
    try {
      return Xv(e, r)
    } catch (n) {
      if ((n.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
      throw n
    }
  },
  Ul = {
    BODY: "bodyAttributes",
    HTML: "htmlAttributes",
    TITLE: "titleAttributes"
  },
  Te = {
    BASE: "base",
    BODY: "body",
    HEAD: "head",
    HTML: "html",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title"
  };
Object.keys(Te).map(function (t) {
  return Te[t]
});
var lt = {
    CHARSET: "charset",
    CSS_TEXT: "cssText",
    HREF: "href",
    HTTPEQUIV: "http-equiv",
    INNER_HTML: "innerHTML",
    ITEM_PROP: "itemprop",
    NAME: "name",
    PROPERTY: "property",
    REL: "rel",
    SRC: "src",
    TARGET: "target"
  },
  x1 = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  },
  F0 = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate"
  },
  o6e = Object.keys(x1).reduce(function (t, e) {
    return t[x1[e]] = e, t
  }, {}),
  l6e = [Te.NOSCRIPT, Te.SCRIPT, Te.STYLE],
  Ai = "data-react-helmet",
  c6e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
    return typeof t
  } : function (t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  },
  u6e = function (t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  },
  f6e = function () {
    function t(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
      }
    }
    return function (e, r, n) {
      return r && t(e.prototype, r), n && t(e, n), e
    }
  }(),
  Ur = Object.assign || function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
    }
    return t
  },
  d6e = function (t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
  },
  S6 = function (t, e) {
    var r = {};
    for (var n in t) e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    return r
  },
  h6e = function (t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t
  },
  pA = function (e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return r === !1 ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
  },
  p6e = function (e) {
    var r = Gu(e, Te.TITLE),
      n = Gu(e, F0.TITLE_TEMPLATE);
    if (n && r) return n.replace(/%s/g, function () {
      return Array.isArray(r) ? r.join("") : r
    });
    var i = Gu(e, F0.DEFAULT_TITLE);
    return r || i || void 0
  },
  g6e = function (e) {
    return Gu(e, F0.ON_CHANGE_CLIENT_STATE) || function () {}
  },
  wT = function (e, r) {
    return r.filter(function (n) {
      return typeof n[e] < "u"
    }).map(function (n) {
      return n[e]
    }).reduce(function (n, i) {
      return Ur({}, n, i)
    }, {})
  },
  m6e = function (e, r) {
    return r.filter(function (n) {
      return typeof n[Te.BASE] < "u"
    }).map(function (n) {
      return n[Te.BASE]
    }).reverse().reduce(function (n, i) {
      if (!n.length)
        for (var a = Object.keys(i), s = 0; s < a.length; s++) {
          var o = a[s],
            c = o.toLowerCase();
          if (e.indexOf(c) !== -1 && i[c]) return n.concat(i)
        }
      return n
    }, [])
  },
  Jd = function (e, r, n) {
    var i = {};
    return n.filter(function (a) {
      return Array.isArray(a[e]) ? !0 : (typeof a[e] < "u" && b6e("Helmet: " + e + ' should be of type "Array". Instead found type "' + c6e(a[e]) + '"'), !1)
    }).map(function (a) {
      return a[e]
    }).reverse().reduce(function (a, s) {
      var o = {};
      s.filter(function (d) {
        for (var h = void 0, p = Object.keys(d), v = 0; v < p.length; v++) {
          var g = p[v],
            m = g.toLowerCase();
          r.indexOf(m) !== -1 && !(h === lt.REL && d[h].toLowerCase() === "canonical") && !(m === lt.REL && d[m].toLowerCase() === "stylesheet") && (h = m), r.indexOf(g) !== -1 && (g === lt.INNER_HTML || g === lt.CSS_TEXT || g === lt.ITEM_PROP) && (h = g)
        }
        if (!h || !d[h]) return !1;
        var y = d[h].toLowerCase();
        return i[h] || (i[h] = {}), o[h] || (o[h] = {}), i[h][y] ? !1 : (o[h][y] = !0, !0)
      }).reverse().forEach(function (d) {
        return a.push(d)
      });
      for (var c = Object.keys(o), l = 0; l < c.length; l++) {
        var u = c[l],
          f = NI({}, i[u], o[u]);
        i[u] = f
      }
      return a
    }, []).reverse()
  },
  Gu = function (e, r) {
    for (var n = e.length - 1; n >= 0; n--) {
      var i = e[n];
      if (i.hasOwnProperty(r)) return i[r]
    }
    return null
  },
  v6e = function (e) {
    return {
      baseTag: m6e([lt.HREF, lt.TARGET], e),
      bodyAttributes: wT(Ul.BODY, e),
      defer: Gu(e, F0.DEFER),
      encode: Gu(e, F0.ENCODE_SPECIAL_CHARACTERS),
      htmlAttributes: wT(Ul.HTML, e),
      linkTags: Jd(Te.LINK, [lt.REL, lt.HREF], e),
      metaTags: Jd(Te.META, [lt.NAME, lt.CHARSET, lt.HTTPEQUIV, lt.PROPERTY, lt.ITEM_PROP], e),
      noscriptTags: Jd(Te.NOSCRIPT, [lt.INNER_HTML], e),
      onChangeClientState: g6e(e),
      scriptTags: Jd(Te.SCRIPT, [lt.SRC, lt.INNER_HTML], e),
      styleTags: Jd(Te.STYLE, [lt.CSS_TEXT], e),
      title: p6e(e),
      titleAttributes: wT(Ul.TITLE, e)
    }
  },
  gA = function () {
    var t = Date.now();
    return function (e) {
      var r = Date.now();
      r - t > 16 ? (t = r, e(r)) : setTimeout(function () {
        gA(e)
      }, 0)
    }
  }(),
  _6 = function (e) {
    return clearTimeout(e)
  },
  y6e = typeof window < "u" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || gA : global.requestAnimationFrame || gA,
  x6e = typeof window < "u" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || _6 : global.cancelAnimationFrame || _6,
  b6e = function (e) {
    return console && typeof console.warn == "function" && console.warn(e)
  },
  eh = null,
  E6e = function (e) {
    eh && x6e(eh), e.defer ? eh = y6e(function () {
      T6(e, function () {
        eh = null
      })
    }) : (T6(e), eh = null)
  },
  T6 = function (e, r) {
    var n = e.baseTag,
      i = e.bodyAttributes,
      a = e.htmlAttributes,
      s = e.linkTags,
      o = e.metaTags,
      c = e.noscriptTags,
      l = e.onChangeClientState,
      u = e.scriptTags,
      f = e.styleTags,
      d = e.title,
      h = e.titleAttributes;
    mA(Te.BODY, i), mA(Te.HTML, a), S6e(d, h);
    var p = {
        baseTag: Hc(Te.BASE, n),
        linkTags: Hc(Te.LINK, s),
        metaTags: Hc(Te.META, o),
        noscriptTags: Hc(Te.NOSCRIPT, c),
        scriptTags: Hc(Te.SCRIPT, u),
        styleTags: Hc(Te.STYLE, f)
      },
      v = {},
      g = {};
    Object.keys(p).forEach(function (m) {
      var y = p[m],
        x = y.newTags,
        b = y.oldTags;
      x.length && (v[m] = x), b.length && (g[m] = p[m].oldTags)
    }), r && r(), l(e, v, g)
  },
  cq = function (e) {
    return Array.isArray(e) ? e.join("") : e
  },
  S6e = function (e, r) {
    typeof e < "u" && document.title !== e && (document.title = cq(e)), mA(Te.TITLE, r)
  },
  mA = function (e, r) {
    var n = document.getElementsByTagName(e)[0];
    if (n) {
      for (var i = n.getAttribute(Ai), a = i ? i.split(",") : [], s = [].concat(a), o = Object.keys(r), c = 0; c < o.length; c++) {
        var l = o[c],
          u = r[l] || "";
        n.getAttribute(l) !== u && n.setAttribute(l, u), a.indexOf(l) === -1 && a.push(l);
        var f = s.indexOf(l);
        f !== -1 && s.splice(f, 1)
      }
      for (var d = s.length - 1; d >= 0; d--) n.removeAttribute(s[d]);
      a.length === s.length ? n.removeAttribute(Ai) : n.getAttribute(Ai) !== o.join(",") && n.setAttribute(Ai, o.join(","))
    }
  },
  Hc = function (e, r) {
    var n = document.head || document.querySelector(Te.HEAD),
      i = n.querySelectorAll(e + "[" + Ai + "]"),
      a = Array.prototype.slice.call(i),
      s = [],
      o = void 0;
    return r && r.length && r.forEach(function (c) {
      var l = document.createElement(e);
      for (var u in c)
        if (c.hasOwnProperty(u))
          if (u === lt.INNER_HTML) l.innerHTML = c.innerHTML;
          else if (u === lt.CSS_TEXT) l.styleSheet ? l.styleSheet.cssText = c.cssText : l.appendChild(document.createTextNode(c.cssText));
      else {
        var f = typeof c[u] > "u" ? "" : c[u];
        l.setAttribute(u, f)
      }
      l.setAttribute(Ai, "true"), a.some(function (d, h) {
        return o = h, l.isEqualNode(d)
      }) ? a.splice(o, 1) : s.push(l)
    }), a.forEach(function (c) {
      return c.parentNode.removeChild(c)
    }), s.forEach(function (c) {
      return n.appendChild(c)
    }), {
      oldTags: a,
      newTags: s
    }
  },
  uq = function (e) {
    return Object.keys(e).reduce(function (r, n) {
      var i = typeof e[n] < "u" ? n + '="' + e[n] + '"' : "" + n;
      return r ? r + " " + i : i
    }, "")
  },
  _6e = function (e, r, n, i) {
    var a = uq(n),
      s = cq(r);
    return a ? "<" + e + " " + Ai + '="true" ' + a + ">" + pA(s, i) + "</" + e + ">" : "<" + e + " " + Ai + '="true">' + pA(s, i) + "</" + e + ">"
  },
  T6e = function (e, r, n) {
    return r.reduce(function (i, a) {
      var s = Object.keys(a).filter(function (l) {
          return !(l === lt.INNER_HTML || l === lt.CSS_TEXT)
        }).reduce(function (l, u) {
          var f = typeof a[u] > "u" ? u : u + '="' + pA(a[u], n) + '"';
          return l ? l + " " + f : f
        }, ""),
        o = a.innerHTML || a.cssText || "",
        c = l6e.indexOf(e) === -1;
      return i + "<" + e + " " + Ai + '="true" ' + s + (c ? "/>" : ">" + o + "</" + e + ">")
    }, "")
  },
  fq = function (e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(e).reduce(function (n, i) {
      return n[x1[i] || i] = e[i], n
    }, r)
  },
  w6e = function (e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(e).reduce(function (n, i) {
      return n[o6e[i] || i] = e[i], n
    }, r)
  },
  R6e = function (e, r, n) {
    var i, a = (i = {
        key: r
      }, i[Ai] = !0, i),
      s = fq(n, a);
    return [ce.createElement(Te.TITLE, s, r)]
  },
  A6e = function (e, r) {
    return r.map(function (n, i) {
      var a, s = (a = {
        key: i
      }, a[Ai] = !0, a);
      return Object.keys(n).forEach(function (o) {
        var c = x1[o] || o;
        if (c === lt.INNER_HTML || c === lt.CSS_TEXT) {
          var l = n.innerHTML || n.cssText;
          s.dangerouslySetInnerHTML = {
            __html: l
          }
        } else s[c] = n[o]
      }), ce.createElement(e, s)
    })
  },
  ka = function (e, r, n) {
    switch (e) {
      case Te.TITLE:
        return {
          toComponent: function () {
            return R6e(e, r.title, r.titleAttributes)
          }, toString: function () {
            return _6e(e, r.title, r.titleAttributes, n)
          }
        };
      case Ul.BODY:
      case Ul.HTML:
        return {
          toComponent: function () {
            return fq(r)
          }, toString: function () {
            return uq(r)
          }
        };
      default:
        return {
          toComponent: function () {
            return A6e(e, r)
          }, toString: function () {
            return T6e(e, r, n)
          }
        }
    }
  },
  dq = function (e) {
    var r = e.baseTag,
      n = e.bodyAttributes,
      i = e.encode,
      a = e.htmlAttributes,
      s = e.linkTags,
      o = e.metaTags,
      c = e.noscriptTags,
      l = e.scriptTags,
      u = e.styleTags,
      f = e.title,
      d = f === void 0 ? "" : f,
      h = e.titleAttributes;
    return {
      base: ka(Te.BASE, r, i),
      bodyAttributes: ka(Ul.BODY, n, i),
      htmlAttributes: ka(Ul.HTML, a, i),
      link: ka(Te.LINK, s, i),
      meta: ka(Te.META, o, i),
      noscript: ka(Te.NOSCRIPT, c, i),
      script: ka(Te.SCRIPT, l, i),
      style: ka(Te.STYLE, u, i),
      title: ka(Te.TITLE, {
        title: d,
        titleAttributes: h
      }, i)
    }
  },
  I6e = function (e) {
    var r, n;
    return n = r = function (i) {
      d6e(a, i);

      function a() {
        return u6e(this, a), h6e(this, i.apply(this, arguments))
      }
      return a.prototype.shouldComponentUpdate = function (o) {
        return !s6e(this.props, o)
      }, a.prototype.mapNestedChildrenToProps = function (o, c) {
        if (!c) return null;
        switch (o.type) {
          case Te.SCRIPT:
          case Te.NOSCRIPT:
            return {
              innerHTML: c
            };
          case Te.STYLE:
            return {
              cssText: c
            }
        }
        throw new Error("<" + o.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.")
      }, a.prototype.flattenArrayTypeChildren = function (o) {
        var c, l = o.child,
          u = o.arrayTypeChildren,
          f = o.newChildProps,
          d = o.nestedChildren;
        return Ur({}, u, (c = {}, c[l.type] = [].concat(u[l.type] || [], [Ur({}, f, this.mapNestedChildrenToProps(l, d))]), c))
      }, a.prototype.mapObjectTypeChildren = function (o) {
        var c, l, u = o.child,
          f = o.newProps,
          d = o.newChildProps,
          h = o.nestedChildren;
        switch (u.type) {
          case Te.TITLE:
            return Ur({}, f, (c = {}, c[u.type] = h, c.titleAttributes = Ur({}, d), c));
          case Te.BODY:
            return Ur({}, f, {
              bodyAttributes: Ur({}, d)
            });
          case Te.HTML:
            return Ur({}, f, {
              htmlAttributes: Ur({}, d)
            })
        }
        return Ur({}, f, (l = {}, l[u.type] = Ur({}, d), l))
      }, a.prototype.mapArrayTypeChildrenToProps = function (o, c) {
        var l = Ur({}, c);
        return Object.keys(o).forEach(function (u) {
          var f;
          l = Ur({}, l, (f = {}, f[u] = o[u], f))
        }), l
      }, a.prototype.warnOnInvalidChildren = function (o, c) {
        return !0
      }, a.prototype.mapChildrenToProps = function (o, c) {
        var l = this,
          u = {};
        return ce.Children.forEach(o, function (f) {
          if (!(!f || !f.props)) {
            var d = f.props,
              h = d.children,
              p = S6(d, ["children"]),
              v = w6e(p);
            switch (l.warnOnInvalidChildren(f, h), f.type) {
              case Te.LINK:
              case Te.META:
              case Te.NOSCRIPT:
              case Te.SCRIPT:
              case Te.STYLE:
                u = l.flattenArrayTypeChildren({
                  child: f,
                  arrayTypeChildren: u,
                  newChildProps: v,
                  nestedChildren: h
                });
                break;
              default:
                c = l.mapObjectTypeChildren({
                  child: f,
                  newProps: c,
                  newChildProps: v,
                  nestedChildren: h
                });
                break
            }
          }
        }), c = this.mapArrayTypeChildrenToProps(u, c), c
      }, a.prototype.render = function () {
        var o = this.props,
          c = o.children,
          l = S6(o, ["children"]),
          u = Ur({}, l);
        return c && (u = this.mapChildrenToProps(c, u)), ce.createElement(e, u)
      }, f6e(a, null, [{
        key: "canUseDOM",
        set: function (o) {
          e.canUseDOM = o
        }
      }]), a
    }(ce.Component), r.propTypes = {
      base: be.object,
      bodyAttributes: be.object,
      children: be.oneOfType([be.arrayOf(be.node), be.node]),
      defaultTitle: be.string,
      defer: be.bool,
      encodeSpecialCharacters: be.bool,
      htmlAttributes: be.object,
      link: be.arrayOf(be.object),
      meta: be.arrayOf(be.object),
      noscript: be.arrayOf(be.object),
      onChangeClientState: be.func,
      script: be.arrayOf(be.object),
      style: be.arrayOf(be.object),
      title: be.string,
      titleAttributes: be.object,
      titleTemplate: be.string
    }, r.defaultProps = {
      defer: !0,
      encodeSpecialCharacters: !0
    }, r.peek = e.peek, r.rewind = function () {
      var i = e.rewind();
      return i || (i = dq({
        baseTag: [],
        bodyAttributes: {},
        encodeSpecialCharacters: !0,
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      })), i
    }, n
  },
  $6e = function () {
    return null
  },
  C6e = t6e(v6e, E6e, dq)($6e),
  va = I6e(C6e);
va.renderStatic = va.rewind;

function lg(t) {
  return E("div", {
    className: t.className,
    children: Y("div", {
      className: "flex flex-col items-center justify-center",
      children: [Y("div", {
        className: "flex h-12 items-center justify-center",
        children: [E("div", {
          className: "mx-1 h-2 w-2 animate-loading-pin rounded-full bg-denim-300"
        }), E("div", {
          className: "mx-1 h-2 w-2 animate-loading-pin rounded-full bg-denim-300 [animation-delay:150ms]"
        }), E("div", {
          className: "mx-1 h-2 w-2 animate-loading-pin rounded-full bg-denim-300 [animation-delay:300ms]"
        }), E("div", {
          className: "mx-1 h-2 w-2 animate-loading-pin rounded-full bg-denim-300 [animation-delay:450ms]"
        })]
      }), t.text && t.text.length ? E("p", {
        className: "mt-3 max-w-xs text-sm opacity-75",
        children: t.text
      }) : null]
    })
  })
}

function nE() {
  const t = nd();
  return A.useCallback(() => {
    t.action !== "POP" ? t.goBack() : t.push("/")
  }, [t])
}

function ad(t) {
  const [e, r] = A.useState(!1), [n, i] = A.useState(!1), [a, s] = A.useState(void 0), o = A.useRef(!0), c = A.useMemo(() => t, []);
  return ce.useEffect(() => (o.current = !0, () => {
    o.current = !1
  }), []), [A.useMemo(() => async (...u) => (r(!0), i(!1), s(void 0), new Promise(f => {
    c(...u).then(d => o.current ? (i(!0), f(d), null) : f(void 0)).catch(d => {
      o && (s(d), console.error("USELOADING ERROR", d), i(!1)), f(void 0)
    })
  }).finally(() => o.current && r(!1))), [c]), e, a, n]
}
let _l = [],
  Su = [];

function Fi(t) {
  t.disabled || _l.push(t)
}

function cg(t) {
  t.disabled || Su.push(t)
}

function k6e() {
  _l = _l.sort((i, a) => a.rank - i.rank), Su = Su.sort((i, a) => a.rank - i.rank);
  let t = null;
  _l.forEach(i => {
    if (t === null) {
      t = i.rank;
      return
    }
    if (t === i.rank) throw new Error(`Duplicate rank number for provider ${i.id}`);
    t = i.rank
  }), t = null, _l.forEach(i => {
    if (t === null) {
      t = i.rank;
      return
    }
    if (t === i.rank) throw new Error(`Duplicate rank number for embed scraper ${i.id}`);
    t = i.rank
  });
  const e = _l.map(i => i.id);
  if (e.length > 0 && new Set(e).size !== e.length) throw new Error("Duplicate IDS in providers");
  const r = Su.map(i => i.id);
  if (r.length > 0 && new Set(r).size !== r.length) throw new Error("Duplicate IDS in embed scrapers");
  const n = Su.map(i => i.for);
  if (n.length > 0 && new Set(n).size !== n.length) throw new Error("Duplicate types in embed scrapers")
}

function hq() {
  return _l
}

function O6e() {
  return Su
}

function iE(t) {
  return O6e().find(e => e.for === t) ? ? null
}

function L6e(t) {
  return t.embeds = t.embeds.map(e => [e, e.type ? iE(e.type) : null]).sort(([, e], [, r]) => ((r == null ? void 0 : r.rank) ? ? 0) - ((e == null ? void 0 : e.rank) ? ? 0)).map(e => e[0]), t
}
async function pq(t, e) {
  try {
    const r = await t.scrape(e);
    return L6e(r)
  } catch (r) {
    throw console.error("Failed to run provider", r, {
      id: t.id,
      ctx: {
        ...e
      }
    }), r
  }
}
async function Qk(t, e) {
  try {
    return await t.getStream(e)
  } catch (r) {
    throw console.error("Failed to run embed scraper", {
      id: t.id,
      ctx: {
        ...e
      }
    }), r
  }
}
async function P6e(t, e, r) {
  var i, a, s;
  if (t.stream) return {
    ...t.stream,
    providerId: e,
    embedId: e
  };
  let n = 0;
  for (const o of t.embeds) {
    if (n += 1, !o.type) continue;
    const c = iE(o.type);
    if (!c) throw new Error(`Type for embed not found: ${o.type}`);
    const l = [e, c.id, n].join("|");
    (i = r.onNext) == null || i.call(r, {
      id: c.id,
      type: "embed",
      eventId: l
    });
    let u;
    try {
      u = await Qk(c, {
        url: o.url,
        progress(f) {
          var d;
          (d = r.onProgress) == null || d.call(r, {
            errored: !1,
            eventId: l,
            id: c.id,
            percentage: f,
            type: "embed"
          })
        }
      })
    } catch {
      (a = r.onProgress) == null || a.call(r, {
        errored: !0,
        eventId: l,
        id: c.id,
        percentage: 100,
        type: "embed"
      });
      continue
    }
    return (s = r.onProgress) == null || s.call(r, {
      errored: !1,
      eventId: l,
      id: c.id,
      percentage: 100,
      type: "embed"
    }), u.providerId = e, u
  }
  return null
}
async function N6e(t) {
  var r, n, i;
  const e = hq();
  for (const a of e) {
    const s = a.id;
    (r = t.onNext) == null || r.call(t, {
      id: a.id,
      type: "provider",
      eventId: s
    });
    let o;
    try {
      let l;
      t.type === ae.SERIES ? l = {
        media: t.media,
        type: t.type,
        episode: t.episode,
        season: t.season,
        progress(u) {
          var f;
          (f = t.onProgress) == null || f.call(t, {
            percentage: u,
            eventId: s,
            errored: !1,
            id: a.id,
            type: "provider"
          })
        }
      } : l = {
        media: t.media,
        type: t.type,
        progress(u) {
          var f;
          (f = t.onProgress) == null || f.call(t, {
            percentage: u,
            eventId: s,
            errored: !1,
            id: a.id,
            type: "provider"
          })
        }
      }, o = await pq(a, l)
    } catch {
      (n = t.onProgress) == null || n.call(t, {
        percentage: 100,
        errored: !0,
        eventId: s,
        id: a.id,
        type: "provider"
      });
      continue
    }(i = t.onProgress) == null || i.call(t, {
      errored: !1,
      id: a.id,
      eventId: s,
      percentage: 100,
      type: "provider"
    });
    const c = await P6e(o, a.id, t);
    if (c) return c
  }
  return null
}

function D6e(t, e) {
  const [r, n] = A.useState([]), [i, a] = A.useState(null), [s, o] = A.useState(!0);
  return A.useEffect(() => {
    o(!0), a(null), n([]), (async () => {
      const c = await N6e({
        media: t,
        ...e,
        onNext(l) {
          n(u => [...u, {
            errored: !1,
            id: l.id,
            eventId: l.eventId,
            type: l.type,
            percentage: 0
          }])
        },
        onProgress(l) {
          n(u => {
            const f = u.reverse().find(d => d.id === l.id);
            return f && (f.errored = l.errored, f.percentage = l.percentage), [...u]
          })
        }
      });
      o(!1), a(c)
    })()
  }, [t, e]), {
    stream: i,
    pending: s,
    eventLog: r
  }
}
let M6e = t => crypto.getRandomValues(new Uint8Array(t)),
  F6e = (t, e, r) => {
    let n = (2 << Math.log(t.length - 1) / Math.LN2) - 1,
      i = -~(1.6 * n * e / t.length);
    return (a = e) => {
      let s = "";
      for (;;) {
        let o = r(i),
          c = i;
        for (; c--;)
          if (s += t[o[c] & n] || "", s.length === a) return s
      }
    }
  },
  B6e = (t, e = 21) => F6e(t, e, M6e),
  U6e = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, r) => (r &= 63, r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r > 62 ? e += "-" : e += "_", e), "");
const B0 = new Map;

function br(t) {
  const e = B0.get(t);
  if (!e) throw new Error("invalid descriptor or has been unregistered");
  return e
}

function j6e(t) {
  const e = t;
  e.mediaPlaying = {
    isPlaying: !1,
    isPaused: !0,
    isLoading: !1,
    isSeeking: !1,
    isDragSeeking: !1,
    isFirstLoading: !0,
    hasPlayedOnce: !1,
    volume: e.mediaPlaying.volume,
    playbackSpeed: 1
  }, e.progress = {
    time: 0,
    duration: 0,
    buffered: 0,
    draggingTime: 0
  }, e.initalized = !1
}

function H6e() {
  return {
    interface: {
      popout: null, isFullscreen: !1, isFocused: !1, leftControlHovering: !1, popoutBounds: null, volumeChangedWithKeybind: !1, volumeChangedWithKeybindDebounce: null, timeFormat: 0
    },
    mediaPlaying: {
      isPlaying: !1,
      isPaused: !0,
      isLoading: !1,
      isSeeking: !1,
      isDragSeeking: !1,
      isFirstLoading: !0,
      hasPlayedOnce: !1,
      volume: 0,
      playbackSpeed: 1
    },
    progress: {
      time: 0,
      duration: 0,
      buffered: 0,
      draggingTime: 0
    },
    casting: {
      isCasting: !1,
      controller: null,
      instance: null,
      player: null
    },
    meta: null,
    source: null,
    error: null,
    canAirplay: !1,
    initalized: !1,
    stateProviderId: "video",
    pausedWhenSeeking: !1,
    hlsInstance: null,
    stateProvider: null,
    wrapperElement: null
  }
}

function z6e() {
  const t = U6e();
  if (B0.has(t)) throw new Error("duplicate id");
  return B0.set(t, H6e()), t
}

function G6e(t) {
  B0.has(t) && B0.delete(t)
}
const gq = A.createContext("");

function V6e(t) {
  const [e, r] = A.useState(null);
  return A.useEffect(() => {
    const n = z6e();
    return r(n), () => {
      G6e(n)
    }
  }, [r]), e ? E(gq.Provider, {
    value: e,
    children: t.children
  }) : null
}

function Re() {
  return A.useContext(gq)
}

function Zk(t, e) {
  return `_vid:::${t}:::${e}`
}

function yc(t, e, r) {
  const n = new CustomEvent(Zk(t, e), {
    detail: r
  });
  document.dispatchEvent(n)
}

function xc(t, e, r) {
  document.addEventListener(Zk(t, e), r)
}

function bc(t, e, r) {
  document.removeEventListener(Zk(t, e), r)
}

function mq(t) {
  return {
    popout: t.interface.popout,
    leftControlHovering: t.interface.leftControlHovering,
    isFocused: t.interface.isFocused,
    isFullscreen: t.interface.isFullscreen,
    popoutBounds: t.interface.popoutBounds,
    volumeChangedWithKeybind: t.interface.volumeChangedWithKeybind,
    timeFormat: t.interface.timeFormat
  }
}

function mn(t, e) {
  yc(t, "interface", mq(e))
}

function Bi(t) {
  const e = br(t),
    [r, n] = A.useState(mq(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "interface", i), () => {
      bc(t, "interface", i)
    }
  }, [t]), r
}

function vq(t) {
  return t.meta ? {
    ...t.meta
  } : null
}

function w6(t, e) {
  yc(t, "meta", vq(e))
}

function ui(t) {
  const e = br(t),
    [r, n] = A.useState(vq(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "meta", i), () => {
      bc(t, "meta", i)
    }
  }, [t]), r
}

function yq(t) {
  return {
    time: t.progress.time,
    duration: t.progress.duration,
    buffered: t.progress.buffered,
    draggingTime: t.progress.draggingTime
  }
}

function Xa(t, e) {
  yc(t, "progress", yq(e))
}

function Xo(t) {
  const e = br(t),
    [r, n] = A.useState(yq(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "progress", i), () => {
      bc(t, "progress", i)
    }
  }, [t]), r
}

function st(t) {
  const e = br(t);
  return {
    getId() {
      var r;
      return ((r = e.stateProvider) == null ? void 0 : r.getId()) ? ? ""
    },
    pause() {
      var r;
      (r = e.stateProvider) == null || r.pause()
    },
    play() {
      var r;
      (r = e.stateProvider) == null || r.play()
    },
    setSource(r) {
      var n;
      (n = e.stateProvider) == null || n.setSource(r)
    },
    setSeeking(r) {
      var n;
      (n = e.stateProvider) == null || n.setSeeking(r)
    },
    setTime(r) {
      var n;
      (n = e.stateProvider) == null || n.setTime(r)
    },
    exitFullscreen() {
      var r;
      (r = e.stateProvider) == null || r.exitFullscreen()
    },
    enterFullscreen() {
      var r;
      (r = e.stateProvider) == null || r.enterFullscreen()
    },
    setVolume(r, n = !1) {
      var i;
      n && (e.interface.volumeChangedWithKeybindDebounce && clearTimeout(e.interface.volumeChangedWithKeybindDebounce), e.interface.volumeChangedWithKeybind = !0, mn(t, e), e.interface.volumeChangedWithKeybindDebounce = setTimeout(() => {
        e.interface.volumeChangedWithKeybind = !1, mn(t, e)
      }, 3e3)), (i = e.stateProvider) == null || i.setVolume(r, n)
    },
    startAirplay() {
      var r;
      (r = e.stateProvider) == null || r.startAirplay()
    },
    setCaption(r, n) {
      var i;
      (i = e.stateProvider) == null || i.setCaption(r, n)
    },
    clearCaption() {
      var r;
      (r = e.stateProvider) == null || r.clearCaption()
    },
    setLeftControlsHover(r) {
      e.interface.leftControlHovering = r, mn(t, e)
    },
    setDraggingTime(r) {
      e.progress.draggingTime = Math.max(0, Math.min(e.progress.duration, r)), Xa(t, e)
    },
    openPopout(r) {
      e.interface.popout = r, mn(t, e)
    },
    closePopout() {
      e.interface.popout = null, mn(t, e)
    },
    setFocused(r) {
      e.interface.isFocused = r, mn(t, e)
    },
    setMeta(r) {
      r ? e.meta = r : e.meta = null, w6(t, e)
    },
    setCurrentEpisode(r, n) {
      e.meta && (e.meta.episode = {
        seasonId: r,
        episodeId: n
      }, w6(t, e))
    },
    togglePictureInPicture() {
      var r;
      (r = e.stateProvider) == null || r.togglePictureInPicture(), mn(t, e)
    },
    setPlaybackSpeed(r) {
      var n;
      (n = e.stateProvider) == null || n.setPlaybackSpeed(r), mn(t, e)
    },
    setTimeFormat(r) {
      e.interface.timeFormat = r, mn(t, e)
    }
  }
}

function W6e(t) {
  var r, n;
  const e = (n = (r = t.data) == null ? void 0 : r.seasons) == null ? void 0 : n.map(i => {
    var a;
    return i.id === ((a = t.seasonData) == null ? void 0 : a.id) ? {
      ...i,
      episodes: t.seasonData.episodes
    } : i
  });
  if (t.data) return {
    meta: t.data.meta,
    episode: t.data.episode,
    seasons: e,
    captions: t.linkedCaptions ? ? []
  }
}

function K6e(t) {
  const e = Re(),
    r = st(e);
  return A.useEffect(() => {
    r.setMeta(W6e(t))
  }, [t, r]), null
}
var xq = "Expected a function",
  R6 = 0 / 0,
  Y6e = "[object Symbol]",
  q6e = /^\s+|\s+$/g,
  X6e = /^[-+]0x[0-9a-f]+$/i,
  Q6e = /^0b[01]+$/i,
  Z6e = /^0o[0-7]+$/i,
  J6e = parseInt,
  e5e = typeof me == "object" && me && me.Object === Object && me,
  t5e = typeof self == "object" && self && self.Object === Object && self,
  r5e = e5e || t5e || Function("return this")(),
  n5e = Object.prototype,
  i5e = n5e.toString,
  a5e = Math.max,
  s5e = Math.min,
  RT = function () {
    return r5e.Date.now()
  };

function o5e(t, e, r) {
  var n, i, a, s, o, c, l = 0,
    u = !1,
    f = !1,
    d = !0;
  if (typeof t != "function") throw new TypeError(xq);
  e = A6(e) || 0, b1(r) && (u = !!r.leading, f = "maxWait" in r, a = f ? a5e(A6(r.maxWait) || 0, e) : a, d = "trailing" in r ? !!r.trailing : d);

  function h(S) {
    var T = n,
      R = i;
    return n = i = void 0, l = S, s = t.apply(R, T), s
  }

  function p(S) {
    return l = S, o = setTimeout(m, e), u ? h(S) : s
  }

  function v(S) {
    var T = S - c,
      R = S - l,
      I = e - T;
    return f ? s5e(I, a - R) : I
  }

  function g(S) {
    var T = S - c,
      R = S - l;
    return c === void 0 || T >= e || T < 0 || f && R >= a
  }

  function m() {
    var S = RT();
    if (g(S)) return y(S);
    o = setTimeout(m, v(S))
  }

  function y(S) {
    return o = void 0, d && n ? h(S) : (n = i = void 0, s)
  }

  function x() {
    o !== void 0 && clearTimeout(o), l = 0, n = c = i = o = void 0
  }

  function b() {
    return o === void 0 ? s : y(RT())
  }

  function _() {
    var S = RT(),
      T = g(S);
    if (n = arguments, i = this, c = S, T) {
      if (o === void 0) return p(c);
      if (f) return o = setTimeout(m, e), h(c)
    }
    return o === void 0 && (o = setTimeout(m, e)), s
  }
  return _.cancel = x, _.flush = b, _
}

function l5e(t, e, r) {
  var n = !0,
    i = !0;
  if (typeof t != "function") throw new TypeError(xq);
  return b1(r) && (n = "leading" in r ? !!r.leading : n, i = "trailing" in r ? !!r.trailing : i), o5e(t, e, {
    leading: n,
    maxWait: e,
    trailing: i
  })
}

function b1(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function")
}

function c5e(t) {
  return !!t && typeof t == "object"
}

function u5e(t) {
  return typeof t == "symbol" || c5e(t) && i5e.call(t) == Y6e
}

function A6(t) {
  if (typeof t == "number") return t;
  if (u5e(t)) return R6;
  if (b1(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = b1(e) ? e + "" : e
  }
  if (typeof t != "string") return t === 0 ? t : +t;
  t = t.replace(q6e, "");
  var r = Q6e.test(t);
  return r || Z6e.test(t) ? J6e(t.slice(2), r ? 2 : 8) : X6e.test(t) ? R6 : +t
}
var f5e = l5e;

function d5e() {
  const t = Bk();
  return A.useMemo(() => Object.fromEntries(new URLSearchParams(t.search).entries()), [t])
}

function bq(t) {
  return {
    hasPlayedOnce: t.mediaPlaying.hasPlayedOnce,
    isLoading: t.mediaPlaying.isLoading,
    isPaused: t.mediaPlaying.isPaused,
    isPlaying: t.mediaPlaying.isPlaying,
    isSeeking: t.mediaPlaying.isSeeking,
    isDragSeeking: t.mediaPlaying.isDragSeeking,
    isFirstLoading: t.mediaPlaying.isFirstLoading,
    volume: t.mediaPlaying.volume,
    playbackSpeed: t.mediaPlaying.playbackSpeed
  }
}

function Jt(t, e) {
  yc(t, "mediaplaying", bq(e))
}

function Cn(t) {
  const e = br(t),
    [r, n] = A.useState(bq(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "mediaplaying", i), () => {
      bc(t, "mediaplaying", i)
    }
  }, [t]), r
}

function Eq(t) {
  return {
    canAirplay: t.canAirplay,
    wrapperInitialized: !!t.wrapperElement,
    initalized: t.initalized,
    isCasting: t.casting.isCasting,
    stateProviderId: t.stateProviderId
  }
}

function sd(t, e) {
  yc(t, "misc", Eq(e))
}

function Ss(t) {
  const e = br(t),
    [r, n] = A.useState(Eq(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "misc", i), () => {
      bc(t, "misc", i)
    }
  }, [t]), r
}

function h5e(t) {
  const e = Re(),
    r = Cn(e),
    n = Xo(e),
    i = st(e),
    a = Ss(e),
    s = A.useRef(null),
    o = A.useRef(t.startAt ? ? 0),
    c = d5e(),
    l = A.useMemo(() => f5e((d, h) => {
      var p;
      o.current = d, (p = t.onProgress) == null || p.call(t, d, h)
    }, 1e3), [t]);
  A.useEffect(() => {
    r.isPlaying && (n.duration === 0 || n.time === 0 || l(n.time, n.duration))
  }, [n, r, l]), A.useEffect(() => () => {
    l.cancel()
  }, [l]), A.useEffect(() => {
    s.current || r.isFirstLoading || Number.isNaN(n.duration) || (i.setTime(o.current), s.current = !0)
  }, [s, t, n, r, i]);
  const u = A.useRef(null),
    f = A.useMemo(() => a.stateProviderId, [a]);
  return A.useEffect(() => {
    if (u.current !== f && !r.isFirstLoading) {
      if (u.current = f, (c.t ? ? null) !== null) {
        const d = c.t.toString().split(":").map(Number).reverse(),
          h = d[2] ? ? 0,
          p = Math.min(d[1] ? ? 0, 59),
          v = Math.min(d[0] ? ? 0, p > 0 ? 59 : 1 / 0),
          g = h * 60 * 60 + p * 60 + v;
        i.setTime(g);
        return
      }
      i.setTime(o.current)
    }
  }, [i, r, f, c]), A.useEffect(() => {
    s.current && r.isFirstLoading && (s.current = null)
  }, [r]), null
}

function p5e(t) {
  const e = Re(),
    r = ui(e),
    n = nd(),
    i = A.useRef(null);
  return A.useEffect(() => {
    var s, o, c, l, u;
    const a = {
      episodeId: (s = r == null ? void 0 : r.episode) == null ? void 0 : s.episodeId,
      seasonId: (o = r == null ? void 0 : r.episode) == null ? void 0 : o.seasonId
    };
    if (i.current === null) {
      if (!r) return;
      i.current = a;
      return
    }(a.episodeId !== ((c = i.current) == null ? void 0 : c.episodeId) || a.seasonId !== ((l = i.current) == null ? void 0 : l.seasonId)) && (i.current = a, (u = t.onSelect) == null || u.call(t, a))
  }, [r, t, n]), null
} /*! @license DOMPurify 3.0.2 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.2/LICENSE */
const {
  entries: Sq,
  setPrototypeOf: I6,
  isFrozen: g5e,
  getPrototypeOf: m5e,
  getOwnPropertyDescriptor: v5e
} = Object;
let {
  freeze: Or,
  seal: Oi,
  create: y5e
} = Object, {
  apply: vA,
  construct: yA
} = typeof Reflect < "u" && Reflect;
vA || (vA = function (e, r, n) {
  return e.apply(r, n)
});
Or || (Or = function (e) {
  return e
});
Oi || (Oi = function (e) {
  return e
});
yA || (yA = function (e, r) {
  return new e(...r)
});
const x5e = Jn(Array.prototype.forEach),
  $6 = Jn(Array.prototype.pop),
  th = Jn(Array.prototype.push),
  Qv = Jn(String.prototype.toLowerCase),
  AT = Jn(String.prototype.toString),
  b5e = Jn(String.prototype.match),
  mi = Jn(String.prototype.replace),
  E5e = Jn(String.prototype.indexOf),
  S5e = Jn(String.prototype.trim),
  dn = Jn(RegExp.prototype.test),
  IT = _5e(TypeError);

function Jn(t) {
  return function (e) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
    return vA(t, e, n)
  }
}

function _5e(t) {
  return function () {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];
    return yA(t, r)
  }
}

function Ae(t, e, r) {
  r = r || Qv, I6 && I6(t, null);
  let n = e.length;
  for (; n--;) {
    let i = e[n];
    if (typeof i == "string") {
      const a = r(i);
      a !== i && (g5e(e) || (e[n] = a), i = a)
    }
    t[i] = !0
  }
  return t
}

function zc(t) {
  const e = y5e(null);
  for (const [r, n] of Sq(t)) e[r] = n;
  return e
}

function Mm(t, e) {
  for (; t !== null;) {
    const n = v5e(t, e);
    if (n) {
      if (n.get) return Jn(n.get);
      if (typeof n.value == "function") return Jn(n.value)
    }
    t = m5e(t)
  }

  function r(n) {
    return console.warn("fallback value for", n), null
  }
  return r
}
const C6 = Or(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]),
  $T = Or(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]),
  CT = Or(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]),
  T5e = Or(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]),
  kT = Or(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]),
  w5e = Or(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]),
  k6 = Or(["#text"]),
  O6 = Or(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]),
  OT = Or(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]),
  L6 = Or(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]),
  Fm = Or(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]),
  R5e = Oi(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
  A5e = Oi(/<%[\w\W]*|[\w\W]*%>/gm),
  I5e = Oi(/\${[\w\W]*}/gm),
  $5e = Oi(/^data-[\-\w.\u00B7-\uFFFF]/),
  C5e = Oi(/^aria-[\-\w]+$/),
  _q = Oi(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
  k5e = Oi(/^(?:\w+script|data):/i),
  O5e = Oi(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
  Tq = Oi(/^html$/i);
var P6 = Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: R5e,
  ERB_EXPR: A5e,
  TMPLIT_EXPR: I5e,
  DATA_ATTR: $5e,
  ARIA_ATTR: C5e,
  IS_ALLOWED_URI: _q,
  IS_SCRIPT_OR_DATA: k5e,
  ATTR_WHITESPACE: O5e,
  DOCTYPE_NAME: Tq
});
const L5e = () => typeof window > "u" ? null : window,
  P5e = function (e, r) {
    if (typeof e != "object" || typeof e.createPolicy != "function") return null;
    let n = null;
    const i = "data-tt-policy-suffix";
    r.currentScript && r.currentScript.hasAttribute(i) && (n = r.currentScript.getAttribute(i));
    const a = "dompurify" + (n ? "#" + n : "");
    try {
      return e.createPolicy(a, {
        createHTML(s) {
          return s
        },
        createScriptURL(s) {
          return s
        }
      })
    } catch {
      return console.warn("TrustedTypes policy " + a + " could not be created."), null
    }
  };

function wq() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : L5e();
  const e = pe => wq(pe);
  if (e.version = "3.0.2", e.removed = [], !t || !t.document || t.document.nodeType !== 9) return e.isSupported = !1, e;
  const r = t.document;
  let {
    document: n
  } = t;
  const {
    DocumentFragment: i,
    HTMLTemplateElement: a,
    Node: s,
    Element: o,
    NodeFilter: c,
    NamedNodeMap: l = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: u,
    DOMParser: f,
    trustedTypes: d
  } = t, h = o.prototype, p = Mm(h, "cloneNode"), v = Mm(h, "nextSibling"), g = Mm(h, "childNodes"), m = Mm(h, "parentNode");
  if (typeof a == "function") {
    const pe = n.createElement("template");
    pe.content && pe.content.ownerDocument && (n = pe.content.ownerDocument)
  }
  const y = P5e(d, r),
    x = y ? y.createHTML("") : "",
    {
      implementation: b,
      createNodeIterator: _,
      createDocumentFragment: S,
      getElementsByTagName: T
    } = n,
    {
      importNode: R
    } = r;
  let I = {};
  e.isSupported = typeof Sq == "function" && typeof m == "function" && b && typeof b.createHTMLDocument < "u";
  const {
    MUSTACHE_EXPR: w,
    ERB_EXPR: C,
    TMPLIT_EXPR: L,
    DATA_ATTR: H,
    ARIA_ATTR: N,
    IS_SCRIPT_OR_DATA: P,
    ATTR_WHITESPACE: B
  } = P6;
  let {
    IS_ALLOWED_URI: V
  } = P6, M = null;
  const U = Ae({}, [...C6, ...$T, ...CT, ...kT, ...k6]);
  let W = null;
  const k = Ae({}, [...O6, ...OT, ...L6, ...Fm]);
  let O = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })),
    F = null,
    D = null,
    Q = !0,
    ee = !0,
    de = !1,
    oe = !0,
    rt = !1,
    Ft = !1,
    Dr = !1,
    un = !1,
    Tt = !1,
    wt = !1,
    Ia = !1,
    As = !0,
    Zo = !1;
  const Jo = "user-content-";
  let el = !0,
    fi = !1,
    Bt = {},
    kt = null;
  const di = Ae({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let tl = null;
  const xd = Ae({}, ["audio", "video", "img", "source", "image", "track"]);
  let ji = null;
  const Is = Ae({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]),
    Ic = "http://www.w3.org/1998/Math/MathML",
    rl = "http://www.w3.org/2000/svg",
    kn = "http://www.w3.org/1999/xhtml";
  let fn = kn,
    $a = !1,
    bd = null;
  const kg = Ae({}, [Ic, rl, kn], AT);
  let Hi;
  const jE = ["application/xhtml+xml", "text/html"],
    HE = "text/html";
  let Rt, $s = null;
  const Og = n.createElement("form"),
    Lg = function (z) {
      return z instanceof RegExp || z instanceof Function
    },
    $c = function (z) {
      $s && $s === z || ((!z || typeof z != "object") && (z = {}), z = zc(z), Hi = jE.indexOf(z.PARSER_MEDIA_TYPE) === -1 ? Hi = HE : Hi = z.PARSER_MEDIA_TYPE, Rt = Hi === "application/xhtml+xml" ? AT : Qv, M = "ALLOWED_TAGS" in z ? Ae({}, z.ALLOWED_TAGS, Rt) : U, W = "ALLOWED_ATTR" in z ? Ae({}, z.ALLOWED_ATTR, Rt) : k, bd = "ALLOWED_NAMESPACES" in z ? Ae({}, z.ALLOWED_NAMESPACES, AT) : kg, ji = "ADD_URI_SAFE_ATTR" in z ? Ae(zc(Is), z.ADD_URI_SAFE_ATTR, Rt) : Is, tl = "ADD_DATA_URI_TAGS" in z ? Ae(zc(xd), z.ADD_DATA_URI_TAGS, Rt) : xd, kt = "FORBID_CONTENTS" in z ? Ae({}, z.FORBID_CONTENTS, Rt) : di, F = "FORBID_TAGS" in z ? Ae({}, z.FORBID_TAGS, Rt) : {}, D = "FORBID_ATTR" in z ? Ae({}, z.FORBID_ATTR, Rt) : {}, Bt = "USE_PROFILES" in z ? z.USE_PROFILES : !1, Q = z.ALLOW_ARIA_ATTR !== !1, ee = z.ALLOW_DATA_ATTR !== !1, de = z.ALLOW_UNKNOWN_PROTOCOLS || !1, oe = z.ALLOW_SELF_CLOSE_IN_ATTR !== !1, rt = z.SAFE_FOR_TEMPLATES || !1, Ft = z.WHOLE_DOCUMENT || !1, Tt = z.RETURN_DOM || !1, wt = z.RETURN_DOM_FRAGMENT || !1, Ia = z.RETURN_TRUSTED_TYPE || !1, un = z.FORCE_BODY || !1, As = z.SANITIZE_DOM !== !1, Zo = z.SANITIZE_NAMED_PROPS || !1, el = z.KEEP_CONTENT !== !1, fi = z.IN_PLACE || !1, V = z.ALLOWED_URI_REGEXP || _q, fn = z.NAMESPACE || kn, O = z.CUSTOM_ELEMENT_HANDLING || {}, z.CUSTOM_ELEMENT_HANDLING && Lg(z.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (O.tagNameCheck = z.CUSTOM_ELEMENT_HANDLING.tagNameCheck), z.CUSTOM_ELEMENT_HANDLING && Lg(z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (O.attributeNameCheck = z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), z.CUSTOM_ELEMENT_HANDLING && typeof z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (O.allowCustomizedBuiltInElements = z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), rt && (ee = !1), wt && (Tt = !0), Bt && (M = Ae({}, [...k6]), W = [], Bt.html === !0 && (Ae(M, C6), Ae(W, O6)), Bt.svg === !0 && (Ae(M, $T), Ae(W, OT), Ae(W, Fm)), Bt.svgFilters === !0 && (Ae(M, CT), Ae(W, OT), Ae(W, Fm)), Bt.mathMl === !0 && (Ae(M, kT), Ae(W, L6), Ae(W, Fm))), z.ADD_TAGS && (M === U && (M = zc(M)), Ae(M, z.ADD_TAGS, Rt)), z.ADD_ATTR && (W === k && (W = zc(W)), Ae(W, z.ADD_ATTR, Rt)), z.ADD_URI_SAFE_ATTR && Ae(ji, z.ADD_URI_SAFE_ATTR, Rt), z.FORBID_CONTENTS && (kt === di && (kt = zc(kt)), Ae(kt, z.FORBID_CONTENTS, Rt)), el && (M["#text"] = !0), Ft && Ae(M, ["html", "head", "body"]), M.table && (Ae(M, ["tbody"]), delete F.tbody), Or && Or(z), $s = z)
    },
    Pg = Ae({}, ["mi", "mo", "mn", "ms", "mtext"]),
    Ng = Ae({}, ["foreignobject", "desc", "title", "annotation-xml"]),
    zE = Ae({}, ["title", "style", "font", "a", "script"]),
    nl = Ae({}, $T);
  Ae(nl, CT), Ae(nl, T5e);
  const Ed = Ae({}, kT);
  Ae(Ed, w5e);
  const GE = function (z) {
      let Z = m(z);
      (!Z || !Z.tagName) && (Z = {
        namespaceURI: fn,
        tagName: "template"
      });
      const se = Qv(z.tagName),
        Xe = Qv(Z.tagName);
      return bd[z.namespaceURI] ? z.namespaceURI === rl ? Z.namespaceURI === kn ? se === "svg" : Z.namespaceURI === Ic ? se === "svg" && (Xe === "annotation-xml" || Pg[Xe]) : !!nl[se] : z.namespaceURI === Ic ? Z.namespaceURI === kn ? se === "math" : Z.namespaceURI === rl ? se === "math" && Ng[Xe] : !!Ed[se] : z.namespaceURI === kn ? Z.namespaceURI === rl && !Ng[Xe] || Z.namespaceURI === Ic && !Pg[Xe] ? !1 : !Ed[se] && (zE[se] || !nl[se]) : !!(Hi === "application/xhtml+xml" && bd[z.namespaceURI]) : !1
    },
    zi = function (z) {
      th(e.removed, {
        element: z
      });
      try {
        z.parentNode.removeChild(z)
      } catch {
        z.remove()
      }
    },
    Sd = function (z, Z) {
      try {
        th(e.removed, {
          attribute: Z.getAttributeNode(z),
          from: Z
        })
      } catch {
        th(e.removed, {
          attribute: null,
          from: Z
        })
      }
      if (Z.removeAttribute(z), z === "is" && !W[z])
        if (Tt || wt) try {
          zi(Z)
        } catch {} else try {
          Z.setAttribute(z, "")
        } catch {}
    },
    _d = function (z) {
      let Z, se;
      if (un) z = "<remove></remove>" + z;
      else {
        const On = b5e(z, /^[\r\n\t ]+/);
        se = On && On[0]
      }
      Hi === "application/xhtml+xml" && fn === kn && (z = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + z + "</body></html>");
      const Xe = y ? y.createHTML(z) : z;
      if (fn === kn) try {
        Z = new f().parseFromString(Xe, Hi)
      } catch {}
      if (!Z || !Z.documentElement) {
        Z = b.createDocument(fn, "template", null);
        try {
          Z.documentElement.innerHTML = $a ? x : Xe
        } catch {}
      }
      const Ut = Z.body || Z.documentElement;
      return z && se && Ut.insertBefore(n.createTextNode(se), Ut.childNodes[0] || null), fn === kn ? T.call(Z, Ft ? "html" : "body")[0] : Ft ? Z.documentElement : Ut
    },
    cr = function (z) {
      return _.call(z.ownerDocument || z, z, c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT, null, !1)
    },
    Gi = function (z) {
      return z instanceof u && (typeof z.nodeName != "string" || typeof z.textContent != "string" || typeof z.removeChild != "function" || !(z.attributes instanceof l) || typeof z.removeAttribute != "function" || typeof z.setAttribute != "function" || typeof z.namespaceURI != "string" || typeof z.insertBefore != "function" || typeof z.hasChildNodes != "function")
    },
    il = function (z) {
      return typeof s == "object" ? z instanceof s : z && typeof z == "object" && typeof z.nodeType == "number" && typeof z.nodeName == "string"
    },
    hi = function (z, Z, se) {
      I[z] && x5e(I[z], Xe => {
        Xe.call(e, Z, se, $s)
      })
    },
    IL = function (z) {
      let Z;
      if (hi("beforeSanitizeElements", z, null), Gi(z)) return zi(z), !0;
      const se = Rt(z.nodeName);
      if (hi("uponSanitizeElement", z, {
          tagName: se,
          allowedTags: M
        }), z.hasChildNodes() && !il(z.firstElementChild) && (!il(z.content) || !il(z.content.firstElementChild)) && dn(/<[/\w]/g, z.innerHTML) && dn(/<[/\w]/g, z.textContent)) return zi(z), !0;
      if (!M[se] || F[se]) {
        if (!F[se] && CL(se) && (O.tagNameCheck instanceof RegExp && dn(O.tagNameCheck, se) || O.tagNameCheck instanceof Function && O.tagNameCheck(se))) return !1;
        if (el && !kt[se]) {
          const Xe = m(z) || z.parentNode,
            Ut = g(z) || z.childNodes;
          if (Ut && Xe) {
            const On = Ut.length;
            for (let gt = On - 1; gt >= 0; --gt) Xe.insertBefore(p(Ut[gt], !0), v(z))
          }
        }
        return zi(z), !0
      }
      return z instanceof o && !GE(z) || (se === "noscript" || se === "noembed") && dn(/<\/no(script|embed)/i, z.innerHTML) ? (zi(z), !0) : (rt && z.nodeType === 3 && (Z = z.textContent, Z = mi(Z, w, " "), Z = mi(Z, C, " "), Z = mi(Z, L, " "), z.textContent !== Z && (th(e.removed, {
        element: z.cloneNode()
      }), z.textContent = Z)), hi("afterSanitizeElements", z, null), !1)
    },
    $L = function (z, Z, se) {
      if (As && (Z === "id" || Z === "name") && (se in n || se in Og)) return !1;
      if (!(ee && !D[Z] && dn(H, Z))) {
        if (!(Q && dn(N, Z))) {
          if (!W[Z] || D[Z]) {
            if (!(CL(z) && (O.tagNameCheck instanceof RegExp && dn(O.tagNameCheck, z) || O.tagNameCheck instanceof Function && O.tagNameCheck(z)) && (O.attributeNameCheck instanceof RegExp && dn(O.attributeNameCheck, Z) || O.attributeNameCheck instanceof Function && O.attributeNameCheck(Z)) || Z === "is" && O.allowCustomizedBuiltInElements && (O.tagNameCheck instanceof RegExp && dn(O.tagNameCheck, se) || O.tagNameCheck instanceof Function && O.tagNameCheck(se)))) return !1
          } else if (!ji[Z]) {
            if (!dn(V, mi(se, B, ""))) {
              if (!((Z === "src" || Z === "xlink:href" || Z === "href") && z !== "script" && E5e(se, "data:") === 0 && tl[z])) {
                if (!(de && !dn(P, mi(se, B, "")))) {
                  if (se) return !1
                }
              }
            }
          }
        }
      }
      return !0
    },
    CL = function (z) {
      return z.indexOf("-") > 0
    },
    kL = function (z) {
      let Z, se, Xe, Ut;
      hi("beforeSanitizeAttributes", z, null);
      const {
        attributes: On
      } = z;
      if (!On) return;
      const gt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: W
      };
      for (Ut = On.length; Ut--;) {
        Z = On[Ut];
        const {
          name: Vi,
          namespaceURI: VE
        } = Z;
        if (se = Vi === "value" ? Z.value : S5e(Z.value), Xe = Rt(Vi), gt.attrName = Xe, gt.attrValue = se, gt.keepAttr = !0, gt.forceKeepAttr = void 0, hi("uponSanitizeAttribute", z, gt), se = gt.attrValue, gt.forceKeepAttr || (Sd(Vi, z), !gt.keepAttr)) continue;
        if (!oe && dn(/\/>/i, se)) {
          Sd(Vi, z);
          continue
        }
        rt && (se = mi(se, w, " "), se = mi(se, C, " "), se = mi(se, L, " "));
        const OL = Rt(z.nodeName);
        if ($L(OL, Xe, se)) {
          if (Zo && (Xe === "id" || Xe === "name") && (Sd(Vi, z), se = Jo + se), y && typeof d == "object" && typeof d.getAttributeType == "function" && !VE) switch (d.getAttributeType(OL, Xe)) {
            case "TrustedHTML":
              se = y.createHTML(se);
              break;
            case "TrustedScriptURL":
              se = y.createScriptURL(se);
              break
          }
          try {
            VE ? z.setAttributeNS(VE, Vi, se) : z.setAttribute(Vi, se), $6(e.removed)
          } catch {}
        }
      }
      hi("afterSanitizeAttributes", z, null)
    },
    Aee = function pe(z) {
      let Z;
      const se = cr(z);
      for (hi("beforeSanitizeShadowDOM", z, null); Z = se.nextNode();) hi("uponSanitizeShadowNode", Z, null), !IL(Z) && (Z.content instanceof i && pe(Z.content), kL(Z));
      hi("afterSanitizeShadowDOM", z, null)
    };
  return e.sanitize = function (pe) {
    let z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      Z, se, Xe, Ut;
    if ($a = !pe, $a && (pe = "<!-->"), typeof pe != "string" && !il(pe)) {
      if (typeof pe.toString != "function") throw IT("toString is not a function");
      if (pe = pe.toString(), typeof pe != "string") throw IT("dirty is not a string, aborting")
    }
    if (!e.isSupported) return pe;
    if (Dr || $c(z), e.removed = [], typeof pe == "string" && (fi = !1), fi) {
      if (pe.nodeName) {
        const Vi = Rt(pe.nodeName);
        if (!M[Vi] || F[Vi]) throw IT("root node is forbidden and cannot be sanitized in-place")
      }
    } else if (pe instanceof s) Z = _d("<!---->"), se = Z.ownerDocument.importNode(pe, !0), se.nodeType === 1 && se.nodeName === "BODY" || se.nodeName === "HTML" ? Z = se : Z.appendChild(se);
    else {
      if (!Tt && !rt && !Ft && pe.indexOf("<") === -1) return y && Ia ? y.createHTML(pe) : pe;
      if (Z = _d(pe), !Z) return Tt ? null : Ia ? x : ""
    }
    Z && un && zi(Z.firstChild);
    const On = cr(fi ? pe : Z);
    for (; Xe = On.nextNode();) IL(Xe) || (Xe.content instanceof i && Aee(Xe.content), kL(Xe));
    if (fi) return pe;
    if (Tt) {
      if (wt)
        for (Ut = S.call(Z.ownerDocument); Z.firstChild;) Ut.appendChild(Z.firstChild);
      else Ut = Z;
      return (W.shadowroot || W.shadowrootmod) && (Ut = R.call(r, Ut, !0)), Ut
    }
    let gt = Ft ? Z.outerHTML : Z.innerHTML;
    return Ft && M["!doctype"] && Z.ownerDocument && Z.ownerDocument.doctype && Z.ownerDocument.doctype.name && dn(Tq, Z.ownerDocument.doctype.name) && (gt = "<!DOCTYPE " + Z.ownerDocument.doctype.name + `>
` + gt), rt && (gt = mi(gt, w, " "), gt = mi(gt, C, " "), gt = mi(gt, L, " ")), y && Ia ? y.createHTML(gt) : gt
  }, e.setConfig = function (pe) {
    $c(pe), Dr = !0
  }, e.clearConfig = function () {
    $s = null, Dr = !1
  }, e.isValidAttribute = function (pe, z, Z) {
    $s || $c({});
    const se = Rt(pe),
      Xe = Rt(z);
    return $L(se, Xe, Z)
  }, e.addHook = function (pe, z) {
    typeof z == "function" && (I[pe] = I[pe] || [], th(I[pe], z))
  }, e.removeHook = function (pe) {
    if (I[pe]) return $6(I[pe])
  }, e.removeHooks = function (pe) {
    I[pe] && (I[pe] = [])
  }, e.removeAllHooks = function () {
    I = {}
  }, e
}
var N5e = wq();
class D5e {
  constructor({
    name: e,
    build: r,
    detect: n,
    helper: i,
    parse: a
  }) {
    this.name = e, this.helper = i, this.build = r, this.detect = s => {
      if (typeof s != "string") throw new Error("Expected string content!");
      return n(s)
    }, this.parse = (s, o) => {
      if (typeof s != "string") throw new Error("Expected string content!");
      return a(s, o)
    }
  }
}
const _s = t => new D5e(t),
  M5e = "ssa",
  xf = {
    toMilliseconds: t => {
      const e = /^\s*(\d+:)?(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(t);
      if (!e) throw new Error(`Invalid time format: ${t}`);
      const r = e[1] ? parseInt(e[1].replace(":", "")) : 0,
        n = parseInt(e[2]),
        i = parseInt(e[3]),
        a = e[4] ? parseInt(e[4]) : 0;
      return r * 3600 * 1e3 + n * 60 * 1e3 + i * 1e3 + a * 10
    },
    toTimeString: t => {
      const e = Math.floor(t / 1e3 / 3600),
        r = Math.floor(t / 1e3 / 60 % 60),
        n = Math.floor(t / 1e3 % 60),
        i = Math.floor(t % 1e3 / 10);
      return `${e}:${r<10?"0":""}${r}:${n<10?"0":""}${n}.${i<10?"0":""}${i}`
    }
  },
  Rq = (t, e) => {
    let r, n = null;
    const i = [],
      a = e.eol || `\r
`,
      s = t.split(/\r?\n\s*\n/);
    for (let o = 0; o < s.length; o++) {
      const l = /^\s*\[([^\]]+)\]\r?\n([\s\S]*)$/.exec(s[o]);
      if (l) {
        const u = l[1],
          f = l[2].split(/\r?\n/);
        for (let d = 0; d < f.length; d++) {
          const h = f[d];
          if (/^\s*;/.test(h)) continue;
          const p = /^\s*([^\s:]+):\s*(.*)$/.exec(h);
          if (p) {
            if (u === "Script Info")
              if (r || (r = {}, r.type = "meta", r.data = {}, i.push(r)), typeof r.data == "object") {
                const v = p[1].trim(),
                  g = p[2].trim();
                r.data[v] = g
              } else throw new Error(`Invalid meta data: ${h}`);
            else if (u === "V4 Styles" || u === "V4+ Styles") {
              const v = p[1].trim(),
                g = p[2].trim();
              if (v === "Format") n = g.split(/\s*,\s*/g);
              else if (v === "Style" && n) {
                const m = g.split(/\s*,\s*/g),
                  y = {};
                y.type = "style", y.data = {};
                for (let x = 0; x < n.length && x < m.length; x++) y.data[n[x]] = m[x];
                i.push(y)
              }
            } else if (u === "Events") {
              const v = p[1].trim(),
                g = p[2].trim();
              if (v === "Format") n = g.split(/\s*,\s*/g);
              else if (v === "Dialogue" && n) {
                const m = g.split(/\s*,\s*/g),
                  y = {};
                y.type = "caption", y.data = {};
                for (let _ = 0; _ < n.length && _ < m.length; _++) y.data[n[_]] = m[_];
                y.start = xf.toMilliseconds(y.data.Start), y.end = xf.toMilliseconds(y.data.End), y.duration = y.end - y.start, y.content = y.data.Text;
                const b = ((_, S, T) => _.split(S, T).join(S).length)(g, ",", n.length - 1) + 1;
                y.content = g.substring(b), y.data.Text = y.content, y.text = y.content.replace(/\\N/g, a).replace(/\{[^}]+\}/g, ""), i.push(y)
              }
            }
          }
        }
      }
      e.verbose && console.log("WARN: Unknown part", s[o])
    }
    return i
  },
  Aq = (t, e) => {
    const r = e.eol || `\r
`,
      n = e.format === "ass";
    let i = "";
    i += `[Script Info]${r}`, i += `; Script generated by subsrt ${r}`, i += `ScriptType: v4.00${n?"+":""}${r}`, i += `Collisions: Normal${r}`, i += r, n ? (i += `[V4+ Styles]${r}`, i += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding${r}`, i += `Style: DefaultVCD, Arial,28,&H00B4FCFC,&H00B4FCFC,&H00000008,&H80000008,-1,0,0,0,100,100,0.00,0.00,1,1.00,2.00,2,30,30,30,0${r}`) : (i += `[V4 Styles]${r}`, i += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding${r}`, i += `Style: DefaultVCD, Arial,28,11861244,11861244,11861244,-2147483640,-1,0,1,1,2,2,30,30,30,0,0${r}`), i += r, i += `[Events]${r}`, i += `Format: ${n?"Layer":"Marked"}, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text${r}`;
    for (let a = 0; a < t.length; a++) {
      const s = t[a];
      if (s.type !== "meta") {
        if (!s.type || s.type === "caption") {
          i += `Dialogue: ${n?"0":"Marked=0"},${xf.toTimeString(s.start)},${xf.toTimeString(s.end)},DefaultVCD, NTP,0000,0000,0000,,${s.text.replace(/\r?\n/g,"\\N")}${r}`;
          continue
        }
        e.verbose && console.log("SKIP:", s)
      }
    }
    return i
  },
  Iq = t => /^\s*\[Script Info\]\r?\n/.test(t) && /\s*\[Events\]\r?\n/.test(t) ? t.indexOf("[V4+ Styles]") > 0 ? "ass" : "ssa" : !1,
  F5e = _s({
    name: M5e,
    build: Aq,
    detect: Iq,
    helper: xf,
    parse: Rq
  }),
  B5e = "ass",
  U5e = _s({
    name: B5e,
    build: Aq,
    detect: Iq,
    helper: xf,
    parse: Rq
  }),
  j5e = "json",
  H5e = (t, e) => JSON.parse(t),
  z5e = (t, e) => JSON.stringify(t, void 0, 2),
  G5e = t => {
    try {
      const e = JSON.parse(t);
      return Array.isArray(e) && e.length > 0 && typeof e[0] == "object"
    } catch {
      return !1
    }
  },
  V5e = _s({
    name: j5e,
    build: z5e,
    detect: G5e,
    parse: H5e
  }),
  W5e = "lrc",
  Jk = {
    toMilliseconds: t => {
      const e = /^\s*(\d+):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(t);
      if (!e) throw new Error(`Invalid time format: ${t}`);
      const r = parseInt(e[1]),
        n = parseInt(e[2]),
        i = e[3] ? parseInt(e[3]) : 0;
      return r * 60 * 1e3 + n * 1e3 + i * 10
    },
    toTimeString: t => {
      const e = Math.floor(t / 1e3 / 60),
        r = Math.floor(t / 1e3 % 60),
        n = Math.floor(t % 1e3);
      return `${(e<10?"0":"")+e}:${r<10?"0":""}${r}.${n<100?"0":""}${n<10?"0":Math.floor(n/10)}`
    }
  },
  K5e = (t, e) => {
    let r = null;
    const n = [],
      i = t.split(/\r?\n/);
    for (let a = 0; a < i.length; a++) {
      if (!i[a] || i[a].trim().length === 0) continue;
      const o = /^\[(\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\](.*)(?:\r?\n)*$/.exec(i[a]);
      if (o) {
        const l = {};
        l.type = "caption", l.start = Jk.toMilliseconds(o[1]), l.end = l.start + 2e3, l.duration = l.end - l.start, l.content = o[2], l.text = l.content, n.push(l), r && (r.end = l.start, r.duration = r.end - r.start), r = l;
        continue
      }
      const c = /^\[(\w+):([^\]]*)\](?:\r?\n)*$/.exec(i[a]);
      if (c) {
        const l = {};
        l.type = "meta", l.tag = c[1], c[2] && (l.data = c[2]), n.push(l);
        continue
      }
      e.verbose && console.log("WARN: Unknown part", i[a])
    }
    return n
  },
  Y5e = (t, e) => {
    let r = "",
      n = !1;
    const i = e.eol || `\r
`;
    for (let a = 0; a < t.length; a++) {
      const s = t[a];
      if (s.type === "meta") {
        s.tag && s.data && typeof s.data == "string" && (r += `[${s.tag}:${s.data.replace(/[\r\n]+/g," ")}]${i}`);
        continue
      }
      if (!s.type || s.type === "caption") {
        n || (r += i, n = !0), r += `[${Jk.toTimeString(s.start)}]${s.text}${i}`;
        continue
      }
      e.verbose && console.log("SKIP:", s)
    }
    return r
  },
  q5e = t => /\r?\n\[\d+:\d{1,2}(?:[.,]\d{1,3})?\].*\r?\n/.test(t),
  X5e = _s({
    name: W5e,
    build: Y5e,
    detect: q5e,
    helper: Jk,
    parse: K5e
  }),
  Q5e = "sbv",
  U0 = {
    toMilliseconds: t => {
      const e = /^\s*(\d{1,2}):(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(t);
      if (!e) throw new Error(`Invalid time format: ${t}`);
      const r = parseInt(e[1]),
        n = parseInt(e[2]),
        i = parseInt(e[3]),
        a = e[4] ? parseInt(e[4]) : 0;
      return r * 3600 * 1e3 + n * 60 * 1e3 + i * 1e3 + a
    },
    toTimeString: t => {
      const e = Math.floor(t / 1e3 / 3600),
        r = Math.floor(t / 1e3 / 60 % 60),
        n = Math.floor(t / 1e3 % 60),
        i = Math.floor(t % 1e3);
      return `${(e<10?"0":"")+e}:${r<10?"0":""}${r}:${n<10?"0":""}${n}.${i<100?"0":""}${i<10?"0":""}${i}`
    }
  },
  Z5e = (t, e) => {
    const r = [],
      n = e.eol || `\r
`,
      i = t.split(/\r?\n\s*\n/);
    for (let a = 0; a < i.length; a++) {
      const o = /^(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*[,;]\s*(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\r?\n([\s\S]*)$/.exec(i[a]);
      if (o) {
        const c = {};
        c.type = "caption", c.start = U0.toMilliseconds(o[1]), c.end = U0.toMilliseconds(o[2]), c.duration = c.end - c.start;
        const l = o[3].split(/\[br\]|\r?\n/gi);
        c.content = l.join(n), c.text = c.content.replace(/>>[^:]+:\s*/g, ""), r.push(c);
        continue
      }
      e.verbose && console.log("WARN: Unknown part", i[a])
    }
    return r
  },
  J5e = (t, e) => {
    let r = "";
    const n = e.eol || `\r
`;
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (!a.type || a.type === "caption") {
        r += `${U0.toTimeString(a.start)},${U0.toTimeString(a.end)}${n}`, r += a.text + n, r += n;
        continue
      }
      e.verbose && console.log("SKIP:", a)
    }
    return r
  },
  eBe = t => /\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?\s*[,;]\s*\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?/.test(t),
  tBe = _s({
    name: Q5e,
    build: J5e,
    detect: eBe,
    helper: U0,
    parse: Z5e
  }),
  $q = "smi",
  eO = {
    htmlEncode: t => t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n/g, "<BR>"),
    htmlDecode: (t, e) => t.replace(/<BR\s*\/?>/gi, e || `\r
`).replace(/&nbsp;/g, " ").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")
  },
  rBe = (t, e) => {
    if (e.format && e.format !== $q) throw new Error(`Invalid format: ${e.format}`);
    const r = [],
      n = e.eol || `\r
`,
      i = /<TITLE[^>]*>([\s\S]*)<\/TITLE>/i.exec(t);
    if (i) {
      const l = {};
      l.type = "meta", l.name = "title", l.data = i[1].replace(/^\s*/g, "").replace(/\s*$/g, ""), r.push(l)
    }
    const a = /<STYLE[^>]*>([\s\S]*)<\/STYLE>/i.exec(t);
    if (a) {
      const l = {};
      l.type = "meta", l.name = "style", l.data = a[1], r.push(l)
    }
    const s = t.replace(/^[\s\S]*<BODY[^>]*>/gi, "").replace(/<\/BODY[^>]*>[\s\S]*$/gi, "");
    let o = null;
    const c = s.split(/<SYNC/gi);
    for (let l = 0; l < c.length; l++) {
      if (!c[l] || c[l].trim().length === 0) continue;
      const u = `<SYNC${c[l]}`,
        f = /^<SYNC[^>]+Start\s*=\s*["']?(\d+)[^\d>]*>([\s\S]*)/i.exec(u);
      if (f) {
        const d = {};
        d.type = "caption", d.start = parseInt(f[1]), d.end = d.start + 2e3, d.duration = d.end - d.start, d.content = f[2].replace(/^<\/SYNC[^>]*>/gi, "");
        let h = !0;
        const p = /^<P.+Class\s*=\s*["']?([\w-]+)(?: .*)?>([\s\S]*)/i.exec(d.content) || /^<P([^>]*)>([\s\S]*)/i.exec(d.content);
        if (p) {
          let v = p[2].replace(/<P[\s\S]+$/gi, "");
          v = v.replace(/<BR\s*\/?>\s+/gi, n).replace(/<BR\s*\/?>/gi, n).replace(/<[^>]+>/g, ""), v = v.replace(/^\s+/g, "").replace(/\s+$/g, ""), h = v.replace(/&nbsp;/gi, " ").replace(/\s+/g, "").length === 0, d.text = eO.htmlDecode(v, n)
        }!e.preserveSpaces && h ? e.verbose && console.log(`INFO: Skipping white space caption at ${d.start}`) : r.push(d), o && (o.end = d.start, o.duration = o.end - o.start), o = d;
        continue
      }
      e.verbose && console.log("WARN: Unknown part", c[l])
    }
    return r
  },
  nBe = (t, e) => {
    const r = e.eol || `\r
`;
    let n = "";
    n += `<SAMI>${r}`, n += `<HEAD>${r}`, n += `<TITLE>${e.title||""}</TITLE>${r}`, n += `<STYLE TYPE="text/css">${r}`, n += `<!--${r}`, n += `P { font-family: Arial; font-weight: normal; color: white; background-color: black; text-align: center; }${r}`, n += `.LANG { Name: ${e.langName||"English"}; lang: ${e.langCode||"en-US"}; SAMIType: CC; }${r}`, n += `-->${r}`, n += `</STYLE>${r}`, n += `</HEAD>${r}`, n += `<BODY>${r}`;
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (a.type !== "meta") {
        if (!a.type || a.type === "caption") {
          n += `<SYNC Start=${a.start}>${r}`, n += `  <P Class=LANG>${eO.htmlEncode(a.text||"")}${e.closeTags?"</P>":""}${r}`, e.closeTags && (n += `</SYNC>${r}`), n += `<SYNC Start=${a.end}>${r}`, n += `  <P Class=LANG>&nbsp;${e.closeTags?"</P>":""}${r}`, e.closeTags && (n += `</SYNC>${r}`);
          continue
        }
        e.verbose && console.log("SKIP:", a)
      }
    }
    return n += `</BODY>${r}`, n += `</SAMI>${r}`, n
  },
  iBe = t => /<SAMI[^>]*>[\s\S]*<BODY[^>]*>/.test(t),
  aBe = _s({
    name: $q,
    build: nBe,
    detect: iBe,
    helper: eO,
    parse: rBe
  }),
  sBe = "srt",
  j0 = {
    toMilliseconds: t => {
      const e = /^\s*(\d{1,2}):(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(t);
      if (!e) throw new Error(`Invalid time format: ${t}`);
      const r = parseInt(e[1]),
        n = parseInt(e[2]),
        i = parseInt(e[3]),
        a = e[4] ? parseInt(e[4]) : 0;
      return r * 3600 * 1e3 + n * 60 * 1e3 + i * 1e3 + a
    },
    toTimeString: t => {
      const e = Math.floor(t / 1e3 / 3600),
        r = Math.floor(t / 1e3 / 60 % 60),
        n = Math.floor(t / 1e3 % 60),
        i = Math.floor(t % 1e3);
      return `${(e<10?"0":"")+e}:${r<10?"0":""}${r}:${n<10?"0":""}${n},${i<100?"0":""}${i<10?"0":""}${i}`
    }
  },
  oBe = (t, e) => {
    const r = [],
      n = e.eol || `\r
`,
      i = t.split(/\r?\n\s*\n/g);
    for (let a = 0; a < i.length; a++) {
      const o = /^(\d+)\r?\n(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*-->\s*(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\r?\n([\s\S]*)$/.exec(i[a]);
      if (o) {
        const c = {};
        c.type = "caption", c.index = parseInt(o[1]), c.start = j0.toMilliseconds(o[2]), c.end = j0.toMilliseconds(o[3]), c.duration = c.end - c.start;
        const l = o[4].split(/\r?\n/);
        c.content = l.join(n), c.text = c.content.replace(/<[^>]+>/g, "").replace(/\{[^}]+\}/g, "").replace(/>>[^:]*:\s*/g, ""), r.push(c);
        continue
      }
      e.verbose && console.log("WARN: Unknown part", i[a])
    }
    return r
  },
  lBe = (t, e) => {
    let r = "";
    const n = e.eol || `\r
`;
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (!a.type || a.type === "caption") {
        r += (i + 1).toString() + n, r += `${j0.toTimeString(a.start)} --> ${j0.toTimeString(a.end)}${n}`, r += a.text + n, r += n;
        continue
      }
      e.verbose && console.log("SKIP:", a)
    }
    return r
  },
  cBe = t => /\d+\r?\n\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?\s*-->\s*\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?/.test(t),
  uBe = _s({
    name: sBe,
    build: lBe,
    detect: cBe,
    helper: j0,
    parse: oBe
  }),
  fBe = "sub",
  xA = 25,
  dBe = (t, e) => {
    e.fps || (e.fps = xA);
    const r = e.fps > 0 ? e.fps : xA,
      n = [],
      i = e.eol || `\r
`,
      a = t.split(/\r?\n/g);
    for (let s = 0; s < a.length; s++) {
      const c = /^\{(\d+)\}\{(\d+)\}(.*)$/.exec(a[s]);
      if (c) {
        const l = {};
        l.type = "caption", l.index = s + 1, l.frame = {
          start: parseInt(c[1]),
          end: parseInt(c[2]),
          count: parseInt(c[2]) - parseInt(c[1])
        }, l.start = Math.round(l.frame.start / r), l.end = Math.round(l.frame.end / r), l.duration = l.end - l.start;
        const u = c[3].split(/\|/g);
        l.content = u.join(i), l.text = l.content.replace(/\{[^}]+\}/g, ""), n.push(l);
        continue
      }
      e.verbose && console.log("WARN: Unknown part", a[s])
    }
    return n
  },
  hBe = (t, e) => {
    const r = (e.fps || 0) > 0 ? e.fps : xA;
    let n = "";
    const i = e.eol || `\r
`;
    for (let a = 0; a < t.length; a++) {
      const s = t[a];
      if (!s.type || s.type === "caption") {
        const o = typeof s.frame == "object" && s.frame.start >= 0 ? s.frame.start : s.start * r,
          c = typeof s.frame == "object" && s.frame.end >= 0 ? s.frame.end : s.end * r,
          l = s.text.replace(/\r?\n/, "|");
        n += `{${o}}{${c}}${l}${i}`;
        continue
      }
      e.verbose && console.log("SKIP:", s)
    }
    return n
  },
  pBe = t => /^\{\d+\}\{\d+\}.*/.test(t),
  gBe = _s({
    name: fBe,
    build: hBe,
    detect: pBe,
    parse: dBe
  }),
  mBe = "vtt",
  H0 = {
    toMilliseconds: t => {
      const e = /^\s*(\d{1,2}:)?(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(t);
      if (!e) throw new Error(`Invalid time format: ${t}`);
      const r = e[1] ? parseInt(e[1].replace(":", "")) : 0,
        n = parseInt(e[2]),
        i = parseInt(e[3]),
        a = e[4] ? parseInt(e[4]) : 0;
      return r * 3600 * 1e3 + n * 60 * 1e3 + i * 1e3 + a
    },
    toTimeString: t => {
      const e = Math.floor(t / 1e3 / 3600),
        r = Math.floor(t / 1e3 / 60 % 60),
        n = Math.floor(t / 1e3 % 60),
        i = Math.floor(t % 1e3);
      return `${(e<10?"0":"")+e}:${r<10?"0":""}${r}:${n<10?"0":""}${n}.${i<100?"0":""}${i<10?"0":""}${i}`
    }
  },
  vBe = (t, e) => {
    let r = 1;
    const n = [],
      i = t.split(/\r?\n\s*\n/);
    for (const a of i) {
      const o = /^([^\r\n]+\r?\n)?((?:\d{1,2}:)?\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*-->\s*((?:\d{1,2}:)?\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)[^\S\r\n]?.*\r?\n([\s\S]*)$/.exec(a);
      if (o) {
        const l = {};
        l.type = "caption", l.index = r++, o[1] && (l.cue = o[1].replace(/[\r\n]*/g, "")), l.start = H0.toMilliseconds(o[2]), l.end = H0.toMilliseconds(o[3]), l.duration = l.end - l.start, l.content = o[4], l.text = l.content.replace(/<[^>]+>/g, "").replace(/\{[^}]+\}/g, ""), n.push(l);
        continue
      }
      const c = /^([A-Z]+)(\r?\n([\s\S]*))?$/.exec(a) || /^([A-Z]+)\s+([^\r\n]*)$/.exec(a);
      if (c) {
        const l = {};
        l.type = "meta", l.name = c[1], c[3] && (l.data = c[3]), n.push(l);
        continue
      }
      e.verbose && console.log("WARN: Unknown part", a)
    }
    return n
  },
  yBe = (t, e) => {
    const r = e.eol || `\r
`;
    let n = `WEBVTT${r}${r}`;
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (a.type === "meta") {
        if (a.name === "WEBVTT") continue;
        n += a.name + r, n += a.data ? a.data + r : "", n += r;
        continue
      }
      if (!a.type || a.type === "caption") {
        n += (i + 1).toString() + r, n += `${H0.toTimeString(a.start)} --> ${H0.toTimeString(a.end)}${r}`, n += a.text + r, n += r;
        continue
      }
      e.verbose && console.log("SKIP:", a)
    }
    return n
  },
  xBe = t => /^\s*WEBVTT\r?\n/.test(t),
  bBe = _s({
    name: mBe,
    build: yBe,
    detect: xBe,
    helper: H0,
    parse: vBe
  }),
  EBe = {
    vtt: bBe,
    lrc: X5e,
    smi: aBe,
    ssa: F5e,
    ass: U5e,
    sub: gBe,
    srt: uBe,
    sbv: tBe,
    json: V5e
  },
  SBe = t => JSON.parse(JSON.stringify(t));
class _Be {
  constructor() {
    this.format = EBe, this.list = () => Object.keys(this.format), this.detect = e => {
      const r = this.list();
      for (let n = 0; n < r.length; n++) {
        const i = r[n],
          a = this.format[i];
        if (typeof a > "u" || typeof a.detect != "function") continue;
        const s = a.detect(e);
        if (s === !0 || s === i) return i
      }
      return ""
    }, this.parse = (e, r = {}) => {
      const n = r.format || this.detect(e);
      if (!n || n.trim().length === 0) throw new Error("Cannot determine subtitle format!");
      const i = this.format[n];
      if (typeof i > "u") throw new Error(`Unsupported subtitle format: ${n}`);
      const a = i.parse;
      if (typeof a != "function") throw new Error(`Subtitle format does not support 'parse' op: ${n}`);
      return a(e, r)
    }, this.build = (e, r = {}) => {
      const n = r.format || "srt";
      if (!n || n.trim().length === 0) throw new Error("Cannot determine subtitle format!");
      const i = this.format[n];
      if (typeof i > "u") throw new Error(`Unsupported subtitle format: ${n}`);
      const a = i.build;
      if (typeof a != "function") throw new Error(`Subtitle format does not support 'build' op: ${n}`);
      return a(e, r)
    }, this.convert = (e, r = {}) => {
      let n = {};
      typeof r == "string" ? n.to = r : n = r;
      const i = {
        format: n.from || void 0,
        verbose: n.verbose,
        eol: n.eol
      };
      let a = this.parse(e, i);
      n.resync && (a = this.resync(a, n.resync));
      const s = {
        format: n.to || n.format,
        verbose: n.verbose,
        eol: n.eol
      };
      return this.build(a, s)
    }, this.resync = (e, r = {}) => {
      let n, i, a = !1,
        s;
      if (typeof r == "function") n = r;
      else if (typeof r == "number") s = r, n = c => [c[0] + s, c[1] + s];
      else if (typeof r == "object") s = (r.offset || 0) * (r.frame ? r.fps || 25 : 1), i = r.ratio || 1, a = r.frame || !1, n = c => [Math.round(c[0] * i + s), Math.round(c[1] * i + s)];
      else throw new Error("Argument 'options' not defined!");
      const o = [];
      for (let c = 0; c < e.length; c++) {
        const l = SBe(e[c]);
        if (!l.type || l.type === "caption")
          if (a) {
            const u = n([l.frame.start, l.frame.end]);
            u && u.length === 2 && (l.frame.start = u[0], l.frame.end = u[1], l.frame.count = l.frame.end - l.frame.start)
          } else {
            const u = n([l.start, l.end]);
            u && u.length === 2 && (l.start = u[0], l.end = u[1], l.duration = l.end - l.start)
          } o.push(l)
      }
      return o
    }
  }
}
const TBe = new _Be,
  {
    format: M0t,
    list: wBe,
    detect: RBe,
    parse: ABe,
    build: F0t,
    convert: IBe,
    resync: B0t
  } = TBe;
var Ct = (t => (t.MP4 = "mp4", t.HLS = "hls", t))(Ct || {}),
  Li = (t => (t.VTT = "vtt", t.SRT = "srt", t.LRC = "lrc", t.SBV = "sbv", t.SUB = "sub", t.SSA = "ssa", t.ASS = "ass", t.JSON = "json", t.UNKNOWN = "unknown", t))(Li || {}),
  Oe = (t => (t.Q360P = "360p", t.Q540P = "540p", t.Q480P = "480p", t.Q720P = "720p", t.Q1080P = "1080p", t.QUNKNOWN = "unknown", t))(Oe || {});
const rh = "external-custom";

function bA(t, e) {
  return e ? `linked-${t.langIso}` : `external-${t.langIso}`
}
const tO = wBe().map(t => `.${t}`);

function rO(t) {
  return tO.some(e => t.endsWith(e))
}

function Cq(t) {
  if (!rO(t)) return Li.UNKNOWN;
  const e = tO.find(r => t.endsWith(r));
  return e ? e.slice(1) : Li.UNKNOWN
}
const $Be = N5e.sanitize;
async function kq(t) {
  let e;
  t.url.startsWith("blob:") ? e = await (await fetch(t.url)).blob() : t.needsProxy ? e = await xe(t.url, {
    responseType: "blob"
  }) : e = await Zh(t.url, {
    responseType: "blob"
  });
  const r = await e.text(),
    n = IBe(r, "vtt");
  return URL.createObjectURL(new Blob([n], {
    type: "text/vtt"
  }))
}

function E1(t) {
  t && t.startsWith("blob:") && URL.revokeObjectURL(t)
}

function Oq(t) {
  const e = t.trim();
  if (e === "") throw new Error("Given text is empty");
  if (RBe(e) === "") throw new Error("Invalid subtitle format");
  return ABe(e).filter(r => r.type === "caption")
}
const S1 = [{
  id: "none",
  englishName: "None",
  name: "None",
  nativeName: "Lorem ipsum"
}, {
  id: "pirate",
  englishName: "Pirate",
  name: "Pirate English",
  nativeName: "Pirate English"
}, {
  id: "aa",
  englishName: "Afar",
  name: "Afar - Afaraf",
  nativeName: "Afaraf"
}, {
  id: "ab",
  englishName: "Abkhaz",
  name: "Abkhaz - ÐÒ§ÑÑÐ° Ð±ÑÐ·ÑÓÐ°",
  nativeName: "ÐÒ§ÑÑÐ° Ð±ÑÐ·ÑÓÐ°"
}, {
  id: "ae",
  englishName: "Avestan",
  name: "Avestan - Avesta",
  nativeName: "Avesta"
}, {
  id: "af",
  englishName: "Afrikaans",
  name: "Afrikaans - Afrikaans",
  nativeName: "Afrikaans"
}, {
  id: "ak",
  englishName: "Akan",
  name: "Akan - Akan",
  nativeName: "Akan"
}, {
  id: "am",
  englishName: "Amharic",
  name: "Amharic - á áá­á",
  nativeName: "á áá­á"
}, {
  id: "an",
  englishName: "Aragonese",
  name: "Aragonese - AragonÃ©s",
  nativeName: "AragonÃ©s"
}, {
  id: "ar",
  englishName: "Arabic",
  name: "Arabic - Ø§ÙÙØºØ© Ø§ÙØ¹Ø±Ø¨ÙØ©",
  nativeName: "Ø§ÙÙØºØ© Ø§ÙØ¹Ø±Ø¨ÙØ©"
}, {
  id: "as",
  englishName: "Assamese",
  name: "Assamese - à¦à¦¸à¦®à§à¦¯à¦¼à¦¾",
  nativeName: "à¦à¦¸à¦®à§à¦¯à¦¼à¦¾"
}, {
  id: "av",
  englishName: "Avaric",
  name: "Avaric - ÐÐ²Ð°Ñ Ð¼Ð°ÑÓ",
  nativeName: "ÐÐ²Ð°Ñ Ð¼Ð°ÑÓ"
}, {
  id: "ay",
  englishName: "Aymara",
  name: "Aymara - Aymar aru",
  nativeName: "Aymar aru"
}, {
  id: "az",
  englishName: "Azerbaijani",
  name: "Azerbaijani - AzÉrbaycan dili",
  nativeName: "AzÉrbaycan dili"
}, {
  id: "ba",
  englishName: "Bashkir",
  name: "Bashkir - ÐÐ°ÑÒ¡Ð¾ÑÑ ÑÐµÐ»Ðµ",
  nativeName: "ÐÐ°ÑÒ¡Ð¾ÑÑ ÑÐµÐ»Ðµ"
}, {
  id: "be",
  englishName: "Belarusian",
  name: "Belarusian - ÐÐµÐ»Ð°ÑÑÑÐºÐ°Ñ Ð¼Ð¾Ð²Ð°",
  nativeName: "ÐÐµÐ»Ð°ÑÑÑÐºÐ°Ñ Ð¼Ð¾Ð²Ð°"
}, {
  id: "bg",
  englishName: "Bulgarian",
  name: "Bulgarian - ÐÑÐ»Ð³Ð°ÑÑÐºÐ¸ ÐµÐ·Ð¸Ðº",
  nativeName: "ÐÑÐ»Ð³Ð°ÑÑÐºÐ¸ ÐµÐ·Ð¸Ðº"
}, {
  id: "bh",
  englishName: "Bihari",
  name: "Bihari - à¤­à¥à¤à¤ªà¥à¤°à¥",
  nativeName: "à¤­à¥à¤à¤ªà¥à¤°à¥"
}, {
  id: "bi",
  englishName: "Bislama",
  name: "Bislama - Bislama",
  nativeName: "Bislama"
}, {
  id: "bm",
  englishName: "Bambara",
  name: "Bambara - Bamanankan",
  nativeName: "Bamanankan"
}, {
  id: "bn",
  englishName: "Bengali",
  name: "Bengali - à¦¬à¦¾à¦à¦²à¦¾",
  nativeName: "à¦¬à¦¾à¦à¦²à¦¾"
}, {
  id: "bo",
  englishName: "Tibetan Standard",
  name: "Tibetan Standard - à½à½¼à½à¼à½¡à½²à½",
  nativeName: "à½à½¼à½à¼à½¡à½²à½"
}, {
  id: "br",
  englishName: "Breton",
  name: "Breton - Brezhoneg",
  nativeName: "Brezhoneg"
}, {
  id: "bs",
  englishName: "Bosnian",
  name: "Bosnian - Bosanski jezik",
  nativeName: "Bosanski jezik"
}, {
  id: "ca",
  englishName: "Catalan",
  name: "Catalan - CatalÃ ",
  nativeName: "CatalÃ "
}, {
  id: "ce",
  englishName: "Chechen",
  name: "Chechen - ÐÐ¾ÑÑÐ¸Ð¹Ð½ Ð¼Ð¾ÑÑ",
  nativeName: "ÐÐ¾ÑÑÐ¸Ð¹Ð½ Ð¼Ð¾ÑÑ"
}, {
  id: "ch",
  englishName: "Chamorro",
  name: "Chamorro - Chamoru",
  nativeName: "Chamoru"
}, {
  id: "co",
  englishName: "Corsican",
  name: "Corsican - Corsu",
  nativeName: "Corsu"
}, {
  id: "cr",
  englishName: "Cree",
  name: "Cree - áá¦áá­ááá£",
  nativeName: "áá¦áá­ááá£"
}, {
  id: "cs",
  englishName: "Czech",
  name: "Czech - ÄeÅ¡tina",
  nativeName: "ÄeÅ¡tina"
}, {
  id: "cu",
  englishName: "Old Church Slavonic",
  name: "Old Church Slavonic - Ñ¨Ð·ÑÐºÑ ÑÐ»Ð¾Ð²Ñ£Ð½ÑÑÐºÑ",
  nativeName: "Ñ¨Ð·ÑÐºÑ ÑÐ»Ð¾Ð²Ñ£Ð½ÑÑÐºÑ"
}, {
  id: "cv",
  englishName: "Chuvash",
  name: "Chuvash - Ð§ÓÐ²Ð°Ñ ÑÓÐ»ÑÐ¸",
  nativeName: "Ð§ÓÐ²Ð°Ñ ÑÓÐ»ÑÐ¸"
}, {
  id: "cy",
  englishName: "Welsh",
  name: "Welsh - Cymraeg",
  nativeName: "Cymraeg"
}, {
  id: "da",
  englishName: "Danish",
  name: "Danish - Dansk",
  nativeName: "Dansk"
}, {
  id: "de",
  englishName: "German",
  name: "German - Deutsch",
  nativeName: "Deutsch"
}, {
  id: "dv",
  englishName: "Divehi",
  name: "Divehi - Dhivehi",
  nativeName: "Dhivehi"
}, {
  id: "dz",
  englishName: "Dzongkha",
  name: "Dzongkha - à½¢à¾«à½¼à½à¼à½",
  nativeName: "à½¢à¾«à½¼à½à¼à½"
}, {
  id: "ee",
  englishName: "Ewe",
  name: "Ewe - EÊegbe",
  nativeName: "EÊegbe"
}, {
  id: "el",
  englishName: "Greek",
  name: "Greek - ÎÎ»Î»Î·Î½Î¹ÎºÎ¬",
  nativeName: "ÎÎ»Î»Î·Î½Î¹ÎºÎ¬"
}, {
  id: "en",
  englishName: "English",
  name: "English - English",
  nativeName: "English"
}, {
  id: "eo",
  englishName: "Esperanto",
  name: "Esperanto - Esperanto",
  nativeName: "Esperanto"
}, {
  id: "es",
  englishName: "Spanish",
  name: "Spanish - EspaÃ±ol",
  nativeName: "EspaÃ±ol"
}, {
  id: "et",
  englishName: "Estonian",
  name: "Estonian - Eesti",
  nativeName: "Eesti"
}, {
  id: "eu",
  englishName: "Basque",
  name: "Basque - Euskara",
  nativeName: "Euskara"
}, {
  id: "fa",
  englishName: "Persian",
  name: "Persian - ÙØ§Ø±Ø³Û",
  nativeName: "ÙØ§Ø±Ø³Û"
}, {
  id: "ff",
  englishName: "Fula",
  name: "Fula - Fulfulde",
  nativeName: "Fulfulde"
}, {
  id: "fi",
  englishName: "Finnish",
  name: "Finnish - Suomi",
  nativeName: "Suomi"
}, {
  id: "fj",
  englishName: "Fijian",
  name: "Fijian - Vakaviti",
  nativeName: "Vakaviti"
}, {
  id: "fo",
  englishName: "Faroese",
  name: "Faroese - FÃ¸royskt",
  nativeName: "FÃ¸royskt"
}, {
  id: "fr",
  englishName: "French",
  name: "French - FranÃ§ais",
  nativeName: "FranÃ§ais"
}, {
  id: "fy",
  englishName: "Western Frisian",
  name: "Western Frisian - Frysk",
  nativeName: "Frysk"
}, {
  id: "ga",
  englishName: "Irish",
  name: "Irish - Gaeilge",
  nativeName: "Gaeilge"
}, {
  id: "gd",
  englishName: "Scottish Gaelic",
  name: "Scottish Gaelic - GÃ idhlig",
  nativeName: "GÃ idhlig"
}, {
  id: "gl",
  englishName: "Galician",
  name: "Galician - Galego",
  nativeName: "Galego"
}, {
  id: "gn",
  englishName: "GuaranÃ­",
  name: "GuaranÃ­ - AvaÃ±eáº½",
  nativeName: "AvaÃ±eáº½"
}, {
  id: "gu",
  englishName: "Gujarati",
  name: "Gujarati - àªà«àªàª°àª¾àª¤à«",
  nativeName: "àªà«àªàª°àª¾àª¤à«"
}, {
  id: "gv",
  englishName: "Manx",
  name: "Manx - Gaelg",
  nativeName: "Gaelg"
}, {
  id: "ha",
  englishName: "Hausa",
  name: "Hausa - ÙÙÙÙØ³Ù",
  nativeName: "ÙÙÙÙØ³Ù"
}, {
  id: "he",
  englishName: "Hebrew",
  name: "Hebrew - ×¢××¨××ª",
  nativeName: "×¢××¨××ª"
}, {
  id: "hi",
  englishName: "Hindi",
  name: "Hindi - à¤¹à¤¿à¤¨à¥à¤¦à¥",
  nativeName: "à¤¹à¤¿à¤¨à¥à¤¦à¥"
}, {
  id: "ho",
  englishName: "Hiri Motu",
  name: "Hiri Motu - Hiri Motu",
  nativeName: "Hiri Motu"
}, {
  id: "hr",
  englishName: "Croatian",
  name: "Croatian - Hrvatski jezik",
  nativeName: "Hrvatski jezik"
}, {
  id: "ht",
  englishName: "Haitian",
  name: "Haitian - KreyÃ²l ayisyen",
  nativeName: "KreyÃ²l ayisyen"
}, {
  id: "hu",
  englishName: "Hungarian",
  name: "Hungarian - Magyar",
  nativeName: "Magyar"
}, {
  id: "hy",
  englishName: "Armenian",
  name: "Armenian - ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶",
  nativeName: "ÕÕ¡ÕµÕ¥ÖÕ¥Õ¶"
}, {
  id: "hz",
  englishName: "Herero",
  name: "Herero - Otjiherero",
  nativeName: "Otjiherero"
}, {
  id: "ia",
  englishName: "Interlingua",
  name: "Interlingua - Interlingua",
  nativeName: "Interlingua"
}, {
  id: "id",
  englishName: "Indonesian",
  name: "Indonesian - Indonesian",
  nativeName: "Indonesian"
}, {
  id: "ie",
  englishName: "Interlingue",
  name: "Interlingue - Interlingue",
  nativeName: "Interlingue"
}, {
  id: "ig",
  englishName: "Igbo",
  name: "Igbo - Asá»¥sá»¥ Igbo",
  nativeName: "Asá»¥sá»¥ Igbo"
}, {
  id: "ii",
  englishName: "Nuosu",
  name: "Nuosu - êê ê¿ Nuosuhxop",
  nativeName: "êê ê¿ Nuosuhxop"
}, {
  id: "ik",
  englishName: "Inupiaq",
  name: "Inupiaq - IÃ±upiaq",
  nativeName: "IÃ±upiaq"
}, {
  id: "io",
  englishName: "Ido",
  name: "Ido - Ido",
  nativeName: "Ido"
}, {
  id: "is",
  englishName: "Icelandic",
  name: "Icelandic - Ãslenska",
  nativeName: "Ãslenska"
}, {
  id: "it",
  englishName: "Italian",
  name: "Italian - Italiano",
  nativeName: "Italiano"
}, {
  id: "iu",
  englishName: "Inuktitut",
  name: "Inuktitut - áááááá¦",
  nativeName: "áááááá¦"
}, {
  id: "ja",
  englishName: "Japanese",
  name: "Japanese - æ¥æ¬èª",
  nativeName: "æ¥æ¬èª"
}, {
  id: "jv",
  englishName: "Javanese",
  name: "Javanese - Basa Jawa",
  nativeName: "Basa Jawa"
}, {
  id: "ka",
  englishName: "Georgian",
  name: "Georgian - á²¥áá áá£áá",
  nativeName: "á²¥áá áá£áá"
}, {
  id: "kg",
  englishName: "Kongo",
  name: "Kongo - Kikongo",
  nativeName: "Kikongo"
}, {
  id: "ki",
  englishName: "Kikuyu",
  name: "Kikuyu - GÄ©kÅ©yÅ©",
  nativeName: "GÄ©kÅ©yÅ©"
}, {
  id: "kj",
  englishName: "Kwanyama",
  name: "Kwanyama - Kuanyama",
  nativeName: "Kuanyama"
}, {
  id: "kk",
  englishName: "Kazakh",
  name: "Kazakh - ÒÐ°Ð·Ð°Ò ÑÑÐ»Ñ",
  nativeName: "ÒÐ°Ð·Ð°Ò ÑÑÐ»Ñ"
}, {
  id: "kl",
  englishName: "Kalaallisut",
  name: "Kalaallisut - Kalaallisut",
  nativeName: "Kalaallisut"
}, {
  id: "km",
  englishName: "Khmer",
  name: "Khmer - áááááá¶áá¶",
  nativeName: "áááááá¶áá¶"
}, {
  id: "kn",
  englishName: "Kannada",
  name: "Kannada - à²à²¨à³à²¨à²¡",
  nativeName: "à²à²¨à³à²¨à²¡"
}, {
  id: "ko",
  englishName: "Korean",
  name: "Korean - íêµ­ì´",
  nativeName: "íêµ­ì´"
}, {
  id: "kr",
  englishName: "Kanuri",
  name: "Kanuri - Kanuri",
  nativeName: "Kanuri"
}, {
  id: "ks",
  englishName: "Kashmiri",
  name: "Kashmiri - à¤à¤¶à¥à¤®à¥à¤°à¥",
  nativeName: "à¤à¤¶à¥à¤®à¥à¤°à¥"
}, {
  id: "ku",
  englishName: "Kurdish",
  name: "Kurdish - KurdÃ®",
  nativeName: "KurdÃ®"
}, {
  id: "kv",
  englishName: "Komi",
  name: "Komi - ÐÐ¾Ð¼Ð¸ ÐºÑÐ²",
  nativeName: "ÐÐ¾Ð¼Ð¸ ÐºÑÐ²"
}, {
  id: "kw",
  englishName: "Cornish",
  name: "Cornish - Kernewek",
  nativeName: "Kernewek"
}, {
  id: "ky",
  englishName: "Kyrgyz",
  name: "Kyrgyz - ÐÑÑÐ³ÑÐ·ÑÐ°",
  nativeName: "ÐÑÑÐ³ÑÐ·ÑÐ°"
}, {
  id: "la",
  englishName: "Latin",
  name: "Latin - Latine",
  nativeName: "Latine"
}, {
  id: "lb",
  englishName: "Luxembourgish",
  name: "Luxembourgish - LÃ«tzebuergesch",
  nativeName: "LÃ«tzebuergesch"
}, {
  id: "lg",
  englishName: "Ganda",
  name: "Ganda - Luganda",
  nativeName: "Luganda"
}, {
  id: "li",
  englishName: "Limburgish",
  name: "Limburgish - Limburgs",
  nativeName: "Limburgs"
}, {
  id: "ln",
  englishName: "Lingala",
  name: "Lingala - LingÃ¡la",
  nativeName: "LingÃ¡la"
}, {
  id: "lo",
  englishName: "Lao",
  name: "Lao - àºàº²àºªàº²",
  nativeName: "àºàº²àºªàº²"
}, {
  id: "lt",
  englishName: "Lithuanian",
  name: "Lithuanian - LietuviÅ³ kalba",
  nativeName: "LietuviÅ³ kalba"
}, {
  id: "lu",
  englishName: "Luba-Katanga",
  name: "Luba-Katanga - Tshiluba",
  nativeName: "Tshiluba"
}, {
  id: "lv",
  englishName: "Latvian",
  name: "Latvian - LatvieÅ¡u valoda",
  nativeName: "LatvieÅ¡u valoda"
}, {
  id: "mg",
  englishName: "Malagasy",
  name: "Malagasy - Fiteny malagasy",
  nativeName: "Fiteny malagasy"
}, {
  id: "mh",
  englishName: "Marshallese",
  name: "Marshallese - Kajin MÌ§ajeÄ¼",
  nativeName: "Kajin MÌ§ajeÄ¼"
}, {
  id: "mi",
  englishName: "MÄori",
  name: "MÄori - Te reo MÄori",
  nativeName: "Te reo MÄori"
}, {
  id: "mk",
  englishName: "Macedonian",
  name: "Macedonian - ÐÐ°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸ ÑÐ°Ð·Ð¸Ðº",
  nativeName: "ÐÐ°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸ ÑÐ°Ð·Ð¸Ðº"
}, {
  id: "ml",
  englishName: "Malayalam",
  name: "Malayalam - à´®à´²à´¯à´¾à´³à´",
  nativeName: "à´®à´²à´¯à´¾à´³à´"
}, {
  id: "mn",
  englishName: "Mongolian",
  name: "Mongolian - ÐÐ¾Ð½Ð³Ð¾Ð» ÑÑÐ»",
  nativeName: "ÐÐ¾Ð½Ð³Ð¾Ð» ÑÑÐ»"
}, {
  id: "mr",
  englishName: "Marathi",
  name: "Marathi - à¤®à¤°à¤¾à¤ à¥",
  nativeName: "à¤®à¤°à¤¾à¤ à¥"
}, {
  id: "ms",
  englishName: "Malay",
  name: "Malay - ÙØ§Ø³ ÙÙØ§ÙÙâ",
  nativeName: "ÙØ§Ø³ ÙÙØ§ÙÙâ"
}, {
  id: "mt",
  englishName: "Maltese",
  name: "Maltese - Malti",
  nativeName: "Malti"
}, {
  id: "my",
  englishName: "Burmese",
  name: "Burmese - ááá¬áá¬",
  nativeName: "ááá¬áá¬"
}, {
  id: "na",
  englishName: "Nauru",
  name: "Nauru - EkakairÅ© Naoero",
  nativeName: "EkakairÅ© Naoero"
}, {
  id: "nb",
  englishName: "Norwegian BokmÃ¥l",
  name: "Norwegian BokmÃ¥l - Norsk bokmÃ¥l",
  nativeName: "Norsk bokmÃ¥l"
}, {
  id: "nd",
  englishName: "Northern Ndebele",
  name: "Northern Ndebele - IsiNdebele",
  nativeName: "IsiNdebele"
}, {
  id: "ne",
  englishName: "Nepali",
  name: "Nepali - à¤¨à¥à¤ªà¤¾à¤²à¥",
  nativeName: "à¤¨à¥à¤ªà¤¾à¤²à¥"
}, {
  id: "ng",
  englishName: "Ndonga",
  name: "Ndonga - Owambo",
  nativeName: "Owambo"
}, {
  id: "nl",
  englishName: "Dutch",
  name: "Dutch - Nederlands",
  nativeName: "Nederlands"
}, {
  id: "nn",
  englishName: "Norwegian Nynorsk",
  name: "Norwegian Nynorsk - Norsk nynorsk",
  nativeName: "Norsk nynorsk"
}, {
  id: "no",
  englishName: "Norwegian",
  name: "Norwegian - Norsk",
  nativeName: "Norsk"
}, {
  id: "nr",
  englishName: "Southern Ndebele",
  name: "Southern Ndebele - IsiNdebele",
  nativeName: "IsiNdebele"
}, {
  id: "nv",
  englishName: "Navajo",
  name: "Navajo - DinÃ© bizaad",
  nativeName: "DinÃ© bizaad"
}, {
  id: "ny",
  englishName: "Chichewa",
  name: "Chichewa - ChiCheÅµa",
  nativeName: "ChiCheÅµa"
}, {
  id: "oc",
  englishName: "Occitan",
  name: "Occitan - Occitan",
  nativeName: "Occitan"
}, {
  id: "oj",
  englishName: "Ojibwe",
  name: "Ojibwe - ááááá¯á§áá",
  nativeName: "ááááá¯á§áá"
}, {
  id: "om",
  englishName: "Oromo",
  name: "Oromo - Afaan Oromoo",
  nativeName: "Afaan Oromoo"
}, {
  id: "or",
  englishName: "Oriya",
  name: "Oriya - à¬à¬¡à¬¼à¬¿à¬",
  nativeName: "à¬à¬¡à¬¼à¬¿à¬"
}, {
  id: "os",
  englishName: "Ossetian",
  name: "Ossetian - ÐÑÐ¾Ð½ Ã¦Ð²Ð·Ð°Ð³",
  nativeName: "ÐÑÐ¾Ð½ Ã¦Ð²Ð·Ð°Ð³"
}, {
  id: "pa",
  englishName: "Panjabi",
  name: "Panjabi - à¨ªà©°à¨à¨¾à¨¬à©",
  nativeName: "à¨ªà©°à¨à¨¾à¨¬à©"
}, {
  id: "pi",
  englishName: "PÄli",
  name: "PÄli - à¤ªà¤¾à¤´à¤¿",
  nativeName: "à¤ªà¤¾à¤´à¤¿"
}, {
  id: "pl",
  englishName: "Polish",
  name: "Polish - JÄzyk polski",
  nativeName: "JÄzyk polski"
}, {
  id: "ps",
  englishName: "Pashto",
  name: "Pashto - Ù¾ÚØªÙ",
  nativeName: "Ù¾ÚØªÙ"
}, {
  id: "pt",
  englishName: "Portuguese",
  name: "Portuguese - PortuguÃªs",
  nativeName: "PortuguÃªs"
}, {
  id: "qu",
  englishName: "Quechua",
  name: "Quechua - Runa Simi",
  nativeName: "Runa Simi"
}, {
  id: "rm",
  englishName: "Romansh",
  name: "Romansh - Rumantsch grischun",
  nativeName: "Rumantsch grischun"
}, {
  id: "rn",
  englishName: "Kirundi",
  name: "Kirundi - Ikirundi",
  nativeName: "Ikirundi"
}, {
  id: "ro",
  englishName: "Romanian",
  name: "Romanian - RomÃ¢nÄ",
  nativeName: "RomÃ¢nÄ"
}, {
  id: "ru",
  englishName: "Russian",
  name: "Russian - Ð ÑÑÑÐºÐ¸Ð¹",
  nativeName: "Ð ÑÑÑÐºÐ¸Ð¹"
}, {
  id: "rw",
  englishName: "Kinyarwanda",
  name: "Kinyarwanda - Ikinyarwanda",
  nativeName: "Ikinyarwanda"
}, {
  id: "sa",
  englishName: "Sanskrit",
  name: "Sanskrit - à¤¸à¤à¤¸à¥à¤à¥à¤¤à¤®à¥",
  nativeName: "à¤¸à¤à¤¸à¥à¤à¥à¤¤à¤®à¥"
}, {
  id: "sc",
  englishName: "Sardinian",
  name: "Sardinian - Sardu",
  nativeName: "Sardu"
}, {
  id: "sd",
  englishName: "Sindhi",
  name: "Sindhi - à¤¸à¤¿à¤¨à¥à¤§à¥",
  nativeName: "à¤¸à¤¿à¤¨à¥à¤§à¥"
}, {
  id: "se",
  englishName: "Northern Sami",
  name: "Northern Sami - DavvisÃ¡megiella",
  nativeName: "DavvisÃ¡megiella"
}, {
  id: "sg",
  englishName: "Sango",
  name: "Sango - YÃ¢ngÃ¢ tÃ® sÃ¤ngÃ¶",
  nativeName: "YÃ¢ngÃ¢ tÃ® sÃ¤ngÃ¶"
}, {
  id: "si",
  englishName: "Sinhala",
  name: "Sinhala - à·à·à¶à·à¶½",
  nativeName: "à·à·à¶à·à¶½"
}, {
  id: "sk",
  englishName: "Slovak",
  name: "Slovak - SlovenÄina",
  nativeName: "SlovenÄina"
}, {
  id: "sl",
  englishName: "Slovene",
  name: "Slovene - Slovenski jezik",
  nativeName: "Slovenski jezik"
}, {
  id: "sm",
  englishName: "Samoan",
  name: "Samoan - Gagana faa Samoa",
  nativeName: "Gagana faa Samoa"
}, {
  id: "sn",
  englishName: "Shona",
  name: "Shona - ChiShona",
  nativeName: "ChiShona"
}, {
  id: "so",
  englishName: "Somali",
  name: "Somali - Soomaaliga",
  nativeName: "Soomaaliga"
}, {
  id: "sq",
  englishName: "Albanian",
  name: "Albanian - Shqip",
  nativeName: "Shqip"
}, {
  id: "sr",
  englishName: "Serbian",
  name: "Serbian - Ð¡ÑÐ¿ÑÐºÐ¸ ÑÐµÐ·Ð¸Ðº",
  nativeName: "Ð¡ÑÐ¿ÑÐºÐ¸ ÑÐµÐ·Ð¸Ðº"
}, {
  id: "ss",
  englishName: "Swati",
  name: "Swati - SiSwati",
  nativeName: "SiSwati"
}, {
  id: "st",
  englishName: "Southern Sotho",
  name: "Southern Sotho - Sesotho",
  nativeName: "Sesotho"
}, {
  id: "su",
  englishName: "Sundanese",
  name: "Sundanese - Basa Sunda",
  nativeName: "Basa Sunda"
}, {
  id: "sv",
  englishName: "Swedish",
  name: "Swedish - Svenska",
  nativeName: "Svenska"
}, {
  id: "sw",
  englishName: "Swahili",
  name: "Swahili - Kiswahili",
  nativeName: "Kiswahili"
}, {
  id: "ta",
  englishName: "Tamil",
  name: "Tamil - à®¤à®®à®¿à®´à¯",
  nativeName: "à®¤à®®à®¿à®´à¯"
}, {
  id: "te",
  englishName: "Telugu",
  name: "Telugu - à°¤à±à°²à±à°à±",
  nativeName: "à°¤à±à°²à±à°à±"
}, {
  id: "tg",
  englishName: "Tajik",
  name: "Tajik - Ð¢Ð¾Ò·Ð¸ÐºÓ£",
  nativeName: "Ð¢Ð¾Ò·Ð¸ÐºÓ£"
}, {
  id: "th",
  englishName: "Thai",
  name: "Thai - à¹à¸à¸¢",
  nativeName: "à¹à¸à¸¢"
}, {
  id: "ti",
  englishName: "Tigrinya",
  name: "Tigrinya - áµáá­á",
  nativeName: "áµáá­á"
}, {
  id: "tk",
  englishName: "Turkmen",
  name: "Turkmen - TÃ¼rkmen",
  nativeName: "TÃ¼rkmen"
}, {
  id: "tl",
  englishName: "Tagalog",
  name: "Tagalog - Wikang Tagalog",
  nativeName: "Wikang Tagalog"
}, {
  id: "tn",
  englishName: "Tswana",
  name: "Tswana - Setswana",
  nativeName: "Setswana"
}, {
  id: "to",
  englishName: "Tonga",
  name: "Tonga - Faka Tonga",
  nativeName: "Faka Tonga"
}, {
  id: "tr",
  englishName: "Turkish",
  name: "Turkish - TÃ¼rkÃ§e",
  nativeName: "TÃ¼rkÃ§e"
}, {
  id: "ts",
  englishName: "Tsonga",
  name: "Tsonga - Xitsonga",
  nativeName: "Xitsonga"
}, {
  id: "tt",
  englishName: "Tatar",
  name: "Tatar - Ð¢Ð°ÑÐ°Ñ ÑÐµÐ»Ðµ",
  nativeName: "Ð¢Ð°ÑÐ°Ñ ÑÐµÐ»Ðµ"
}, {
  id: "tw",
  englishName: "Twi",
  name: "Twi - Twi",
  nativeName: "Twi"
}, {
  id: "ty",
  englishName: "Tahitian",
  name: "Tahitian - Reo Tahiti",
  nativeName: "Reo Tahiti"
}, {
  id: "ug",
  englishName: "Uyghur",
  name: "Uyghur - Ø¦ÛÙØºÛØ±ÚÛâ",
  nativeName: "Ø¦ÛÙØºÛØ±ÚÛâ"
}, {
  id: "uk",
  englishName: "Ukrainian",
  name: "Ukrainian - Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°",
  nativeName: "Ð£ÐºÑÐ°ÑÐ½ÑÑÐºÐ°"
}, {
  id: "ur",
  englishName: "Urdu",
  name: "Urdu - Ø§Ø±Ø¯Ù",
  nativeName: "Ø§Ø±Ø¯Ù"
}, {
  id: "uz",
  englishName: "Uzbek",
  name: "Uzbek - ÐÐ·Ð±ÐµÐº",
  nativeName: "ÐÐ·Ð±ÐµÐº"
}, {
  id: "ve",
  englishName: "Venda",
  name: "Venda - Tshivená¸a",
  nativeName: "Tshivená¸a"
}, {
  id: "vi",
  englishName: "Vietnamese",
  name: "Vietnamese - Tiáº¿ng Viá»t",
  nativeName: "Tiáº¿ng Viá»t"
}, {
  id: "vo",
  englishName: "VolapÃ¼k",
  name: "VolapÃ¼k - VolapÃ¼k",
  nativeName: "VolapÃ¼k"
}, {
  id: "wa",
  englishName: "Walloon",
  name: "Walloon - Walon",
  nativeName: "Walon"
}, {
  id: "wo",
  englishName: "Wolof",
  name: "Wolof - Wollof",
  nativeName: "Wollof"
}, {
  id: "xh",
  englishName: "Xhosa",
  name: "Xhosa - IsiXhosa",
  nativeName: "IsiXhosa"
}, {
  id: "yi",
  englishName: "Yiddish",
  name: "Yiddish - ××Ö´×××©",
  nativeName: "××Ö´×××©"
}, {
  id: "yo",
  englishName: "Yoruba",
  name: "Yoruba - YorÃ¹bÃ¡",
  nativeName: "YorÃ¹bÃ¡"
}, {
  id: "za",
  englishName: "Zhuang",
  name: "Zhuang - SaÉ¯ cueÅÆ",
  nativeName: "SaÉ¯ cueÅÆ"
}, {
  id: "zh",
  englishName: "Chinese",
  name: "Chinese - ä¸­æ",
  nativeName: "ä¸­æ"
}, {
  id: "zu",
  englishName: "Zulu",
  name: "Zulu - IsiZulu",
  nativeName: "IsiZulu"
}];

function CBe(t) {
  const e = Ss(t);
  return {
    initialized: A.useMemo(() => !!e.initalized, [e])
  }
}
async function kBe(t) {
  for (let e = 0; e < t.length; e += 1) {
    const r = t[e];
    try {
      const n = await kq(r);
      return {
        caption: r,
        blobUrl: n
      }
    } catch {
      continue
    }
  }
  return null
}

function OBe(t) {
  const e = Re(),
    r = st(e),
    {
      initialized: n
    } = CBe(e),
    i = A.useRef(!1),
    {
      captionSettings: a
    } = id();
  return A.useEffect(() => {
    if (i.current || !n) return;
    r.setSource(t);
    const s = S1.find(c => c.id === a.language);
    if (!s) return;
    const o = t.captions.filter(c => c.langIso.indexOf(s.englishName) !== -1 || c.langIso.indexOf(s.nativeName) !== -1);
    o && (kBe(o).then(c => {
      if (!c) return;
      const l = bA(c.caption, !0);
      r.setCaption(l, c.blobUrl)
    }), i.current = !0)
  }, [t, r, n, a.language]), null
}

function Lq(t) {
  const {
    t: e
  } = ke();
  return Y("div", {
    className: `flex items-center space-x-2 rounded-full bg-bink-300 bg-opacity-50 px-4 py-2 text-bink-600 ${t.clickable?"transition-[transform,background-color] hover:scale-105 hover:bg-bink-400 hover:text-bink-700 active:scale-95":""}`,
    children: [E(Ve, {
      className: "text-xl",
      icon: ue.MOVIE_WEB
    }), E("span", {
      className: ["font-semibold text-white", t.hideTextOnMobile ? "hidden sm:block" : ""].join(" "),
      children: e("global.name")
    })]
  })
}

function Aa(t) {
  const [e, r] = A.useState(!1), n = A.useRef(!1);
  return A.useEffect(() => {
    function i() {
      const a = t ? window.innerHeight < 600 : window.innerWidth < 1024;
      n.current !== a && (n.current = a, r(a))
    }
    return i(), window.addEventListener("resize", i), () => {
      window.removeEventListener("resize", i)
    }
  }, [t]), {
    isMobile: e
  }
}
const Ts = A.forwardRef((t, e) => E("div", {
  className: t.className,
  ref: e,
  children: E("button", {
    type: "button",
    onClick: t.onClick,
    className: ["group pointer-events-auto p-2 text-white transition-transform duration-100 active:scale-110", t.disabled ? "pointer-events-none cursor-not-allowed opacity-50" : ""].join(" "),
    children: Y("div", {
      className: ["flex items-center justify-center rounded-full bg-denim-600 bg-opacity-0 transition-colors duration-100", t.active ? "!bg-denim-500 !bg-opacity-100" : "", t.noPadding ? "" : t.wide ? "p-2 sm:px-4" : "p-2", t.disabled ? "" : "group-hover:bg-opacity-50 group-active:bg-denim-500 group-active:bg-opacity-100"].join(" "),
      children: [E(Ve, {
        icon: t.icon,
        className: t.iconSize ? ? "text-2xl"
      }), E("p", {
        className: "hidden sm:block",
        children: t.text ? E("span", {
          className: "ml-2",
          children: t.text
        }) : null
      })]
    })
  })
}));

function Pq(t) {
  const e = Re(),
    r = st(e),
    n = Ss(e),
    i = A.useCallback(() => {
      r.startAirplay()
    }, [r]);
  return n.canAirplay ? E(Ts, {
    className: t.className,
    onClick: i,
    icon: ue.AIRPLAY
  }) : null
}

function Nq(t) {
  const [e, r] = A.useState(!1), n = Re(), a = Ss(n).isCasting, s = A.useRef(null), o = A.useCallback(c => {
    const l = (c.getAttribute("style") ? ? "").includes("inline");
    r(!l)
  }, [r]);
  return A.useEffect(() => {
    var u;
    const c = (u = s.current) == null ? void 0 : u.querySelector("google-cast-launcher");
    if (!c) return;
    const l = new MutationObserver(() => {
      o(c)
    });
    return l.observe(c, {
      attributes: !0,
      attributeFilter: ["style"]
    }), o(c), () => {
      l.disconnect()
    }
  }, [o]), E(Ts, {
    ref: s,
    className: [t.className ? ? "", "google-cast-button", a ? "casting" : "", e ? "hidden" : ""].join(" "),
    icon: ue.CASTING,
    onClick: c => {
      const l = c.currentTarget.querySelector("google-cast-launcher");
      l && l.click()
    }
  })
}

function Ec(t) {
  const {
    isMobile: e
  } = Aa(), {
    bookmarkStore: r,
    setItemBookmark: n
  } = Xk(), i = t.media ? sq(r.bookmarks, t.media) : !1, a = t.media && t.onClick, {
    t: s
  } = ke(), o = Jb();
  return Y("div", {
    className: "flex items-center",
    style: {
      paddingTop: t.isFullScreen ? `${o}px` : void 0
    },
    children: [Y("div", {
      className: "flex min-w-0 flex-1 items-center",
      children: [Y("p", {
        className: "flex items-center truncate",
        children: [t.onClick ? Y("span", {
          onClick: t.onClick,
          className: "flex cursor-pointer items-center py-1 text-white opacity-50 transition-opacity hover:opacity-100",
          children: [E(Ve, {
            className: "mr-2",
            icon: ue.ARROW_LEFT
          }), e ? E("span", {
            children: s("videoPlayer.backToHomeShort")
          }) : E("span", {
            children: s("videoPlayer.backToHome")
          })]
        }) : null, a ? E("span", {
          className: "mx-4 h-6 w-[1.5px] rotate-[30deg] bg-white opacity-50"
        }) : null, t.media ? E("span", {
          className: "truncate text-white",
          children: t.media.title
        }) : null]
      }), t.media && E(rn, {
        clickable: !0,
        transparent: !0,
        icon: i ? ue.BOOKMARK : ue.BOOKMARK_OUTLINE,
        className: "ml-2 text-white",
        onClick: () => t.media && n(t.media, !i)
      })]
    }), t.showControls ? Y(yr, {
      children: [E(Pq, {}), E(Nq, {})]
    }) : E(Lq, {
      hideTextOnMobile: !0
    })]
  })
}
var LBe = Object.defineProperty,
  PBe = (t, e, r) => e in t ? LBe(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
  }) : t[e] = r,
  LT = (t, e, r) => (PBe(t, typeof e != "symbol" ? e + "" : e, r), r);
let NBe = class {
    constructor() {
      LT(this, "current", this.detect()), LT(this, "handoffState", "pending"), LT(this, "currentId", 0)
    }
    set(e) {
      this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e)
    }
    reset() {
      this.set(this.detect())
    }
    nextId() {
      return ++this.currentId
    }
    get isServer() {
      return this.current === "server"
    }
    get isClient() {
      return this.current === "client"
    }
    detect() {
      return typeof window > "u" || typeof document > "u" ? "server" : "client"
    }
    handoff() {
      this.handoffState === "pending" && (this.handoffState = "complete")
    }
    get isHandoffComplete() {
      return this.handoffState === "complete"
    }
  },
  jl = new NBe,
  ei = (t, e) => {
    jl.isServer ? A.useEffect(t, e) : A.useLayoutEffect(t, e)
  };

function ts(t) {
  let e = A.useRef(t);
  return ei(() => {
    e.current = t
  }, [t]), e
}

function Dq(t, e) {
  let [r, n] = A.useState(t), i = ts(t);
  return ei(() => n(i.current), [i, n, ...e]), r
}

function DBe(t) {
  typeof queueMicrotask == "function" ? queueMicrotask(t) : Promise.resolve().then(t).catch(e => setTimeout(() => {
    throw e
  }))
}

function Po() {
  let t = [],
    e = {
      addEventListener(r, n, i, a) {
        return r.addEventListener(n, i, a), e.add(() => r.removeEventListener(n, i, a))
      },
      requestAnimationFrame(...r) {
        let n = requestAnimationFrame(...r);
        return e.add(() => cancelAnimationFrame(n))
      },
      nextFrame(...r) {
        return e.requestAnimationFrame(() => e.requestAnimationFrame(...r))
      },
      setTimeout(...r) {
        let n = setTimeout(...r);
        return e.add(() => clearTimeout(n))
      },
      microTask(...r) {
        let n = {
          current: !0
        };
        return DBe(() => {
          n.current && r[0]()
        }), e.add(() => {
          n.current = !1
        })
      },
      style(r, n, i) {
        let a = r.style.getPropertyValue(n);
        return Object.assign(r.style, {
          [n]: i
        }), this.add(() => {
          Object.assign(r.style, {
            [n]: a
          })
        })
      },
      group(r) {
        let n = Po();
        return r(n), this.add(() => n.dispose())
      },
      add(r) {
        return t.push(r), () => {
          let n = t.indexOf(r);
          if (n >= 0)
            for (let i of t.splice(n, 1)) i()
        }
      },
      dispose() {
        for (let r of t.splice(0)) r()
      }
    };
  return e
}

function bf() {
  let [t] = A.useState(Po);
  return A.useEffect(() => () => t.dispose(), [t]), t
}
let Ke = function (t) {
  let e = ts(t);
  return ce.useCallback((...r) => e.current(...r), [e])
};

function nO() {
  let [t, e] = A.useState(jl.isHandoffComplete);
  return t && jl.isHandoffComplete === !1 && e(!1), A.useEffect(() => {
    t !== !0 && e(!0)
  }, [t]), A.useEffect(() => jl.handoff(), []), t
}
var N6;
let aE = (N6 = ce.useId) != null ? N6 : function () {
  let t = nO(),
    [e, r] = ce.useState(t ? () => jl.nextId() : null);
  return ei(() => {
    e === null && r(jl.nextId())
  }, [e]), e != null ? "" + e : void 0
};

function rr(t, e, ...r) {
  if (t in e) {
    let i = e[t];
    return typeof i == "function" ? i(...r) : i
  }
  let n = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i=>`"${i}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(n, rr), n
}

function Mq(t) {
  return jl.isServer ? null : t instanceof Node ? t.ownerDocument : t != null && t.hasOwnProperty("current") && t.current instanceof Node ? t.current.ownerDocument : document
}
let D6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(t => `${t}:not([tabindex='-1'])`).join(",");
var MBe = (t => (t[t.First = 1] = "First", t[t.Previous = 2] = "Previous", t[t.Next = 4] = "Next", t[t.Last = 8] = "Last", t[t.WrapAround = 16] = "WrapAround", t[t.NoScroll = 32] = "NoScroll", t))(MBe || {}),
  FBe = (t => (t[t.Error = 0] = "Error", t[t.Overflow = 1] = "Overflow", t[t.Success = 2] = "Success", t[t.Underflow = 3] = "Underflow", t))(FBe || {}),
  BBe = (t => (t[t.Previous = -1] = "Previous", t[t.Next = 1] = "Next", t))(BBe || {}),
  iO = (t => (t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(iO || {});

function Fq(t, e = 0) {
  var r;
  return t === ((r = Mq(t)) == null ? void 0 : r.body) ? !1 : rr(e, {
    [0]() {
      return t.matches(D6)
    },
    [1]() {
      let n = t;
      for (; n !== null;) {
        if (n.matches(D6)) return !0;
        n = n.parentElement
      }
      return !1
    }
  })
}
var UBe = (t => (t[t.Keyboard = 0] = "Keyboard", t[t.Mouse = 1] = "Mouse", t))(UBe || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", t => {
  t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0), document.addEventListener("click", t => {
  t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0));

function jBe(t, e = r => r) {
  return t.slice().sort((r, n) => {
    let i = e(r),
      a = e(n);
    if (i === null || a === null) return 0;
    let s = i.compareDocumentPosition(a);
    return s & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : s & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
  })
}

function PT(t, e, r) {
  let n = ts(e);
  A.useEffect(() => {
    function i(a) {
      n.current(a)
    }
    return document.addEventListener(t, i, r), () => document.removeEventListener(t, i, r)
  }, [t, r])
}

function HBe(t, e, r = !0) {
  let n = A.useRef(!1);
  A.useEffect(() => {
    requestAnimationFrame(() => {
      n.current = r
    })
  }, [r]);

  function i(s, o) {
    if (!n.current || s.defaultPrevented) return;
    let c = function u(f) {
        return typeof f == "function" ? u(f()) : Array.isArray(f) || f instanceof Set ? f : [f]
      }(t),
      l = o(s);
    if (l !== null && l.getRootNode().contains(l)) {
      for (let u of c) {
        if (u === null) continue;
        let f = u instanceof HTMLElement ? u : u.current;
        if (f != null && f.contains(l) || s.composed && s.composedPath().includes(f)) return
      }
      return !Fq(l, iO.Loose) && l.tabIndex !== -1 && s.preventDefault(), e(s, l)
    }
  }
  let a = A.useRef(null);
  PT("mousedown", s => {
    var o, c;
    n.current && (a.current = ((c = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : c[0]) || s.target)
  }, !0), PT("click", s => {
    a.current && (i(s, () => a.current), a.current = null)
  }, !0), PT("blur", s => i(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}

function M6(t) {
  var e;
  if (t.type) return t.type;
  let r = (e = t.as) != null ? e : "button";
  if (typeof r == "string" && r.toLowerCase() === "button") return "button"
}

function zBe(t, e) {
  let [r, n] = A.useState(() => M6(t));
  return ei(() => {
    n(M6(t))
  }, [t.type, t.as]), ei(() => {
    r || e.current && e.current instanceof HTMLButtonElement && !e.current.hasAttribute("type") && n("button")
  }, [r, e]), r
}
let GBe = Symbol();

function Sc(...t) {
  let e = A.useRef(t);
  A.useEffect(() => {
    e.current = t
  }, [t]);
  let r = Ke(n => {
    for (let i of e.current) i != null && (typeof i == "function" ? i(n) : i.current = n)
  });
  return t.every(n => n == null || (n == null ? void 0 : n[GBe])) ? void 0 : r
}

function VBe(t) {
  throw new Error("Unexpected object: " + t)
}
var Zr = (t => (t[t.First = 0] = "First", t[t.Previous = 1] = "Previous", t[t.Next = 2] = "Next", t[t.Last = 3] = "Last", t[t.Specific = 4] = "Specific", t[t.Nothing = 5] = "Nothing", t))(Zr || {});

function WBe(t, e) {
  let r = e.resolveItems();
  if (r.length <= 0) return null;
  let n = e.resolveActiveIndex(),
    i = n ? ? -1,
    a = (() => {
      switch (t.focus) {
        case 0:
          return r.findIndex(s => !e.resolveDisabled(s));
        case 1: {
          let s = r.slice().reverse().findIndex((o, c, l) => i !== -1 && l.length - c - 1 >= i ? !1 : !e.resolveDisabled(o));
          return s === -1 ? s : r.length - 1 - s
        }
        case 2:
          return r.findIndex((s, o) => o <= i ? !1 : !e.resolveDisabled(s));
        case 3: {
          let s = r.slice().reverse().findIndex(o => !e.resolveDisabled(o));
          return s === -1 ? s : r.length - 1 - s
        }
        case 4:
          return r.findIndex(s => e.resolveId(s) === t.id);
        case 5:
          return null;
        default:
          VBe(t)
      }
    })();
  return a === -1 ? n : a
}

function EA(...t) {
  return t.filter(Boolean).join(" ")
}
var _1 = (t => (t[t.None = 0] = "None", t[t.RenderStrategy = 1] = "RenderStrategy", t[t.Static = 2] = "Static", t))(_1 || {}),
  Qa = (t => (t[t.Unmount = 0] = "Unmount", t[t.Hidden = 1] = "Hidden", t))(Qa || {});

function Qo({
  ourProps: t,
  theirProps: e,
  slot: r,
  defaultTag: n,
  features: i,
  visible: a = !0,
  name: s
}) {
  let o = Bq(e, t);
  if (a) return Bm(o, r, n, s);
  let c = i ? ? 0;
  if (c & 2) {
    let {
      static: l = !1,
      ...u
    } = o;
    if (l) return Bm(u, r, n, s)
  }
  if (c & 1) {
    let {
      unmount: l = !0,
      ...u
    } = o;
    return rr(l ? 0 : 1, {
      [0]() {
        return null
      },
      [1]() {
        return Bm({
          ...u,
          hidden: !0,
          style: {
            display: "none"
          }
        }, r, n, s)
      }
    })
  }
  return Bm(o, r, n, s)
}

function Bm(t, e = {}, r, n) {
  let {
    as: i = r,
    children: a,
    refName: s = "ref",
    ...o
  } = NT(t, ["unmount", "static"]), c = t.ref !== void 0 ? {
    [s]: t.ref
  } : {}, l = typeof a == "function" ? a(e) : a;
  "className" in o && o.className && typeof o.className == "function" && (o.className = o.className(e));
  let u = {};
  if (e) {
    let f = !1,
      d = [];
    for (let [h, p] of Object.entries(e)) typeof p == "boolean" && (f = !0), p === !0 && d.push(h);
    f && (u["data-headlessui-state"] = d.join(" "))
  }
  if (i === A.Fragment && Object.keys(SA(o)).length > 0) {
    if (!A.isValidElement(l) || Array.isArray(l) && l.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${n} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o).map(p => `  - ${p}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(p => `  - ${p}`).join(`
`)].join(`
`));
    let f = l.props,
      d = typeof (f == null ? void 0 : f.className) == "function" ? (...p) => EA(f == null ? void 0 : f.className(...p), o.className) : EA(f == null ? void 0 : f.className, o.className),
      h = d ? {
        className: d
      } : {};
    return A.cloneElement(l, Object.assign({}, Bq(l.props, SA(NT(o, ["ref"]))), u, c, KBe(l.ref, c.ref), h))
  }
  return A.createElement(i, Object.assign({}, NT(o, ["ref"]), i !== A.Fragment && c, i !== A.Fragment && u), l)
}

function KBe(...t) {
  return {
    ref: t.every(e => e == null) ? void 0 : e => {
      for (let r of t) r != null && (typeof r == "function" ? r(e) : r.current = e)
    }
  }
}

function Bq(...t) {
  if (t.length === 0) return {};
  if (t.length === 1) return t[0];
  let e = {},
    r = {};
  for (let n of t)
    for (let i in n) i.startsWith("on") && typeof n[i] == "function" ? (r[i] != null || (r[i] = []), r[i].push(n[i])) : e[i] = n[i];
  if (e.disabled || e["aria-disabled"]) return Object.assign(e, Object.fromEntries(Object.keys(r).map(n => [n, void 0])));
  for (let n in r) Object.assign(e, {
    [n](i, ...a) {
      let s = r[n];
      for (let o of s) {
        if ((i instanceof Event || (i == null ? void 0 : i.nativeEvent) instanceof Event) && i.defaultPrevented) return;
        o(i, ...a)
      }
    }
  });
  return e
}

function ws(t) {
  var e;
  return Object.assign(A.forwardRef(t), {
    displayName: (e = t.displayName) != null ? e : t.name
  })
}

function SA(t) {
  let e = Object.assign({}, t);
  for (let r in e) e[r] === void 0 && delete e[r];
  return e
}

function NT(t, e = []) {
  let r = Object.assign({}, t);
  for (let n of e) n in r && delete r[n];
  return r
}

function YBe(t) {
  let e = t.parentElement,
    r = null;
  for (; e && !(e instanceof HTMLFieldSetElement);) e instanceof HTMLLegendElement && (r = e), e = e.parentElement;
  let n = (e == null ? void 0 : e.getAttribute("disabled")) === "";
  return n && qBe(r) ? !1 : n
}

function qBe(t) {
  if (!t) return !1;
  let e = t.previousElementSibling;
  for (; e !== null;) {
    if (e instanceof HTMLLegendElement) return !1;
    e = e.previousElementSibling
  }
  return !0
}

function Uq(t = {}, e = null, r = []) {
  for (let [n, i] of Object.entries(t)) Hq(r, jq(e, n), i);
  return r
}

function jq(t, e) {
  return t ? t + "[" + e + "]" : e
}

function Hq(t, e, r) {
  if (Array.isArray(r))
    for (let [n, i] of r.entries()) Hq(t, jq(e, n.toString()), i);
  else r instanceof Date ? t.push([e, r.toISOString()]) : typeof r == "boolean" ? t.push([e, r ? "1" : "0"]) : typeof r == "string" ? t.push([e, r]) : typeof r == "number" ? t.push([e, `${r}`]) : r == null ? t.push([e, ""]) : Uq(r, e, t)
}
let XBe = "div";
var zq = (t => (t[t.None = 1] = "None", t[t.Focusable = 2] = "Focusable", t[t.Hidden = 4] = "Hidden", t))(zq || {});

function QBe(t, e) {
  let {
    features: r = 1,
    ...n
  } = t, i = {
    ref: e,
    "aria-hidden": (r & 2) === 2 ? !0 : void 0,
    style: {
      position: "fixed",
      top: 1,
      left: 1,
      width: 1,
      height: 0,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      borderWidth: "0",
      ...(r & 4) === 4 && (r & 2) !== 2 && {
        display: "none"
      }
    }
  };
  return Qo({
    ourProps: i,
    theirProps: n,
    slot: {},
    defaultTag: XBe,
    name: "Hidden"
  })
}
let ZBe = ws(QBe),
  aO = A.createContext(null);
aO.displayName = "OpenClosedContext";
var yn = (t => (t[t.Open = 1] = "Open", t[t.Closed = 2] = "Closed", t[t.Closing = 4] = "Closing", t[t.Opening = 8] = "Opening", t))(yn || {});

function sO() {
  return A.useContext(aO)
}

function Gq({
  value: t,
  children: e
}) {
  return ce.createElement(aO.Provider, {
    value: t
  }, e)
}
var Ht = (t => (t.Space = " ", t.Enter = "Enter", t.Escape = "Escape", t.Backspace = "Backspace", t.Delete = "Delete", t.ArrowLeft = "ArrowLeft", t.ArrowUp = "ArrowUp", t.ArrowRight = "ArrowRight", t.ArrowDown = "ArrowDown", t.Home = "Home", t.End = "End", t.PageUp = "PageUp", t.PageDown = "PageDown", t.Tab = "Tab", t))(Ht || {});

function JBe(t, e, r) {
  let [n, i] = A.useState(r), a = t !== void 0, s = A.useRef(a), o = A.useRef(!1), c = A.useRef(!1);
  return a && !s.current && !o.current ? (o.current = !0, s.current = a, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !a && s.current && !c.current && (c.current = !0, s.current = a, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [a ? t : n, Ke(l => (a || i(l), e == null ? void 0 : e(l)))]
}

function F6(t) {
  return [t.screenX, t.screenY]
}

function eUe() {
  let t = A.useRef([-1, -1]);
  return {
    wasMoved(e) {
      let r = F6(e);
      return t.current[0] === r[0] && t.current[1] === r[1] ? !1 : (t.current = r, !0)
    },
    update(e) {
      t.current = F6(e)
    }
  }
}

function oO() {
  let t = A.useRef(!1);
  return ei(() => (t.current = !0, () => {
    t.current = !1
  }), []), t
}
var tUe = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(tUe || {}),
  rUe = (t => (t[t.Single = 0] = "Single", t[t.Multi = 1] = "Multi", t))(rUe || {}),
  nUe = (t => (t[t.Pointer = 0] = "Pointer", t[t.Other = 1] = "Other", t))(nUe || {}),
  iUe = (t => (t[t.OpenListbox = 0] = "OpenListbox", t[t.CloseListbox = 1] = "CloseListbox", t[t.GoToOption = 2] = "GoToOption", t[t.Search = 3] = "Search", t[t.ClearSearch = 4] = "ClearSearch", t[t.RegisterOption = 5] = "RegisterOption", t[t.UnregisterOption = 6] = "UnregisterOption", t[t.RegisterLabel = 7] = "RegisterLabel", t))(iUe || {});

function DT(t, e = r => r) {
  let r = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null,
    n = jBe(e(t.options.slice()), a => a.dataRef.current.domRef.current),
    i = r ? n.indexOf(r) : null;
  return i === -1 && (i = null), {
    options: n,
    activeOptionIndex: i
  }
}
let aUe = {
    [1](t) {
      return t.dataRef.current.disabled || t.listboxState === 1 ? t : {
        ...t,
        activeOptionIndex: null,
        listboxState: 1
      }
    },
    [0](t) {
      if (t.dataRef.current.disabled || t.listboxState === 0) return t;
      let e = t.activeOptionIndex,
        {
          isSelected: r
        } = t.dataRef.current,
        n = t.options.findIndex(i => r(i.dataRef.current.value));
      return n !== -1 && (e = n), {
        ...t,
        listboxState: 0,
        activeOptionIndex: e
      }
    },
    [2](t, e) {
      var r;
      if (t.dataRef.current.disabled || t.listboxState === 1) return t;
      let n = DT(t),
        i = WBe(e, {
          resolveItems: () => n.options,
          resolveActiveIndex: () => n.activeOptionIndex,
          resolveId: a => a.id,
          resolveDisabled: a => a.dataRef.current.disabled
        });
      return {
        ...t,
        ...n,
        searchQuery: "",
        activeOptionIndex: i,
        activationTrigger: (r = e.trigger) != null ? r : 1
      }
    },
    [3]: (t, e) => {
      if (t.dataRef.current.disabled || t.listboxState === 1) return t;
      let r = t.searchQuery !== "" ? 0 : 1,
        n = t.searchQuery + e.value.toLowerCase(),
        i = (t.activeOptionIndex !== null ? t.options.slice(t.activeOptionIndex + r).concat(t.options.slice(0, t.activeOptionIndex + r)) : t.options).find(s => {
          var o;
          return !s.dataRef.current.disabled && ((o = s.dataRef.current.textValue) == null ? void 0 : o.startsWith(n))
        }),
        a = i ? t.options.indexOf(i) : -1;
      return a === -1 || a === t.activeOptionIndex ? {
        ...t,
        searchQuery: n
      } : {
        ...t,
        searchQuery: n,
        activeOptionIndex: a,
        activationTrigger: 1
      }
    },
    [4](t) {
      return t.dataRef.current.disabled || t.listboxState === 1 || t.searchQuery === "" ? t : {
        ...t,
        searchQuery: ""
      }
    },
    [5]: (t, e) => {
      let r = {
          id: e.id,
          dataRef: e.dataRef
        },
        n = DT(t, i => [...i, r]);
      return t.activeOptionIndex === null && t.dataRef.current.isSelected(e.dataRef.current.value) && (n.activeOptionIndex = n.options.indexOf(r)), {
        ...t,
        ...n
      }
    },
    [6]: (t, e) => {
      let r = DT(t, n => {
        let i = n.findIndex(a => a.id === e.id);
        return i !== -1 && n.splice(i, 1), n
      });
      return {
        ...t,
        ...r,
        activationTrigger: 1
      }
    },
    [7]: (t, e) => ({
      ...t,
      labelId: e.id
    })
  },
  lO = A.createContext(null);
lO.displayName = "ListboxActionsContext";

function ug(t) {
  let e = A.useContext(lO);
  if (e === null) {
    let r = new Error(`<${t} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, ug), r
  }
  return e
}
let cO = A.createContext(null);
cO.displayName = "ListboxDataContext";

function fg(t) {
  let e = A.useContext(cO);
  if (e === null) {
    let r = new Error(`<${t} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, fg), r
  }
  return e
}

function sUe(t, e) {
  return rr(e.type, aUe, t, e)
}
let oUe = A.Fragment;

function lUe(t, e) {
  let {
    value: r,
    defaultValue: n,
    form: i,
    name: a,
    onChange: s,
    by: o = (D, Q) => D === Q,
    disabled: c = !1,
    horizontal: l = !1,
    multiple: u = !1,
    ...f
  } = t;
  const d = l ? "horizontal" : "vertical";
  let h = Sc(e),
    [p = u ? [] : void 0, v] = JBe(r, s, n),
    [g, m] = A.useReducer(sUe, {
      dataRef: A.createRef(),
      listboxState: 1,
      options: [],
      searchQuery: "",
      labelId: null,
      activeOptionIndex: null,
      activationTrigger: 1
    }),
    y = A.useRef({
      static: !1,
      hold: !1
    }),
    x = A.useRef(null),
    b = A.useRef(null),
    _ = A.useRef(null),
    S = Ke(typeof o == "string" ? (D, Q) => {
      let ee = o;
      return (D == null ? void 0 : D[ee]) === (Q == null ? void 0 : Q[ee])
    } : o),
    T = A.useCallback(D => rr(R.mode, {
      [1]: () => p.some(Q => S(Q, D)),
      [0]: () => S(p, D)
    }), [p]),
    R = A.useMemo(() => ({
      ...g,
      value: p,
      disabled: c,
      mode: u ? 1 : 0,
      orientation: d,
      compare: S,
      isSelected: T,
      optionsPropsRef: y,
      labelRef: x,
      buttonRef: b,
      optionsRef: _
    }), [p, c, u, g]);
  ei(() => {
    g.dataRef.current = R
  }, [R]), HBe([R.buttonRef, R.optionsRef], (D, Q) => {
    var ee;
    m({
      type: 1
    }), Fq(Q, iO.Loose) || (D.preventDefault(), (ee = R.buttonRef.current) == null || ee.focus())
  }, R.listboxState === 0);
  let I = A.useMemo(() => ({
      open: R.listboxState === 0,
      disabled: c,
      value: p
    }), [R, c, p]),
    w = Ke(D => {
      let Q = R.options.find(ee => ee.id === D);
      Q && V(Q.dataRef.current.value)
    }),
    C = Ke(() => {
      if (R.activeOptionIndex !== null) {
        let {
          dataRef: D,
          id: Q
        } = R.options[R.activeOptionIndex];
        V(D.current.value), m({
          type: 2,
          focus: Zr.Specific,
          id: Q
        })
      }
    }),
    L = Ke(() => m({
      type: 0
    })),
    H = Ke(() => m({
      type: 1
    })),
    N = Ke((D, Q, ee) => D === Zr.Specific ? m({
      type: 2,
      focus: Zr.Specific,
      id: Q,
      trigger: ee
    }) : m({
      type: 2,
      focus: D,
      trigger: ee
    })),
    P = Ke((D, Q) => (m({
      type: 5,
      id: D,
      dataRef: Q
    }), () => m({
      type: 6,
      id: D
    }))),
    B = Ke(D => (m({
      type: 7,
      id: D
    }), () => m({
      type: 7,
      id: null
    }))),
    V = Ke(D => rr(R.mode, {
      [0]() {
        return v == null ? void 0 : v(D)
      },
      [1]() {
        let Q = R.value.slice(),
          ee = Q.findIndex(de => S(de, D));
        return ee === -1 ? Q.push(D) : Q.splice(ee, 1), v == null ? void 0 : v(Q)
      }
    })),
    M = Ke(D => m({
      type: 3,
      value: D
    })),
    U = Ke(() => m({
      type: 4
    })),
    W = A.useMemo(() => ({
      onChange: V,
      registerOption: P,
      registerLabel: B,
      goToOption: N,
      closeListbox: H,
      openListbox: L,
      selectActiveOption: C,
      selectOption: w,
      search: M,
      clearSearch: U
    }), []),
    k = {
      ref: h
    },
    O = A.useRef(null),
    F = bf();
  return A.useEffect(() => {
    O.current && n !== void 0 && F.addEventListener(O.current, "reset", () => {
      V(n)
    })
  }, [O, V]), ce.createElement(lO.Provider, {
    value: W
  }, ce.createElement(cO.Provider, {
    value: R
  }, ce.createElement(Gq, {
    value: rr(R.listboxState, {
      [0]: yn.Open,
      [1]: yn.Closed
    })
  }, a != null && p != null && Uq({
    [a]: p
  }).map(([D, Q], ee) => ce.createElement(ZBe, {
    features: zq.Hidden,
    ref: ee === 0 ? de => {
      var oe;
      O.current = (oe = de == null ? void 0 : de.closest("form")) != null ? oe : null
    } : void 0,
    ...SA({
      key: D,
      as: "input",
      type: "hidden",
      hidden: !0,
      readOnly: !0,
      form: i,
      name: D,
      value: Q
    })
  })), Qo({
    ourProps: k,
    theirProps: f,
    slot: I,
    defaultTag: oUe,
    name: "Listbox"
  }))))
}
let cUe = "button";

function uUe(t, e) {
  var r;
  let n = aE(),
    {
      id: i = `headlessui-listbox-button-${n}`,
      ...a
    } = t,
    s = fg("Listbox.Button"),
    o = ug("Listbox.Button"),
    c = Sc(s.buttonRef, e),
    l = bf(),
    u = Ke(g => {
      switch (g.key) {
        case Ht.Space:
        case Ht.Enter:
        case Ht.ArrowDown:
          g.preventDefault(), o.openListbox(), l.nextFrame(() => {
            s.value || o.goToOption(Zr.First)
          });
          break;
        case Ht.ArrowUp:
          g.preventDefault(), o.openListbox(), l.nextFrame(() => {
            s.value || o.goToOption(Zr.Last)
          });
          break
      }
    }),
    f = Ke(g => {
      switch (g.key) {
        case Ht.Space:
          g.preventDefault();
          break
      }
    }),
    d = Ke(g => {
      if (YBe(g.currentTarget)) return g.preventDefault();
      s.listboxState === 0 ? (o.closeListbox(), l.nextFrame(() => {
        var m;
        return (m = s.buttonRef.current) == null ? void 0 : m.focus({
          preventScroll: !0
        })
      })) : (g.preventDefault(), o.openListbox())
    }),
    h = Dq(() => {
      if (s.labelId) return [s.labelId, i].join(" ")
    }, [s.labelId, i]),
    p = A.useMemo(() => ({
      open: s.listboxState === 0,
      disabled: s.disabled,
      value: s.value
    }), [s]),
    v = {
      ref: c,
      id: i,
      type: zBe(t, s.buttonRef),
      "aria-haspopup": "listbox",
      "aria-controls": (r = s.optionsRef.current) == null ? void 0 : r.id,
      "aria-expanded": s.disabled ? void 0 : s.listboxState === 0,
      "aria-labelledby": h,
      disabled: s.disabled,
      onKeyDown: u,
      onKeyUp: f,
      onClick: d
    };
  return Qo({
    ourProps: v,
    theirProps: a,
    slot: p,
    defaultTag: cUe,
    name: "Listbox.Button"
  })
}
let fUe = "label";

function dUe(t, e) {
  let r = aE(),
    {
      id: n = `headlessui-listbox-label-${r}`,
      ...i
    } = t,
    a = fg("Listbox.Label"),
    s = ug("Listbox.Label"),
    o = Sc(a.labelRef, e);
  ei(() => s.registerLabel(n), [n]);
  let c = Ke(() => {
      var u;
      return (u = a.buttonRef.current) == null ? void 0 : u.focus({
        preventScroll: !0
      })
    }),
    l = A.useMemo(() => ({
      open: a.listboxState === 0,
      disabled: a.disabled
    }), [a]);
  return Qo({
    ourProps: {
      ref: o,
      id: n,
      onClick: c
    },
    theirProps: i,
    slot: l,
    defaultTag: fUe,
    name: "Listbox.Label"
  })
}
let hUe = "ul",
  pUe = _1.RenderStrategy | _1.Static;

function gUe(t, e) {
  var r;
  let n = aE(),
    {
      id: i = `headlessui-listbox-options-${n}`,
      ...a
    } = t,
    s = fg("Listbox.Options"),
    o = ug("Listbox.Options"),
    c = Sc(s.optionsRef, e),
    l = bf(),
    u = bf(),
    f = sO(),
    d = (() => f !== null ? (f & yn.Open) === yn.Open : s.listboxState === 0)();
  A.useEffect(() => {
    var m;
    let y = s.optionsRef.current;
    y && s.listboxState === 0 && y !== ((m = Mq(y)) == null ? void 0 : m.activeElement) && y.focus({
      preventScroll: !0
    })
  }, [s.listboxState, s.optionsRef]);
  let h = Ke(m => {
      switch (u.dispose(), m.key) {
        case Ht.Space:
          if (s.searchQuery !== "") return m.preventDefault(), m.stopPropagation(), o.search(m.key);
        case Ht.Enter:
          if (m.preventDefault(), m.stopPropagation(), s.activeOptionIndex !== null) {
            let {
              dataRef: y
            } = s.options[s.activeOptionIndex];
            o.onChange(y.current.value)
          }
          s.mode === 0 && (o.closeListbox(), Po().nextFrame(() => {
            var y;
            return (y = s.buttonRef.current) == null ? void 0 : y.focus({
              preventScroll: !0
            })
          }));
          break;
        case rr(s.orientation, {
          vertical: Ht.ArrowDown,
          horizontal: Ht.ArrowRight
        }):
          return m.preventDefault(), m.stopPropagation(), o.goToOption(Zr.Next);
        case rr(s.orientation, {
          vertical: Ht.ArrowUp,
          horizontal: Ht.ArrowLeft
        }):
          return m.preventDefault(), m.stopPropagation(), o.goToOption(Zr.Previous);
        case Ht.Home:
        case Ht.PageUp:
          return m.preventDefault(), m.stopPropagation(), o.goToOption(Zr.First);
        case Ht.End:
        case Ht.PageDown:
          return m.preventDefault(), m.stopPropagation(), o.goToOption(Zr.Last);
        case Ht.Escape:
          return m.preventDefault(), m.stopPropagation(), o.closeListbox(), l.nextFrame(() => {
            var y;
            return (y = s.buttonRef.current) == null ? void 0 : y.focus({
              preventScroll: !0
            })
          });
        case Ht.Tab:
          m.preventDefault(), m.stopPropagation();
          break;
        default:
          m.key.length === 1 && (o.search(m.key), u.setTimeout(() => o.clearSearch(), 350));
          break
      }
    }),
    p = Dq(() => {
      var m, y, x;
      return (x = (m = s.labelRef.current) == null ? void 0 : m.id) != null ? x : (y = s.buttonRef.current) == null ? void 0 : y.id
    }, [s.labelRef.current, s.buttonRef.current]),
    v = A.useMemo(() => ({
      open: s.listboxState === 0
    }), [s]),
    g = {
      "aria-activedescendant": s.activeOptionIndex === null || (r = s.options[s.activeOptionIndex]) == null ? void 0 : r.id,
      "aria-multiselectable": s.mode === 1 ? !0 : void 0,
      "aria-labelledby": p,
      "aria-orientation": s.orientation,
      id: i,
      onKeyDown: h,
      role: "listbox",
      tabIndex: 0,
      ref: c
    };
  return Qo({
    ourProps: g,
    theirProps: a,
    slot: v,
    defaultTag: hUe,
    features: pUe,
    visible: d,
    name: "Listbox.Options"
  })
}
let mUe = "li";

function vUe(t, e) {
  let r = aE(),
    {
      id: n = `headlessui-listbox-option-${r}`,
      disabled: i = !1,
      value: a,
      ...s
    } = t,
    o = fg("Listbox.Option"),
    c = ug("Listbox.Option"),
    l = o.activeOptionIndex !== null ? o.options[o.activeOptionIndex].id === n : !1,
    u = o.isSelected(a),
    f = A.useRef(null),
    d = ts({
      disabled: i,
      value: a,
      domRef: f,
      get textValue() {
        var _, S;
        return (S = (_ = f.current) == null ? void 0 : _.textContent) == null ? void 0 : S.toLowerCase()
      }
    }),
    h = Sc(e, f);
  ei(() => {
    if (o.listboxState !== 0 || !l || o.activationTrigger === 0) return;
    let _ = Po();
    return _.requestAnimationFrame(() => {
      var S, T;
      (T = (S = f.current) == null ? void 0 : S.scrollIntoView) == null || T.call(S, {
        block: "nearest"
      })
    }), _.dispose
  }, [f, l, o.listboxState, o.activationTrigger, o.activeOptionIndex]), ei(() => c.registerOption(n, d), [d, n]);
  let p = Ke(_ => {
      if (i) return _.preventDefault();
      c.onChange(a), o.mode === 0 && (c.closeListbox(), Po().nextFrame(() => {
        var S;
        return (S = o.buttonRef.current) == null ? void 0 : S.focus({
          preventScroll: !0
        })
      }))
    }),
    v = Ke(() => {
      if (i) return c.goToOption(Zr.Nothing);
      c.goToOption(Zr.Specific, n)
    }),
    g = eUe(),
    m = Ke(_ => g.update(_)),
    y = Ke(_ => {
      g.wasMoved(_) && (i || l || c.goToOption(Zr.Specific, n, 0))
    }),
    x = Ke(_ => {
      g.wasMoved(_) && (i || l && c.goToOption(Zr.Nothing))
    }),
    b = A.useMemo(() => ({
      active: l,
      selected: u,
      disabled: i
    }), [l, u, i]);
  return Qo({
    ourProps: {
      id: n,
      ref: h,
      role: "option",
      tabIndex: i === !0 ? void 0 : -1,
      "aria-disabled": i === !0 ? !0 : void 0,
      "aria-selected": u,
      disabled: void 0,
      onClick: p,
      onFocus: v,
      onPointerEnter: m,
      onMouseEnter: m,
      onPointerMove: y,
      onMouseMove: y,
      onPointerLeave: x,
      onMouseLeave: x
    },
    theirProps: s,
    slot: b,
    defaultTag: mUe,
    name: "Listbox.Option"
  })
}
let yUe = ws(lUe),
  xUe = ws(uUe),
  bUe = ws(dUe),
  EUe = ws(gUe),
  SUe = ws(vUe),
  Um = Object.assign(yUe, {
    Button: xUe,
    Label: bUe,
    Options: EUe,
    Option: SUe
  });

function _Ue(t = 0) {
  let [e, r] = A.useState(t), n = oO(), i = A.useCallback(c => {
    n.current && r(l => l | c)
  }, [e, n]), a = A.useCallback(c => !!(e & c), [e]), s = A.useCallback(c => {
    n.current && r(l => l & ~c)
  }, [r, n]), o = A.useCallback(c => {
    n.current && r(l => l ^ c)
  }, [r]);
  return {
    flags: e,
    addFlag: i,
    hasFlag: a,
    removeFlag: s,
    toggleFlag: o
  }
}

function TUe(t) {
  let e = {
    called: !1
  };
  return (...r) => {
    if (!e.called) return e.called = !0, t(...r)
  }
}

function MT(t, ...e) {
  t && e.length > 0 && t.classList.add(...e)
}

function FT(t, ...e) {
  t && e.length > 0 && t.classList.remove(...e)
}

function wUe(t, e) {
  let r = Po();
  if (!t) return r.dispose;
  let {
    transitionDuration: n,
    transitionDelay: i
  } = getComputedStyle(t), [a, s] = [n, i].map(c => {
    let [l = 0] = c.split(",").filter(Boolean).map(u => u.includes("ms") ? parseFloat(u) : parseFloat(u) * 1e3).sort((u, f) => f - u);
    return l
  }), o = a + s;
  if (o !== 0) {
    r.group(l => {
      l.setTimeout(() => {
        e(), l.dispose()
      }, o), l.addEventListener(t, "transitionrun", u => {
        u.target === u.currentTarget && l.dispose()
      })
    });
    let c = r.addEventListener(t, "transitionend", l => {
      l.target === l.currentTarget && (e(), c())
    })
  } else e();
  return r.add(() => e()), r.dispose
}

function RUe(t, e, r, n) {
  let i = r ? "enter" : "leave",
    a = Po(),
    s = n !== void 0 ? TUe(n) : () => {};
  i === "enter" && (t.removeAttribute("hidden"), t.style.display = "");
  let o = rr(i, {
      enter: () => e.enter,
      leave: () => e.leave
    }),
    c = rr(i, {
      enter: () => e.enterTo,
      leave: () => e.leaveTo
    }),
    l = rr(i, {
      enter: () => e.enterFrom,
      leave: () => e.leaveFrom
    });
  return FT(t, ...e.enter, ...e.enterTo, ...e.enterFrom, ...e.leave, ...e.leaveFrom, ...e.leaveTo, ...e.entered), MT(t, ...o, ...l), a.nextFrame(() => {
    FT(t, ...l), MT(t, ...c), wUe(t, () => (FT(t, ...o), MT(t, ...e.entered), s()))
  }), a.dispose
}

function AUe({
  container: t,
  direction: e,
  classes: r,
  onStart: n,
  onStop: i
}) {
  let a = oO(),
    s = bf(),
    o = ts(e);
  ei(() => {
    let c = Po();
    s.add(c.dispose);
    let l = t.current;
    if (l && o.current !== "idle" && a.current) return c.dispose(), n.current(o.current), c.add(RUe(l, r.current, o.current === "enter", () => {
      c.dispose(), i.current(o.current)
    })), c.dispose
  }, [e])
}

function hl(t = "") {
  return t.split(" ").filter(e => e.trim().length > 1)
}
let sE = A.createContext(null);
sE.displayName = "TransitionContext";
var IUe = (t => (t.Visible = "visible", t.Hidden = "hidden", t))(IUe || {});

function $Ue() {
  let t = A.useContext(sE);
  if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t
}

function CUe() {
  let t = A.useContext(oE);
  if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t
}
let oE = A.createContext(null);
oE.displayName = "NestingContext";

function lE(t) {
  return "children" in t ? lE(t.children) : t.current.filter(({
    el: e
  }) => e.current !== null).filter(({
    state: e
  }) => e === "visible").length > 0
}

function Vq(t, e) {
  let r = ts(t),
    n = A.useRef([]),
    i = oO(),
    a = bf(),
    s = Ke((h, p = Qa.Hidden) => {
      let v = n.current.findIndex(({
        el: g
      }) => g === h);
      v !== -1 && (rr(p, {
        [Qa.Unmount]() {
          n.current.splice(v, 1)
        },
        [Qa.Hidden]() {
          n.current[v].state = "hidden"
        }
      }), a.microTask(() => {
        var g;
        !lE(n) && i.current && ((g = r.current) == null || g.call(r))
      }))
    }),
    o = Ke(h => {
      let p = n.current.find(({
        el: v
      }) => v === h);
      return p ? p.state !== "visible" && (p.state = "visible") : n.current.push({
        el: h,
        state: "visible"
      }), () => s(h, Qa.Unmount)
    }),
    c = A.useRef([]),
    l = A.useRef(Promise.resolve()),
    u = A.useRef({
      enter: [],
      leave: [],
      idle: []
    }),
    f = Ke((h, p, v) => {
      c.current.splice(0), e && (e.chains.current[p] = e.chains.current[p].filter(([g]) => g !== h)), e == null || e.chains.current[p].push([h, new Promise(g => {
        c.current.push(g)
      })]), e == null || e.chains.current[p].push([h, new Promise(g => {
        Promise.all(u.current[p].map(([m, y]) => y)).then(() => g())
      })]), p === "enter" ? l.current = l.current.then(() => e == null ? void 0 : e.wait.current).then(() => v(p)) : v(p)
    }),
    d = Ke((h, p, v) => {
      Promise.all(u.current[p].splice(0).map(([g, m]) => m)).then(() => {
        var g;
        (g = c.current.shift()) == null || g()
      }).then(() => v(p))
    });
  return A.useMemo(() => ({
    children: n,
    register: o,
    unregister: s,
    onStart: f,
    onStop: d,
    wait: l,
    chains: u
  }), [o, s, n, f, d, u, l])
}

function kUe() {}
let OUe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];

function B6(t) {
  var e;
  let r = {};
  for (let n of OUe) r[n] = (e = t[n]) != null ? e : kUe;
  return r
}

function LUe(t) {
  let e = A.useRef(B6(t));
  return A.useEffect(() => {
    e.current = B6(t)
  }, [t]), e
}
let PUe = "div",
  Wq = _1.RenderStrategy;

function NUe(t, e) {
  let {
    beforeEnter: r,
    afterEnter: n,
    beforeLeave: i,
    afterLeave: a,
    enter: s,
    enterFrom: o,
    enterTo: c,
    entered: l,
    leave: u,
    leaveFrom: f,
    leaveTo: d,
    ...h
  } = t, p = A.useRef(null), v = Sc(p, e), g = h.unmount ? Qa.Unmount : Qa.Hidden, {
    show: m,
    appear: y,
    initial: x
  } = $Ue(), [b, _] = A.useState(m ? "visible" : "hidden"), S = CUe(), {
    register: T,
    unregister: R
  } = S, I = A.useRef(null);
  A.useEffect(() => T(p), [T, p]), A.useEffect(() => {
    if (g === Qa.Hidden && p.current) {
      if (m && b !== "visible") {
        _("visible");
        return
      }
      return rr(b, {
        hidden: () => R(p),
        visible: () => T(p)
      })
    }
  }, [b, p, T, R, m, g]);
  let w = ts({
      enter: hl(s),
      enterFrom: hl(o),
      enterTo: hl(c),
      entered: hl(l),
      leave: hl(u),
      leaveFrom: hl(f),
      leaveTo: hl(d)
    }),
    C = LUe({
      beforeEnter: r,
      afterEnter: n,
      beforeLeave: i,
      afterLeave: a
    }),
    L = nO();
  A.useEffect(() => {
    if (L && b === "visible" && p.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")
  }, [p, b, L]);
  let H = x && !y,
    N = (() => !L || H || I.current === m ? "idle" : m ? "enter" : "leave")(),
    P = _Ue(0),
    B = Ke(k => rr(k, {
      enter: () => {
        P.addFlag(yn.Opening), C.current.beforeEnter()
      },
      leave: () => {
        P.addFlag(yn.Closing), C.current.beforeLeave()
      },
      idle: () => {}
    })),
    V = Ke(k => rr(k, {
      enter: () => {
        P.removeFlag(yn.Opening), C.current.afterEnter()
      },
      leave: () => {
        P.removeFlag(yn.Closing), C.current.afterLeave()
      },
      idle: () => {}
    })),
    M = Vq(() => {
      _("hidden"), R(p)
    }, S);
  AUe({
    container: p,
    classes: w,
    direction: N,
    onStart: ts(k => {
      M.onStart(p, k, B)
    }),
    onStop: ts(k => {
      M.onStop(p, k, V), k === "leave" && !lE(M) && (_("hidden"), R(p))
    })
  }), A.useEffect(() => {
    H && (g === Qa.Hidden ? I.current = null : I.current = m)
  }, [m, H, b]);
  let U = h,
    W = {
      ref: v
    };
  return y && m && (U = {
    ...U,
    className: EA(h.className, ...w.current.enter, ...w.current.enterFrom)
  }), ce.createElement(oE.Provider, {
    value: M
  }, ce.createElement(Gq, {
    value: rr(b, {
      visible: yn.Open,
      hidden: yn.Closed
    }) | P.flags
  }, Qo({
    ourProps: W,
    theirProps: U,
    defaultTag: PUe,
    features: Wq,
    visible: b === "visible",
    name: "Transition.Child"
  })))
}

function DUe(t, e) {
  let {
    show: r,
    appear: n = !1,
    unmount: i,
    ...a
  } = t, s = A.useRef(null), o = Sc(s, e);
  nO();
  let c = sO();
  if (r === void 0 && c !== null && (r = (c & yn.Open) === yn.Open), ![!0, !1].includes(r)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [l, u] = A.useState(r ? "visible" : "hidden"), f = Vq(() => {
    u("hidden")
  }), [d, h] = A.useState(!0), p = A.useRef([r]);
  ei(() => {
    d !== !1 && p.current[p.current.length - 1] !== r && (p.current.push(r), h(!1))
  }, [p, r]);
  let v = A.useMemo(() => ({
    show: r,
    appear: n,
    initial: d
  }), [r, n, d]);
  A.useEffect(() => {
    if (r) u("visible");
    else if (!lE(f)) u("hidden");
    else {
      let m = s.current;
      if (!m) return;
      let y = m.getBoundingClientRect();
      y.x === 0 && y.y === 0 && y.width === 0 && y.height === 0 && u("hidden")
    }
  }, [r, f]);
  let g = {
    unmount: i
  };
  return ce.createElement(oE.Provider, {
    value: f
  }, ce.createElement(sE.Provider, {
    value: v
  }, Qo({
    ourProps: {
      ...g,
      as: A.Fragment,
      children: ce.createElement(Kq, {
        ref: o,
        ...g,
        ...a
      })
    },
    theirProps: {},
    defaultTag: A.Fragment,
    features: Wq,
    visible: l === "visible",
    name: "Transition"
  })))
}

function MUe(t, e) {
  let r = A.useContext(sE) !== null,
    n = sO() !== null;
  return ce.createElement(ce.Fragment, null, !r && n ? ce.createElement(_A, {
    ref: e,
    ...t
  }) : ce.createElement(Kq, {
    ref: e,
    ...t
  }))
}
let _A = ws(DUe),
  Kq = ws(NUe),
  FUe = ws(MUe),
  TA = Object.assign(_A, {
    Child: FUe,
    Root: _A
  });

function BUe(t, e) {
  return t === "slide-down" ? {
    leave: `transition-[transform,opacity] ${e}`,
    leaveFrom: "opacity-100 translate-y-0",
    leaveTo: "-translate-y-4 opacity-0",
    enter: `transition-[transform,opacity] ${e}`,
    enterFrom: "opacity-0 -translate-y-4",
    enterTo: "translate-y-0 opacity-100"
  } : t === "slide-up" ? {
    leave: `transition-[transform,opacity] ${e}`,
    leaveFrom: "opacity-100 translate-y-0",
    leaveTo: "translate-y-4 opacity-0",
    enter: `transition-[transform,opacity] ${e}`,
    enterFrom: "opacity-0 translate-y-4",
    enterTo: "translate-y-0 opacity-100"
  } : t === "slide-full-left" ? {
    leave: `transition-[transform] ${e}`,
    leaveFrom: "translate-x-0",
    leaveTo: "-translate-x-full",
    enter: `transition-[transform] ${e}`,
    enterFrom: "-translate-x-full",
    enterTo: "translate-x-0"
  } : t === "slide-full-right" ? {
    leave: `transition-[transform] ${e}`,
    leaveFrom: "translate-x-0",
    leaveTo: "translate-x-full",
    enter: `transition-[transform] ${e}`,
    enterFrom: "translate-x-full",
    enterTo: "translate-x-0"
  } : t === "fade" ? {
    leave: `transition-[transform,opacity] ${e}`,
    leaveFrom: "opacity-100",
    leaveTo: "opacity-0",
    enter: `transition-[transform,opacity] ${e}`,
    enterFrom: "opacity-0",
    enterTo: "opacity-100"
  } : {}
}

function $i(t) {
  const e = t.durationClass ? ? "duration-200",
    r = BUe(t.animation, e);
  return t.isChild ? E(TA.Child, {
    as: A.Fragment,
    ...r,
    children: E("div", {
      className: t.className,
      children: t.children
    })
  }) : E(TA, {
    show: t.show,
    as: A.Fragment,
    ...r,
    children: E("div", {
      className: t.className,
      children: t.children
    })
  })
}

function UUe(t) {
  const e = Re(),
    r = st(e),
    n = Cn(e),
    i = Bi(e),
    [a, s] = A.useState(!1),
    o = A.useRef(null),
    c = A.useRef(null),
    l = A.useRef(0),
    u = A.useCallback(() => {
      a || setTimeout(() => {
        Date.now() - l.current < 200 || s(!0)
      }, 20), o.current && clearTimeout(o.current), o.current = setTimeout(() => {
        s(!1), o.current = null
      }, 3e3)
    }, [s, a]),
    f = A.useCallback(() => {
      s(!1)
    }, [s]),
    d = A.useCallback(g => {
      if (!(!c.current || c.current !== g.target) && i.popout === null) {
        if (g.type === "touchend") {
          l.current = Date.now();
          return
        }
        g.button === 0 && setTimeout(() => {
          if (Date.now() - l.current < 200) {
            s(m => !m);
            return
          }
          n.isPlaying ? r.pause() : r.play()
        }, 20)
      }
    }, [r, n, i]),
    h = A.useCallback(g => {
      !c.current || c.current !== g.target || (i.isFullscreen ? r.exitFullscreen() : r.enterFullscreen())
    }, [r, i]),
    p = A.useRef(null);
  A.useEffect(() => {
    var m;
    const g = a || n.isPaused || !!i.popout;
    g !== p.current && (p.current = g, (m = t.onBackdropChange) == null || m.call(t, g))
  }, [a, n, t, i]);
  const v = a || n.isPaused || !!i.popout;
  return Y("div", {
    className: `absolute inset-0 ${v?"":"cursor-none"}`,
    onMouseMove: u,
    onMouseLeave: f,
    ref: c,
    onMouseUp: d,
    onTouchEnd: d,
    onDoubleClick: h,
    children: [E("div", {
      className: `pointer-events-none absolute inset-0 bg-black bg-opacity-20 transition-opacity duration-200 ${v?"":"!opacity-0"}`
    }), E("div", {
      className: `pointer-events-none absolute inset-x-0 bottom-0 h-[20%] bg-gradient-to-t from-black to-transparent transition-opacity duration-200 ${v?"":"!opacity-0"}`
    }), E("div", {
      className: `pointer-events-none absolute inset-x-0 top-0 h-[20%] bg-gradient-to-b from-black to-transparent transition-opacity duration-200 ${v?"":"!opacity-0"}`
    }), E("div", {
      className: "pointer-events-none absolute inset-0",
      children: t.children
    })]
  })
}

function jUe() {
  const {
    t
  } = ke(), e = Re();
  return Ss(e).isCasting ? Y("div", {
    className: "flex flex-col items-center justify-center gap-4",
    children: [E("div", {
      className: "rounded-full bg-denim-200 p-3 brightness-100 grayscale",
      children: E(Ve, {
        icon: ue.CASTING
      })
    }), E("p", {
      className: "text-center text-gray-300",
      children: t("casting.casting")
    })]
  }) : null
}
var hn = {
    fullscreenEnabled: 0,
    fullscreenElement: 1,
    requestFullscreen: 2,
    exitFullscreen: 3,
    fullscreenchange: 4,
    fullscreenerror: 5,
    fullscreen: 6
  },
  U6 = ["webkitFullscreenEnabled", "webkitFullscreenElement", "webkitRequestFullscreen", "webkitExitFullscreen", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
  j6 = ["mozFullScreenEnabled", "mozFullScreenElement", "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
  H6 = ["msFullscreenEnabled", "msFullscreenElement", "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"],
  zr = typeof window < "u" && typeof window.document < "u" ? window.document : {},
  Dn = "fullscreenEnabled" in zr && Object.keys(hn) || U6[0] in zr && U6 || j6[0] in zr && j6 || H6[0] in zr && H6 || [],
  HUe = {
    requestFullscreen: function (t) {
      return t[Dn[hn.requestFullscreen]]()
    },
    requestFullscreenFunction: function (t) {
      return t[Dn[hn.requestFullscreen]]
    },
    get exitFullscreen() {
      return zr[Dn[hn.exitFullscreen]].bind(zr)
    },
    get fullscreenPseudoClass() {
      return ":" + Dn[hn.fullscreen]
    },
    addEventListener: function (t, e, r) {
      return zr.addEventListener(Dn[hn[t]], e, r)
    },
    removeEventListener: function (t, e, r) {
      return zr.removeEventListener(Dn[hn[t]], e, r)
    },
    get fullscreenEnabled() {
      return !!zr[Dn[hn.fullscreenEnabled]]
    },
    set fullscreenEnabled(t) {},
    get fullscreenElement() {
      return zr[Dn[hn.fullscreenElement]]
    },
    set fullscreenElement(t) {},
    get onfullscreenchange() {
      return zr[("on" + Dn[hn.fullscreenchange]).toLowerCase()]
    },
    set onfullscreenchange(t) {
      return zr[("on" + Dn[hn.fullscreenchange]).toLowerCase()] = t
    },
    get onfullscreenerror() {
      return zr[("on" + Dn[hn.fullscreenerror]).toLowerCase()]
    },
    set onfullscreenerror(t) {
      return zr[("on" + Dn[hn.fullscreenerror]).toLowerCase()] = t
    }
  };
const xn = HUe,
  zUe = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
let BT = null;
async function z0() {
  if (BT === null) {
    const t = new Promise(r => {
        setTimeout(() => r(!1), 1e3)
      }),
      e = new Promise(r => {
        const n = document.createElement("video"),
          i = () => {
            n.removeEventListener("volumechange", i), r(!0)
          };
        n.addEventListener("volumechange", i), n.volume = .5
      });
    BT = await Promise.race([e, t])
  }
  return BT
}

function cE() {
  return xn.fullscreenEnabled
}

function uO() {
  return cE() || zUe
}

function fO() {
  return cE() || uO()
}

function Yq() {
  return "pictureInPictureEnabled" in document
}

function qq() {
  return "webkitSupportsPresentationMode" in document.createElement("video")
}

function z6(t) {
  const e = Re(),
    r = Bi(e),
    n = st(e),
    i = A.useCallback(() => {
      r.isFullscreen ? n.exitFullscreen() : n.enterFullscreen()
    }, [n, r]);
  return fO() ? E(Ts, {
    className: t.className,
    onClick: i,
    icon: r.isFullscreen ? ue.COMPRESS : ue.EXPAND
  }) : null
}

function GUe(t) {
  const e = Re(),
    r = ui(e);
  return E(Ec, {
    media: r == null ? void 0 : r.meta.meta,
    ...t
  })
}

function Xq(t) {
  const [e, r] = A.useState(1), n = st(t), i = Cn(t);
  return {
    storedVolume: e,
    setStoredVolume: r,
    toggleVolume: (s = !1) => {
      i.volume > 0 ? (r(i.volume), n.setVolume(0, s)) : n.setVolume(e > 0 ? e : 1, s)
    }
  }
}

function VUe() {
  const t = Re(),
    e = st(t),
    r = Bi(t),
    n = Cn(t),
    i = Xo(t),
    {
      toggleVolume: a
    } = Xq(t),
    s = A.useRef(0);
  return A.useEffect(() => {
    s.current = i.time
  }, [i]), A.useEffect(() => {
    const c = br(t).wrapperElement;
    if (!c) return;
    let l = !1;
    const u = f => {
      if (r.isFocused) switch (f.key.toLowerCase()) {
        case "f":
          r.isFullscreen ? e.exitFullscreen() : e.enterFullscreen();
          break;
        case "arrowleft":
          e.setTime(s.current - 5);
          break;
        case "arrowright":
          e.setTime(s.current + 5);
          break;
        case " ":
          n.isPaused ? e.play() : e.pause();
          break;
        case "m":
          a(!0);
          break;
        case "arrowdown":
          e.setVolume(Math.max(n.volume - .1, 0), !0);
          break;
        case "arrowup":
          e.setVolume(Math.min(n.volume + .1, 1), !0);
          break;
        case "r":
          if (l || f.ctrlKey || f.metaKey) return;
          l = !0, c.classList.add("roll"), setTimeout(() => {
            l = !1, c.classList.remove("roll")
          }, 1e3);
          break
      }
    };
    return window.addEventListener("keydown", u), () => {
      window.removeEventListener("keydown", u)
    }
  }, [e, t, n, r, a]), null
}

function Qq(t) {
  return E("div", {
    className: ["spinner", t.className ? ? ""].join(" ")
  })
}

function WUe() {
  const t = Re(),
    e = Cn(t),
    r = Ss(t),
    n = e.isFirstLoading || e.isLoading,
    i = !r.isCasting;
  return !n || !i ? null : E(Qq, {})
}

function KUe() {
  const t = Re(),
    e = st(t),
    r = Cn(t),
    n = A.useCallback(() => {
      r != null && r.isPlaying ? e.pause() : e.play()
    }, [e, r]);
  return r.hasPlayedOnce || r.isPlaying || r.isFirstLoading ? null : E("div", {
    onClick: n,
    className: "group pointer-events-auto flex h-16 w-16 items-center justify-center rounded-full bg-denim-400 text-white transition-[background-color,transform] hover:scale-125 hover:bg-denim-500 active:scale-100",
    children: E(Ve, {
      icon: ue.PLAY,
      className: "text-2xl transition-transform group-hover:scale-125"
    })
  })
}

function Zq(t) {
  const e = Re(),
    r = Cn(e),
    n = st(e),
    i = A.useCallback(() => {
      r.isPlaying ? n.pause() : n.play()
    }, [r, n]),
    a = r.isPlaying || r.isSeeking ? ue.PAUSE : ue.PLAY;
  return E(Ts, {
    iconSize: t.iconSize,
    className: t.className,
    icon: a,
    onClick: i
  })
}

function Jq() {
  const t = Re(),
    e = st(t),
    r = Xo(t),
    n = () => {
      e.setTime(r.time - 10)
    };
  return E(Ts, {
    icon: ue.SKIP_BACKWARD,
    onClick: n
  })
}

function eX() {
  const t = Re(),
    e = st(t),
    r = Xo(t),
    n = () => {
      e.setTime(r.time + 10)
    };
  return E(Ts, {
    icon: ue.SKIP_FORWARD,
    onClick: n
  })
}

function YUe(t) {
  return E("div", {
    className: t.className,
    children: Y("div", {
      className: "flex select-none items-center text-white",
      children: [E(Jq, {}), E(eX, {})]
    })
  })
}

function qUe() {
  const t = Re(),
    e = Cn(t),
    r = e.isFirstLoading || e.isLoading;
  return Y("div", {
    className: "flex items-center space-x-8",
    children: [E(Jq, {}), E(Zq, {
      iconSize: "text-5xl",
      className: r ? "pointer-events-none opacity-0" : ""
    }), E(eX, {})]
  })
}

function tX(t) {
  const e = ui(t),
    {
      t: r
    } = ke(),
    n = A.useMemo(() => {
      var o;
      return (o = e == null ? void 0 : e.seasons) == null ? void 0 : o.find(c => {
        var l;
        return c.id === ((l = e == null ? void 0 : e.episode) == null ? void 0 : l.seasonId)
      })
    }, [e]),
    i = A.useMemo(() => {
      var o;
      return (o = n == null ? void 0 : n.episodes) == null ? void 0 : o.find(c => {
        var l;
        return c.id === ((l = e == null ? void 0 : e.episode) == null ? void 0 : l.episodeId)
      })
    }, [n, e]);
  return !((e == null ? void 0 : e.meta.meta.type) === ae.SERIES && (e != null && e.episode)) ? {
    isSeries: !1
  } : {
    isSeries: !0,
    humanizedEpisodeId: r("videoPlayer.seasonAndEpisode", {
      season: n == null ? void 0 : n.number,
      episode: i == null ? void 0 : i.number
    }),
    currentSeasonInfo: n,
    currentEpisodeInfo: i,
    meta: e == null ? void 0 : e.meta
  }
}

function XUe() {
  const t = Re(),
    {
      isSeries: e,
      humanizedEpisodeId: r,
      meta: n
    } = tX(t);
  if (!n) return null;
  const i = e ? `${n.meta.title} - ${r}` : n.meta.title;
  return E(va, {
    children: E("title", {
      children: i
    })
  })
}

function G6(t) {
  const {
    isMobile: e
  } = Aa(), {
    t: r
  } = ke(), n = Re(), i = st(n), a = A.useCallback(() => {
    i.togglePictureInPicture()
  }, [i]);
  return !Yq() && !qq() ? null : E(Ts, {
    className: t.className,
    icon: ue.PICTURE_IN_PICTURE,
    onClick: a,
    text: e ? r("videoPlayer.buttons.pictureInPicture") : ""
  })
}

function Zv(t) {
  return `${t.toFixed(2)}%`
}

function e0(t) {
  return Number(Math.max(0, Math.min(t, 100)).toFixed(2))
}

function QUe(t) {
  return t.type === "mousedown" || t.type === "mouseup" || t.type === "mousemove"
}
const UT = t => QUe(t) ? t.pageX : t.changedTouches[0].pageX;

function rX(t, e, r = !1) {
  const [n, i] = A.useState(!1), [a, s] = A.useState(0);
  A.useEffect(() => {
    function c(u) {
      if (!n || !t.current) return;
      const f = t.current.getBoundingClientRect(),
        d = (UT(u) - f.left) / t.current.offsetWidth;
      s(d * 100), r && e(d)
    }

    function l(u) {
      if (!n || (i(!1), document.body.removeAttribute("data-no-select"), !t.current)) return;
      const f = t.current.getBoundingClientRect(),
        d = (UT(u) - f.left) / t.current.offsetWidth;
      e(d)
    }
    return document.addEventListener("mousemove", c), document.addEventListener("touchmove", c), document.addEventListener("mouseup", l), document.addEventListener("touchend", l), () => {
      document.removeEventListener("mousemove", c), document.removeEventListener("touchmove", c), document.removeEventListener("mouseup", l), document.removeEventListener("touchend", l)
    }
  }, [n, t, e, r]);
  const o = A.useCallback(c => {
    if (i(!0), document.body.setAttribute("data-no-select", "true"), !t.current) return;
    const l = t.current.getBoundingClientRect(),
      u = (UT(c) - l.left) / t.current.offsetWidth * 100;
    s(u)
  }, [s, t]);
  return {
    dragging: n,
    dragPercentage: a,
    dragMouseDown: o
  }
}

function ZUe() {
  const t = Re(),
    e = st(t),
    r = Xo(t),
    n = A.useRef(null),
    i = A.useRef(!1),
    a = A.useRef(e);
  A.useEffect(() => {
    a.current = e
  }, [e]);
  const s = A.useCallback(d => {
      e.setTime(d * r.duration)
    }, [e, r]),
    {
      dragging: o,
      dragPercentage: c,
      dragMouseDown: l
    } = rX(n, s);
  A.useEffect(() => {
    i.current !== o && (i.current = o, e.setSeeking(o))
  }, [i, o, e]), A.useEffect(() => {
    if (o) {
      const d = br(t);
      a.current.setDraggingTime(d.progress.duration * (c / 100))
    }
  }, [t, o, c]);
  let u = Zv(e0(r.time / r.duration * 100));
  o && (u = Zv(e0(c)));
  const f = Zv(e0(r.buffered / r.duration * 100));
  return E("div", {
    className: "group pointer-events-auto w-full cursor-pointer rounded-full px-2",
    children: E("div", {
      ref: n,
      className: "-my-3 flex h-8 items-center",
      onMouseDown: l,
      onTouchStart: l,
      children: Y("div", {
        className: `relative h-1 flex-1 rounded-full bg-gray-500 bg-opacity-50 transition-[height] duration-100 group-hover:h-2 ${o?"!h-2":""}`,
        children: [E("div", {
          className: "absolute inset-y-0 left-0 flex items-center justify-end rounded-full bg-gray-300 bg-opacity-20",
          style: {
            width: f
          }
        }), E("div", {
          className: "absolute inset-y-0 left-0 flex items-center justify-end rounded-full bg-bink-600",
          style: {
            width: u
          },
          children: E("div", {
            className: `absolute h-1 w-1 translate-x-1/2 rounded-full bg-white opacity-0 transition-[transform,opacity] group-hover:scale-[400%] group-hover:opacity-100 ${o?"!scale-[400%] !opacity-100":""}`
          })
        })]
      })
    })
  })
}

function wA(t) {
  return `__floating::anchor::${t}`
}

function nX(t) {
  const e = A.useRef(null),
    r = A.useRef(null);
  return A.useEffect(() => {
    if (!e.current) return;
    let n = !1;

    function i() {
      if (!n) {
        if (e.current) {
          const a = r.current,
            s = e.current.getBoundingClientRect(),
            o = JSON.stringify(s);
          if (a !== o) {
            r.current = o;
            const c = wA(t.id);
            window[c] = s;
            const l = new CustomEvent(wA(t.id), {
              detail: s
            });
            document.dispatchEvent(l)
          }
        }
        window.requestAnimationFrame(i)
      }
    }
    return window.requestAnimationFrame(i), () => {
      n = !0
    }
  }, [t]), E("div", {
    ref: e,
    children: t.children
  })
}

function V6(t) {
  const {
    t: e
  } = ke(), r = Re(), n = ui(r), i = Bi(r), a = st(r);
  return (n == null ? void 0 : n.meta.meta.type) !== ae.SERIES ? null : E("div", {
    className: t.className,
    children: E("div", {
      className: "relative",
      children: E(nX, {
        id: "episodes",
        children: E(Ts, {
          active: i.popout === "episodes",
          icon: ue.EPISODES,
          text: e("videoPlayer.buttons.episodes"),
          wide: !0,
          onClick: () => a.openPopout("episodes")
        })
      })
    })
  })
}

function JUe() {
  const t = Re(),
    {
      isSeries: e,
      currentEpisodeInfo: r,
      humanizedEpisodeId: n
    } = tX(t);
  return e ? Y("p", {
    className: "ml-8 select-none space-x-2 text-white",
    children: [E("span", {
      children: n
    }), E("span", {
      className: "opacity-50",
      children: r == null ? void 0 : r.title
    })]
  }) : null
}
var vl = (t => (t[t.REGULAR = 0] = "REGULAR", t[t.REMAINING = 1] = "REMAINING", t))(vl || {});

function e7e(t) {
  return t > 60 * 60
}

function jT(t, e = !1) {
  if (Number.isNaN(t)) return e ? "0:00:00" : "0:00";
  let r = t;
  const n = Math.floor(r % 60);
  r /= 60;
  const i = Math.floor(r % 60);
  r /= 60;
  const a = Math.floor(r),
    s = n.toString().padStart(2, "0"),
    o = i.toString().padStart(2, "0");
  return e ? [a, o, s].join(":") : [o, s].join(":")
}

function iX(t) {
  const e = Re(),
    r = Xo(e),
    n = Cn(e),
    {
      setTimeFormat: i
    } = st(e),
    {
      timeFormat: a
    } = Bi(e),
    {
      isMobile: s
    } = Aa(),
    {
      t: o
    } = ke(),
    c = e7e(r.duration),
    l = jT(n.isDragSeeking ? r.draggingTime : r.time, c),
    u = jT(r.duration, c),
    f = jT((r.duration - r.time) / n.playbackSpeed, c),
    d = new Date(new Date().getTime() + (r.duration - r.time) * 1e3 / n.playbackSpeed),
    h = ` - ${o("videoPlayer.finishAt",{timeFinished:d,formatParams:{timeFinished:{hour:"numeric",minute:"numeric"}}})}`;
  let p;
  return a === vl.REGULAR ? p = `${l} ${t.noDuration?"":`/ ${u}`}` : a === vl.REMAINING && !s ? p = `${o("videoPlayer.timeLeft",{timeLeft:f})}${r.time===r.duration?"":h} ` : a === vl.REMAINING && s ? p = `-${f}` : p = "", E("button", {
    type: "button",
    className: ["group pointer-events-auto text-white transition-transform duration-100 active:scale-110"].join(" "),
    onClick: () => {
      i(a === vl.REGULAR ? vl.REMAINING : vl.REGULAR)
    },
    children: E("div", {
      className: ["flex items-center justify-center rounded-full bg-denim-600 bg-opacity-0 p-2 transition-colors duration-100 group-hover:bg-opacity-50 group-active:bg-denim-500 group-active:bg-opacity-100 sm:px-4"].join(" "),
      children: E("div", {
        className: t.className,
        children: E("p", {
          className: "select-none text-white",
          children: p
        })
      })
    })
  })
}

function t7e(t) {
  const e = Re(),
    r = st(e),
    n = Cn(e),
    i = Bi(e),
    {
      setStoredVolume: a,
      toggleVolume: s
    } = Xq(e),
    o = A.useRef(null),
    [c, l] = A.useState(!1),
    u = A.useCallback(y => {
      r.setVolume(y), a(y)
    }, [r, a]),
    {
      dragging: f,
      dragPercentage: d,
      dragMouseDown: h
    } = rX(o, u, !0);
  A.useEffect(() => {
    i.leftControlHovering || l(!1)
  }, [i]);
  const p = A.useCallback(() => {
      s()
    }, [s]),
    v = A.useCallback(async () => {
      await z0() && l(!0)
    }, [l]);
  let g = e0(n.volume * 100);
  f && (g = e0(d));
  const m = Zv(g);
  return E("div", {
    className: t.className,
    children: Y("div", {
      className: "pointer-events-auto flex cursor-pointer items-center",
      onMouseEnter: v,
      children: [E("div", {
        className: "px-4 text-2xl text-white",
        onClick: p,
        children: E(Ve, {
          icon: g > 0 ? ue.VOLUME : ue.VOLUME_X
        })
      }), E("div", {
        className: `linear -ml-2 w-0 overflow-hidden transition-[width,opacity] duration-300 ${c||f?"!w-24 opacity-100":"w-4 opacity-0"}`,
        children: E("div", {
          ref: o,
          className: "flex h-10 w-20 items-center px-2",
          onMouseDown: h,
          onTouchStart: h,
          children: E("div", {
            className: "relative h-1 flex-1 rounded-full bg-gray-500 bg-opacity-50",
            children: E("div", {
              className: "absolute inset-y-0 left-0 flex items-center justify-end rounded-full bg-bink-500",
              style: {
                width: m
              },
              children: E("div", {
                className: "absolute h-3 w-3 translate-x-1/2 rounded-full bg-white"
              })
            })
          })
        })
      })]
    })
  })
}

function aX(t) {
  return {
    error: t.error
  }
}

function HT(t, e) {
  yc(t, "error", aX(e))
}

function r7e(t) {
  const e = br(t),
    [r, n] = A.useState(aX(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "error", i), () => {
      bc(t, "error", i)
    }
  }, [t]), r
}

function n7e(t) {
  const e = Re(),
    r = ui(e),
    i = r7e(e).error;
  return i ? Y("div", {
    children: [Y("div", {
      className: "absolute inset-0 flex flex-col items-center justify-center bg-denim-100",
      children: [E(rn, {
        icon: ue.WARNING,
        className: "mb-6 text-red-400"
      }), E(og, {
        children: "Failed to load media"
      }), Y("p", {
        className: "my-6 max-w-lg text-center",
        children: [i == null ? void 0 : i.name, ": ", i == null ? void 0 : i.description]
      })]
    }), E("div", {
      className: "pointer-events-auto absolute inset-x-0 top-0 flex flex-col px-8 py-6 pb-2",
      children: E(Ec, {
        media: r == null ? void 0 : r.meta.meta,
        onClick: t.onGoBack
      })
    })]
  }) : t.children
}
var dO = hg(),
  we = t => dg(t, dO),
  hO = hg();
we.write = t => dg(t, hO);
var uE = hg();
we.onStart = t => dg(t, uE);
var pO = hg();
we.onFrame = t => dg(t, pO);
var gO = hg();
we.onFinish = t => dg(t, gO);
var Vu = [];
we.setTimeout = (t, e) => {
  let r = we.now() + e,
    n = () => {
      let a = Vu.findIndex(s => s.cancel == n);
      ~a && Vu.splice(a, 1), no -= ~a ? 1 : 0
    },
    i = {
      time: r,
      handler: t,
      cancel: n
    };
  return Vu.splice(sX(r), 0, i), no += 1, oX(), i
};
var sX = t => ~(~Vu.findIndex(e => e.time > t) || ~Vu.length);
we.cancel = t => {
  uE.delete(t), pO.delete(t), gO.delete(t), dO.delete(t), hO.delete(t)
};
we.sync = t => {
  RA = !0, we.batchedUpdates(t), RA = !1
};
we.throttle = t => {
  let e;

  function r() {
    try {
      t(...e)
    } finally {
      e = null
    }
  }

  function n(...i) {
    e = i, we.onStart(r)
  }
  return n.handler = t, n.cancel = () => {
    uE.delete(r), e = null
  }, n
};
var mO = typeof window < "u" ? window.requestAnimationFrame : () => {};
we.use = t => mO = t;
we.now = typeof performance < "u" ? () => performance.now() : Date.now;
we.batchedUpdates = t => t();
we.catch = console.error;
we.frameLoop = "always";
we.advance = () => {
  we.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : cX()
};
var ro = -1,
  no = 0,
  RA = !1;

function dg(t, e) {
  RA ? (e.delete(t), t(0)) : (e.add(t), oX())
}

function oX() {
  ro < 0 && (ro = 0, we.frameLoop !== "demand" && mO(lX))
}

function i7e() {
  ro = -1
}

function lX() {
  ~ro && (mO(lX), we.batchedUpdates(cX))
}

function cX() {
  let t = ro;
  ro = we.now();
  let e = sX(ro);
  if (e && (uX(Vu.splice(0, e), r => r.handler()), no -= e), !no) {
    i7e();
    return
  }
  uE.flush(), dO.flush(t ? Math.min(64, ro - t) : 16.667), pO.flush(), hO.flush(), gO.flush()
}

function hg() {
  let t = new Set,
    e = t;
  return {
    add(r) {
      no += e == t && !t.has(r) ? 1 : 0, t.add(r)
    },
    delete(r) {
      return no -= e == t && t.has(r) ? 1 : 0, t.delete(r)
    },
    flush(r) {
      e.size && (t = new Set, no -= e.size, uX(e, n => n(r) && t.add(n)), no += t.size, e = t)
    }
  }
}

function uX(t, e) {
  t.forEach(r => {
    try {
      e(r)
    } catch (n) {
      we.catch(n)
    }
  })
}
var a7e = Object.defineProperty,
  s7e = (t, e) => {
    for (var r in e) a7e(t, r, {
      get: e[r],
      enumerable: !0
    })
  },
  Pi = {};
s7e(Pi, {
  assign: () => l7e,
  colors: () => vo,
  createStringInterpolator: () => yO,
  skipAnimation: () => dX,
  to: () => fX,
  willAdvance: () => xO
});

function AA() {}
var o7e = (t, e, r) => Object.defineProperty(t, e, {
    value: r,
    writable: !0,
    configurable: !0
  }),
  ne = {
    arr: Array.isArray,
    obj: t => !!t && t.constructor.name === "Object",
    fun: t => typeof t == "function",
    str: t => typeof t == "string",
    num: t => typeof t == "number",
    und: t => t === void 0
  };

function Ba(t, e) {
  if (ne.arr(t)) {
    if (!ne.arr(e) || t.length !== e.length) return !1;
    for (let r = 0; r < t.length; r++)
      if (t[r] !== e[r]) return !1;
    return !0
  }
  return t === e
}
var Ne = (t, e) => t.forEach(e);

function ya(t, e, r) {
  if (ne.arr(t)) {
    for (let n = 0; n < t.length; n++) e.call(r, t[n], `${n}`);
    return
  }
  for (let n in t) t.hasOwnProperty(n) && e.call(r, t[n], n)
}
var En = t => ne.und(t) ? [] : ne.arr(t) ? t : [t];

function t0(t, e) {
  if (t.size) {
    let r = Array.from(t);
    t.clear(), Ne(r, e)
  }
}
var Rh = (t, ...e) => t0(t, r => r(...e)),
  vO = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  yO, fX, vo = null,
  dX = !1,
  xO = AA,
  l7e = t => {
    t.to && (fX = t.to), t.now && (we.now = t.now), t.colors !== void 0 && (vo = t.colors), t.skipAnimation != null && (dX = t.skipAnimation), t.createStringInterpolator && (yO = t.createStringInterpolator), t.requestAnimationFrame && we.use(t.requestAnimationFrame), t.batchedUpdates && (we.batchedUpdates = t.batchedUpdates), t.willAdvance && (xO = t.willAdvance), t.frameLoop && (we.frameLoop = t.frameLoop)
  },
  r0 = new Set,
  Kn = [],
  zT = [],
  T1 = 0,
  fE = {
    get idle() {
      return !r0.size && !Kn.length
    },
    start(t) {
      T1 > t.priority ? (r0.add(t), we.onStart(c7e)) : (hX(t), we(IA))
    },
    advance: IA,
    sort(t) {
      if (T1) we.onFrame(() => fE.sort(t));
      else {
        let e = Kn.indexOf(t);
        ~e && (Kn.splice(e, 1), pX(t))
      }
    },
    clear() {
      Kn = [], r0.clear()
    }
  };

function c7e() {
  r0.forEach(hX), r0.clear(), we(IA)
}

function hX(t) {
  Kn.includes(t) || pX(t)
}

function pX(t) {
  Kn.splice(u7e(Kn, e => e.priority > t.priority), 0, t)
}

function IA(t) {
  let e = zT;
  for (let r = 0; r < Kn.length; r++) {
    let n = Kn[r];
    T1 = n.priority, n.idle || (xO(n), n.advance(t), n.idle || e.push(n))
  }
  return T1 = 0, zT = Kn, zT.length = 0, Kn = e, Kn.length > 0
}

function u7e(t, e) {
  let r = t.findIndex(e);
  return r < 0 ? t.length : r
}
var f7e = (t, e, r) => Math.min(Math.max(r, t), e),
  d7e = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  },
  Ii = "[-+]?\\d*\\.?\\d+",
  w1 = Ii + "%";

function dE(...t) {
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)"
}
var h7e = new RegExp("rgb" + dE(Ii, Ii, Ii)),
  p7e = new RegExp("rgba" + dE(Ii, Ii, Ii, Ii)),
  g7e = new RegExp("hsl" + dE(Ii, w1, w1)),
  m7e = new RegExp("hsla" + dE(Ii, w1, w1, Ii)),
  v7e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  y7e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  x7e = /^#([0-9a-fA-F]{6})$/,
  b7e = /^#([0-9a-fA-F]{8})$/;

function E7e(t) {
  let e;
  return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = x7e.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : vo && vo[t] !== void 0 ? vo[t] : (e = h7e.exec(t)) ? (Gc(e[1]) << 24 | Gc(e[2]) << 16 | Gc(e[3]) << 8 | 255) >>> 0 : (e = p7e.exec(t)) ? (Gc(e[1]) << 24 | Gc(e[2]) << 16 | Gc(e[3]) << 8 | Y6(e[4])) >>> 0 : (e = v7e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = b7e.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = y7e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = g7e.exec(t)) ? (W6(K6(e[1]), jm(e[2]), jm(e[3])) | 255) >>> 0 : (e = m7e.exec(t)) ? (W6(K6(e[1]), jm(e[2]), jm(e[3])) | Y6(e[4])) >>> 0 : null
}

function GT(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t
}

function W6(t, e, r) {
  let n = r < .5 ? r * (1 + e) : r + e - r * e,
    i = 2 * r - n,
    a = GT(i, n, t + 1 / 3),
    s = GT(i, n, t),
    o = GT(i, n, t - 1 / 3);
  return Math.round(a * 255) << 24 | Math.round(s * 255) << 16 | Math.round(o * 255) << 8
}

function Gc(t) {
  let e = parseInt(t, 10);
  return e < 0 ? 0 : e > 255 ? 255 : e
}

function K6(t) {
  return (parseFloat(t) % 360 + 360) % 360 / 360
}

function Y6(t) {
  let e = parseFloat(t);
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}

function jm(t) {
  let e = parseFloat(t);
  return e < 0 ? 0 : e > 100 ? 1 : e / 100
}

function q6(t) {
  let e = E7e(t);
  if (e === null) return t;
  e = e || 0;
  let r = (e & 4278190080) >>> 24,
    n = (e & 16711680) >>> 16,
    i = (e & 65280) >>> 8,
    a = (e & 255) / 255;
  return `rgba(${r}, ${n}, ${i}, ${a})`
}
var G0 = (t, e, r) => {
  if (ne.fun(t)) return t;
  if (ne.arr(t)) return G0({
    range: t,
    output: e,
    extrapolate: r
  });
  if (ne.str(t.output[0])) return yO(t);
  let n = t,
    i = n.output,
    a = n.range || [0, 1],
    s = n.extrapolateLeft || n.extrapolate || "extend",
    o = n.extrapolateRight || n.extrapolate || "extend",
    c = n.easing || (l => l);
  return l => {
    let u = _7e(l, a);
    return S7e(l, a[u], a[u + 1], i[u], i[u + 1], c, s, o, n.map)
  }
};

function S7e(t, e, r, n, i, a, s, o, c) {
  let l = c ? c(t) : t;
  if (l < e) {
    if (s === "identity") return l;
    s === "clamp" && (l = e)
  }
  if (l > r) {
    if (o === "identity") return l;
    o === "clamp" && (l = r)
  }
  return n === i ? n : e === r ? t <= e ? n : i : (e === -1 / 0 ? l = -l : r === 1 / 0 ? l = l - e : l = (l - e) / (r - e), l = a(l), n === -1 / 0 ? l = -l : i === 1 / 0 ? l = l + n : l = l * (i - n) + n, l)
}

function _7e(t, e) {
  for (var r = 1; r < e.length - 1 && !(e[r] >= t); ++r);
  return r - 1
}
var T7e = (t, e = "end") => r => {
    r = e === "end" ? Math.min(r, .999) : Math.max(r, .001);
    let n = r * t,
      i = e === "end" ? Math.floor(n) : Math.ceil(n);
    return f7e(0, 1, i / t)
  },
  R1 = 1.70158,
  Hm = R1 * 1.525,
  X6 = R1 + 1,
  Q6 = 2 * Math.PI / 3,
  Z6 = 2 * Math.PI / 4.5,
  zm = t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
  $A = {
    linear: t => t,
    easeInQuad: t => t * t,
    easeOutQuad: t => 1 - (1 - t) * (1 - t),
    easeInOutQuad: t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
    easeInCubic: t => t * t * t,
    easeOutCubic: t => 1 - Math.pow(1 - t, 3),
    easeInOutCubic: t => t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
    easeInQuart: t => t * t * t * t,
    easeOutQuart: t => 1 - Math.pow(1 - t, 4),
    easeInOutQuart: t => t < .5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
    easeInQuint: t => t * t * t * t * t,
    easeOutQuint: t => 1 - Math.pow(1 - t, 5),
    easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
    easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
    easeOutSine: t => Math.sin(t * Math.PI / 2),
    easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
    easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
    easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
    easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
    easeInCirc: t => 1 - Math.sqrt(1 - Math.pow(t, 2)),
    easeOutCirc: t => Math.sqrt(1 - Math.pow(t - 1, 2)),
    easeInOutCirc: t => t < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
    easeInBack: t => X6 * t * t * t - R1 * t * t,
    easeOutBack: t => 1 + X6 * Math.pow(t - 1, 3) + R1 * Math.pow(t - 1, 2),
    easeInOutBack: t => t < .5 ? Math.pow(2 * t, 2) * ((Hm + 1) * 2 * t - Hm) / 2 : (Math.pow(2 * t - 2, 2) * ((Hm + 1) * (t * 2 - 2) + Hm) + 2) / 2,
    easeInElastic: t => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * Q6),
    easeOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - .75) * Q6) + 1,
    easeInOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Z6)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Z6) / 2 + 1,
    easeInBounce: t => 1 - zm(1 - t),
    easeOutBounce: zm,
    easeInOutBounce: t => t < .5 ? (1 - zm(1 - 2 * t)) / 2 : (1 + zm(2 * t - 1)) / 2,
    steps: T7e
  },
  Ef = Symbol.for("FluidValue.get"),
  Jl = Symbol.for("FluidValue.observers"),
  zn = t => !!(t && t[Ef]),
  Kr = t => t && t[Ef] ? t[Ef]() : t,
  J6 = t => t[Jl] || null;

function w7e(t, e) {
  t.eventObserved ? t.eventObserved(e) : t(e)
}

function V0(t, e) {
  let r = t[Jl];
  r && r.forEach(n => {
    w7e(n, e)
  })
}
var O0t, L0t, B9, gX = (B9 = class {
    constructor(t) {
      le(this, O0t);
      le(this, L0t);
      if (!t && !(t = this.get)) throw Error("Unknown getter");
      R7e(this, t)
    }
  }, O0t = Ef, L0t = Jl, B9),
  R7e = (t, e) => mX(t, Ef, e);

function od(t, e) {
  if (t[Ef]) {
    let r = t[Jl];
    r || mX(t, Jl, r = new Set), r.has(e) || (r.add(e), t.observerAdded && t.observerAdded(r.size, e))
  }
  return e
}

function W0(t, e) {
  let r = t[Jl];
  if (r && r.has(e)) {
    let n = r.size - 1;
    n ? r.delete(e) : t[Jl] = null, t.observerRemoved && t.observerRemoved(n, e)
  }
}
var mX = (t, e, r) => Object.defineProperty(t, e, {
    value: r,
    writable: !0,
    configurable: !0
  }),
  Jv = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
  A7e = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
  e5 = new RegExp(`(${Jv.source})(%|[a-z]+)`, "i"),
  I7e = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
  hE = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
  vX = t => {
    let [e, r] = $7e(t);
    if (!e || vO()) return t;
    let n = window.getComputedStyle(document.documentElement).getPropertyValue(e);
    return n ? n.trim() : r && r.startsWith("--") ? window.getComputedStyle(document.documentElement).getPropertyValue(r) || t : r && hE.test(r) ? vX(r) : r || t
  },
  $7e = t => {
    let e = hE.exec(t);
    if (!e) return [, ];
    let [, r, n] = e;
    return [r, n]
  },
  VT, C7e = (t, e, r, n, i) => `rgba(${Math.round(e)}, ${Math.round(r)}, ${Math.round(n)}, ${i})`,
  yX = t => {
    VT || (VT = vo ? new RegExp(`(${Object.keys(vo).join("|")})(?!\\w)`, "g") : /^\b$/);
    let e = t.output.map(i => Kr(i).replace(hE, vX).replace(A7e, q6).replace(VT, q6)),
      r = e.map(i => i.match(Jv).map(Number)),
      n = r[0].map((i, a) => r.map(s => {
        if (!(a in s)) throw Error('The arity of each "output" value must be equal');
        return s[a]
      })).map(i => G0({
        ...t,
        output: i
      }));
    return i => {
      var o;
      let a = !e5.test(e[0]) && ((o = e.find(c => e5.test(c))) == null ? void 0 : o.replace(Jv, "")),
        s = 0;
      return e[0].replace(Jv, () => `${n[s++](i)}${a||""}`).replace(I7e, C7e)
    }
  },
  bO = "react-spring: ",
  xX = t => {
    let e = t,
      r = !1;
    if (typeof e != "function") throw new TypeError(`${bO}once requires a function parameter`);
    return (...n) => {
      r || (e(...n), r = !0)
    }
  },
  k7e = xX(console.warn);

function O7e() {
  k7e(`${bO}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
var L7e = xX(console.warn);

function P7e() {
  L7e(`${bO}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}

function pE(t) {
  return ne.str(t) && (t[0] == "#" || /\d/.test(t) || !vO() && hE.test(t) || t in (vo || {}))
}

function N7e(t) {
  let e = A.useRef(null);
  return e.current === null && (e.current = t()), e.current
}
var EO = vO() ? A.useEffect : A.useLayoutEffect,
  D7e = () => {
    let t = A.useRef(!1);
    return EO(() => (t.current = !0, () => {
      t.current = !1
    }), []), t
  };

function bX() {
  let t = A.useState()[1],
    e = D7e();
  return () => {
    e.current && t(Math.random())
  }
}

function M7e(t, e) {
  let [r] = A.useState(() => ({
    inputs: e,
    result: t()
  })), n = A.useRef(), i = n.current, a = i;
  return a ? e && a.inputs && F7e(e, a.inputs) || (a = {
    inputs: e,
    result: t()
  }) : a = r, A.useEffect(() => {
    n.current = a, i == r && (r.inputs = r.result = void 0)
  }, [a]), a.result
}

function F7e(t, e) {
  if (t.length !== e.length) return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r]) return !1;
  return !0
}
var SO = t => A.useEffect(t, B7e),
  B7e = [];

function t5(t) {
  let e = A.useRef();
  return A.useEffect(() => {
    e.current = t
  }), e.current
}
var K0 = Symbol.for("Animated:node"),
  U7e = t => !!t && t[K0] === t,
  Zi = t => t && t[K0],
  _O = (t, e) => o7e(t, K0, e),
  gE = t => t && t[K0] && t[K0].getPayload(),
  EX = class {
    constructor() {
      le(this, "payload");
      _O(this, this)
    }
    getPayload() {
      return this.payload || []
    }
  },
  pg = class extends EX {
    constructor(e) {
      super();
      le(this, "done", !0);
      le(this, "elapsedTime");
      le(this, "lastPosition");
      le(this, "lastVelocity");
      le(this, "v0");
      le(this, "durationProgress", 0);
      this._value = e, ne.num(this._value) && (this.lastPosition = this._value)
    }
    static create(e) {
      return new pg(e)
    }
    getPayload() {
      return [this]
    }
    getValue() {
      return this._value
    }
    setValue(e, r) {
      return ne.num(e) && (this.lastPosition = e, r && (e = Math.round(e / r) * r, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0)
    }
    reset() {
      let {
        done: e
      } = this;
      this.done = !1, ne.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null)
    }
  },
  Y0 = class extends pg {
    constructor(e) {
      super(0);
      le(this, "_string", null);
      le(this, "_toString");
      this._toString = G0({
        output: [e, e]
      })
    }
    static create(e) {
      return new Y0(e)
    }
    getValue() {
      return this._string ? ? (this._string = this._toString(this._value))
    }
    setValue(e) {
      if (ne.str(e)) {
        if (e == this._string) return !1;
        this._string = e, this._value = 1
      } else if (super.setValue(e)) this._string = null;
      else return !1;
      return !0
    }
    reset(e) {
      e && (this._toString = G0({
        output: [this.getValue(), e]
      })), this._value = 0, super.reset()
    }
  },
  A1 = {
    dependencies: null
  },
  mE = class extends EX {
    constructor(t) {
      super(), this.source = t, this.setValue(t)
    }
    getValue(t) {
      let e = {};
      return ya(this.source, (r, n) => {
        U7e(r) ? e[n] = r.getValue(t) : zn(r) ? e[n] = Kr(r) : t || (e[n] = r)
      }), e
    }
    setValue(t) {
      this.source = t, this.payload = this._makePayload(t)
    }
    reset() {
      this.payload && Ne(this.payload, t => t.reset())
    }
    _makePayload(t) {
      if (t) {
        let e = new Set;
        return ya(t, this._addToPayload, e), Array.from(e)
      }
    }
    _addToPayload(t) {
      A1.dependencies && zn(t) && A1.dependencies.add(t);
      let e = gE(t);
      e && Ne(e, r => this.add(r))
    }
  },
  SX = class extends mE {
    constructor(e) {
      super(e)
    }
    static create(e) {
      return new SX(e)
    }
    getValue() {
      return this.source.map(e => e.getValue())
    }
    setValue(e) {
      let r = this.getPayload();
      return e.length == r.length ? r.map((n, i) => n.setValue(e[i])).some(Boolean) : (super.setValue(e.map(j7e)), !0)
    }
  };

function j7e(t) {
  return (pE(t) ? Y0 : pg).create(t)
}

function CA(t) {
  let e = Zi(t);
  return e ? e.constructor : ne.arr(t) ? SX : pE(t) ? Y0 : pg
}
var r5 = (t, e) => {
    let r = !ne.fun(t) || t.prototype && t.prototype.isReactComponent;
    return A.forwardRef((n, i) => {
      let a = A.useRef(null),
        s = r && A.useCallback(p => {
          a.current = G7e(i, p)
        }, [i]),
        [o, c] = z7e(n, e),
        l = bX(),
        u = () => {
          let p = a.current;
          r && !p || (p ? e.applyAnimatedValues(p, o.getValue(!0)) : !1) === !1 && l()
        },
        f = new H7e(u, c),
        d = A.useRef();
      EO(() => (d.current = f, Ne(c, p => od(p, f)), () => {
        d.current && (Ne(d.current.deps, p => W0(p, d.current)), we.cancel(d.current.update))
      })), A.useEffect(u, []), SO(() => () => {
        let p = d.current;
        Ne(p.deps, v => W0(v, p))
      });
      let h = e.getComponentProps(o.getValue());
      return A.createElement(t, {
        ...h,
        ref: s
      })
    })
  },
  H7e = class {
    constructor(t, e) {
      this.update = t, this.deps = e
    }
    eventObserved(t) {
      t.type == "change" && we.write(this.update)
    }
  };

function z7e(t, e) {
  let r = new Set;
  return A1.dependencies = r, t.style && (t = {
    ...t,
    style: e.createAnimatedStyle(t.style)
  }), t = new mE(t), A1.dependencies = null, [t, r]
}

function G7e(t, e) {
  return t && (ne.fun(t) ? t(e) : t.current = e), e
}
var n5 = Symbol.for("AnimatedComponent"),
  V7e = (t, {
    applyAnimatedValues: e = () => !1,
    createAnimatedStyle: r = i => new mE(i),
    getComponentProps: n = i => i
  } = {}) => {
    let i = {
        applyAnimatedValues: e,
        createAnimatedStyle: r,
        getComponentProps: n
      },
      a = s => {
        let o = i5(s) || "Anonymous";
        return ne.str(s) ? s = a[s] || (a[s] = r5(s, i)) : s = s[n5] || (s[n5] = r5(s, i)), s.displayName = `Animated(${o})`, s
      };
    return ya(t, (s, o) => {
      ne.arr(t) && (o = i5(s)), a[o] = a(s)
    }), {
      animated: a
    }
  },
  i5 = t => ne.str(t) ? t : t && ne.str(t.displayName) ? t.displayName : ne.fun(t) && t.name || null;

function Tl(t, ...e) {
  return ne.fun(t) ? t(...e) : t
}
var n0 = (t, e) => t === !0 || !!(e && t && (ne.fun(t) ? t(e) : En(t).includes(e))),
  _X = (t, e) => ne.obj(t) ? e && t[e] : t,
  TX = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0,
  W7e = t => t,
  TO = (t, e = W7e) => {
    let r = K7e;
    t.default && t.default !== !0 && (t = t.default, r = Object.keys(t));
    let n = {};
    for (let i of r) {
      let a = e(t[i], i);
      ne.und(a) || (n[i] = a)
    }
    return n
  },
  K7e = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"],
  Y7e = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };

function q7e(t) {
  let e = {},
    r = 0;
  if (ya(t, (n, i) => {
      Y7e[i] || (e[i] = n, r++)
    }), r) return e
}

function wX(t) {
  let e = q7e(t);
  if (e) {
    let r = {
      to: e
    };
    return ya(t, (n, i) => i in e || (r[i] = n)), r
  }
  return {
    ...t
  }
}

function q0(t) {
  return t = Kr(t), ne.arr(t) ? t.map(q0) : pE(t) ? Pi.createStringInterpolator({
    range: [0, 1],
    output: [t, t]
  })(1) : t
}

function X7e(t) {
  for (let e in t) return !0;
  return !1
}

function kA(t) {
  return ne.fun(t) || ne.arr(t) && ne.obj(t[0])
}

function Q7e(t, e) {
  var r;
  (r = t.ref) == null || r.delete(t), e == null || e.delete(t)
}

function Z7e(t, e) {
  var r;
  e && t.ref !== e && ((r = t.ref) == null || r.delete(t), e.add(t), t.ref = e)
}
var OA = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  },
  LA = {
    ...OA.default,
    mass: 1,
    damping: 1,
    easing: $A.linear,
    clamp: !1
  },
  J7e = class {
    constructor() {
      le(this, "tension");
      le(this, "friction");
      le(this, "frequency");
      le(this, "damping");
      le(this, "mass");
      le(this, "velocity", 0);
      le(this, "restVelocity");
      le(this, "precision");
      le(this, "progress");
      le(this, "duration");
      le(this, "easing");
      le(this, "clamp");
      le(this, "bounce");
      le(this, "decay");
      le(this, "round");
      Object.assign(this, LA)
    }
  };

function e9e(t, e, r) {
  r && (r = {
    ...r
  }, a5(r, e), e = {
    ...r,
    ...e
  }), a5(t, e), Object.assign(t, e);
  for (let s in LA) t[s] == null && (t[s] = LA[s]);
  let {
    frequency: n,
    damping: i
  } = t, {
    mass: a
  } = t;
  return ne.und(n) || (n < .01 && (n = .01), i < 0 && (i = 0), t.tension = Math.pow(2 * Math.PI / n, 2) * a, t.friction = 4 * Math.PI * i * a / n), t
}

function a5(t, e) {
  if (!ne.und(e.decay)) t.duration = void 0;
  else {
    let r = !ne.und(e.tension) || !ne.und(e.friction);
    (r || !ne.und(e.frequency) || !ne.und(e.damping) || !ne.und(e.mass)) && (t.duration = void 0, t.decay = void 0), r && (t.frequency = void 0)
  }
}
var s5 = [],
  t9e = class {
    constructor() {
      le(this, "changed", !1);
      le(this, "values", s5);
      le(this, "toValues", null);
      le(this, "fromValues", s5);
      le(this, "to");
      le(this, "from");
      le(this, "config", new J7e);
      le(this, "immediate", !1)
    }
  };

function RX(t, {
  key: e,
  props: r,
  defaultProps: n,
  state: i,
  actions: a
}) {
  return new Promise((s, o) => {
    let c, l, u = n0(r.cancel ? ? (n == null ? void 0 : n.cancel), e);
    if (u) h();
    else {
      ne.und(r.pause) || (i.paused = n0(r.pause, e));
      let p = n == null ? void 0 : n.pause;
      p !== !0 && (p = i.paused || n0(p, e)), c = Tl(r.delay || 0, e), p ? (i.resumeQueue.add(d), a.pause()) : (a.resume(), d())
    }

    function f() {
      i.resumeQueue.add(d), i.timeouts.delete(l), l.cancel(), c = l.time - we.now()
    }

    function d() {
      c > 0 && !Pi.skipAnimation ? (i.delayed = !0, l = we.setTimeout(h, c), i.pauseQueue.add(f), i.timeouts.add(l)) : h()
    }

    function h() {
      i.delayed && (i.delayed = !1), i.pauseQueue.delete(f), i.timeouts.delete(l), t <= (i.cancelId || 0) && (u = !0);
      try {
        a.start({
          ...r,
          callId: t,
          cancel: u
        }, s)
      } catch (p) {
        o(p)
      }
    }
  })
}
var wO = (t, e) => e.length == 1 ? e[0] : e.some(r => r.cancelled) ? Wu(t.get()) : e.every(r => r.noop) ? AX(t.get()) : Ei(t.get(), e.every(r => r.finished)),
  AX = t => ({
    value: t,
    noop: !0,
    finished: !0,
    cancelled: !1
  }),
  Ei = (t, e, r = !1) => ({
    value: t,
    finished: e,
    cancelled: r
  }),
  Wu = t => ({
    value: t,
    cancelled: !0,
    finished: !1
  });

function IX(t, e, r, n) {
  let {
    callId: i,
    parentId: a,
    onRest: s
  } = e, {
    asyncTo: o,
    promise: c
  } = r;
  return !a && t === o && !e.reset ? c : r.promise = (async () => {
    r.asyncId = i, r.asyncTo = t;
    let l = TO(e, (g, m) => m === "onRest" ? void 0 : g),
      u, f, d = new Promise((g, m) => (u = g, f = m)),
      h = g => {
        let m = i <= (r.cancelId || 0) && Wu(n) || i !== r.asyncId && Ei(n, !1);
        if (m) throw g.result = m, f(g), g
      },
      p = (g, m) => {
        let y = new o5,
          x = new l5;
        return (async () => {
          if (Pi.skipAnimation) throw X0(r), x.result = Ei(n, !1), f(x), x;
          h(y);
          let b = ne.obj(g) ? {
            ...g
          } : {
            ...m,
            to: g
          };
          b.parentId = i, ya(l, (S, T) => {
            ne.und(b[T]) && (b[T] = S)
          });
          let _ = await n.start(b);
          return h(y), r.paused && await new Promise(S => {
            r.resumeQueue.add(S)
          }), _
        })()
      },
      v;
    if (Pi.skipAnimation) return X0(r), Ei(n, !1);
    try {
      let g;
      ne.arr(t) ? g = (async m => {
        for (let y of m) await p(y)
      })(t) : g = Promise.resolve(t(p, n.stop.bind(n))), await Promise.all([g.then(u), d]), v = Ei(n.get(), !0, !1)
    } catch (g) {
      if (g instanceof o5) v = g.result;
      else if (g instanceof l5) v = g.result;
      else throw g
    } finally {
      i == r.asyncId && (r.asyncId = a, r.asyncTo = a ? o : void 0, r.promise = a ? c : void 0)
    }
    return ne.fun(s) && we.batchedUpdates(() => {
      s(v, n, n.item)
    }), v
  })()
}

function X0(t, e) {
  t0(t.timeouts, r => r.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e)
}
var o5 = class extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      le(this, "result")
    }
  },
  l5 = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
      le(this, "result")
    }
  },
  PA = t => t instanceof RO,
  r9e = 1,
  RO = class extends gX {
    constructor() {
      super(...arguments);
      le(this, "id", r9e++);
      le(this, "_priority", 0)
    }
    get priority() {
      return this._priority
    }
    set priority(e) {
      this._priority != e && (this._priority = e, this._onPriorityChange(e))
    }
    get() {
      let e = Zi(this);
      return e && e.getValue()
    }
    to(...e) {
      return Pi.to(this, e)
    }
    interpolate(...e) {
      return O7e(), Pi.to(this, e)
    }
    toJSON() {
      return this.get()
    }
    observerAdded(e) {
      e == 1 && this._attach()
    }
    observerRemoved(e) {
      e == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange(e, r = !1) {
      V0(this, {
        type: "change",
        parent: this,
        value: e,
        idle: r
      })
    }
    _onPriorityChange(e) {
      this.idle || fE.sort(this), V0(this, {
        type: "priority",
        parent: this,
        priority: e
      })
    }
  },
  ec = Symbol.for("SpringPhase"),
  $X = 1,
  NA = 2,
  DA = 4,
  WT = t => (t[ec] & $X) > 0,
  Ms = t => (t[ec] & NA) > 0,
  nh = t => (t[ec] & DA) > 0,
  c5 = (t, e) => e ? t[ec] |= NA | $X : t[ec] &= ~NA,
  u5 = (t, e) => e ? t[ec] |= DA : t[ec] &= ~DA,
  CX = class extends RO {
    constructor(e, r) {
      super();
      le(this, "key");
      le(this, "animation", new t9e);
      le(this, "queue");
      le(this, "defaultProps", {});
      le(this, "_state", {
        paused: !1,
        delayed: !1,
        pauseQueue: new Set,
        resumeQueue: new Set,
        timeouts: new Set
      });
      le(this, "_pendingCalls", new Set);
      le(this, "_lastCallId", 0);
      le(this, "_lastToId", 0);
      le(this, "_memoizedDuration", 0);
      if (!ne.und(e) || !ne.und(r)) {
        let n = ne.obj(e) ? {
          ...e
        } : {
          ...r,
          from: e
        };
        ne.und(n.default) && (n.default = !0), this.start(n)
      }
    }
    get idle() {
      return !(Ms(this) || this._state.asyncTo) || nh(this)
    }
    get goal() {
      return Kr(this.animation.to)
    }
    get velocity() {
      let e = Zi(this);
      return e instanceof pg ? e.lastVelocity || 0 : e.getPayload().map(r => r.lastVelocity || 0)
    }
    get hasAnimated() {
      return WT(this)
    }
    get isAnimating() {
      return Ms(this)
    }
    get isPaused() {
      return nh(this)
    }
    get isDelayed() {
      return this._state.delayed
    }
    advance(e) {
      let r = !0,
        n = !1,
        i = this.animation,
        {
          toValues: a
        } = i,
        {
          config: s
        } = i,
        o = gE(i.to);
      !o && zn(i.to) && (a = En(Kr(i.to))), i.values.forEach((u, f) => {
        if (u.done) return;
        let d = u.constructor == Y0 ? 1 : o ? o[f].lastPosition : a[f],
          h = i.immediate,
          p = d;
        if (!h) {
          if (p = u.lastPosition, s.tension <= 0) {
            u.done = !0;
            return
          }
          let v = u.elapsedTime += e,
            g = i.fromValues[f],
            m = u.v0 != null ? u.v0 : u.v0 = ne.arr(s.velocity) ? s.velocity[f] : s.velocity,
            y, x = s.precision || (g == d ? .005 : Math.min(1, Math.abs(d - g) * .001));
          if (ne.und(s.duration))
            if (s.decay) {
              let b = s.decay === !0 ? .998 : s.decay,
                _ = Math.exp(-(1 - b) * v);
              p = g + m / (1 - b) * (1 - _), h = Math.abs(u.lastPosition - p) <= x, y = m * _
            } else {
              y = u.lastVelocity == null ? m : u.lastVelocity;
              let b = s.restVelocity || x / 10,
                _ = s.clamp ? 0 : s.bounce,
                S = !ne.und(_),
                T = g == d ? u.v0 > 0 : g < d,
                R, I = !1,
                w = 1,
                C = Math.ceil(e / w);
              for (let L = 0; L < C && (R = Math.abs(y) > b, !(!R && (h = Math.abs(d - p) <= x, h))); ++L) {
                S && (I = p == d || p > d == T, I && (y = -y * _, p = d));
                let H = -s.tension * 1e-6 * (p - d),
                  N = -s.friction * .001 * y,
                  P = (H + N) / s.mass;
                y = y + P * w, p = p + y * w
              }
            }
          else {
            let b = 1;
            s.duration > 0 && (this._memoizedDuration !== s.duration && (this._memoizedDuration = s.duration, u.durationProgress > 0 && (u.elapsedTime = s.duration * u.durationProgress, v = u.elapsedTime += e)), b = (s.progress || 0) + v / this._memoizedDuration, b = b > 1 ? 1 : b < 0 ? 0 : b, u.durationProgress = b), p = g + s.easing(b) * (d - g), y = (p - u.lastPosition) / e, h = b == 1
          }
          u.lastVelocity = y, Number.isNaN(p) && (console.warn("Got NaN while animating:", this), h = !0)
        }
        o && !o[f].done && (h = !1), h ? u.done = !0 : r = !1, u.setValue(p, s.round) && (n = !0)
      });
      let c = Zi(this),
        l = c.getValue();
      if (r) {
        let u = Kr(i.to);
        (l !== u || n) && !s.decay ? (c.setValue(u), this._onChange(u)) : n && s.decay && this._onChange(l), this._stop()
      } else n && this._onChange(l)
    }
    set(e) {
      return we.batchedUpdates(() => {
        this._stop(), this._focus(e), this._set(e)
      }), this
    }
    pause() {
      this._update({
        pause: !0
      })
    }
    resume() {
      this._update({
        pause: !1
      })
    }
    finish() {
      if (Ms(this)) {
        let {
          to: e,
          config: r
        } = this.animation;
        we.batchedUpdates(() => {
          this._onStart(), r.decay || this._set(e, !1), this._stop()
        })
      }
      return this
    }
    update(e) {
      return (this.queue || (this.queue = [])).push(e), this
    }
    start(e, r) {
      let n;
      return ne.und(e) ? (n = this.queue || [], this.queue = []) : n = [ne.obj(e) ? e : {
        ...r,
        to: e
      }], Promise.all(n.map(i => this._update(i))).then(i => wO(this, i))
    }
    stop(e) {
      let {
        to: r
      } = this.animation;
      return this._focus(this.get()), X0(this._state, e && this._lastCallId), we.batchedUpdates(() => this._stop(r, e)), this
    }
    reset() {
      this._update({
        reset: !0
      })
    }
    eventObserved(e) {
      e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1)
    }
    _prepareNode(e) {
      let r = this.key || "",
        {
          to: n,
          from: i
        } = e;
      n = ne.obj(n) ? n[r] : n, (n == null || kA(n)) && (n = void 0), i = ne.obj(i) ? i[r] : i, i == null && (i = void 0);
      let a = {
        to: n,
        from: i
      };
      return WT(this) || (e.reverse && ([n, i] = [i, n]), i = Kr(i), ne.und(i) ? Zi(this) || this._set(n) : this._set(i)), a
    }
    _update({
      ...e
    }, r) {
      let {
        key: n,
        defaultProps: i
      } = this;
      e.default && Object.assign(i, TO(e, (o, c) => /^on/.test(c) ? _X(o, n) : o)), d5(this, e, "onProps"), ah(this, "onProps", e, this);
      let a = this._prepareNode(e);
      if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      let s = this._state;
      return RX(++this._lastCallId, {
        key: n,
        props: e,
        defaultProps: i,
        state: s,
        actions: {
          pause: () => {
            nh(this) || (u5(this, !0), Rh(s.pauseQueue), ah(this, "onPause", Ei(this, ih(this, this.animation.to)), this))
          },
          resume: () => {
            nh(this) && (u5(this, !1), Ms(this) && this._resume(), Rh(s.resumeQueue), ah(this, "onResume", Ei(this, ih(this, this.animation.to)), this))
          },
          start: this._merge.bind(this, a)
        }
      }).then(o => {
        if (e.loop && o.finished && !(r && o.noop)) {
          let c = kX(e);
          if (c) return this._update(c, !0)
        }
        return o
      })
    }
    _merge(e, r, n) {
      if (r.cancel) return this.stop(!0), n(Wu(this));
      let i = !ne.und(e.to),
        a = !ne.und(e.from);
      if (i || a)
        if (r.callId > this._lastToId) this._lastToId = r.callId;
        else return n(Wu(this));
      let {
        key: s,
        defaultProps: o,
        animation: c
      } = this, {
        to: l,
        from: u
      } = c, {
        to: f = l,
        from: d = u
      } = e;
      a && !i && (!r.default || ne.und(f)) && (f = d), r.reverse && ([f, d] = [d, f]);
      let h = !Ba(d, u);
      h && (c.from = d), d = Kr(d);
      let p = !Ba(f, l);
      p && this._focus(f);
      let v = kA(r.to),
        {
          config: g
        } = c,
        {
          decay: m,
          velocity: y
        } = g;
      (i || a) && (g.velocity = 0), r.config && !v && e9e(g, Tl(r.config, s), r.config !== o.config ? Tl(o.config, s) : void 0);
      let x = Zi(this);
      if (!x || ne.und(f)) return n(Ei(this, !0));
      let b = ne.und(r.reset) ? a && !r.default : !ne.und(d) && n0(r.reset, s),
        _ = b ? d : this.get(),
        S = q0(f),
        T = ne.num(S) || ne.arr(S) || pE(S),
        R = !v && (!T || n0(o.immediate || r.immediate, s));
      if (p) {
        let L = CA(f);
        if (L !== x.constructor)
          if (R) x = this._set(S);
          else throw Error(`Cannot animate between ${x.constructor.name} and ${L.name}, as the "to" prop suggests`)
      }
      let I = x.constructor,
        w = zn(f),
        C = !1;
      if (!w) {
        let L = b || !WT(this) && h;
        (p || L) && (C = Ba(q0(_), S), w = !C), (!Ba(c.immediate, R) && !R || !Ba(g.decay, m) || !Ba(g.velocity, y)) && (w = !0)
      }
      if (C && Ms(this) && (c.changed && !b ? w = !0 : w || this._stop(l)), !v && ((w || zn(l)) && (c.values = x.getPayload(), c.toValues = zn(f) ? null : I == Y0 ? [1] : En(S)), c.immediate != R && (c.immediate = R, !R && !b && this._set(l)), w)) {
        let {
          onRest: L
        } = c;
        Ne(i9e, N => d5(this, r, N));
        let H = Ei(this, ih(this, l));
        Rh(this._pendingCalls, H), this._pendingCalls.add(n), c.changed && we.batchedUpdates(() => {
          var N;
          c.changed = !b, L == null || L(H, this), b ? Tl(o.onRest, H) : (N = c.onStart) == null || N.call(c, H, this)
        })
      }
      b && this._set(_), v ? n(IX(r.to, r, this._state, this)) : w ? this._start() : Ms(this) && !p ? this._pendingCalls.add(n) : n(AX(_))
    }
    _focus(e) {
      let r = this.animation;
      e !== r.to && (J6(this) && this._detach(), r.to = e, J6(this) && this._attach())
    }
    _attach() {
      let e = 0,
        {
          to: r
        } = this.animation;
      zn(r) && (od(r, this), PA(r) && (e = r.priority + 1)), this.priority = e
    }
    _detach() {
      let {
        to: e
      } = this.animation;
      zn(e) && W0(e, this)
    }
    _set(e, r = !0) {
      let n = Kr(e);
      if (!ne.und(n)) {
        let i = Zi(this);
        if (!i || !Ba(n, i.getValue())) {
          let a = CA(n);
          !i || i.constructor != a ? _O(this, a.create(n)) : i.setValue(n), i && we.batchedUpdates(() => {
            this._onChange(n, r)
          })
        }
      }
      return Zi(this)
    }
    _onStart() {
      let e = this.animation;
      e.changed || (e.changed = !0, ah(this, "onStart", Ei(this, ih(this, e.to)), this))
    }
    _onChange(e, r) {
      r || (this._onStart(), Tl(this.animation.onChange, e, this)), Tl(this.defaultProps.onChange, e, this), super._onChange(e, r)
    }
    _start() {
      let e = this.animation;
      Zi(this).reset(Kr(e.to)), e.immediate || (e.fromValues = e.values.map(r => r.lastPosition)), Ms(this) || (c5(this, !0), nh(this) || this._resume())
    }
    _resume() {
      Pi.skipAnimation ? this.finish() : fE.start(this)
    }
    _stop(e, r) {
      if (Ms(this)) {
        c5(this, !1);
        let n = this.animation;
        Ne(n.values, a => {
          a.done = !0
        }), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), V0(this, {
          type: "idle",
          parent: this
        });
        let i = r ? Wu(this.get()) : Ei(this.get(), ih(this, e ? ? n.to));
        Rh(this._pendingCalls, i), n.changed && (n.changed = !1, ah(this, "onRest", i, this))
      }
    }
  };

function ih(t, e) {
  let r = q0(e),
    n = q0(t.get());
  return Ba(n, r)
}

function kX(t, e = t.loop, r = t.to) {
  let n = Tl(e);
  if (n) {
    let i = n !== !0 && wX(n),
      a = (i || t).reverse,
      s = !i || i.reset;
    return Q0({
      ...t,
      loop: e,
      default: !1,
      pause: void 0,
      to: !a || kA(r) ? r : void 0,
      from: s ? t.from : void 0,
      reset: s,
      ...i
    })
  }
}

function Q0(t) {
  let {
    to: e,
    from: r
  } = t = wX(t), n = new Set;
  return ne.obj(e) && f5(e, n), ne.obj(r) && f5(r, n), t.keys = n.size ? Array.from(n) : null, t
}

function n9e(t) {
  let e = Q0(t);
  return ne.und(e.default) && (e.default = TO(e)), e
}

function f5(t, e) {
  ya(t, (r, n) => r != null && e.add(n))
}
var i9e = ["onStart", "onRest", "onChange", "onPause", "onResume"];

function d5(t, e, r) {
  t.animation[r] = e[r] !== TX(e, r) ? _X(e[r], t.key) : void 0
}

function ah(t, e, ...r) {
  var n, i, a, s;
  (i = (n = t.animation)[e]) == null || i.call(n, ...r), (s = (a = t.defaultProps)[e]) == null || s.call(a, ...r)
}
var a9e = ["onStart", "onChange", "onRest"],
  s9e = 1,
  o9e = class {
    constructor(t, e) {
      le(this, "id", s9e++);
      le(this, "springs", {});
      le(this, "queue", []);
      le(this, "ref");
      le(this, "_flush");
      le(this, "_initialProps");
      le(this, "_lastAsyncId", 0);
      le(this, "_active", new Set);
      le(this, "_changed", new Set);
      le(this, "_started", !1);
      le(this, "_item");
      le(this, "_state", {
        paused: !1,
        pauseQueue: new Set,
        resumeQueue: new Set,
        timeouts: new Set
      });
      le(this, "_events", {
        onStart: new Map,
        onChange: new Map,
        onRest: new Map
      });
      this._onFrame = this._onFrame.bind(this), e && (this._flush = e), t && this.start({
        default: !0,
        ...t
      })
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every(t => t.idle && !t.isDelayed && !t.isPaused)
    }
    get item() {
      return this._item
    }
    set item(t) {
      this._item = t
    }
    get() {
      let t = {};
      return this.each((e, r) => t[r] = e.get()), t
    }
    set(t) {
      for (let e in t) {
        let r = t[e];
        ne.und(r) || this.springs[e].set(r)
      }
    }
    update(t) {
      return t && this.queue.push(Q0(t)), this
    }
    start(t) {
      let {
        queue: e
      } = this;
      return t ? e = En(t).map(Q0) : this.queue = [], this._flush ? this._flush(this, e) : (DX(this, e), MA(this, e))
    }
    stop(t, e) {
      if (t !== !!t && (e = t), e) {
        let r = this.springs;
        Ne(En(e), n => r[n].stop(!!t))
      } else X0(this._state, this._lastAsyncId), this.each(r => r.stop(!!t));
      return this
    }
    pause(t) {
      if (ne.und(t)) this.start({
        pause: !0
      });
      else {
        let e = this.springs;
        Ne(En(t), r => e[r].pause())
      }
      return this
    }
    resume(t) {
      if (ne.und(t)) this.start({
        pause: !1
      });
      else {
        let e = this.springs;
        Ne(En(t), r => e[r].resume())
      }
      return this
    }
    each(t) {
      ya(this.springs, t)
    }
    _onFrame() {
      let {
        onStart: t,
        onChange: e,
        onRest: r
      } = this._events, n = this._active.size > 0, i = this._changed.size > 0;
      (n && !this._started || i && !this._started) && (this._started = !0, t0(t, ([o, c]) => {
        c.value = this.get(), o(c, this, this._item)
      }));
      let a = !n && this._started,
        s = i || a && r.size ? this.get() : null;
      i && e.size && t0(e, ([o, c]) => {
        c.value = s, o(c, this, this._item)
      }), a && (this._started = !1, t0(r, ([o, c]) => {
        c.value = s, o(c, this, this._item)
      }))
    }
    eventObserved(t) {
      if (t.type == "change") this._changed.add(t.parent), t.idle || this._active.add(t.parent);
      else if (t.type == "idle") this._active.delete(t.parent);
      else return;
      we.onFrame(this._onFrame)
    }
  };

function MA(t, e) {
  return Promise.all(e.map(r => OX(t, r))).then(r => wO(t, r))
}
async function OX(t, e, r) {
  let {
    keys: n,
    to: i,
    from: a,
    loop: s,
    onRest: o,
    onResolve: c
  } = e, l = ne.obj(e.default) && e.default;
  s && (e.loop = !1), i === !1 && (e.to = null), a === !1 && (e.from = null);
  let u = ne.arr(i) || ne.fun(i) ? i : void 0;
  u ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : Ne(a9e, v => {
    let g = e[v];
    if (ne.fun(g)) {
      let m = t._events[v];
      e[v] = ({
        finished: y,
        cancelled: x
      }) => {
        let b = m.get(g);
        b ? (y || (b.finished = !1), x && (b.cancelled = !0)) : m.set(g, {
          value: null,
          finished: y || !1,
          cancelled: x || !1
        })
      }, l && (l[v] = e[v])
    }
  });
  let f = t._state;
  e.pause === !f.paused ? (f.paused = e.pause, Rh(e.pause ? f.pauseQueue : f.resumeQueue)) : f.paused && (e.pause = !0);
  let d = (n || Object.keys(t.springs)).map(v => t.springs[v].start(e)),
    h = e.cancel === !0 || TX(e, "cancel") === !0;
  (u || h && f.asyncId) && d.push(RX(++t._lastAsyncId, {
    props: e,
    state: f,
    actions: {
      pause: AA,
      resume: AA,
      start(v, g) {
        h ? (X0(f, t._lastAsyncId), g(Wu(t))) : (v.onRest = o, g(IX(u, v, f, t)))
      }
    }
  })), f.paused && await new Promise(v => {
    f.resumeQueue.add(v)
  });
  let p = wO(t, await Promise.all(d));
  if (s && p.finished && !(r && p.noop)) {
    let v = kX(e, s, i);
    if (v) return DX(t, [v]), OX(t, v, !0)
  }
  return c && we.batchedUpdates(() => c(p, t, t.item)), p
}

function h5(t, e) {
  let r = {
    ...t.springs
  };
  return e && Ne(En(e), n => {
    ne.und(n.keys) && (n = Q0(n)), ne.obj(n.to) || (n = {
      ...n,
      to: void 0
    }), NX(r, n, i => PX(i))
  }), LX(t, r), r
}

function LX(t, e) {
  ya(e, (r, n) => {
    t.springs[n] || (t.springs[n] = r, od(r, t))
  })
}

function PX(t, e) {
  let r = new CX;
  return r.key = t, e && od(r, e), r
}

function NX(t, e, r) {
  e.keys && Ne(e.keys, n => {
    (t[n] || (t[n] = r(n)))._prepareNode(e)
  })
}

function DX(t, e) {
  Ne(e, r => {
    NX(t.springs, r, n => PX(n, t))
  })
}
var vE = ({
    children: t,
    ...e
  }) => {
    let r = A.useContext(I1),
      n = e.pause || !!r.pause,
      i = e.immediate || !!r.immediate;
    e = M7e(() => ({
      pause: n,
      immediate: i
    }), [n, i]);
    let {
      Provider: a
    } = I1;
    return A.createElement(a, {
      value: e
    }, t)
  },
  I1 = l9e(vE, {});
vE.Provider = I1.Provider;
vE.Consumer = I1.Consumer;

function l9e(t, e) {
  return Object.assign(t, A.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t
}
var c9e = () => {
  let t = [],
    e = function (n) {
      P7e();
      let i = [];
      return Ne(t, (a, s) => {
        if (ne.und(n)) i.push(a.start());
        else {
          let o = r(n, a, s);
          o && i.push(a.start(o))
        }
      }), i
    };
  e.current = t, e.add = function (n) {
    t.includes(n) || t.push(n)
  }, e.delete = function (n) {
    let i = t.indexOf(n);
    ~i && t.splice(i, 1)
  }, e.pause = function () {
    return Ne(t, n => n.pause(...arguments)), this
  }, e.resume = function () {
    return Ne(t, n => n.resume(...arguments)), this
  }, e.set = function (n) {
    Ne(t, (i, a) => {
      let s = ne.fun(n) ? n(a, i) : n;
      s && i.set(s)
    })
  }, e.start = function (n) {
    let i = [];
    return Ne(t, (a, s) => {
      if (ne.und(n)) i.push(a.start());
      else {
        let o = this._getProps(n, a, s);
        o && i.push(a.start(o))
      }
    }), i
  }, e.stop = function () {
    return Ne(t, n => n.stop(...arguments)), this
  }, e.update = function (n) {
    return Ne(t, (i, a) => i.update(this._getProps(n, i, a))), this
  };
  let r = function (n, i, a) {
    return ne.fun(n) ? n(a, i) : n
  };
  return e._getProps = r, e
};

function u9e(t, e, r) {
  let n = ne.fun(e) && e;
  n && !r && (r = []);
  let i = A.useMemo(() => n || arguments.length == 3 ? c9e() : void 0, []),
    a = A.useRef(0),
    s = bX(),
    o = A.useMemo(() => ({
      ctrls: [],
      queue: [],
      flush(m, y) {
        let x = h5(m, y);
        return a.current > 0 && !o.queue.length && !Object.keys(x).some(b => !m.springs[b]) ? MA(m, y) : new Promise(b => {
          LX(m, x), o.queue.push(() => {
            b(MA(m, y))
          }), s()
        })
      }
    }), []),
    c = A.useRef([...o.ctrls]),
    l = [],
    u = t5(t) || 0;
  A.useMemo(() => {
    Ne(c.current.slice(t, u), m => {
      Q7e(m, i), m.stop(!0)
    }), c.current.length = t, f(u, t)
  }, [t]), A.useMemo(() => {
    f(0, Math.min(u, t))
  }, r);

  function f(m, y) {
    for (let x = m; x < y; x++) {
      let b = c.current[x] || (c.current[x] = new o9e(null, o.flush)),
        _ = n ? n(x, b) : e[x];
      _ && (l[x] = n9e(_))
    }
  }
  let d = c.current.map((m, y) => h5(m, l[y])),
    h = A.useContext(vE),
    p = t5(h),
    v = h !== p && X7e(h);
  EO(() => {
    a.current++, o.ctrls = c.current;
    let {
      queue: m
    } = o;
    m.length && (o.queue = [], Ne(m, y => y())), Ne(c.current, (y, x) => {
      i == null || i.add(y), v && y.start({
        default: h
      });
      let b = l[x];
      b && (Z7e(y, b.ref), y.ref ? y.queue.push(b) : y.start(b))
    })
  }), SO(() => () => {
    Ne(o.ctrls, m => m.stop(!0))
  });
  let g = d.map(m => ({
    ...m
  }));
  return i ? [g, i] : g
}

function f9e(t, e) {
  let r = ne.fun(t),
    [
      [n], i
    ] = u9e(1, r ? t : [t], r ? e || [] : e);
  return r || arguments.length == 2 ? [n, i] : n
}
var p5 = (t, e) => {
    let r = N7e(() => new CX(t, e));
    return SO(() => () => {
      r.stop()
    }), r
  },
  d9e = class extends RO {
    constructor(e, r) {
      super();
      le(this, "key");
      le(this, "idle", !0);
      le(this, "calc");
      le(this, "_active", new Set);
      this.source = e, this.calc = G0(...r);
      let n = this._get(),
        i = CA(n);
      _O(this, i.create(n))
    }
    advance(e) {
      let r = this._get(),
        n = this.get();
      Ba(r, n) || (Zi(this).setValue(r), this._onChange(r, this.idle)), !this.idle && g5(this._active) && KT(this)
    }
    _get() {
      let e = ne.arr(this.source) ? this.source.map(Kr) : En(Kr(this.source));
      return this.calc(...e)
    }
    _start() {
      this.idle && !g5(this._active) && (this.idle = !1, Ne(gE(this), e => {
        e.done = !1
      }), Pi.skipAnimation ? (we.batchedUpdates(() => this.advance()), KT(this)) : fE.start(this))
    }
    _attach() {
      let e = 1;
      Ne(En(this.source), r => {
        zn(r) && od(r, this), PA(r) && (r.idle || this._active.add(r), e = Math.max(e, r.priority + 1))
      }), this.priority = e, this._start()
    }
    _detach() {
      Ne(En(this.source), e => {
        zn(e) && W0(e, this)
      }), this._active.clear(), KT(this)
    }
    eventObserved(e) {
      e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = En(this.source).reduce((r, n) => Math.max(r, (PA(n) ? n.priority : 0) + 1), 0))
    }
  };

function h9e(t) {
  return t.idle !== !1
}

function g5(t) {
  return !t.size || Array.from(t).every(h9e)
}

function KT(t) {
  t.idle || (t.idle = !0, Ne(gE(t), e => {
    e.done = !0
  }), V0(t, {
    type: "idle",
    parent: t
  }))
}
Pi.assign({
  createStringInterpolator: yX,
  to: (t, e) => new d9e(t, e)
});
var MX = /^--/;

function p9e(t, e) {
  return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !MX.test(t) && !(i0.hasOwnProperty(t) && i0[t]) ? e + "px" : ("" + e).trim()
}
var m5 = {};

function g9e(t, e) {
  if (!t.nodeType || !t.setAttribute) return !1;
  let r = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter",
    {
      style: n,
      children: i,
      scrollTop: a,
      scrollLeft: s,
      viewBox: o,
      ...c
    } = e,
    l = Object.values(c),
    u = Object.keys(c).map(f => r || t.hasAttribute(f) ? f : m5[f] || (m5[f] = f.replace(/([A-Z])/g, d => "-" + d.toLowerCase())));
  i !== void 0 && (t.textContent = i);
  for (let f in n)
    if (n.hasOwnProperty(f)) {
      let d = p9e(f, n[f]);
      MX.test(f) ? t.style.setProperty(f, d) : t.style[f] = d
    } u.forEach((f, d) => {
    t.setAttribute(f, l[d])
  }), a !== void 0 && (t.scrollTop = a), s !== void 0 && (t.scrollLeft = s), o !== void 0 && t.setAttribute("viewBox", o)
}
var i0 = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  m9e = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1),
  v9e = ["Webkit", "Ms", "Moz", "O"];
i0 = Object.keys(i0).reduce((t, e) => (v9e.forEach(r => t[m9e(r, e)] = t[e]), t), i0);
var y9e = /^(matrix|translate|scale|rotate|skew)/,
  x9e = /^(translate)/,
  b9e = /^(rotate|skew)/,
  YT = (t, e) => ne.num(t) && t !== 0 ? t + e : t,
  ey = (t, e) => ne.arr(t) ? t.every(r => ey(r, e)) : ne.num(t) ? t === e : parseFloat(t) === e,
  E9e = class extends mE {
    constructor({
      x: t,
      y: e,
      z: r,
      ...n
    }) {
      let i = [],
        a = [];
      (t || e || r) && (i.push([t || 0, e || 0, r || 0]), a.push(s => [`translate3d(${s.map(o=>YT(o,"px")).join(",")})`, ey(s, 0)])), ya(n, (s, o) => {
        if (o === "transform") i.push([s || ""]), a.push(c => [c, c === ""]);
        else if (y9e.test(o)) {
          if (delete n[o], ne.und(s)) return;
          let c = x9e.test(o) ? "px" : b9e.test(o) ? "deg" : "";
          i.push(En(s)), a.push(o === "rotate3d" ? ([l, u, f, d]) => [`rotate3d(${l},${u},${f},${YT(d,c)})`, ey(d, 0)] : l => [`${o}(${l.map(u=>YT(u,c)).join(",")})`, ey(l, o.startsWith("scale") ? 1 : 0)])
        }
      }), i.length && (n.transform = new S9e(i, a)), super(n)
    }
  },
  S9e = class extends gX {
    constructor(e, r) {
      super();
      le(this, "_value", null);
      this.inputs = e, this.transforms = r
    }
    get() {
      return this._value || (this._value = this._get())
    }
    _get() {
      let e = "",
        r = !0;
      return Ne(this.inputs, (n, i) => {
        let a = Kr(n[0]),
          [s, o] = this.transforms[i](ne.arr(a) ? a : n.map(Kr));
        e += " " + s, r = r && o
      }), r ? "none" : e
    }
    observerAdded(e) {
      e == 1 && Ne(this.inputs, r => Ne(r, n => zn(n) && od(n, this)))
    }
    observerRemoved(e) {
      e == 0 && Ne(this.inputs, r => Ne(r, n => zn(n) && W0(n, this)))
    }
    eventObserved(e) {
      e.type == "change" && (this._value = null), V0(this, e)
    }
  },
  _9e = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
Pi.assign({
  batchedUpdates: ql.unstable_batchedUpdates,
  createStringInterpolator: yX,
  colors: d7e
});
var T9e = V7e(_9e, {
    applyAnimatedValues: g9e,
    createAnimatedStyle: t => new E9e(t),
    getComponentProps: ({
      scrollTop: t,
      scrollLeft: e,
      ...r
    }) => r
  }),
  FX = T9e.animated;

function w9e(t) {
  const e = A.useRef(null),
    [r, n] = A.useState(0),
    [i, a] = A.useState(0),
    [s, o] = A.useState(null),
    [c, l] = A.useState(null),
    u = A.useCallback((f, d) => {
      const h = f.left + f.width / 2,
        p = window.innerHeight - f.bottom;
      a(window.innerHeight - p - f.height - d.height - 30), n(Math.min(h - d.width / 2, window.innerWidth - d.width - 30))
    }, []);
  return A.useEffect(() => {
    !c || !s || u(c, s)
  }, [c, u, s]), A.useEffect(() => {
    if (!e.current) return;

    function f() {
      var p;
      const h = (p = e.current) == null ? void 0 : p.getBoundingClientRect();
      o(h ? ? null)
    }
    f();
    const d = new ResizeObserver(f);
    return d.observe(e.current), () => {
      d.disconnect()
    }
  }, []), A.useEffect(() => {
    const f = wA(t.id);
    window[f] && l(window[f]);

    function d(h) {
      l(h.detail)
    }
    return document.addEventListener(f, d), () => {
      document.removeEventListener(f, d)
    }
  }, [t.id]), E("div", {
    ref: e,
    style: {
      transform: `translateX(${r}px) translateY(${i}px)`
    },
    className: ["pointer-events-auto z-10 inline-block origin-top-left touch-none overflow-hidden", t.className ? ? ""].join(" "),
    children: t.children
  })
}

function R9e(t, e, r) {
  return Math.max(e, Math.min(t, r))
}
const mr = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t]
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]]
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]]
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1]
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1]
  }
};

function v5(t, e, r) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, r * 5) : t * e * r / (e + r * t)
}

function y5(t, e, r, n = .15) {
  return n === 0 ? R9e(t, e, r) : t < e ? -v5(e - t, r - e, n) + e : t > r ? +v5(t - r, r - e, n) + r : t
}

function A9e(t, [e, r], [n, i]) {
  const [
    [a, s],
    [o, c]
  ] = t;
  return [y5(e, a, s, n), y5(r, o, c, i)]
}

function I9e(t, e) {
  if (typeof t != "object" || t === null) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(t)
}

function $9e(t) {
  var e = I9e(t, "string");
  return typeof e == "symbol" ? e : String(e)
}

function Wr(t, e, r) {
  return e = $9e(e), e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t
}

function x5(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function xt(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? x5(Object(r), !0).forEach(function (n) {
      Wr(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : x5(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}
const BX = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};

function b5(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : ""
}
const C9e = ["enter", "leave"];

function k9e(t = !1, e) {
  return t && !C9e.includes(e)
}

function O9e(t, e = "", r = !1) {
  const n = BX[t],
    i = n && n[e] || e;
  return "on" + b5(t) + b5(i) + (k9e(r, i) ? "Capture" : "")
}
const L9e = ["gotpointercapture", "lostpointercapture"];

function P9e(t) {
  let e = t.substring(2).toLowerCase();
  const r = !!~e.indexOf("passive");
  r && (e = e.replace("passive", ""));
  const n = L9e.includes(e) ? "capturecapture" : "capture",
    i = !!~e.indexOf(n);
  return i && (e = e.replace("capture", "")), {
    device: e,
    capture: i,
    passive: r
  }
}

function N9e(t, e = "") {
  const r = BX[t],
    n = r && r[e] || e;
  return t + n
}

function yE(t) {
  return "touches" in t
}

function UX(t) {
  return yE(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse"
}

function D9e(t) {
  return Array.from(t.touches).filter(e => {
    var r, n;
    return e.target === t.currentTarget || ((r = t.currentTarget) === null || r === void 0 || (n = r.contains) === null || n === void 0 ? void 0 : n.call(r, e.target))
  })
}

function M9e(t) {
  return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches
}

function jX(t) {
  return yE(t) ? M9e(t)[0] : t
}

function F9e(t) {
  return D9e(t).map(e => e.identifier)
}

function qT(t) {
  const e = jX(t);
  return yE(t) ? e.identifier : e.pointerId
}

function E5(t) {
  const e = jX(t);
  return [e.clientX, e.clientY]
}

function B9e(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: r,
      altKey: n,
      metaKey: i,
      ctrlKey: a
    } = t;
    Object.assign(e, {
      shiftKey: r,
      altKey: n,
      metaKey: i,
      ctrlKey: a
    })
  }
  return e
}

function $1(t, ...e) {
  return typeof t == "function" ? t(...e) : t
}

function U9e() {}

function j9e(...t) {
  return t.length === 0 ? U9e : t.length === 1 ? t[0] : function () {
    let e;
    for (const r of t) e = r.apply(this, arguments) || e;
    return e
  }
}

function S5(t, e) {
  return Object.assign({}, e, t || {})
}
const H9e = 32;
class z9e {
  constructor(e, r, n) {
    this.ctrl = e, this.args = r, this.key = n, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset())
  }
  get state() {
    return this.ctrl.state[this.key]
  }
  set state(e) {
    this.ctrl.state[this.key] = e
  }
  get shared() {
    return this.ctrl.state.shared
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key]
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key]
  }
  get config() {
    return this.ctrl.config[this.key]
  }
  get sharedConfig() {
    return this.ctrl.config.shared
  }
  get handler() {
    return this.ctrl.handlers[this.key]
  }
  reset() {
    const {
      state: e,
      shared: r,
      ingKey: n,
      args: i
    } = this;
    r[n] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [
      [-1 / 0, 1 / 0],
      [-1 / 0, 1 / 0]
    ], e.args = i, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0
  }
  start(e) {
    const r = this.state,
      n = this.config;
    r._active || (this.reset(), this.computeInitial(), r._active = !0, r.target = e.target, r.currentTarget = e.currentTarget, r.lastOffset = n.from ? $1(n.from, r) : r.offset, r.offset = r.lastOffset, r.startTime = r.timeStamp = e.timeStamp)
  }
  computeValues(e) {
    const r = this.state;
    r._values = e, r.values = this.config.transform(e)
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values
  }
  compute(e) {
    const {
      state: r,
      config: n,
      shared: i
    } = this;
    r.args = this.args;
    let a = 0;
    if (e && (r.event = e, n.preventDefault && e.cancelable && r.event.preventDefault(), r.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, B9e(e)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, a = e.timeStamp - r.timeStamp, r.timeStamp = e.timeStamp, r.elapsedTime = r.timeStamp - r.startTime), r._active) {
      const S = r._delta.map(Math.abs);
      mr.addTo(r._distance, S)
    }
    this.axisIntent && this.axisIntent(e);
    const [s, o] = r._movement, [c, l] = n.threshold, {
      _step: u,
      values: f
    } = r;
    if (n.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(s) >= c && f[0]), u[1] === !1 && (u[1] = Math.abs(o) >= l && f[1])) : (u[0] === !1 && (u[0] = Math.abs(s) >= c && Math.sign(s) * c), u[1] === !1 && (u[1] = Math.abs(o) >= l && Math.sign(o) * l)), r.intentional = u[0] !== !1 || u[1] !== !1, !r.intentional) return;
    const d = [0, 0];
    if (n.hasCustomTransform) {
      const [S, T] = f;
      d[0] = u[0] !== !1 ? S - u[0] : 0, d[1] = u[1] !== !1 ? T - u[1] : 0
    } else d[0] = u[0] !== !1 ? s - u[0] : 0, d[1] = u[1] !== !1 ? o - u[1] : 0;
    this.restrictToAxis && !r._blocked && this.restrictToAxis(d);
    const h = r.offset,
      p = r._active && !r._blocked || r.active;
    p && (r.first = r._active && !r.active, r.last = !r._active && r.active, r.active = i[this.ingKey] = r._active, e && (r.first && ("bounds" in n && (r._bounds = $1(n.bounds, r)), this.setup && this.setup()), r.movement = d, this.computeOffset()));
    const [v, g] = r.offset, [
      [m, y],
      [x, b]
    ] = r._bounds;
    r.overflow = [v < m ? -1 : v > y ? 1 : 0, g < x ? -1 : g > b ? 1 : 0], r._movementBound[0] = r.overflow[0] ? r._movementBound[0] === !1 ? r._movement[0] : r._movementBound[0] : !1, r._movementBound[1] = r.overflow[1] ? r._movementBound[1] === !1 ? r._movement[1] : r._movementBound[1] : !1;
    const _ = r._active ? n.rubberband || [0, 0] : [0, 0];
    if (r.offset = A9e(r._bounds, r.offset, _), r.delta = mr.sub(r.offset, h), this.computeMovement(), p && (!r.last || a > H9e)) {
      r.delta = mr.sub(r.offset, h);
      const S = r.delta.map(Math.abs);
      mr.addTo(r.distance, S), r.direction = r.delta.map(Math.sign), r._direction = r._delta.map(Math.sign), !r.first && a > 0 && (r.velocity = [S[0] / a, S[1] / a], r.timeDelta = a)
    }
  }
  emit() {
    const e = this.state,
      r = this.shared,
      n = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !n.triggerAllEvents) return;
    const i = this.handler(xt(xt(xt({}, r), e), {}, {
      [this.aliasKey]: e.values
    }));
    i !== void 0 && (e.memo = i)
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean()
  }
}

function G9e([t, e], r) {
  const n = Math.abs(t),
    i = Math.abs(e);
  if (n > i && n > r) return "x";
  if (i > n && i > r) return "y"
}
class V9e extends z9e {
  constructor(...e) {
    super(...e), Wr(this, "aliasKey", "xy")
  }
  reset() {
    super.reset(), this.state.axis = void 0
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0]
  }
  computeOffset() {
    this.state.offset = mr.add(this.state.lastOffset, this.state.movement)
  }
  computeMovement() {
    this.state.movement = mr.sub(this.state.offset, this.state.lastOffset)
  }
  axisIntent(e) {
    const r = this.state,
      n = this.config;
    if (!r.axis && e) {
      const i = typeof n.axisThreshold == "object" ? n.axisThreshold[UX(e)] : n.axisThreshold;
      r.axis = G9e(r._movement, i)
    }
    r._blocked = (n.lockDirection || !!n.axis) && !r.axis || !!n.axis && n.axis !== r.axis
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection) switch (this.state.axis) {
      case "x":
        e[1] = 0;
        break;
      case "y":
        e[0] = 0;
        break
    }
  }
}
const W9e = t => t,
  _5 = .15,
  HX = {
    enabled(t = !0) {
      return t
    },
    eventOptions(t, e, r) {
      return xt(xt({}, r.shared.eventOptions), t)
    },
    preventDefault(t = !1) {
      return t
    },
    triggerAllEvents(t = !1) {
      return t
    },
    rubberband(t = 0) {
      switch (t) {
        case !0:
          return [_5, _5];
        case !1:
          return [0, 0];
        default:
          return mr.toVector(t)
      }
    },
    from(t) {
      if (typeof t == "function") return t;
      if (t != null) return mr.toVector(t)
    },
    transform(t, e, r) {
      const n = t || r.shared.transform;
      return this.hasCustomTransform = !!n, n || W9e
    },
    threshold(t) {
      return mr.toVector(t, 0)
    }
  },
  K9e = 0,
  gg = xt(xt({}, HX), {}, {
    axis(t, e, {
      axis: r
    }) {
      if (this.lockDirection = r === "lock", !this.lockDirection) return r
    },
    axisThreshold(t = K9e) {
      return t
    },
    bounds(t = {}) {
      if (typeof t == "function") return a => gg.bounds(t(a));
      if ("current" in t) return () => t.current;
      if (typeof HTMLElement == "function" && t instanceof HTMLElement) return t;
      const {
        left: e = -1 / 0,
        right: r = 1 / 0,
        top: n = -1 / 0,
        bottom: i = 1 / 0
      } = t;
      return [
        [e, r],
        [n, i]
      ]
    }
  }),
  T5 = {
    ArrowRight: (t, e = 1) => [t * e, 0],
    ArrowLeft: (t, e = 1) => [-1 * t * e, 0],
    ArrowUp: (t, e = 1) => [0, -1 * t * e],
    ArrowDown: (t, e = 1) => [0, t * e]
  };
class Y9e extends V9e {
  constructor(...e) {
    super(...e), Wr(this, "ingKey", "dragging")
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this)
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const r = e._bounds.getBoundingClientRect(),
        n = e.currentTarget.getBoundingClientRect(),
        i = {
          left: r.left - n.left + e.offset[0],
          right: r.right - n.right + e.offset[0],
          top: r.top - n.top + e.offset[1],
          bottom: r.bottom - n.bottom + e.offset[1]
        };
      e._bounds = gg.bounds(i)
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit()
    }, 0))
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean()
  }
  pointerDown(e) {
    const r = this.config,
      n = this.state;
    if (e.buttons != null && (Array.isArray(r.pointerButtons) ? !r.pointerButtons.includes(e.buttons) : r.pointerButtons !== -1 && r.pointerButtons !== e.buttons)) return;
    const i = this.ctrl.setEventIds(e);
    r.pointerCapture && e.target.setPointerCapture(e.pointerId), !(i && i.size > 1 && n._pointerActive) && (this.start(e), this.setupPointer(e), n._pointerId = qT(e), n._pointerActive = !0, this.computeValues(E5(e)), this.computeInitial(), r.preventScrollAxis && UX(e) !== "mouse" ? (n._active = !1, this.setupScrollPrevention(e)) : r.delay > 0 ? (this.setupDelayTrigger(e), r.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e))
  }
  startPointerDrag(e) {
    const r = this.state;
    r._active = !0, r._preventScroll = !0, r._delayed = !1, this.compute(e), this.emit()
  }
  pointerMove(e) {
    const r = this.state,
      n = this.config;
    if (!r._pointerActive || r.type === e.type && e.timeStamp === r.timeStamp) return;
    const i = qT(e);
    if (r._pointerId !== void 0 && i !== r._pointerId) return;
    const a = E5(e);
    if (document.pointerLockElement === e.target ? r._delta = [e.movementX, e.movementY] : (r._delta = mr.sub(a, r._values), this.computeValues(a)), mr.addTo(r._movement, r._delta), this.compute(e), r._delayed && r.intentional) {
      this.timeoutStore.remove("dragDelay"), r.active = !1, this.startPointerDrag(e);
      return
    }
    if (n.preventScrollAxis && !r._preventScroll)
      if (r.axis)
        if (r.axis === n.preventScrollAxis || n.preventScrollAxis === "xy") {
          r._active = !1, this.clean();
          return
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return
        }
    else return;
    this.emit()
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId)
    } catch {}
    const r = this.state,
      n = this.config;
    if (!r._active || !r._pointerActive) return;
    const i = qT(e);
    if (r._pointerId !== void 0 && i !== r._pointerId) return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [a, s] = r._distance;
    if (r.tap = a <= n.tapsThreshold && s <= n.tapsThreshold, r.tap && n.filterTaps) r._force = !0;
    else {
      const [o, c] = r._delta, [l, u] = r._movement, [f, d] = n.swipe.velocity, [h, p] = n.swipe.distance, v = n.swipe.duration;
      if (r.elapsedTime < v) {
        const g = Math.abs(o / r.timeDelta),
          m = Math.abs(c / r.timeDelta);
        g > f && Math.abs(l) > h && (r.swipe[0] = Math.sign(o)), m > d && Math.abs(u) > p && (r.swipe[1] = Math.sign(c))
      }
    }
    this.emit()
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation())
  }
  setupPointer(e) {
    const r = this.config,
      n = r.device;
    r.pointerLock && e.currentTarget.requestPointerLock(), r.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this)))
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault()
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, q9e(e);
    const r = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", r), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", r), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e)
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e)
    }, this.config.delay)
  }
  keyDown(e) {
    const r = T5[e.key];
    if (r) {
      const n = this.state,
        i = e.shiftKey ? 10 : e.altKey ? .1 : 1;
      this.start(e), n._delta = r(this.config.keyboardDisplacement, i), n._keyboardActive = !0, mr.addTo(n._movement, n._delta), this.compute(e), this.emit()
    }
  }
  keyUp(e) {
    e.key in T5 && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit())
  }
  bind(e) {
    const r = this.config.device;
    e(r, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(r, "change", this.pointerMove.bind(this)), e(r, "end", this.pointerUp.bind(this)), e(r, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    })
  }
}

function q9e(t) {
  "persist" in t && typeof t.persist == "function" && t.persist()
}
const mg = typeof window < "u" && window.document && window.document.createElement;

function X9e() {
  return mg && "ontouchstart" in window
}

function w5() {
  return X9e() || mg && window.navigator.maxTouchPoints > 1
}

function Q9e() {
  return mg && "onpointerdown" in window
}

function Z9e() {
  return mg && "exitPointerLock" in window.document
}

function J9e() {
  try {
    return "constructor" in GestureEvent
  } catch {
    return !1
  }
}
const Gn = {
    isBrowser: mg,
    gesture: J9e(),
    touch: w5(),
    touchscreen: w5(),
    pointer: Q9e(),
    pointerLock: Z9e()
  },
  eje = 250,
  tje = 180,
  rje = .5,
  nje = 50,
  ije = 250,
  aje = 10,
  R5 = {
    mouse: 0,
    touch: 0,
    pen: 8
  },
  sje = xt(xt({}, gg), {}, {
    device(t, e, {
      pointer: {
        touch: r = !1,
        lock: n = !1,
        mouse: i = !1
      } = {}
    }) {
      return this.pointerLock = n && Gn.pointerLock, Gn.touch && r ? "touch" : this.pointerLock ? "mouse" : Gn.pointer && !i ? "pointer" : Gn.touch ? "touch" : "mouse"
    },
    preventScrollAxis(t, e, {
      preventScroll: r
    }) {
      if (this.preventScrollDelay = typeof r == "number" ? r : r || r === void 0 && t ? eje : void 0, !(!Gn.touchscreen || r === !1)) return t || (r !== void 0 ? "y" : void 0)
    },
    pointerCapture(t, e, {
      pointer: {
        capture: r = !0,
        buttons: n = 1,
        keys: i = !0
      } = {}
    }) {
      return this.pointerButtons = n, this.keys = i, !this.pointerLock && this.device === "pointer" && r
    },
    threshold(t, e, {
      filterTaps: r = !1,
      tapsThreshold: n = 3,
      axis: i = void 0
    }) {
      const a = mr.toVector(t, r ? n : i ? 1 : 0);
      return this.filterTaps = r, this.tapsThreshold = n, a
    },
    swipe({
      velocity: t = rje,
      distance: e = nje,
      duration: r = ije
    } = {}) {
      return {
        velocity: this.transform(mr.toVector(t)),
        distance: this.transform(mr.toVector(e)),
        duration: r
      }
    },
    delay(t = 0) {
      switch (t) {
        case !0:
          return tje;
        case !1:
          return 0;
        default:
          return t
      }
    },
    axisThreshold(t) {
      return t ? xt(xt({}, R5), t) : R5
    },
    keyboardDisplacement(t = aje) {
      return t
    }
  });
xt(xt({}, HX), {}, {
  device(t, e, {
    shared: r,
    pointer: {
      touch: n = !1
    } = {}
  }) {
    if (r.target && !Gn.touch && Gn.gesture) return "gesture";
    if (Gn.touch && n) return "touch";
    if (Gn.touchscreen) {
      if (Gn.pointer) return "pointer";
      if (Gn.touch) return "touch"
    }
  },
  bounds(t, e, {
    scaleBounds: r = {},
    angleBounds: n = {}
  }) {
    const i = s => {
        const o = S5($1(r, s), {
          min: -1 / 0,
          max: 1 / 0
        });
        return [o.min, o.max]
      },
      a = s => {
        const o = S5($1(n, s), {
          min: -1 / 0,
          max: 1 / 0
        });
        return [o.min, o.max]
      };
    return typeof r != "function" && typeof n != "function" ? [i(), a()] : s => [i(s), a(s)]
  },
  threshold(t, e, r) {
    return this.lockDirection = r.axis === "lock", mr.toVector(t, this.lockDirection ? [.1, 3] : 0)
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t
  },
  pinchOnWheel(t = !0) {
    return t
  }
});
xt(xt({}, gg), {}, {
  mouseOnly: (t = !0) => t
});
xt(xt({}, gg), {}, {
  mouseOnly: (t = !0) => t
});
const zX = new Map,
  FA = new Map;

function oje(t) {
  zX.set(t.key, t.engine), FA.set(t.key, t.resolver)
}
const lje = {
  key: "drag",
  engine: Y9e,
  resolver: sje
};

function cje(t, e) {
  if (t == null) return {};
  var r = {},
    n = Object.keys(t),
    i, a;
  for (a = 0; a < n.length; a++) i = n[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r
}

function uje(t, e) {
  if (t == null) return {};
  var r = cje(t, e),
    n, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    for (i = 0; i < a.length; i++) n = a[i], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n])
  }
  return r
}
const fje = {
    target(t) {
      if (t) return () => "current" in t ? t.current : t
    },
    enabled(t = !0) {
      return t
    },
    window(t = Gn.isBrowser ? window : void 0) {
      return t
    },
    eventOptions({
      passive: t = !0,
      capture: e = !1
    } = {}) {
      return {
        passive: t,
        capture: e
      }
    },
    transform(t) {
      return t
    }
  },
  dje = ["target", "eventOptions", "window", "enabled", "transform"];

function ty(t = {}, e) {
  const r = {};
  for (const [n, i] of Object.entries(e)) switch (typeof i) {
    case "function":
      r[n] = i.call(r, t[n], n, t);
      break;
    case "object":
      r[n] = ty(t[n], i);
      break;
    case "boolean":
      i && (r[n] = t[n]);
      break
  }
  return r
}

function hje(t, e, r = {}) {
  const n = t,
    {
      target: i,
      eventOptions: a,
      window: s,
      enabled: o,
      transform: c
    } = n,
    l = uje(n, dje);
  if (r.shared = ty({
      target: i,
      eventOptions: a,
      window: s,
      enabled: o,
      transform: c
    }, fje), e) {
    const u = FA.get(e);
    r[e] = ty(xt({
      shared: r.shared
    }, l), u)
  } else
    for (const u in l) {
      const f = FA.get(u);
      f && (r[u] = ty(xt({
        shared: r.shared
      }, l[u]), f))
    }
  return r
}
class GX {
  constructor(e, r) {
    Wr(this, "_listeners", new Set), this._ctrl = e, this._gestureKey = r
  }
  add(e, r, n, i, a) {
    const s = this._listeners,
      o = N9e(r, n),
      c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {},
      l = xt(xt({}, c), a);
    e.addEventListener(o, i, l);
    const u = () => {
      e.removeEventListener(o, i, l), s.delete(u)
    };
    return s.add(u), u
  }
  clean() {
    this._listeners.forEach(e => e()), this._listeners.clear()
  }
}
class pje {
  constructor() {
    Wr(this, "_timeouts", new Map)
  }
  add(e, r, n = 140, ...i) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(r, n, ...i))
  }
  remove(e) {
    const r = this._timeouts.get(e);
    r && window.clearTimeout(r)
  }
  clean() {
    this._timeouts.forEach(e => void window.clearTimeout(e)), this._timeouts.clear()
  }
}
class gje {
  constructor(e) {
    Wr(this, "gestures", new Set), Wr(this, "_targetEventStore", new GX(this)), Wr(this, "gestureEventStores", {}), Wr(this, "gestureTimeoutStores", {}), Wr(this, "handlers", {}), Wr(this, "config", {}), Wr(this, "pointerIds", new Set), Wr(this, "touchIds", new Set), Wr(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), mje(this, e)
  }
  setEventIds(e) {
    if (yE(e)) return this.touchIds = new Set(F9e(e)), this.touchIds;
    if ("pointerId" in e) return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds
  }
  applyHandlers(e, r) {
    this.handlers = e, this.nativeHandlers = r
  }
  applyConfig(e, r) {
    this.config = hje(e, r, this.config)
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures) this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean()
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean()
  }
  bind(...e) {
    const r = this.config.shared,
      n = {};
    let i;
    if (!(r.target && (i = r.target(), !i))) {
      if (r.enabled) {
        for (const s of this.gestures) {
          const o = this.config[s],
            c = A5(n, o.eventOptions, !!i);
          if (o.enabled) {
            const l = zX.get(s);
            new l(this, e, s).bind(c)
          }
        }
        const a = A5(n, r.eventOptions, !!i);
        for (const s in this.nativeHandlers) a(s, "", o => this.nativeHandlers[s](xt(xt({}, this.state.shared), {}, {
          event: o,
          args: e
        })), void 0, !0)
      }
      for (const a in n) n[a] = j9e(...n[a]);
      if (!i) return n;
      for (const a in n) {
        const {
          device: s,
          capture: o,
          passive: c
        } = P9e(a);
        this._targetEventStore.add(i, s, "", n[a], {
          capture: o,
          passive: c
        })
      }
    }
  }
}

function Vc(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new GX(t, e), t.gestureTimeoutStores[e] = new pje
}

function mje(t, e) {
  e.drag && Vc(t, "drag"), e.wheel && Vc(t, "wheel"), e.scroll && Vc(t, "scroll"), e.move && Vc(t, "move"), e.pinch && Vc(t, "pinch"), e.hover && Vc(t, "hover")
}
const A5 = (t, e, r) => (n, i, a, s = {}, o = !1) => {
  var c, l;
  const u = (c = s.capture) !== null && c !== void 0 ? c : e.capture,
    f = (l = s.passive) !== null && l !== void 0 ? l : e.passive;
  let d = o ? n : O9e(n, i, u);
  r && f && (d += "Passive"), t[d] = t[d] || [], t[d].push(a)
};

function vje(t, e = {}, r, n) {
  const i = ce.useMemo(() => new gje(t), []);
  if (i.applyHandlers(t, n), i.applyConfig(e, r), ce.useEffect(i.effect.bind(i)), ce.useEffect(() => i.clean.bind(i), []), e.target === void 0) return i.bind.bind(i)
}

function yje(t, e) {
  return oje(lje), vje({
    drag: t
  }, e || {}, "drag")
}

function xje(t) {
  const e = A.useRef(null),
    r = A.useRef(!1),
    [n, i] = A.useState(null),
    [{
      y: a
    }, s] = f9e(() => ({
      y: 0,
      onRest() {
        r.current && t.onClose && t.onClose()
      }
    })),
    o = yje(({
      last: c,
      velocity: [, l],
      direction: [, u],
      movement: [, f],
      ...d
    }) => {
      if (r.current || d.target.closest(".overflow-y-auto")) return;
      const p = (n == null ? void 0 : n.height) ? ? 0;
      c ? f > p * .5 || l > .5 && u > 0 && f > 20 ? (s.start({
        y: p * 1.2,
        immediate: !1,
        config: {
          ...OA.wobbly,
          velocity: l,
          clamp: !0
        }
      }), r.current = !0) : s.start({
        y: 0,
        immediate: !1,
        config: OA.wobbly
      }) : s.start({
        y: f,
        immediate: !0
      })
    }, {
      from: () => [0, a.get()],
      filterTaps: !0,
      bounds: {
        top: 0
      },
      rubberband: !0
    });
  return A.useEffect(() => {
    if (!e.current) return;

    function c() {
      var f;
      const u = (f = e.current) == null ? void 0 : f.getBoundingClientRect();
      i(u ? ? null)
    }
    c();
    const l = new ResizeObserver(c);
    return l.observe(e.current), () => {
      l.disconnect()
    }
  }, []), E("div", {
    className: "is-mobile-view absolute inset-x-0 mx-auto max-w-[400px] origin-bottom-left touch-none",
    style: {
      transform: `translateY(${window.innerHeight-((n==null?void 0:n.height)??0)+200}px)`
    },
    children: E(FX.div, {
      ref: e,
      className: [t.className ? ? "", "touch-none"].join(" "),
      style: {
        y: a
      },
      ...o(),
      children: t.children
    })
  })
}

function VX(t) {
  const e = t.radius ? ? 40;
  return Y("svg", {
    className: `${t.className??""} -rotate-90`,
    viewBox: "0 0 100 100",
    children: [E("circle", {
      className: `fill-transparent stroke-denim-700 stroke-[15] opacity-25 ${t.backingRingClassname??""}`,
      r: e,
      cx: "50",
      cy: "50"
    }), E("circle", {
      className: "fill-transparent stroke-current stroke-[15] transition-[stroke-dashoffset] duration-150",
      r: e,
      cx: "50",
      cy: "50",
      style: {
        strokeDasharray: `${2*Math.PI*e} ${2*Math.PI*e}`,
        strokeDashoffset: `${2*Math.PI*e-t.percentage/100*(2*Math.PI*e)}`
      }
    })]
  })
}

function bje(t) {
  const e = A.createRef(),
    r = A.useRef(!1),
    n = 30;
  return A.useEffect(() => {
    if (r.current || !e.current) return;
    const i = e.current,
      a = i.classList.contains("overflow-y-auto") ? i : i.closest(".overflow-y-auto"),
      s = a == null ? void 0 : a.querySelector(".active");
    if (a && s) {
      let o = 0,
        c = 0,
        l = 0,
        u = 0;
      if ((() => {
          const h = s.getBoundingClientRect(),
            p = a.getBoundingClientRect();
          o = p.height, l = h.height, c = h.top - p.top + a.scrollTop, u = a.scrollTop
        })(), c + l < u + o - n || c > u + n) {
        const h = c + l / 2,
          p = o / 2,
          v = h - p;
        a.scrollTo({
          top: v
        })
      }
    }
    r.current = !0
  }, [e]), E("div", {
    className: t.className,
    ref: e,
    children: t.children
  })
}

function Sf(t) {
  return E(bje, {
    className: ["p-5", t.className || ""].join(" "),
    children: t.children
  })
}

function WX(t) {
  const e = t.isOnDarkBackground ? "bg-ash-200" : "bg-ash-400",
    r = t.isOnDarkBackground ? "hover:bg-ash-200" : "hover:bg-ash-400";
  return Y("div", {
    className: ["group -mx-2 flex cursor-pointer items-center justify-between space-x-1 rounded p-2 font-semibold transition-[background-color,color] duration-150", r, t.active ? `${e} active text-white outline-denim-700` : "text-denim-700 hover:text-white"].join(" "),
    onClick: t.onClick,
    children: [t.active && E("div", {
      className: "absolute left-0 h-8 w-0.5 bg-bink-500"
    }), E("span", {
      className: "truncate",
      children: t.children
    }), Y("div", {
      className: "relative min-h-[1rem] min-w-[1rem]",
      children: [!t.noChevron && E(Ve, {
        className: "absolute inset-0 translate-x-2 text-white opacity-0 transition-[opacity,transform] duration-100 group-hover:translate-x-0 group-hover:opacity-100",
        icon: ue.CHEVRON_RIGHT
      }), t.right]
    })]
  })
}

function rs(t) {
  return E(WX, {
    isOnDarkBackground: t.isOnDarkBackground,
    active: t.active,
    onClick: t.onClick,
    noChevron: t.loading || t.errored,
    right: Y(yr, {
      children: [t.errored && E(Ve, {
        icon: ue.WARNING,
        className: "absolute inset-0 text-rose-400"
      }), t.loading && !t.errored && E(Qq, {
        className: "absolute inset-0 text-base [--color:#9C93B5]"
      }), t.percentageCompleted && !t.loading && !t.errored ? E(VX, {
        className: "absolute inset-0 text-bink-600 opacity-100 transition-[opacity] group-hover:opacity-0",
        backingRingClassname: "stroke-ash-500",
        percentage: t.percentageCompleted > 90 ? 100 : t.percentageCompleted
      }) : ""]
    }),
    children: t.children
  })
}

function xE(t) {
  const e = E(WX, {
    active: t.active,
    isOnDarkBackground: t.isOnDarkBackground,
    right: t.right,
    onClick: t.href ? void 0 : t.onClick,
    noChevron: t.noChevron,
    children: Y("div", {
      className: "flex items-center space-x-3",
      children: [t.icon ? E(Ve, {
        className: "text-xl",
        icon: t.icon
      }) : null, E("div", {
        children: t.children
      })]
    })
  });
  return t.href ? E("a", {
    href: t.href ? t.href : void 0,
    rel: "noreferrer",
    target: "_blank",
    download: t.download ? t.download : void 0,
    onClick: t.onClick,
    children: e
  }) : e
}

function KX() {
  const {
    isMobile: t
  } = Aa();
  return t ? E("div", {
    className: "relative z-50 mx-auto my-3 -mb-3 h-1 w-12 rounded-full bg-ash-500 bg-opacity-30"
  }) : null
}

function Eje() {
  const {
    isMobile: t
  } = Aa();
  return t ? E("div", {
    className: "h-[200px]"
  }) : null
}

function Sje(t) {
  const e = A.useRef(null),
    {
      isMobile: r
    } = Aa(),
    n = p5(0, {
      config: {
        easing: $A.easeInOutSine,
        duration: 300
      }
    }),
    i = p5(0, {
      config: {
        easing: $A.easeInOutSine,
        duration: 300
      }
    }),
    [a, s] = A.useState(null),
    o = A.useCallback((c = !0) => {
      if (!e.current) return;
      const l = e.current.querySelectorAll(":scope *[data-floating-page='true']");
      if (c && s(l), l.length === 0) {
        n.start(0), i.start(0);
        return
      }
      const u = l[l.length - 1],
        f = u.getBoundingClientRect(),
        d = u.scrollHeight;
      n.get() === 0 ? (n.set(d), i.set(f.width)) : (n.start(d), i.start(f.width))
    }, [n, i]);
  return A.useEffect(() => {
    if (!e.current) return;
    o();
    const c = new MutationObserver(() => {
      o()
    });
    return c.observe(e.current, {
      attributes: !1,
      childList: !0,
      subtree: !1
    }), () => {
      c.disconnect()
    }
  }, [o]), A.useEffect(() => {
    const c = new ResizeObserver(() => {
      o(!1)
    });
    return a == null || a.forEach(l => c.observe(l)), () => {
      c.disconnect()
    }
  }, [a, o]), E(FX.div, {
    ref: e,
    style: {
      height: n,
      width: r ? "100%" : i
    },
    className: "relative flex items-center justify-center overflow-hidden",
    children: t.children
  })
}

function _je(t) {
  const {
    isMobile: e
  } = Aa(), r = E(Sje, {
    children: t.children
  });
  return e ? E(xje, {
    className: t.className,
    onClose: t.onClose,
    children: r
  }) : E(w9e, {
    id: t.for,
    className: t.className,
    children: r
  })
}

function Tje(t) {
  return E(_je, {
    className: "overflow-hidden rounded-md bg-ash-300",
    ...t
  })
}
const Ar = {
  Header(t) {
    const {
      t: e
    } = ke();
    let r = Y("div", {
      onClick: t.goBack,
      className: "flex cursor-pointer items-center space-x-2 transition-colors duration-200 hover:text-white",
      children: [E(Ve, {
        icon: ue.ARROW_LEFT
      }), E("span", {
        children: t.backText || e("videoPlayer.popouts.back")
      })]
    });
    return t.close && (r = Y("div", {
      onClick: t.goBack,
      className: "flex cursor-pointer items-center space-x-2 transition-colors duration-200 hover:text-white",
      children: [E(Ve, {
        icon: ue.X
      }), E("span", {
        children: e("videoPlayer.popouts.close")
      })]
    })), Y("div", {
      className: "flex flex-col bg-[#1C161B]",
      children: [E(KX, {}), Y(Sf, {
        children: [Y("div", {
          className: "flex justify-between",
          children: [E("div", {
            children: r
          }), E("div", {
            children: t.action ? ? null
          })]
        }), E("h2", {
          className: "mb-2 mt-8 text-3xl font-bold text-white",
          children: t.title
        }), E("p", {
          children: t.description
        })]
      })]
    })
  },
  Content(t) {
    return Y("div", {
      className: "grid h-full grid-rows-[1fr]",
      children: [t.noSection ? E("div", {
        className: "relative h-full overflow-y-auto bg-ash-300",
        children: t.children
      }) : E(Sf, {
        className: "relative h-full overflow-y-auto bg-ash-300",
        children: t.children
      }), E(Eje, {})]
    })
  }
};

function wje(t) {
  const [e, r] = A.useState(null), n = A.useRef(null), i = A.useRef(null);
  A.useEffect(() => {
    function s(o) {
      i.current = o.target
    }
    return document.addEventListener("mousedown", s), () => {
      document.removeEventListener("mousedown", s)
    }
  });
  const a = A.useCallback(s => {
    const o = i.current;
    i.current = null, s.currentTarget === s.target && o && o.isEqualNode(s.currentTarget) && t.onClose && t.onClose()
  }, [t]);
  return A.useEffect(() => {
    var o;
    const s = (o = n.current) == null ? void 0 : o.closest(".popout-location");
    r(s ? ? document.body)
  }, []), E("div", {
    ref: n,
    children: e ? ql.createPortal(E($i, {
      show: t.show,
      animation: "none",
      children: Y("div", {
        className: "popout-wrapper pointer-events-auto fixed inset-0 z-[999] select-none",
        children: [E($i, {
          animation: "fade",
          isChild: !0,
          children: E("div", {
            onClick: a,
            className: ["absolute inset-0", t.darken ? "bg-black opacity-90" : ""].join(" ")
          })
        }), E($i, {
          animation: "slide-up",
          className: "h-0",
          isChild: !0,
          children: t.children
        })]
      })
    }), e) : null
  })
}

function I5(t, e) {
  const n = new URLSearchParams(t.search).get("modal");
  n ? e.openPopout(n) : e.closePopout()
}

function Rje(t) {
  const e = nd(),
    r = Bi(t),
    n = st(t),
    i = Bk(),
    a = A.useRef(null),
    s = A.useRef(n);
  A.useEffect(() => {
    s.current = n
  }, [n]), A.useEffect(() => {
    const c = r.popout;
    if (a.current !== c)
      if (a.current = c, c) {
        const l = new URLSearchParams([
          ["modal", c]
        ]).toString();
        e.push({
          search: l,
          state: "popout"
        })
      } else {
        if (!new URLSearchParams(e.location.search).has("modal")) return;
        e.length > 0 ? e.goBack() : e.replace({
          search: "",
          state: "popout"
        })
      }
  }, [r, e]), A.useEffect(() => {
    i.state !== "popout" && I5(i, s.current)
  }, [i]);
  const o = A.useRef(!1);
  A.useEffect(() => {
    o.current || (I5(i, s.current), o.current = !0)
  }, [i])
}

function No(t) {
  const {
    isMobile: e
  } = Aa(), r = e ? "100%" : `${t.width}px`;
  return E($i, {
    animation: t.active ? "slide-full-left" : "slide-full-right",
    className: "absolute inset-0",
    durationClass: "duration-[400ms]",
    show: t.show,
    children: E("div", {
      className: [t.className ? ? "", "grid grid-rows-[auto,minmax(0,1fr)]"].join(" "),
      "data-floating-page": t.show ? "true" : void 0,
      style: {
        height: t.height ? `${t.height}px` : void 0,
        maxHeight: "70vh",
        width: t.width ? r : void 0
      },
      children: t.children
    })
  })
}

function YX(t = "/") {
  const [e, r] = A.useState(t.split("/").filter(d => d.length > 0)), [n, i] = A.useState(e), a = e[e.length - 1] ? ? "/";
  A.useLayoutEffect(() => {
    n.length !== e.length && setTimeout(() => {
      i(e)
    }, 20)
  }, [e, n]);

  function s(d) {
    const h = d.split("/").filter(p => p.length > 0);
    h.length > n.length && i(h), r(h)
  }

  function o(d) {
    if (d === "/") return !0;
    const h = n.indexOf(d);
    return !(h === -1 || h === n.length - 1)
  }

  function c(d) {
    return d === a
  }

  function l(d) {
    return d === "/" ? !0 : e.includes(d)
  }

  function u(d) {
    return {
      show: c(d),
      active: o(d)
    }
  }

  function f() {
    s("/")
  }
  return {
    navigate: s,
    reset: f,
    isLoaded: l,
    isCurrentPage: c,
    pageProps: u,
    isActive: o
  }
}

function Aje() {
  var b, _, S, T;
  const t = OY(),
    {
      t: e
    } = ke(),
    {
      pageProps: r,
      navigate: n
    } = YX("/episodes"),
    i = Re(),
    a = ui(i),
    s = st(i),
    [o, c] = A.useState(null),
    [l, u, f] = ad((R, I) => v1(ae.SERIES, R, I)),
    d = A.useCallback(R => {
      var I;
      c({
        seasonId: R,
        season: void 0
      }), l((I = tq(t.media)) == null ? void 0 : I.id, R).then(w => {
        (w == null ? void 0 : w.meta.type) === ae.SERIES && c({
          seasonId: R,
          season: w == null ? void 0 : w.meta.seasonData
        })
      })
    }, [l, t.media]),
    h = (o == null ? void 0 : o.seasonId) ? ? ((b = a == null ? void 0 : a.episode) == null ? void 0 : b.seasonId),
    p = A.useCallback((R, I) => {
      s.closePopout(), setTimeout(() => {
        s.setCurrentEpisode(R, I)
      }, 100)
    }, [s]),
    v = A.useMemo(() => {
      var R;
      return (R = a == null ? void 0 : a.seasons) == null ? void 0 : R.find(I => I.id === h)
    }, [a, h]),
    g = A.useMemo(() => {
      var R, I, w, C;
      return o != null && o.season ? (R = o == null ? void 0 : o.season) == null ? void 0 : R.episodes : (C = (w = (I = a == null ? void 0 : a.seasons) == null ? void 0 : I.find) == null ? void 0 : w.call(I, L => L && L.id === h)) == null ? void 0 : C.episodes
    }, [a, h, o]),
    m = R => {
      d(R), c({
        seasonId: R
      }), n("/episodes")
    },
    {
      watched: y
    } = rE(),
    x = () => {
      s.closePopout()
    };
  return Y(yr, {
    children: [Y(No, {
      ...r("seasons"),
      height: 600,
      width: 375,
      children: [E(Ar.Header, {
        title: e("videoPlayer.popouts.seasons.title"),
        description: e("videoPlayer.popouts.descriptions.seasons"),
        goBack: () => n("/episodes"),
        backText: v == null ? void 0 : v.title
      }), E(Ar.Content, {
        children: v ? (S = (_ = a == null ? void 0 : a.seasons) == null ? void 0 : _.map) == null ? void 0 : S.call(_, R => {
          var I;
          return E(rs, {
            active: ((I = a == null ? void 0 : a.episode) == null ? void 0 : I.seasonId) === R.id,
            onClick: () => m(R.id),
            children: R.title
          }, R.id)
        }) : e("videoPlayer.popouts.seasons.noSeason")
      })]
    }), Y(No, {
      ...r("episodes"),
      height: 600,
      width: 375,
      children: [E(Ar.Header, {
        title: (v == null ? void 0 : v.title) ? ? e("videoPlayer.popouts.episodes.unknown"),
        description: e("videoPlayer.popouts.descriptions.episode"),
        goBack: x,
        close: !0,
        action: Y("button", {
          type: "button",
          onClick: () => n("/episodes/seasons"),
          className: "flex cursor-pointer items-center space-x-2 transition-colors duration-200 hover:text-white",
          children: [E("span", {
            children: e("videoPlayer.popouts.seasons.other")
          }), E(Ve, {
            icon: ue.CHEVRON_RIGHT
          })]
        })
      }), E(Ar.Content, {
        children: u ? E("div", {
          className: "flex h-full w-full items-center justify-center",
          children: E(lg, {})
        }) : f ? E("div", {
          className: "flex h-full w-full items-center justify-center",
          children: Y("div", {
            className: "flex flex-col flex-wrap items-center text-slate-400",
            children: [E(rn, {
              icon: ue.EYE_SLASH,
              className: "text-xl text-bink-600"
            }), E("p", {
              className: "mt-6 w-full text-center",
              children: e("videoPlayer.popouts.errors.loadingWentWrong", {
                seasonTitle: (T = v == null ? void 0 : v.title) == null ? void 0 : T.toLowerCase()
              })
            })]
          })
        }) : E("div", {
          children: g && v ? g.map(R => {
            var I, w;
            return E(rs, {
              active: R.id === ((I = a == null ? void 0 : a.episode) == null ? void 0 : I.episodeId),
              onClick: () => {
                var C;
                R.id === ((C = a == null ? void 0 : a.episode) == null ? void 0 : C.episodeId) ? s.closePopout() : p(v.id, R.id)
              },
              percentageCompleted: (w = y.items.find(C => {
                var L, H, N, P;
                return ((H = (L = C.item) == null ? void 0 : L.series) == null ? void 0 : H.seasonId) === v.id && ((P = (N = C.item) == null ? void 0 : N.series) == null ? void 0 : P.episodeId) === R.id
              })) == null ? void 0 : w.percentage,
              children: e("videoPlayer.popouts.episode", {
                index: R.number,
                title: R.title
              })
            }, R.id)
          }) : e("videoPlayer.popouts.episodes.noEpisode")
        })
      })]
    })]
  })
}

function Ije(t) {
  const {
    t: e
  } = ke();
  return E(xE, {
    icon: ue.CAPTIONS,
    onClick: t.onClick,
    children: e("videoPlayer.buttons.captions")
  })
}

function qX(t) {
  return {
    source: t.source ? {
      ...t.source
    } : null
  }
}

function io(t, e) {
  yc(t, "source", qX(e))
}

function vg(t) {
  const e = br(t),
    [r, n] = A.useState(qX(e));
  return A.useEffect(() => {
    function i(a) {
      n(a.detail)
    }
    return xc(t, "source", i), () => {
      bc(t, "source", i)
    }
  }, [t]), r
}

function $je() {
  var s, o;
  const t = Re(),
    e = vg(t),
    {
      t: r
    } = ke(),
    n = ui(t),
    i = ((s = e.source) == null ? void 0 : s.type) === Ct.HLS;
  if (i) return null;
  const a = n == null ? void 0 : n.meta.meta.title;
  return E(xE, {
    href: i || (o = e.source) == null ? void 0 : o.url,
    download: a ? `${hA(a)}.mp4` : void 0,
    icon: ue.DOWNLOAD,
    children: r("videoPlayer.buttons.download")
  })
}

function Cje(t) {
  const {
    t: e
  } = ke();
  return E(xE, {
    icon: ue.TACHOMETER,
    onClick: t.onClick,
    children: e("videoPlayer.buttons.playbackSpeed")
  })
}

function kje() {
  const t = Re(),
    e = vg(t);
  return e.source ? E("div", {
    className: "rounded-md bg-denim-300 px-2 py-1 transition-colors",
    children: E("p", {
      className: "text-center text-xs font-bold text-slate-300 transition-colors",
      children: e.source.quality
    })
  }) : null
}

function Oje(t) {
  const {
    t: e
  } = ke();
  return E(xE, {
    icon: ue.CLAPPER_BOARD,
    onClick: t.onClick,
    right: E(kje, {}),
    noChevron: !0,
    children: e("videoPlayer.buttons.source")
  })
}

function Lje(t) {
  var h, p;
  const {
    t: e
  } = ke(), r = Re(), n = ui(r), i = vg(r), a = st(r), s = A.useMemo(() => (n == null ? void 0 : n.captions.map(v => ({
    ...v,
    id: bA(v, !0)
  }))) ? ? [], [n]), o = A.useRef(""), [c, l, u] = ad(async (v, g) => {
    const m = bA(v, g);
    o.current = m;
    const y = await kq(v),
      b = await (await fetch(y)).text();
    Oq(b), a.setCaption(m, y), setTimeout(() => {
      a.closePopout()
    }, 100)
  }), f = (p = (h = i.source) == null ? void 0 : h.caption) == null ? void 0 : p.id, d = A.useRef(null);
  return Y(No, {
    ...t.router.pageProps(t.prefix),
    width: 320,
    height: 500,
    children: [E(Ar.Header, {
      title: e("videoPlayer.popouts.captions"),
      description: e("videoPlayer.popouts.descriptions.captions"),
      goBack: () => t.router.navigate("/"),
      action: Y("button", {
        type: "button",
        onClick: () => t.router.navigate(`${t.prefix}/caption-settings`),
        className: "flex cursor-pointer items-center space-x-2 transition-colors duration-200 hover:text-white",
        children: [E("span", {
          children: e("videoPlayer.popouts.captionPreferences.title")
        }), E(Ve, {
          icon: ue.GEAR
        })]
      })
    }), Y(Ar.Content, {
      noSection: !0,
      children: [Y(Sf, {
        children: [E(rs, {
          active: !f,
          onClick: () => {
            a.clearCaption(), a.closePopout()
          },
          children: e("videoPlayer.popouts.noCaptions")
        }), Y(rs, {
          active: f === rh,
          loading: l && o.current === rh,
          errored: u && o.current === rh,
          onClick: () => {
            var v;
            return (v = d.current) == null ? void 0 : v.click()
          },
          children: [e(f === rh ? "videoPlayer.popouts.customCaption" : "videoPlayer.popouts.uploadCustomCaption"), E("input", {
            className: "hidden",
            ref: d,
            accept: tO.join(","),
            type: "file",
            onChange: v => {
              if (!v.target.files) return;
              const g = {
                langIso: "custom",
                url: URL.createObjectURL(v.target.files[0]),
                type: Li.UNKNOWN
              };
              c(g, !1)
            }
          })]
        }, rh)]
      }), Y("p", {
        className: "sticky top-0 z-10 flex items-center space-x-1 bg-ash-300 px-5 py-3 text-xs font-bold uppercase",
        children: [E(Ve, {
          className: "text-base",
          icon: ue.LINK
        }), E("span", {
          children: e("videoPlayer.popouts.linkedCaptions")
        })]
      }), E(Sf, {
        className: "pt-0",
        children: E("div", {
          children: s.map(v => E(rs, {
            active: v.id === f,
            loading: l && v.id === o.current,
            errored: u && v.id === o.current,
            onClick: () => {
              o.current = v.id, c(v, !0)
            },
            children: v.langIso
          }, v.langIso))
        })
      })]
    })]
  })
}
const XX = ["#ffffff", "#00ffff", "#ffff00"];

function QX({
  color: t
}) {
  const {
    captionSettings: e,
    setCaptionColor: r
  } = id();
  return Y("div", {
    className: `flex h-8 w-8 items-center justify-center rounded transition-[background-color,transform] duration-100 hover:bg-[#1c161b79] active:scale-110 ${t===e.style.color?"bg-[#1C161B]":""}`,
    onClick: () => r(t),
    children: [E("div", {
      className: "h-4 w-4 cursor-pointer appearance-none rounded-full",
      style: {
        backgroundColor: t
      }
    }), E(Ve, {
      className: ["absolute text-xs text-[#1C161B]", t === e.style.color ? "" : "hidden"].join(" "),
      icon: ue.CHECKMARK
    })]
  })
}

function Ku(t) {
  const e = A.useRef(null);
  return A.useEffect(() => {
    const r = e.current;
    r.style.setProperty("--value", r.value), r.style.setProperty("--min", r.min === "" ? "0" : r.min), r.style.setProperty("--max", r.max === "" ? "100" : r.max), r.addEventListener("input", () => r.style.setProperty("--value", r.value))
  }, [e]), Y("div", {
    className: "mb-6 flex flex-row gap-4",
    children: [Y("div", {
      className: "flex w-full flex-col gap-2",
      children: [t.label ? E("label", {
        className: "font-bold",
        children: t.label
      }) : null, E("input", {
        type: "range",
        ref: e,
        className: "styled-slider slider-progress mt-[20px]",
        onChange: t.onChange,
        value: t.value,
        max: t.max,
        min: t.min,
        step: t.step
      })]
    }), E("div", {
      className: "mt-1 aspect-[2/1] h-8 rounded-sm bg-[#1C161B] pt-1",
      children: E("div", {
        className: "text-center font-bold text-white",
        children: t.valueDisplay ? ? t.value
      })
    })]
  })
}

function Pje(t) {
  const {
    t: e
  } = ke(), {
    captionSettings: r,
    setCaptionBackgroundColor: n,
    setCaptionDelay: i,
    setCaptionFontSize: a
  } = id();
  return Y(No, {
    ...t.router.pageProps(t.prefix),
    width: 375,
    children: [E(Ar.Header, {
      title: e("videoPlayer.popouts.captionPreferences.title"),
      description: e("videoPlayer.popouts.descriptions.captionPreferences"),
      goBack: () => t.router.navigate("/captions")
    }), Y(Ar.Content, {
      children: [E(Ku, {
        label: e("videoPlayer.popouts.captionPreferences.delay"),
        max: 10,
        min: -10,
        step: .1,
        valueDisplay: `${r.delay.toFixed(1)}s`,
        value: r.delay,
        onChange: s => i(s.target.valueAsNumber)
      }), E(Ku, {
        label: e("videoPlayer.popouts.captionPreferences.fontSize"),
        min: 14,
        step: 1,
        max: 60,
        value: r.style.fontSize,
        onChange: s => a(s.target.valueAsNumber)
      }), E(Ku, {
        label: e("videoPlayer.popouts.captionPreferences.opacity"),
        step: 1,
        min: 0,
        max: 255,
        valueDisplay: `${(parseInt(r.style.backgroundColor.substring(7,9),16)/255*100).toFixed(0)}%`,
        value: parseInt(r.style.backgroundColor.substring(7, 9), 16),
        onChange: s => n(s.target.valueAsNumber)
      }), Y("div", {
        className: "flex flex-row justify-between",
        children: [E("label", {
          className: "font-bold",
          htmlFor: "color",
          children: e("videoPlayer.popouts.captionPreferences.color")
        }), E("div", {
          className: "flex flex-row gap-2",
          children: XX.map(s => E(QX, {
            color: s
          }))
        })]
      })]
    })]
  })
}
const Nje = [.25, .5, .75, 1, 1.25, 1.5, 2];

function Dje(t) {
  const {
    t: e
  } = ke(), r = Re(), n = st(r), i = Cn(r);
  return Y(No, {
    ...t.router.pageProps(t.prefix),
    width: 320,
    height: 500,
    children: [E(Ar.Header, {
      title: e("videoPlayer.popouts.playbackSpeed"),
      description: e("videoPlayer.popouts.descriptions.playbackSpeed"),
      goBack: () => t.router.navigate("/")
    }), Y(Ar.Content, {
      noSection: !0,
      children: [E(Sf, {
        children: Nje.map(a => Y(rs, {
          active: i.playbackSpeed === a,
          onClick: () => {
            n.setPlaybackSpeed(a), n.closePopout()
          },
          children: [a, "x"]
        }, a))
      }), Y("p", {
        className: "sticky top-0 z-10 flex items-center space-x-1 bg-ash-300 px-5 py-3 text-xs font-bold uppercase",
        children: [E(Ve, {
          className: "text-base",
          icon: ue.TACHOMETER
        }), E("span", {
          children: e("videoPlayer.popouts.customPlaybackSpeed")
        })]
      }), E(Sf, {
        className: "pt-0",
        children: E("div", {
          children: E(Ku, {
            min: .1,
            max: 10,
            step: .1,
            value: i.playbackSpeed,
            valueDisplay: `${i.playbackSpeed}x`,
            onChange: a => n.setPlaybackSpeed(a.target.valueAsNumber)
          })
        })
      })]
    })]
  })
}

function Mje(t) {
  const [e, r, n] = ad(async () => {
    const i = iE(t.type);
    if (!i) throw new Error("Embed scraper not found");
    const a = await Qk(i, {
      progress: () => {},
      url: t.url
    });
    t.onSelect(a)
  });
  return E(rs, {
    isOnDarkBackground: !0,
    loading: r,
    errored: !!n,
    active: t.active,
    onClick: () => {
      e()
    },
    children: t.name
  })
}

function Fje(t) {
  const {
    t: e
  } = ke(), r = Re(), n = st(r), i = ui(r), {
    source: a
  } = vg(r), s = A.useRef(null), o = A.useMemo(() => i ? hq().filter(x => x.type.includes(i.meta.meta.type)) : [], [i]), [c, l] = A.useState(null), [u, f] = A.useState(null), d = A.useMemo(() => o.find(x => x.id === c) ? ? null, [o, c]), [h, p, v] = ad(async x => {
    var _, S;
    const b = o.find(T => T.id === x);
    if (!b) throw new Error("Invalid provider");
    if (!i) throw new Error("need meta");
    return pq(b, {
      media: i.meta,
      progress: () => {},
      type: i.meta.meta.type,
      episode: (_ = i.episode) == null ? void 0 : _.episodeId,
      season: (S = i.episode) == null ? void 0 : S.seasonId
    })
  });

  function g(x) {
    n.setSource({
      quality: x.quality,
      source: x.streamUrl,
      type: x.type,
      embedId: x.embedId,
      providerId: s.current ? ? void 0
    }), i && n.setMeta({
      ...i,
      captions: x.captions
    }), n.closePopout()
  }
  const m = x => {
      if (!x) {
        s.current = null, l(null), t.router.navigate(`/${t.prefix}/source`);
        return
      }
      h(x).then(async b => {
        if (s.current) {
          if (b && b.embeds.length + (b.stream ? 1 : 0) === 1) {
            const S = b.stream;
            if (!S) {
              const T = b == null ? void 0 : b.embeds[0];
              if (!T) throw new Error("Embed scraper not found");
              const R = iE(T.type);
              if (!R) throw new Error("Embed scraper not found");
              const I = await Qk(R, {
                progress: () => {},
                url: T.url
              });
              g(I);
              return
            }
            g(S);
            return
          }
          f(b ? ? null)
        }
      }), s.current = x, l(x), t.router.navigate(`/${t.prefix}/source/embeds`)
    },
    y = A.useMemo(() => {
      const x = (u == null ? void 0 : u.embeds) || [],
        b = {};
      for (const S of x) S.type && (b[S.type] || (b[S.type] = []), b[S.type].push({
        ...S,
        displayName: S.type
      }));
      return Object.entries(b).flatMap(([S, T]) => T.length > 1 ? T.map((R, I) => ({
        ...R,
        displayName: `${R.type} ${I+1}`
      })) : T)
    }, [u == null ? void 0 : u.embeds]);
  return Y(yr, {
    children: [Y(No, {
      ...t.router.pageProps(t.prefix),
      width: 320,
      height: 500,
      children: [E(Ar.Header, {
        title: e("videoPlayer.popouts.sources"),
        description: e("videoPlayer.popouts.descriptions.sources"),
        goBack: () => t.router.navigate("/")
      }), E(Ar.Content, {
        children: o.map(x => E(rs, {
          active: x.id === (a == null ? void 0 : a.providerId),
          onClick: () => {
            m(x.id)
          },
          children: x.displayName
        }, x.id))
      })]
    }), Y(No, {
      ...t.router.pageProps("embeds"),
      width: 320,
      height: 500,
      children: [E(Ar.Header, {
        title: (d == null ? void 0 : d.displayName) ? ? "",
        description: e("videoPlayer.popouts.descriptions.embeds"),
        goBack: () => t.router.navigate(`/${t.prefix}`)
      }), E(Ar.Content, {
        children: p ? E("div", {
          className: "flex h-full w-full items-center justify-center",
          children: E(lg, {})
        }) : v ? E("div", {
          className: "flex h-full w-full items-center justify-center",
          children: Y("div", {
            className: "flex flex-col flex-wrap items-center text-slate-400",
            children: [E(rn, {
              icon: ue.EYE_SLASH,
              className: "text-xl text-bink-600"
            }), E("p", {
              className: "mt-6 w-full text-center",
              children: e("videoPlayer.popouts.errors.embedsError")
            })]
          })
        }) : Y(yr, {
          children: [u != null && u.stream ? E(rs, {
            isOnDarkBackground: !0,
            onClick: () => {
              u.stream && g(u.stream)
            },
            active: (d == null ? void 0 : d.id) === (a == null ? void 0 : a.providerId) && (d == null ? void 0 : d.id) === (a == null ? void 0 : a.embedId),
            children: "Native source"
          }) : null, ((y == null ? void 0 : y.length) || 0) > 0 ? y == null ? void 0 : y.map(x => E(Mje, {
            type: x.type,
            name: x.displayName ? ? "",
            url: x.url,
            active: !1,
            onSelect: b => {
              g(b)
            }
          }, x.url)) : E("div", {
            className: "flex h-full w-full items-center justify-center",
            children: Y("div", {
              className: "flex flex-col flex-wrap items-center text-slate-400",
              children: [E(rn, {
                icon: ue.EYE_SLASH,
                className: "text-xl text-bink-600"
              }), E("p", {
                className: "mt-6 w-full text-center",
                children: e("videoPlayer.popouts.noEmbeds")
              })]
            })
          })]
        })
      })]
    })]
  })
}

function Bje() {
  const t = YX(),
    {
      pageProps: e,
      navigate: r
    } = t;
  return Y(yr, {
    children: [Y(No, {
      ...e("/"),
      width: 320,
      children: [E(KX, {}), Y(Ar.Content, {
        children: [E($je, {}), E(Oje, {
          onClick: () => r("/source")
        }), E(Ije, {
          onClick: () => r("/captions")
        }), E(Cje, {
          onClick: () => r("/playback-speed")
        })]
      })]
    }), E(Fje, {
      router: t,
      prefix: "source"
    }), E(Lje, {
      router: t,
      prefix: "captions"
    }), E(Pje, {
      router: t,
      prefix: "caption-settings"
    }), E(Dje, {
      router: t,
      prefix: "playback-speed"
    })]
  })
}

function Uje(t) {
  return E(yr, {
    children: Object.entries({
      settings: E(Bje, {}),
      episodes: E(Aje, {})
    }).map(([r, n]) => E(wje, {
      show: t.popoutId === r,
      onClose: t.onClose,
      children: E(Tje, {
        for: r,
        onClose: t.onClose,
        children: n
      })
    }, r))
  })
}

function jje() {
  const t = Re(),
    e = Bi(t),
    r = st(t);
  Rje(t);
  const n = A.useCallback(() => {
    r.closePopout()
  }, [r]);
  return E(Uje, {
    popoutId: e.popout,
    onClose: n
  })
}
const Hje = "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1",
  ZX = [];
let BA = null;

function zje(t) {
  BA = t, ZX.forEach(e => e(t))
}

function Gje(t) {
  if (BA !== null) return t(BA);
  ZX.push(t)
}

function Vje() {
  if (window.__onGCastApiAvailable = e => {
      zje(e)
    }, !!!document.getElementById("chromecast-script")) {
    const e = document.createElement("script");
    e.setAttribute("src", Hje), e.setAttribute("id", "chromecast-script"), document.body.appendChild(e)
  }
}

function Wje() {
  const [t, e] = A.useState(null);
  return A.useEffect(() => {
    Gje(r => e(r))
  }, []), t
}
const JX = eE().setKey("mw-volume").addVersion({
  version: 0,
  create() {
    return {
      volume: 1
    }
  }
}).build();

function eQ() {
  return JX.get().volume
}

function tQ(t) {
  JX.save({
    volume: t
  })
}

function C1(t, e) {
  const r = e;
  r.hlsInstance && (r.hlsInstance.destroy(), r.hlsInstance = null), j6e(r), Jt(t, r), Xa(t, r), sd(t, r)
}

function Kje(t) {
  const e = br(t),
    r = e.casting.instance,
    n = e.casting.player,
    i = e.casting.controller;
  return {
    getId() {
      return "casting"
    },
    play() {
      e.mediaPlaying.isPaused && (i == null || i.playOrPause())
    },
    pause() {
      e.mediaPlaying.isPlaying && (i == null || i.playOrPause())
    },
    exitFullscreen() {
      xn.fullscreenElement && xn.exitFullscreen()
    },
    enterFullscreen() {
      if (!(!fO() || xn.fullscreenElement)) {
        if (cE()) {
          e.wrapperElement && xn.requestFullscreen(e.wrapperElement);
          return
        }
        uO() && n.webkitEnterFullscreen()
      }
    },
    startAirplay() {},
    setTime(a) {
      let s = Math.min(a, (n == null ? void 0 : n.duration) ? ? 0);
      s = Math.max(0, s), !Number.isNaN(s) && (n && (n.currentTime = s), e.progress.time = s, i == null || i.seek(), Xa(t, e))
    },
    setSeeking(a) {
      if (e.mediaPlaying.isSeeking = a, e.mediaPlaying.isDragSeeking = a, Jt(t, e), !a) {
        e.pausedWhenSeeking || this.play();
        return
      }
      e.pausedWhenSeeking = e.mediaPlaying.isPaused, this.pause()
    },
    togglePictureInPicture() {},
    setPlaybackSpeed(a) {
      var l, u, f;
      const s = new chrome.cast.media.MediaInfo(((l = e.meta) == null ? void 0 : l.meta.meta.id) ? ? "video", "video/mp4");
      s.contentUrl = (u = e.source) == null ? void 0 : u.url, s.streamType = chrome.cast.media.StreamType.BUFFERED, s.metadata = new chrome.cast.media.MovieMediaMetadata, s.metadata.title = ((f = e.meta) == null ? void 0 : f.meta.meta.title) ? ? "", s.customData = {
        playbackRate: a
      };
      const o = new chrome.cast.media.LoadRequest(s);
      o.autoplay = !0;
      const c = r == null ? void 0 : r.getCurrentSession();
      c == null || c.loadMedia(o)
    },
    async setVolume(a) {
      let s = Math.min(a, 1);
      s = Math.max(0, s), await z0() && n && (n.volumeLevel = s), e.mediaPlaying.volume = s, i == null || i.setVolumeLevel(), Jt(t, e), tQ(s)
    },
    setSource(a) {
      var u, f;
      if (!a) {
        C1(t, e), i == null || i.stop(), e.source = null, io(t, e);
        return
      }
      const s = new chrome.cast.media.MovieMediaMetadata;
      s.title = ((u = e.meta) == null ? void 0 : u.meta.meta.title) ? ? "";
      const o = new chrome.cast.media.MediaInfo(((f = e.meta) == null ? void 0 : f.meta.meta.id) ? ? "video", "video/mp4");
      o.contentUrl = a == null ? void 0 : a.source, o.streamType = chrome.cast.media.StreamType.BUFFERED, o.metadata = s;
      const c = new chrome.cast.media.LoadRequest(o);
      c.autoplay = !0;
      const l = r == null ? void 0 : r.getCurrentSession();
      l == null || l.loadMedia(c), e.source = {
        quality: a.quality,
        type: a.type,
        url: a.source,
        caption: null,
        embedId: a.embedId,
        providerId: a.providerId
      }, C1(t, e), io(t, e)
    },
    setCaption(a, s) {
      var o;
      e.source && (E1((o = e.source.caption) == null ? void 0 : o.url), e.source.caption = {
        id: a,
        url: s
      }, io(t, e))
    },
    clearCaption() {
      var a;
      e.source && (E1((a = e.source.caption) == null ? void 0 : a.url), e.source.caption = null, io(t, e))
    },
    providerStart() {
      var c, l, u;
      this.setVolume(eQ());
      const a = async f => {
        switch (f.field) {
          case "volumeLevel":
            await z0() && (e.mediaPlaying.volume = f.value, Jt(t, e));
            break;
          case "currentTime":
            e.progress.time = f.value, Xa(t, e);
            break;
          case "mediaInfo":
            f.value && (e.progress.duration = f.value.duration, Xa(t, e));
            break;
          case "playerState":
            e.mediaPlaying.isLoading = f.value === "BUFFERING", e.mediaPlaying.isPaused = f.value !== "PLAYING", e.mediaPlaying.isPlaying = f.value === "PLAYING", f.value === "PLAYING" && (e.mediaPlaying.hasPlayedOnce = !0, e.mediaPlaying.isFirstLoading = !1), Jt(t, e);
            break;
          case "isMuted":
            e.mediaPlaying.volume = f.value ? 1 : 0, Jt(t, e);
            break;
          case "displayStatus":
          case "canSeek":
          case "title":
          case "isPaused":
            break;
          default:
            console.log(f.type, f.field, f.value);
            break
        }
      }, s = () => {
        e.interface.isFullscreen = !!document.fullscreenElement, mn(t, e)
      }, o = f => {
        e.interface.isFocused = f.type !== "mouseleave", mn(t, e)
      };
      return i == null || i.addEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, a), (c = e.wrapperElement) == null || c.addEventListener("click", o), (l = e.wrapperElement) == null || l.addEventListener("mouseenter", o), (u = e.wrapperElement) == null || u.addEventListener("mouseleave", o), xn.addEventListener("fullscreenchange", s), e.source && this.setSource({
        quality: e.source.quality,
        source: e.source.url,
        type: e.source.type,
        embedId: e.source.embedId,
        providerId: e.source.providerId
      }), {
        destroy: () => {
          var f, d, h;
          i == null || i.removeEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, a), (f = e.wrapperElement) == null || f.removeEventListener("click", o), (d = e.wrapperElement) == null || d.removeEventListener("mouseenter", o), (h = e.wrapperElement) == null || h.removeEventListener("mouseleave", o), xn.removeEventListener("fullscreenchange", s), r == null || r.endCurrentSession(!0)
        }
      }
    }
  }
}

function rQ(t, e) {
  const r = br(t);
  r.stateProvider = e, r.initalized = !0, r.stateProviderId = e.getId(), sd(t, r)
}

function nQ(t, e) {
  var n;
  const r = br(t);
  !r.stateProvider || ((n = r.stateProvider) == null ? void 0 : n.getId()) !== e || (r.stateProvider = null, r.stateProviderId = "video", sd(t, r))
}

function Yje(t, e) {
  for (let r = 0; r < e.length; r += 1)
    if (e.start(e.length - 1 - r) < t) return e.end(e.length - 1 - r);
  return 0
}

function qje() {
  const t = Re(),
    e = Ss(t),
    r = A.useRef(!1),
    n = Wje(),
    i = A.useMemo(() => e.isCasting, [e]);
  return A.useEffect(() => {
    if (r.current === i || (r.current = i, !i)) return;
    const a = Kje(t);
    rQ(t, a);
    const {
      destroy: s
    } = a.providerStart();
    return () => {
      try {
        nQ(t, a.getId())
      } catch {}
      s()
    }
  }, [t, i]), A.useEffect(() => {
    const a = br(t);
    if (!n) return;
    a.casting.instance = cast.framework.CastContext.getInstance(), a.casting.instance.setOptions({
      receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
    }), a.casting.player = new cast.framework.RemotePlayer, a.casting.controller = new cast.framework.RemotePlayerController(a.casting.player);

    function s(o) {
      o.field === "isConnected" && (a.casting.isCasting = o.value, sd(t, a))
    }
    return a.casting.controller.addEventListener(cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED, s), () => {
      var o;
      (o = a.casting.controller) == null || o.removeEventListener(cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED, s)
    }
  }, [n, t]), null
}

function Xje(t) {
  const e = Re();
  return A.useEffect(() => {
    const r = br(e);
    r.wrapperElement = t.wrapper, sd(e, r)
  }, [t.wrapper, e]), null
}
class Qje extends A.Component {
  constructor(e) {
    super(e), this.state = {
      hasError: !1
    }
  }
  static getDerivedStateFromError() {
    return {
      hasError: !0
    }
  }
  componentDidCatch(e, r) {
    if (console.error("Render error caught", e, r), e instanceof Error) {
      const n = e;
      this.setState(i => ({
        ...i,
        hasError: !0,
        error: {
          name: n.name,
          description: n.message,
          path: r.componentStack.split(`
`)[1]
        }
      }))
    }
  }
  render() {
    return this.state.hasError ? Y("div", {
      className: "absolute inset-0 bg-denim-100",
      children: [E("div", {
        className: "pointer-events-auto absolute inset-x-0 top-0 flex flex-col px-8 py-6 pb-2",
        children: E(Ec, {
          media: this.props.media,
          onClick: this.props.onGoBack
        })
      }), E(Gk, {
        error: this.state.error,
        localSize: !0,
        children: Y(zk, {
          i18nKey: "videoPlayer.errors.fatalError",
          children: [E(g1, {
            url: kr().DISCORD_LINK,
            newTab: !0
          }), E(g1, {
            url: kr().GITHUB_LINK,
            newTab: !0
          })]
        })
      })]
    }) : this.props.children
  }
}

function Zje() {
  const t = Re(),
    e = ui(t),
    r = Xo(t);
  return A.useEffect(() => (window.meta || (window.meta = {}), e && (window.meta[t] = {
    meta: e.meta,
    captions: e.captions,
    seasons: e.seasons,
    episode: e.episode,
    progress: {
      time: r.time,
      duration: r.duration
    }
  }), () => {
    window.meta && delete window.meta[t]
  }), [e, t, r]), null
}
var Z0 = {},
  Jje = {
    get exports() {
      return Z0
    },
    set exports(t) {
      Z0 = t
    }
  };
(function (t, e) {
  (function (r) {
    var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
      i = /^(?=([^\/?#]*))\1([^]*)$/,
      a = /(?:\/|^)\.(?=\/)/g,
      s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
      o = {
        buildAbsoluteURL: function (c, l, u) {
          if (u = u || {}, c = c.trim(), l = l.trim(), !l) {
            if (!u.alwaysNormalize) return c;
            var f = o.parseURL(c);
            if (!f) throw new Error("Error trying to parse base URL.");
            return f.path = o.normalizePath(f.path), o.buildURLFromParts(f)
          }
          var d = o.parseURL(l);
          if (!d) throw new Error("Error trying to parse relative URL.");
          if (d.scheme) return u.alwaysNormalize ? (d.path = o.normalizePath(d.path), o.buildURLFromParts(d)) : l;
          var h = o.parseURL(c);
          if (!h) throw new Error("Error trying to parse base URL.");
          if (!h.netLoc && h.path && h.path[0] !== "/") {
            var p = i.exec(h.path);
            h.netLoc = p[1], h.path = p[2]
          }
          h.netLoc && !h.path && (h.path = "/");
          var v = {
            scheme: h.scheme,
            netLoc: d.netLoc,
            path: null,
            params: d.params,
            query: d.query,
            fragment: d.fragment
          };
          if (!d.netLoc && (v.netLoc = h.netLoc, d.path[0] !== "/"))
            if (!d.path) v.path = h.path, d.params || (v.params = h.params, d.query || (v.query = h.query));
            else {
              var g = h.path,
                m = g.substring(0, g.lastIndexOf("/") + 1) + d.path;
              v.path = o.normalizePath(m)
            } return v.path === null && (v.path = u.alwaysNormalize ? o.normalizePath(d.path) : d.path), o.buildURLFromParts(v)
        },
        parseURL: function (c) {
          var l = n.exec(c);
          return l ? {
            scheme: l[1] || "",
            netLoc: l[2] || "",
            path: l[3] || "",
            params: l[4] || "",
            query: l[5] || "",
            fragment: l[6] || ""
          } : null
        },
        normalizePath: function (c) {
          for (c = c.split("").reverse().join("").replace(a, ""); c.length !== (c = c.replace(s, "")).length;);
          return c.split("").reverse().join("")
        },
        buildURLFromParts: function (c) {
          return c.scheme + c.netLoc + c.path + c.params + c.query + c.fragment
        }
      };
    t.exports = o
  })()
})(Jje);

function $5(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function an(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $5(Object(r), !0).forEach(function (n) {
      eHe(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : $5(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function eHe(t, e, r) {
  return e = rHe(e), e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t
}

function Nt() {
  return Nt = Object.assign ? Object.assign.bind() : function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
    }
    return t
  }, Nt.apply(this, arguments)
}

function tHe(t, e) {
  if (typeof t != "object" || t === null) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(t)
}

function rHe(t) {
  var e = tHe(t, "string");
  return typeof e == "symbol" ? e : String(e)
}
const ge = Number.isFinite || function (t) {
  return typeof t == "number" && isFinite(t)
};
let $ = function (t) {
    return t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached", t
  }({}),
  ve = function (t) {
    return t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError", t
  }({}),
  q = function (t) {
    return t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_PARSING_ERROR = "levelParsingError", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.FRAG_GAP = "fragGap", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.UNKNOWN = "unknown", t
  }({});
const yl = function () {},
  UA = {
    trace: yl,
    debug: yl,
    log: yl,
    warn: yl,
    info: yl,
    error: yl
  };
let a0 = UA;

function nHe(t) {
  const e = self.console[t];
  return e ? e.bind(self.console, `[${t}] >`) : yl
}

function iHe(t, ...e) {
  e.forEach(function (r) {
    a0[r] = t[r] ? t[r].bind(t) : nHe(r)
  })
}

function aHe(t, e) {
  if (self.console && t === !0 || typeof t == "object") {
    iHe(t, "debug", "log", "info", "warn", "error");
    try {
      a0.log(`Debug logs enabled for "${e}" in hls.js version 1.4.0`)
    } catch {
      a0 = UA
    }
  } else a0 = UA
}
const G = a0,
  sHe = /^(\d+)x(\d+)$/,
  C5 = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class mt {
  constructor(e) {
    typeof e == "string" && (e = mt.parseAttrList(e));
    for (const r in e) e.hasOwnProperty(r) && (r.substring(0, 2) === "X-" && (this.clientAttrs = this.clientAttrs || [], this.clientAttrs.push(r)), this[r] = e[r])
  }
  decimalInteger(e) {
    const r = parseInt(this[e], 10);
    return r > Number.MAX_SAFE_INTEGER ? 1 / 0 : r
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let r = (this[e] || "0x").slice(2);
      r = (r.length & 1 ? "0" : "") + r;
      const n = new Uint8Array(r.length / 2);
      for (let i = 0; i < r.length / 2; i++) n[i] = parseInt(r.slice(i * 2, i * 2 + 2), 16);
      return n
    } else return null
  }
  hexadecimalIntegerAsNumber(e) {
    const r = parseInt(this[e], 16);
    return r > Number.MAX_SAFE_INTEGER ? 1 / 0 : r
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e])
  }
  optionalFloat(e, r) {
    const n = this[e];
    return n ? parseFloat(n) : r
  }
  enumeratedString(e) {
    return this[e]
  }
  bool(e) {
    return this[e] === "YES"
  }
  decimalResolution(e) {
    const r = sHe.exec(this[e]);
    if (r !== null) return {
      width: parseInt(r[1], 10),
      height: parseInt(r[2], 10)
    }
  }
  static parseAttrList(e) {
    let r;
    const n = {},
      i = '"';
    for (C5.lastIndex = 0;
      (r = C5.exec(e)) !== null;) {
      let a = r[2];
      a.indexOf(i) === 0 && a.lastIndexOf(i) === a.length - 1 && (a = a.slice(1, -1));
      const s = r[1].trim();
      n[s] = a
    }
    return n
  }
}

function oHe(t) {
  return t !== "ID" && t !== "CLASS" && t !== "START-DATE" && t !== "DURATION" && t !== "END-DATE" && t !== "END-ON-NEXT"
}

function lHe(t) {
  return t === "SCTE35-OUT" || t === "SCTE35-IN"
}
class iQ {
  constructor(e, r) {
    if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, r) {
      const n = r.attr;
      for (const i in n)
        if (Object.prototype.hasOwnProperty.call(e, i) && e[i] !== n[i]) {
          G.warn(`DATERANGE tag attribute: "${i}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = i;
          break
        } e = Nt(new mt({}), n, e)
    }
    if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const n = new Date(this.attr["END-DATE"]);
      ge(n.getTime()) && (this._endDate = n)
    }
  }
  get id() {
    return this.attr.ID
  }
  get class() {
    return this.attr.CLASS
  }
  get startDate() {
    return this._startDate
  }
  get endDate() {
    if (this._endDate) return this._endDate;
    const e = this.duration;
    return e !== null ? new Date(this._startDate.getTime() + e * 1e3) : null
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (ge(e)) return e
    } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT")
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && ge(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class)
  }
}
class bE {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    }
  }
}
var Qe = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class aQ {
  constructor(e) {
    this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
      [Qe.AUDIO]: null,
      [Qe.VIDEO]: null,
      [Qe.AUDIOVIDEO]: null
    }, this.baseurl = e
  }
  setByteRange(e, r) {
    const n = e.split("@", 2),
      i = [];
    n.length === 1 ? i[0] = r ? r.byteRangeEndOffset : 0 : i[0] = parseInt(n[1]), i[1] = parseInt(n[0]) + i[0], this._byteRange = i
  }
  get byteRange() {
    return this._byteRange ? this._byteRange : []
  }
  get byteRangeStartOffset() {
    return this.byteRange[0]
  }
  get byteRangeEndOffset() {
    return this.byteRange[1]
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = Z0.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || ""
  }
  set url(e) {
    this._url = e
  }
}
class XT extends aQ {
  constructor(e, r) {
    super(r), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new bE, this.urlId = 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.type = e
  }
  get decryptdata() {
    const {
      levelkeys: e
    } = this;
    if (!e && !this._decryptdata) return null;
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const r = this.levelkeys.identity;
      if (r) this._decryptdata = r.getDecryptData(this.sn);
      else {
        const n = Object.keys(this.levelkeys);
        if (n.length === 1) return this._decryptdata = this.levelkeys[n[0]].getDecryptData(this.sn)
      }
    }
    return this._decryptdata
  }
  get end() {
    return this.start + this.duration
  }
  get endProgramDateTime() {
    if (this.programDateTime === null || !ge(this.programDateTime)) return null;
    const e = ge(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted) return !0;
    if (this.levelkeys) {
      const r = Object.keys(this.levelkeys),
        n = r.length;
      if (n > 1 || n === 1 && this.levelkeys[r[0]].encrypted) return !0
    }
    return !1
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const r = this.levelkeys[e];
      r && !this._decryptdata && (this._decryptdata = r.getDecryptData(this.sn))
    }
  }
  abortRequests() {
    var e, r;
    (e = this.loader) == null || e.abort(), (r = this.keyLoader) == null || r.abort()
  }
  setElementaryStreamInfo(e, r, n, i, a, s = !1) {
    const {
      elementaryStreams: o
    } = this, c = o[e];
    if (!c) {
      o[e] = {
        startPTS: r,
        endPTS: n,
        startDTS: i,
        endDTS: a,
        partial: s
      };
      return
    }
    c.startPTS = Math.min(c.startPTS, r), c.endPTS = Math.max(c.endPTS, n), c.startDTS = Math.min(c.startDTS, i), c.endDTS = Math.max(c.endDTS, a)
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[Qe.AUDIO] = null, e[Qe.VIDEO] = null, e[Qe.AUDIOVIDEO] = null
  }
}
class cHe extends aQ {
  constructor(e, r, n, i, a) {
    super(n), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new bE, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = r, this.index = i;
    const s = e.enumeratedString("BYTERANGE");
    s && this.setByteRange(s, a), a && (this.fragOffset = a.fragOffset + a.duration)
  }
  get start() {
    return this.fragment.start + this.fragOffset
  }
  get end() {
    return this.start + this.duration
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo)
  }
}
const uHe = 10;
class fHe {
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return
    }
    const r = this.lastPartSn - e.lastPartSn,
      n = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!n || !!r, this.advanced = this.endSN > e.endSN || r > 0 || r === 0 && n > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * .6) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
  }
  get hasProgramDateTime() {
    return this.fragments.length ? ge(this.fragments[this.fragments.length - 1].programDateTime) : !1
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || uHe
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1
  }
  get edge() {
    return this.partEnd || this.fragmentEnd
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
  }
  get fragmentEnd() {
    var e;
    return (e = this.fragments) != null && e.length ? this.fragments[this.fragments.length - 1].end : 0
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
  }
}

function AO(t) {
  return Uint8Array.from(atob(t), e => e.charCodeAt(0))
}

function dHe(t) {
  const e = sQ(t).subarray(0, 16),
    r = new Uint8Array(16);
  return r.set(e, 16 - e.length), r
}

function hHe(t) {
  const e = function (n, i, a) {
    const s = n[i];
    n[i] = n[a], n[a] = s
  };
  e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7)
}

function pHe(t) {
  const e = t.split(":");
  let r = null;
  if (e[0] === "data" && e.length === 2) {
    const n = e[1].split(";"),
      i = n[n.length - 1].split(",");
    if (i.length === 2) {
      const a = i[0] === "base64",
        s = i[1];
      a ? (n.splice(-1, 1), r = AO(s)) : r = dHe(s)
    }
  }
  return r
}

function sQ(t) {
  return Uint8Array.from(unescape(encodeURIComponent(t)), e => e.charCodeAt(0))
}
var vt = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
  },
  qr = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
  };

function k5(t) {
  switch (t) {
    case qr.FAIRPLAY:
      return vt.FAIRPLAY;
    case qr.PLAYREADY:
      return vt.PLAYREADY;
    case qr.WIDEVINE:
      return vt.WIDEVINE;
    case qr.CLEARKEY:
      return vt.CLEARKEY
  }
}
var oQ = {
  WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
};

function gHe(t) {
  if (t === oQ.WIDEVINE) return vt.WIDEVINE
}

function O5(t) {
  switch (t) {
    case vt.FAIRPLAY:
      return qr.FAIRPLAY;
    case vt.PLAYREADY:
      return qr.PLAYREADY;
    case vt.WIDEVINE:
      return qr.WIDEVINE;
    case vt.CLEARKEY:
      return qr.CLEARKEY
  }
}

function QT(t) {
  const {
    drmSystems: e,
    widevineLicenseUrl: r
  } = t, n = e ? [vt.FAIRPLAY, vt.WIDEVINE, vt.PLAYREADY, vt.CLEARKEY].filter(i => !!e[i]) : [];
  return !n[vt.WIDEVINE] && r && n.push(vt.WIDEVINE), n
}
const lQ = function () {
  return typeof self < "u" && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
}();

function mHe(t, e, r, n) {
  let i;
  switch (t) {
    case vt.FAIRPLAY:
      i = ["cenc", "sinf"];
      break;
    case vt.WIDEVINE:
    case vt.PLAYREADY:
      i = ["cenc"];
      break;
    case vt.CLEARKEY:
      i = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${t}`)
  }
  return vHe(i, e, r, n)
}

function vHe(t, e, r, n) {
  return [{
    initDataTypes: t,
    persistentState: n.persistentState || "not-allowed",
    distinctiveIdentifier: n.distinctiveIdentifier || "not-allowed",
    sessionTypes: n.sessionTypes || [n.sessionType || "temporary"],
    audioCapabilities: e.map(a => ({
      contentType: `audio/mp4; codecs="${a}"`,
      robustness: n.audioRobustness || "",
      encryptionScheme: n.audioEncryptionScheme || null
    })),
    videoCapabilities: r.map(a => ({
      contentType: `video/mp4; codecs="${a}"`,
      robustness: n.videoRobustness || "",
      encryptionScheme: n.videoEncryptionScheme || null
    }))
  }]
}

function Hl(t, e, r) {
  return Uint8Array.prototype.slice ? t.slice(e, r) : new Uint8Array(Array.prototype.slice.call(t, e, r))
}
const IO = (t, e) => e + 10 <= t.length && t[e] === 73 && t[e + 1] === 68 && t[e + 2] === 51 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128,
  cQ = (t, e) => e + 10 <= t.length && t[e] === 51 && t[e + 1] === 68 && t[e + 2] === 73 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128,
  k1 = (t, e) => {
    const r = e;
    let n = 0;
    for (; IO(t, e);) {
      n += 10;
      const i = EE(t, e + 6);
      n += i, cQ(t, e + 10) && (n += 10), e += n
    }
    if (n > 0) return t.subarray(r, r + n)
  },
  EE = (t, e) => {
    let r = 0;
    return r = (t[e] & 127) << 21, r |= (t[e + 1] & 127) << 14, r |= (t[e + 2] & 127) << 7, r |= t[e + 3] & 127, r
  },
  yHe = (t, e) => IO(t, e) && EE(t, e + 6) + 10 <= t.length - e,
  xHe = t => {
    const e = fQ(t);
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (uQ(n)) return wHe(n)
    }
  },
  uQ = t => t && t.key === "PRIV" && t.info === "com.apple.streaming.transportStreamTimestamp",
  bHe = t => {
    const e = String.fromCharCode(t[0], t[1], t[2], t[3]),
      r = EE(t, 4),
      n = 10;
    return {
      type: e,
      size: r,
      data: t.subarray(n, n + r)
    }
  },
  fQ = t => {
    let e = 0;
    const r = [];
    for (; IO(t, e);) {
      const n = EE(t, e + 6);
      e += 10;
      const i = e + n;
      for (; e + 8 < i;) {
        const a = bHe(t.subarray(e)),
          s = EHe(a);
        s && r.push(s), e += a.size + 10
      }
      cQ(t, e) && (e += 10)
    }
    return r
  },
  EHe = t => t.type === "PRIV" ? SHe(t) : t.type[0] === "W" ? THe(t) : _He(t),
  SHe = t => {
    if (t.size < 2) return;
    const e = fa(t.data, !0),
      r = new Uint8Array(t.data.subarray(e.length + 1));
    return {
      key: t.type,
      info: e,
      data: r.buffer
    }
  },
  _He = t => {
    if (t.size < 2) return;
    if (t.type === "TXXX") {
      let r = 1;
      const n = fa(t.data.subarray(r), !0);
      r += n.length + 1;
      const i = fa(t.data.subarray(r));
      return {
        key: t.type,
        info: n,
        data: i
      }
    }
    const e = fa(t.data.subarray(1));
    return {
      key: t.type,
      data: e
    }
  },
  THe = t => {
    if (t.type === "WXXX") {
      if (t.size < 2) return;
      let r = 1;
      const n = fa(t.data.subarray(r), !0);
      r += n.length + 1;
      const i = fa(t.data.subarray(r));
      return {
        key: t.type,
        info: n,
        data: i
      }
    }
    const e = fa(t.data);
    return {
      key: t.type,
      data: e
    }
  },
  wHe = t => {
    if (t.data.byteLength === 8) {
      const e = new Uint8Array(t.data),
        r = e[3] & 1;
      let n = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
      return n /= 45, r && (n += 4772185884e-2), Math.round(n)
    }
  },
  fa = (t, e = !1) => {
    const r = RHe();
    if (r) {
      const l = r.decode(t);
      if (e) {
        const u = l.indexOf("\0");
        return u !== -1 ? l.substring(0, u) : l
      }
      return l.replace(/\0/g, "")
    }
    const n = t.length;
    let i, a, s, o = "",
      c = 0;
    for (; c < n;) {
      if (i = t[c++], i === 0 && e) return o;
      if (i === 0 || i === 3) continue;
      switch (i >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          o += String.fromCharCode(i);
          break;
        case 12:
        case 13:
          a = t[c++], o += String.fromCharCode((i & 31) << 6 | a & 63);
          break;
        case 14:
          a = t[c++], s = t[c++], o += String.fromCharCode((i & 15) << 12 | (a & 63) << 6 | (s & 63) << 0);
          break
      }
    }
    return o
  };
let ZT;

function RHe() {
  return !ZT && typeof self.TextDecoder < "u" && (ZT = new self.TextDecoder("utf-8")), ZT
}
const Ji = {
    hexDump: function (t) {
      let e = "";
      for (let r = 0; r < t.length; r++) {
        let n = t[r].toString(16);
        n.length < 2 && (n = "0" + n), e += n
      }
      return e
    }
  },
  O1 = Math.pow(2, 32) - 1,
  AHe = [].push,
  dQ = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };

function Qt(t) {
  return String.fromCharCode.apply(null, t)
}

function hQ(t, e) {
  const r = t[e] << 8 | t[e + 1];
  return r < 0 ? 65536 + r : r
}

function Ee(t, e) {
  const r = pQ(t, e);
  return r < 0 ? 4294967296 + r : r
}

function pQ(t, e) {
  return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]
}

function JT(t, e, r) {
  t[e] = r >> 24, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = r & 255
}

function Ue(t, e) {
  const r = [];
  if (!e.length) return r;
  const n = t.byteLength;
  for (let i = 0; i < n;) {
    const a = Ee(t, i),
      s = Qt(t.subarray(i + 4, i + 8)),
      o = a > 1 ? i + a : n;
    if (s === e[0])
      if (e.length === 1) r.push(t.subarray(i + 8, o));
      else {
        const c = Ue(t.subarray(i + 8, o), e.slice(1));
        c.length && AHe.apply(r, c)
      } i = o
  }
  return r
}

function IHe(t) {
  const e = [],
    r = t[0];
  let n = 8;
  const i = Ee(t, n);
  n += 4;
  const a = 0,
    s = 0;
  r === 0 ? n += 8 : n += 16, n += 2;
  let o = t.length + s;
  const c = hQ(t, n);
  n += 2;
  for (let l = 0; l < c; l++) {
    let u = n;
    const f = Ee(t, u);
    u += 4;
    const d = f & 2147483647;
    if ((f & 2147483648) >>> 31 === 1) return G.warn("SIDX has hierarchical references (not supported)"), null;
    const p = Ee(t, u);
    u += 4, e.push({
      referenceSize: d,
      subsegmentDuration: p,
      info: {
        duration: p / i,
        start: o,
        end: o + d - 1
      }
    }), o += d, u += 4, n = u
  }
  return {
    earliestPresentationTime: a,
    timescale: i,
    version: r,
    referencesCount: c,
    references: e
  }
}

function gQ(t) {
  const e = [],
    r = Ue(t, ["moov", "trak"]);
  for (let i = 0; i < r.length; i++) {
    const a = r[i],
      s = Ue(a, ["tkhd"])[0];
    if (s) {
      let o = s[0],
        c = o === 0 ? 12 : 20;
      const l = Ee(s, c),
        u = Ue(a, ["mdia", "mdhd"])[0];
      if (u) {
        o = u[0], c = o === 0 ? 12 : 20;
        const f = Ee(u, c),
          d = Ue(a, ["mdia", "hdlr"])[0];
        if (d) {
          const h = Qt(d.subarray(8, 12)),
            p = {
              soun: Qe.AUDIO,
              vide: Qe.VIDEO
            } [h];
          if (p) {
            const v = Ue(a, ["mdia", "minf", "stbl", "stsd"])[0];
            let g;
            v && (g = Qt(v.subarray(12, 16))), e[l] = {
              timescale: f,
              type: p
            }, e[p] = {
              timescale: f,
              id: l,
              codec: g
            }
          }
        }
      }
    }
  }
  return Ue(t, ["moov", "mvex", "trex"]).forEach(i => {
    const a = Ee(i, 4),
      s = e[a];
    s && (s.default = {
      duration: Ee(i, 12),
      flags: Ee(i, 20)
    })
  }), e
}

function $He(t, e) {
  if (!t || !e) return t;
  const r = e.keyId;
  return r && e.isCommonEncryption && Ue(t, ["moov", "trak"]).forEach(i => {
    const s = Ue(i, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
    let o = Ue(s, ["enca"]);
    const c = o.length > 0;
    c || (o = Ue(s, ["encv"])), o.forEach(l => {
      const u = c ? l.subarray(28) : l.subarray(78);
      Ue(u, ["sinf"]).forEach(d => {
        const h = mQ(d);
        if (h) {
          const p = h.subarray(8, 24);
          p.some(v => v !== 0) || (G.log(`[eme] Patching keyId in 'enc${c?"a":"v"}>sinf>>tenc' box: ${Ji.hexDump(p)} -> ${Ji.hexDump(r)}`), h.set(r, 8))
        }
      })
    })
  }), t
}

function mQ(t) {
  const e = Ue(t, ["schm"])[0];
  if (e) {
    const r = Qt(e.subarray(4, 8));
    if (r === "cbcs" || r === "cenc") return Ue(t, ["schi", "tenc"])[0]
  }
  return G.error("[eme] missing 'schm' box"), null
}

function CHe(t, e) {
  return Ue(e, ["moof", "traf"]).reduce((r, n) => {
    const i = Ue(n, ["tfdt"])[0],
      a = i[0],
      s = Ue(n, ["tfhd"]).reduce((o, c) => {
        const l = Ee(c, 4),
          u = t[l];
        if (u) {
          let f = Ee(i, 4);
          if (a === 1) {
            if (f === O1) return G.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), o;
            f *= O1 + 1, f += Ee(i, 8)
          }
          const d = u.timescale || 9e4,
            h = f / d;
          if (isFinite(h) && (o === null || h < o)) return h
        }
        return o
      }, null);
    return s !== null && isFinite(s) && (r === null || s < r) ? s : r
  }, null)
}

function kHe(t, e) {
  let r = 0,
    n = 0,
    i = 0;
  const a = Ue(t, ["moof", "traf"]);
  for (let s = 0; s < a.length; s++) {
    const o = a[s],
      c = Ue(o, ["tfhd"])[0],
      l = Ee(c, 4),
      u = e[l];
    if (!u) continue;
    const f = u.default,
      d = Ee(c, 0) | (f == null ? void 0 : f.flags);
    let h = f == null ? void 0 : f.duration;
    d & 8 && (d & 2 ? h = Ee(c, 12) : h = Ee(c, 8));
    const p = u.timescale || 9e4,
      v = Ue(o, ["trun"]);
    for (let g = 0; g < v.length; g++) {
      if (r = OHe(v[g]), !r && h) {
        const m = Ee(v[g], 4);
        r = h * m
      }
      u.type === Qe.VIDEO ? n += r / p : u.type === Qe.AUDIO && (i += r / p)
    }
  }
  if (n === 0 && i === 0) {
    let s = 0;
    const o = Ue(t, ["sidx"]);
    for (let c = 0; c < o.length; c++) {
      const l = IHe(o[c]);
      l != null && l.references && (s += l.references.reduce((u, f) => u + f.info.duration || 0, 0))
    }
    return s
  }
  return n || i
}

function OHe(t) {
  const e = Ee(t, 0);
  let r = 8;
  e & 1 && (r += 4), e & 4 && (r += 4);
  let n = 0;
  const i = Ee(t, 4);
  for (let a = 0; a < i; a++) {
    if (e & 256) {
      const s = Ee(t, r);
      n += s, r += 4
    }
    e & 512 && (r += 4), e & 1024 && (r += 4), e & 2048 && (r += 4)
  }
  return n
}

function LHe(t, e, r) {
  Ue(e, ["moof", "traf"]).forEach(n => {
    Ue(n, ["tfhd"]).forEach(i => {
      const a = Ee(i, 4),
        s = t[a];
      if (!s) return;
      const o = s.timescale || 9e4;
      Ue(n, ["tfdt"]).forEach(c => {
        const l = c[0];
        let u = Ee(c, 4);
        if (l === 0) u -= r * o, u = Math.max(u, 0), JT(c, 4, u);
        else {
          u *= Math.pow(2, 32), u += Ee(c, 8), u -= r * o, u = Math.max(u, 0);
          const f = Math.floor(u / (O1 + 1)),
            d = Math.floor(u % (O1 + 1));
          JT(c, 4, f), JT(c, 8, d)
        }
      })
    })
  })
}

function PHe(t) {
  const e = {
      valid: null,
      remainder: null
    },
    r = Ue(t, ["moof"]);
  if (r) {
    if (r.length < 2) return e.remainder = t, e
  } else return e;
  const n = r[r.length - 1];
  return e.valid = Hl(t, 0, n.byteOffset - 8), e.remainder = Hl(t, n.byteOffset - 8), e
}

function tc(t, e) {
  const r = new Uint8Array(t.length + e.length);
  return r.set(t), r.set(e, t.length), r
}

function L5(t, e) {
  const r = [],
    n = e.samples,
    i = e.timescale,
    a = e.id;
  let s = !1;
  return Ue(n, ["moof"]).map(c => {
    const l = c.byteOffset - 8;
    Ue(c, ["traf"]).map(f => {
      const d = Ue(f, ["tfdt"]).map(h => {
        const p = h[0];
        let v = Ee(h, 4);
        return p === 1 && (v *= Math.pow(2, 32), v += Ee(h, 8)), v / i
      })[0];
      return d !== void 0 && (t = d), Ue(f, ["tfhd"]).map(h => {
        const p = Ee(h, 4),
          v = Ee(h, 0) & 16777215,
          g = (v & 1) !== 0,
          m = (v & 2) !== 0,
          y = (v & 8) !== 0;
        let x = 0;
        const b = (v & 16) !== 0;
        let _ = 0;
        const S = (v & 32) !== 0;
        let T = 8;
        p === a && (g && (T += 8), m && (T += 4), y && (x = Ee(h, T), T += 4), b && (_ = Ee(h, T), T += 4), S && (T += 4), e.type === "video" && (s = NHe(e.codec)), Ue(f, ["trun"]).map(R => {
          const I = R[0],
            w = Ee(R, 0) & 16777215,
            C = (w & 1) !== 0;
          let L = 0;
          const H = (w & 4) !== 0,
            N = (w & 256) !== 0;
          let P = 0;
          const B = (w & 512) !== 0;
          let V = 0;
          const M = (w & 1024) !== 0,
            U = (w & 2048) !== 0;
          let W = 0;
          const k = Ee(R, 4);
          let O = 8;
          C && (L = Ee(R, O), O += 4), H && (O += 4);
          let F = L + l;
          for (let D = 0; D < k; D++) {
            if (N ? (P = Ee(R, O), O += 4) : P = x, B ? (V = Ee(R, O), O += 4) : V = _, M && (O += 4), U && (I === 0 ? W = Ee(R, O) : W = pQ(R, O), O += 4), e.type === Qe.VIDEO) {
              let Q = 0;
              for (; Q < V;) {
                const ee = Ee(n, F);
                if (F += 4, DHe(s, n[F])) {
                  const de = n.subarray(F, F + ee);
                  vQ(de, s ? 2 : 1, t + W / i, r)
                }
                F += ee, Q += ee + 4
              }
            }
            t += P / i
          }
        }))
      })
    })
  }), r
}

function NHe(t) {
  if (!t) return !1;
  const e = t.indexOf("."),
    r = e < 0 ? t : t.substring(0, e);
  return r === "hvc1" || r === "hev1" || r === "dvh1" || r === "dvhe"
}

function DHe(t, e) {
  if (t) {
    const r = e >> 1 & 63;
    return r === 39 || r === 40
  } else return (e & 31) === 6
}

function vQ(t, e, r, n) {
  const i = yQ(t);
  let a = 0;
  a += e;
  let s = 0,
    o = 0,
    c = !1,
    l = 0;
  for (; a < i.length;) {
    s = 0;
    do {
      if (a >= i.length) break;
      l = i[a++], s += l
    } while (l === 255);
    o = 0;
    do {
      if (a >= i.length) break;
      l = i[a++], o += l
    } while (l === 255);
    const u = i.length - a;
    if (!c && s === 4 && a < i.length) {
      if (c = !0, i[a++] === 181) {
        const d = hQ(i, a);
        if (a += 2, d === 49) {
          const h = Ee(i, a);
          if (a += 4, h === 1195456820) {
            const p = i[a++];
            if (p === 3) {
              const v = i[a++],
                g = 31 & v,
                m = 64 & v,
                y = m ? 2 + g * 3 : 0,
                x = new Uint8Array(y);
              if (m) {
                x[0] = v;
                for (let b = 1; b < y; b++) x[b] = i[a++]
              }
              n.push({
                type: p,
                payloadType: s,
                pts: r,
                bytes: x
              })
            }
          }
        }
      }
    } else if (s === 5 && o < u) {
      if (c = !0, o > 16) {
        const f = [];
        for (let p = 0; p < 16; p++) {
          const v = i[a++].toString(16);
          f.push(v.length == 1 ? "0" + v : v), (p === 3 || p === 5 || p === 7 || p === 9) && f.push("-")
        }
        const d = o - 16,
          h = new Uint8Array(d);
        for (let p = 0; p < d; p++) h[p] = i[a++];
        n.push({
          payloadType: s,
          pts: r,
          uuid: f.join(""),
          userData: fa(h),
          userDataBytes: h
        })
      }
    } else if (o < u) a += o;
    else if (o > u) break
  }
}

function yQ(t) {
  const e = t.byteLength,
    r = [];
  let n = 1;
  for (; n < e - 2;) t[n] === 0 && t[n + 1] === 0 && t[n + 2] === 3 ? (r.push(n + 2), n += 2) : n++;
  if (r.length === 0) return t;
  const i = e - r.length,
    a = new Uint8Array(i);
  let s = 0;
  for (n = 0; n < i; s++, n++) s === r[0] && (s++, r.shift()), a[n] = t[s];
  return a
}

function MHe(t) {
  const e = t[0];
  let r = "",
    n = "",
    i = 0,
    a = 0,
    s = 0,
    o = 0,
    c = 0,
    l = 0;
  if (e === 0) {
    for (; Qt(t.subarray(l, l + 1)) !== "\0";) r += Qt(t.subarray(l, l + 1)), l += 1;
    for (r += Qt(t.subarray(l, l + 1)), l += 1; Qt(t.subarray(l, l + 1)) !== "\0";) n += Qt(t.subarray(l, l + 1)), l += 1;
    n += Qt(t.subarray(l, l + 1)), l += 1, i = Ee(t, 12), a = Ee(t, 16), o = Ee(t, 20), c = Ee(t, 24), l = 28
  } else if (e === 1) {
    l += 4, i = Ee(t, l), l += 4;
    const f = Ee(t, l);
    l += 4;
    const d = Ee(t, l);
    for (l += 4, s = 2 ** 32 * f + d, Number.isSafeInteger(s) || (s = Number.MAX_SAFE_INTEGER, G.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = Ee(t, l), l += 4, c = Ee(t, l), l += 4; Qt(t.subarray(l, l + 1)) !== "\0";) r += Qt(t.subarray(l, l + 1)), l += 1;
    for (r += Qt(t.subarray(l, l + 1)), l += 1; Qt(t.subarray(l, l + 1)) !== "\0";) n += Qt(t.subarray(l, l + 1)), l += 1;
    n += Qt(t.subarray(l, l + 1)), l += 1
  }
  const u = t.subarray(l, t.byteLength);
  return {
    schemeIdUri: r,
    value: n,
    timeScale: i,
    presentationTime: s,
    presentationTimeDelta: a,
    eventDuration: o,
    id: c,
    payload: u
  }
}

function FHe(t, ...e) {
  const r = e.length;
  let n = 8,
    i = r;
  for (; i--;) n += e[i].byteLength;
  const a = new Uint8Array(n);
  for (a[0] = n >> 24 & 255, a[1] = n >> 16 & 255, a[2] = n >> 8 & 255, a[3] = n & 255, a.set(t, 4), i = 0, n = 8; i < r; i++) a.set(e[i], n), n += e[i].byteLength;
  return a
}

function BHe(t, e, r) {
  if (t.byteLength !== 16) throw new RangeError("Invalid system id");
  let n, i;
  if (e) {
    n = 1, i = new Uint8Array(e.length * 16);
    for (let o = 0; o < e.length; o++) {
      const c = e[o];
      if (c.byteLength !== 16) throw new RangeError("Invalid key");
      i.set(c, o * 16)
    }
  } else n = 0, i = new Uint8Array;
  let a;
  n > 0 ? (a = new Uint8Array(4), e.length > 0 && new DataView(a.buffer).setUint32(0, e.length, !1)) : a = new Uint8Array;
  const s = new Uint8Array(4);
  return r && r.byteLength > 0 && new DataView(s.buffer).setUint32(0, r.byteLength, !1), FHe([112, 115, 115, 104], new Uint8Array([n, 0, 0, 0]), t, a, i, s, r || new Uint8Array)
}

function UHe(t) {
  if (!(t instanceof ArrayBuffer) || t.byteLength < 32) return null;
  const e = {
      version: 0,
      systemId: "",
      kids: null,
      data: null
    },
    r = new DataView(t),
    n = r.getUint32(0);
  if (t.byteLength !== n && n > 44 || r.getUint32(4) !== 1886614376 || (e.version = r.getUint32(8) >>> 24, e.version > 1)) return null;
  e.systemId = Ji.hexDump(new Uint8Array(t, 12, 16));
  const a = r.getUint32(28);
  if (e.version === 0) {
    if (n - 32 < a) return null;
    e.data = new Uint8Array(t, 32, a)
  } else if (e.version === 1) {
    e.kids = [];
    for (let s = 0; s < a; s++) e.kids.push(new Uint8Array(t, 32 + s * 16, 16))
  }
  return e
}
let Gm = {};
class J0 {
  static clearKeyUriToKeyIdMap() {
    Gm = {}
  }
  constructor(e, r, n, i = [1], a = null) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = r, this.keyFormat = n, this.keyFormatVersions = i, this.iv = a, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && e !== "AES-128"
  }
  isSupported() {
    if (this.method) {
      if (this.method === "AES-128" || this.method === "NONE") return !0;
      if (this.keyFormat === "identity") return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case qr.FAIRPLAY:
        case qr.WIDEVINE:
        case qr.PLAYREADY:
        case qr.CLEARKEY:
          return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1
      }
    }
    return !1
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri) return null;
    if (this.method === "AES-128" && this.uri && !this.iv) {
      typeof e != "number" && (this.method === "AES-128" && !this.iv && G.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0);
      const n = jHe(e);
      return new J0(this.method, this.uri, "identity", this.keyFormatVersions, n)
    }
    const r = pHe(this.uri);
    if (r) switch (this.keyFormat) {
      case qr.WIDEVINE:
        this.pssh = r, r.length >= 22 && (this.keyId = r.subarray(r.length - 22, r.length - 6));
        break;
      case qr.PLAYREADY: {
        const n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
        this.pssh = BHe(n, null, r);
        const i = new Uint16Array(r.buffer, r.byteOffset, r.byteLength / 2),
          a = String.fromCharCode.apply(null, Array.from(i)),
          s = a.substring(a.indexOf("<"), a.length),
          l = new DOMParser().parseFromString(s, "text/xml").getElementsByTagName("KID")[0];
        if (l) {
          const u = l.childNodes[0] ? l.childNodes[0].nodeValue : l.getAttribute("VALUE");
          if (u) {
            const f = AO(u).subarray(0, 16);
            hHe(f), this.keyId = f
          }
        }
        break
      }
      default: {
        let n = r.subarray(0, 16);
        if (n.length !== 16) {
          const i = new Uint8Array(16);
          i.set(n, 16 - n.length), n = i
        }
        this.keyId = n;
        break
      }
    }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let n = Gm[this.uri];
      if (!n) {
        const i = Object.keys(Gm).length % Number.MAX_SAFE_INTEGER;
        n = new Uint8Array(16), new DataView(n.buffer, 12, 4).setUint32(0, i), Gm[this.uri] = n
      }
      this.keyId = n
    }
    return this
  }
}

function jHe(t) {
  const e = new Uint8Array(16);
  for (let r = 12; r < 16; r++) e[r] = t >> 8 * (15 - r) & 255;
  return e
}
const xQ = /\{\$([a-zA-Z0-9-_]+)\}/g;

function P5(t) {
  return xQ.test(t)
}

function jr(t, e, r) {
  if (t.variableList !== null || t.hasVariableRefs)
    for (let n = r.length; n--;) {
      const i = r[n],
        a = e[i];
      a && (e[i] = jA(t, a))
    }
}

function jA(t, e) {
  if (t.variableList !== null || t.hasVariableRefs) {
    const r = t.variableList;
    return e.replace(xQ, n => {
      const i = n.substring(2, n.length - 1),
        a = r == null ? void 0 : r[i];
      return a === void 0 ? (t.playlistParsingError || (t.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${i}"`)), n) : a
    })
  }
  return e
}

function N5(t, e, r) {
  let n = t.variableList;
  n || (t.variableList = n = {});
  let i, a;
  if ("QUERYPARAM" in e) {
    i = e.QUERYPARAM;
    try {
      const s = new self.URL(r).searchParams;
      if (s.has(i)) a = s.get(i);
      else throw new Error(`"${i}" does not match any query parameter in URI: "${r}"`)
    } catch (s) {
      t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${s.message}`))
    }
  } else i = e.NAME, a = e.VALUE;
  i in n ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${i}"`)) : n[i] = a || ""
}

function HHe(t, e, r) {
  const n = e.IMPORT;
  if (r && n in r) {
    let i = t.variableList;
    i || (t.variableList = i = {}), i[n] = r[n]
  } else t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${n}"`))
}
const zHe = {
  audio: {
    a3ds: !0,
    "ac-3": !0,
    "ac-4": !0,
    alac: !0,
    alaw: !0,
    dra1: !0,
    "dts+": !0,
    "dts-": !0,
    dtsc: !0,
    dtse: !0,
    dtsh: !0,
    "ec-3": !0,
    enca: !0,
    g719: !0,
    g726: !0,
    m4ae: !0,
    mha1: !0,
    mha2: !0,
    mhm1: !0,
    mhm2: !0,
    mlpa: !0,
    mp4a: !0,
    "raw ": !0,
    Opus: !0,
    opus: !0,
    samr: !0,
    sawb: !0,
    sawp: !0,
    sevc: !0,
    sqcp: !0,
    ssmv: !0,
    twos: !0,
    ulaw: !0
  },
  video: {
    avc1: !0,
    avc2: !0,
    avc3: !0,
    avc4: !0,
    avcp: !0,
    av01: !0,
    drac: !0,
    dva1: !0,
    dvav: !0,
    dvh1: !0,
    dvhe: !0,
    encv: !0,
    hev1: !0,
    hvc1: !0,
    mjp2: !0,
    mp4v: !0,
    mvc1: !0,
    mvc2: !0,
    mvc3: !0,
    mvc4: !0,
    resv: !0,
    rv60: !0,
    s263: !0,
    svc1: !0,
    svc2: !0,
    "vc-1": !0,
    vp08: !0,
    vp09: !0
  },
  text: {
    stpp: !0,
    wvtt: !0
  }
};

function GHe(t, e) {
  const r = zHe[e];
  return !!r && r[t.slice(0, 4)] === !0
}

function ew(t, e) {
  return MediaSource.isTypeSupported(`${e||"video"}/mp4;codecs="${t}"`)
}
const D5 = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
  M5 = /#EXT-X-MEDIA:(.*)/g,
  VHe = /^#EXT(?:INF|-X-TARGETDURATION):/m,
  F5 = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
  WHe = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class Ti {
  static findGroup(e, r) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (i.id === r) return i
    }
  }
  static convertAVC1ToAVCOTI(e) {
    const r = e.split(".");
    if (r.length > 2) {
      let n = r.shift() + ".";
      return n += parseInt(r.shift()).toString(16), n += ("000" + parseInt(r.shift()).toString(16)).slice(-4), n
    }
    return e
  }
  static resolve(e, r) {
    return Z0.buildAbsoluteURL(r, e, {
      alwaysNormalize: !0
    })
  }
  static isMediaPlaylist(e) {
    return VHe.test(e)
  }
  static parseMasterPlaylist(e, r) {
    const n = P5(e),
      i = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs: n
      },
      a = [];
    D5.lastIndex = 0;
    let s;
    for (;
      (s = D5.exec(e)) != null;)
      if (s[1]) {
        var o;
        const l = new mt(s[1]);
        jr(i, l, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
        const u = jA(i, s[2]),
          f = {
            attrs: l,
            bitrate: l.decimalInteger("AVERAGE-BANDWIDTH") || l.decimalInteger("BANDWIDTH"),
            name: l.NAME,
            url: Ti.resolve(u, r)
          },
          d = l.decimalResolution("RESOLUTION");
        d && (f.width = d.width, f.height = d.height), KHe((l.CODECS || "").split(/[ ,]+/).filter(h => h), f), f.videoCodec && f.videoCodec.indexOf("avc1") !== -1 && (f.videoCodec = Ti.convertAVC1ToAVCOTI(f.videoCodec)), (o = f.unknownCodecs) != null && o.length || a.push(f), i.levels.push(f)
      } else if (s[3]) {
      const l = s[3],
        u = s[4];
      switch (l) {
        case "SESSION-DATA": {
          const f = new mt(u);
          jr(i, f, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
          const d = f["DATA-ID"];
          d && (i.sessionData === null && (i.sessionData = {}), i.sessionData[d] = f);
          break
        }
        case "SESSION-KEY": {
          const f = B5(u, r, i);
          f.encrypted && f.isSupported() ? (i.sessionKeys === null && (i.sessionKeys = []), i.sessionKeys.push(f)) : G.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
          break
        }
        case "DEFINE": {
          {
            const f = new mt(u);
            jr(i, f, ["NAME", "VALUE", "QUERYPARAM"]), N5(i, f, r)
          }
          break
        }
        case "CONTENT-STEERING": {
          const f = new mt(u);
          jr(i, f, ["SERVER-URI", "PATHWAY-ID"]), i.contentSteering = {
            uri: Ti.resolve(f["SERVER-URI"], r),
            pathwayId: f["PATHWAY-ID"] || "."
          };
          break
        }
        case "START": {
          i.startTimeOffset = U5(u);
          break
        }
      }
    }
    const c = a.length > 0 && a.length < i.levels.length;
    return i.levels = c ? a : i.levels, i.levels.length === 0 && (i.playlistParsingError = new Error("no levels found in manifest")), i
  }
  static parseMasterPlaylistMedia(e, r, n) {
    let i;
    const a = {},
      s = n.levels,
      o = {
        AUDIO: s.map(l => ({
          id: l.attrs.AUDIO,
          audioCodec: l.audioCodec
        })),
        SUBTITLES: s.map(l => ({
          id: l.attrs.SUBTITLES,
          textCodec: l.textCodec
        })),
        "CLOSED-CAPTIONS": []
      };
    let c = 0;
    for (M5.lastIndex = 0;
      (i = M5.exec(e)) !== null;) {
      const l = new mt(i[1]),
        u = l.TYPE;
      if (u) {
        const f = o[u],
          d = a[u] || [];
        a[u] = d, jr(n, l, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
        const h = {
          attrs: l,
          bitrate: 0,
          id: c++,
          groupId: l["GROUP-ID"] || "",
          instreamId: l["INSTREAM-ID"],
          name: l.NAME || l.LANGUAGE || "",
          type: u,
          default: l.bool("DEFAULT"),
          autoselect: l.bool("AUTOSELECT"),
          forced: l.bool("FORCED"),
          lang: l.LANGUAGE,
          url: l.URI ? Ti.resolve(l.URI, r) : ""
        };
        if (f != null && f.length) {
          const p = Ti.findGroup(f, h.groupId) || f[0];
          j5(h, p, "audioCodec"), j5(h, p, "textCodec")
        }
        d.push(h)
      }
    }
    return a
  }
  static parseLevelPlaylist(e, r, n, i, a, s) {
    const o = new fHe(r),
      c = o.fragments;
    let l = null,
      u = 0,
      f = 0,
      d = 0,
      h = 0,
      p = null,
      v = new XT(i, r),
      g, m, y, x = -1,
      b = !1;
    for (F5.lastIndex = 0, o.m3u8 = e, o.hasVariableRefs = P5(e);
      (g = F5.exec(e)) !== null;) {
      b && (b = !1, v = new XT(i, r), v.start = d, v.sn = u, v.cc = h, v.level = n, l && (v.initSegment = l, v.rawProgramDateTime = l.rawProgramDateTime, l.rawProgramDateTime = null));
      const R = g[1];
      if (R) {
        v.duration = parseFloat(R);
        const I = (" " + g[2]).slice(1);
        v.title = I || null, v.tagList.push(I ? ["INF", R, I] : ["INF", R])
      } else if (g[3]) {
        if (ge(v.duration)) {
          v.start = d, y && G5(v, y, o), v.sn = u, v.level = n, v.cc = h, v.urlId = a, c.push(v);
          const I = (" " + g[3]).slice(1);
          v.relurl = jA(o, I), H5(v, p), p = v, d += v.duration, u++, f = 0, b = !0
        }
      } else if (g[4]) {
        const I = (" " + g[4]).slice(1);
        p ? v.setByteRange(I, p) : v.setByteRange(I)
      } else if (g[5]) v.rawProgramDateTime = (" " + g[5]).slice(1), v.tagList.push(["PROGRAM-DATE-TIME", v.rawProgramDateTime]), x === -1 && (x = c.length);
      else {
        if (g = g[0].match(WHe), !g) {
          G.warn("No matches on slow regex match for level playlist!");
          continue
        }
        for (m = 1; m < g.length && !(typeof g[m] < "u"); m++);
        const I = (" " + g[m]).slice(1),
          w = (" " + g[m + 1]).slice(1),
          C = g[m + 2] ? (" " + g[m + 2]).slice(1) : "";
        switch (I) {
          case "PLAYLIST-TYPE":
            o.type = w.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            u = o.startSN = parseInt(w);
            break;
          case "SKIP": {
            const L = new mt(w);
            jr(o, L, ["RECENTLY-REMOVED-DATERANGES"]);
            const H = L.decimalInteger("SKIPPED-SEGMENTS");
            if (ge(H)) {
              o.skippedSegments = H;
              for (let P = H; P--;) c.unshift(null);
              u += H
            }
            const N = L.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            N && (o.recentlyRemovedDateranges = N.split("	"));
            break
          }
          case "TARGETDURATION":
            o.targetduration = Math.max(parseInt(w), 1);
            break;
          case "VERSION":
            o.version = parseInt(w);
            break;
          case "EXTM3U":
            break;
          case "ENDLIST":
            o.live = !1;
            break;
          case "#":
            (w || C) && v.tagList.push(C ? [w, C] : [w]);
            break;
          case "DISCONTINUITY":
            h++, v.tagList.push(["DIS"]);
            break;
          case "GAP":
            v.gap = !0, v.tagList.push([I]);
            break;
          case "BITRATE":
            v.tagList.push([I, w]);
            break;
          case "DATERANGE": {
            const L = new mt(w);
            jr(o, L, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), jr(o, L, L.clientAttrs);
            const H = new iQ(L, o.dateRanges[L.ID]);
            H.isValid || o.skippedSegments ? o.dateRanges[H.id] = H : G.warn(`Ignoring invalid DATERANGE tag: "${w}"`), v.tagList.push(["EXT-X-DATERANGE", w]);
            break
          }
          case "DEFINE": {
            {
              const L = new mt(w);
              jr(o, L, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in L ? HHe(o, L, s) : N5(o, L, r)
            }
            break
          }
          case "DISCONTINUITY-SEQUENCE":
            h = parseInt(w);
            break;
          case "KEY": {
            const L = B5(w, r, o);
            if (L.isSupported()) {
              if (L.method === "NONE") {
                y = void 0;
                break
              }
              y || (y = {}), y[L.keyFormat] && (y = Nt({}, y)), y[L.keyFormat] = L
            } else G.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${w}"`);
            break
          }
          case "START":
            o.startTimeOffset = U5(w);
            break;
          case "MAP": {
            const L = new mt(w);
            if (jr(o, L, ["BYTERANGE", "URI"]), v.duration) {
              const H = new XT(i, r);
              z5(H, L, n, y), l = H, v.initSegment = l, l.rawProgramDateTime && !v.rawProgramDateTime && (v.rawProgramDateTime = l.rawProgramDateTime)
            } else z5(v, L, n, y), l = v, b = !0;
            break
          }
          case "SERVER-CONTROL": {
            const L = new mt(w);
            o.canBlockReload = L.bool("CAN-BLOCK-RELOAD"), o.canSkipUntil = L.optionalFloat("CAN-SKIP-UNTIL", 0), o.canSkipDateRanges = o.canSkipUntil > 0 && L.bool("CAN-SKIP-DATERANGES"), o.partHoldBack = L.optionalFloat("PART-HOLD-BACK", 0), o.holdBack = L.optionalFloat("HOLD-BACK", 0);
            break
          }
          case "PART-INF": {
            const L = new mt(w);
            o.partTarget = L.decimalFloatingPoint("PART-TARGET");
            break
          }
          case "PART": {
            let L = o.partList;
            L || (L = o.partList = []);
            const H = f > 0 ? L[L.length - 1] : void 0,
              N = f++,
              P = new mt(w);
            jr(o, P, ["BYTERANGE", "URI"]);
            const B = new cHe(P, v, r, N, H);
            L.push(B), v.duration += B.duration;
            break
          }
          case "PRELOAD-HINT": {
            const L = new mt(w);
            jr(o, L, ["URI"]), o.preloadHint = L;
            break
          }
          case "RENDITION-REPORT": {
            const L = new mt(w);
            jr(o, L, ["URI"]), o.renditionReports = o.renditionReports || [], o.renditionReports.push(L);
            break
          }
          default:
            G.warn(`line parsed but not handled: ${g}`);
            break
        }
      }
    }
    p && !p.relurl ? (c.pop(), d -= p.duration, o.partList && (o.fragmentHint = p)) : o.partList && (H5(v, p), v.cc = h, o.fragmentHint = v, y && G5(v, y, o));
    const _ = c.length,
      S = c[0],
      T = c[_ - 1];
    if (d += o.skippedSegments * o.targetduration, d > 0 && _ && T) {
      o.averagetargetduration = d / _;
      const R = T.sn;
      o.endSN = R !== "initSegment" ? R : 0, o.live || (T.endList = !0), S && (o.startCC = S.cc)
    } else o.endSN = 0, o.startCC = 0;
    return o.fragmentHint && (d += o.fragmentHint.duration), o.totalduration = d, o.endCC = h, x > 0 && YHe(c, x), o
  }
}

function B5(t, e, r) {
  var n, i;
  const a = new mt(t);
  jr(r, a, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
  const s = (n = a.METHOD) != null ? n : "",
    o = a.URI,
    c = a.hexadecimalInteger("IV"),
    l = a.KEYFORMATVERSIONS,
    u = (i = a.KEYFORMAT) != null ? i : "identity";
  o && a.IV && !c && G.error(`Invalid IV: ${a.IV}`);
  const f = o ? Ti.resolve(o, e) : "",
    d = (l || "1").split("/").map(Number).filter(Number.isFinite);
  return new J0(s, f, u, d, c)
}

function U5(t) {
  const r = new mt(t).decimalFloatingPoint("TIME-OFFSET");
  return ge(r) ? r : null
}

function KHe(t, e) {
  ["video", "audio", "text"].forEach(r => {
    const n = t.filter(i => GHe(i, r));
    if (n.length) {
      const i = n.filter(a => a.lastIndexOf("avc1", 0) === 0 || a.lastIndexOf("mp4a", 0) === 0);
      e[`${r}Codec`] = i.length > 0 ? i[0] : n[0], t = t.filter(a => n.indexOf(a) === -1)
    }
  }), e.unknownCodecs = t
}

function j5(t, e, r) {
  const n = e[r];
  n && (t[r] = n)
}

function YHe(t, e) {
  let r = t[e];
  for (let n = e; n--;) {
    const i = t[n];
    if (!i) return;
    i.programDateTime = r.programDateTime - i.duration * 1e3, r = i
  }
}

function H5(t, e) {
  t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : e != null && e.programDateTime && (t.programDateTime = e.endProgramDateTime), ge(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null)
}

function z5(t, e, r, n) {
  t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = r, t.sn = "initSegment", n && (t.levelkeys = n), t.initSegment = null
}

function G5(t, e, r) {
  t.levelkeys = e;
  const {
    encryptedFragments: n
  } = r;
  (!n.length || n[n.length - 1].levelkeys !== e) && Object.keys(e).some(i => e[i].isCommonEncryption) && n.push(t)
}
var ze = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  },
  ye = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };

function V5(t) {
  const {
    type: e
  } = t;
  switch (e) {
    case ze.AUDIO_TRACK:
      return ye.AUDIO;
    case ze.SUBTITLE_TRACK:
      return ye.SUBTITLE;
    default:
      return ye.MAIN
  }
}

function tw(t, e) {
  let r = t.url;
  return (r === void 0 || r.indexOf("data:") === 0) && (r = e.url), r
}
class qHe {
  constructor(e) {
    this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners()
  }
  startLoad(e) {}
  stopLoad() {
    this.destroyInternalLoaders()
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.LEVEL_LOADING, this.onLevelLoading, this), e.on($.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on($.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.LEVEL_LOADING, this.onLevelLoading, this), e.off($.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off($.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  createInternalLoader(e) {
    const r = this.hls.config,
      n = r.pLoader,
      i = r.loader,
      a = n || i,
      s = new a(r);
    return this.loaders[e.type] = s, s
  }
  getInternalLoader(e) {
    return this.loaders[e.type]
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e]
  }
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const r = this.loaders[e];
      r && r.destroy(), this.resetInternalLoader(e)
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
  }
  onManifestLoading(e, r) {
    const {
      url: n
    } = r;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: ze.MANIFEST,
      url: n,
      deliveryDirectives: null
    })
  }
  onLevelLoading(e, r) {
    const {
      id: n,
      level: i,
      url: a,
      deliveryDirectives: s
    } = r;
    this.load({
      id: n,
      level: i,
      responseType: "text",
      type: ze.LEVEL,
      url: a,
      deliveryDirectives: s
    })
  }
  onAudioTrackLoading(e, r) {
    const {
      id: n,
      groupId: i,
      url: a,
      deliveryDirectives: s
    } = r;
    this.load({
      id: n,
      groupId: i,
      level: null,
      responseType: "text",
      type: ze.AUDIO_TRACK,
      url: a,
      deliveryDirectives: s
    })
  }
  onSubtitleTrackLoading(e, r) {
    const {
      id: n,
      groupId: i,
      url: a,
      deliveryDirectives: s
    } = r;
    this.load({
      id: n,
      groupId: i,
      level: null,
      responseType: "text",
      type: ze.SUBTITLE_TRACK,
      url: a,
      deliveryDirectives: s
    })
  }
  load(e) {
    var r;
    const n = this.hls.config;
    let i = this.getInternalLoader(e);
    if (i) {
      const l = i.context;
      if (l && l.url === e.url) {
        G.trace("[playlist-loader]: playlist request ongoing");
        return
      }
      G.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort()
    }
    let a;
    if (e.type === ze.MANIFEST ? a = n.manifestLoadPolicy.default : a = Nt({}, n.playlistLoadPolicy.default, {
        timeoutRetry: null,
        errorRetry: null
      }), i = this.createInternalLoader(e), (r = e.deliveryDirectives) != null && r.part) {
      let l;
      if (e.type === ze.LEVEL && e.level !== null ? l = this.hls.levels[e.level].details : e.type === ze.AUDIO_TRACK && e.id !== null ? l = this.hls.audioTracks[e.id].details : e.type === ze.SUBTITLE_TRACK && e.id !== null && (l = this.hls.subtitleTracks[e.id].details), l) {
        const u = l.partTarget,
          f = l.targetduration;
        if (u && f) {
          const d = Math.max(u * 3, f * .8) * 1e3;
          a = Nt({}, a, {
            maxTimeToFirstByteMs: Math.min(d, a.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(d, a.maxTimeToFirstByteMs)
          })
        }
      }
    }
    const s = a.errorRetry || a.timeoutRetry || {},
      o = {
        loadPolicy: a,
        timeout: a.maxLoadTimeMs,
        maxRetry: s.maxNumRetry || 0,
        retryDelay: s.retryDelayMs || 0,
        maxRetryDelay: s.maxRetryDelayMs || 0
      },
      c = {
        onSuccess: (l, u, f, d) => {
          const h = this.getInternalLoader(f);
          this.resetInternalLoader(f.type);
          const p = l.data;
          if (p.indexOf("#EXTM3U") !== 0) {
            this.handleManifestParsingError(l, f, new Error("no EXTM3U delimiter"), d || null, u);
            return
          }
          u.parsing.start = performance.now(), Ti.isMediaPlaylist(p) ? this.handleTrackOrLevelPlaylist(l, u, f, d || null, h) : this.handleMasterPlaylist(l, u, f, d)
        },
        onError: (l, u, f, d) => {
          this.handleNetworkError(u, f, !1, l, d)
        },
        onTimeout: (l, u, f) => {
          this.handleNetworkError(u, f, !0, void 0, l)
        }
      };
    i.load(e, o, c)
  }
  handleMasterPlaylist(e, r, n, i) {
    const a = this.hls,
      s = e.data,
      o = tw(e, n),
      c = Ti.parseMasterPlaylist(s, o);
    if (c.playlistParsingError) {
      this.handleManifestParsingError(e, n, c.playlistParsingError, i, r);
      return
    }
    const {
      contentSteering: l,
      levels: u,
      sessionData: f,
      sessionKeys: d,
      startTimeOffset: h,
      variableList: p
    } = c;
    this.variableList = p;
    const {
      AUDIO: v = [],
      SUBTITLES: g,
      "CLOSED-CAPTIONS": m
    } = Ti.parseMasterPlaylistMedia(s, o, c);
    v.length && !v.some(x => !x.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (G.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), v.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new mt({}),
      bitrate: 0,
      url: ""
    })), a.trigger($.MANIFEST_LOADED, {
      levels: u,
      audioTracks: v,
      subtitles: g,
      captions: m,
      contentSteering: l,
      url: o,
      stats: r,
      networkDetails: i,
      sessionData: f,
      sessionKeys: d,
      startTimeOffset: h,
      variableList: p
    })
  }
  handleTrackOrLevelPlaylist(e, r, n, i, a) {
    const s = this.hls,
      {
        id: o,
        level: c,
        type: l
      } = n,
      u = tw(e, n),
      f = ge(o) ? o : 0,
      d = ge(c) ? c : f,
      h = V5(n),
      p = Ti.parseLevelPlaylist(e.data, u, d, h, f, this.variableList);
    if (l === ze.MANIFEST) {
      const v = {
        attrs: new mt({}),
        bitrate: 0,
        details: p,
        name: "",
        url: u
      };
      s.trigger($.MANIFEST_LOADED, {
        levels: [v],
        audioTracks: [],
        url: u,
        stats: r,
        networkDetails: i,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      })
    }
    r.parsing.end = performance.now(), n.levelDetails = p, this.handlePlaylistLoaded(p, e, r, n, i, a)
  }
  handleManifestParsingError(e, r, n, i, a) {
    this.hls.trigger($.ERROR, {
      type: ve.NETWORK_ERROR,
      details: q.MANIFEST_PARSING_ERROR,
      fatal: r.type === ze.MANIFEST,
      url: e.url,
      err: n,
      error: n,
      reason: n.message,
      response: e,
      context: r,
      networkDetails: i,
      stats: a
    })
  }
  handleNetworkError(e, r, n = !1, i, a) {
    let s = `A network ${n?"timeout":"error"+(i?" (status "+i.code+")":"")} occurred while loading ${e.type}`;
    e.type === ze.LEVEL ? s += `: ${e.level} id: ${e.id}` : (e.type === ze.AUDIO_TRACK || e.type === ze.SUBTITLE_TRACK) && (s += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(s);
    G.warn(`[playlist-loader]: ${s}`);
    let c = q.UNKNOWN,
      l = !1;
    const u = this.getInternalLoader(e);
    switch (e.type) {
      case ze.MANIFEST:
        c = n ? q.MANIFEST_LOAD_TIMEOUT : q.MANIFEST_LOAD_ERROR, l = !0;
        break;
      case ze.LEVEL:
        c = n ? q.LEVEL_LOAD_TIMEOUT : q.LEVEL_LOAD_ERROR, l = !1;
        break;
      case ze.AUDIO_TRACK:
        c = n ? q.AUDIO_TRACK_LOAD_TIMEOUT : q.AUDIO_TRACK_LOAD_ERROR, l = !1;
        break;
      case ze.SUBTITLE_TRACK:
        c = n ? q.SUBTITLE_TRACK_LOAD_TIMEOUT : q.SUBTITLE_LOAD_ERROR, l = !1;
        break
    }
    u && this.resetInternalLoader(e.type);
    const f = {
      type: ve.NETWORK_ERROR,
      details: c,
      fatal: l,
      url: e.url,
      loader: u,
      context: e,
      error: o,
      networkDetails: r,
      stats: a
    };
    if (i) {
      const d = (r == null ? void 0 : r.url) || e.url;
      f.response = an({
        url: d,
        data: void 0
      }, i)
    }
    this.hls.trigger($.ERROR, f)
  }
  handlePlaylistLoaded(e, r, n, i, a, s) {
    const o = this.hls,
      {
        type: c,
        level: l,
        id: u,
        groupId: f,
        deliveryDirectives: d
      } = i,
      h = tw(r, i),
      p = V5(i),
      v = typeof i.level == "number" && p === ye.MAIN ? l : void 0;
    if (!e.fragments.length) {
      const m = new Error("No Segments found in Playlist");
      o.trigger($.ERROR, {
        type: ve.NETWORK_ERROR,
        details: q.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: h,
        error: m,
        reason: m.message,
        response: r,
        context: i,
        level: v,
        parent: p,
        networkDetails: a,
        stats: n
      });
      return
    }
    e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
    const g = e.playlistParsingError;
    if (g) {
      o.trigger($.ERROR, {
        type: ve.NETWORK_ERROR,
        details: q.LEVEL_PARSING_ERROR,
        fatal: !1,
        url: h,
        error: g,
        reason: g.message,
        response: r,
        context: i,
        level: v,
        parent: p,
        networkDetails: a,
        stats: n
      });
      return
    }
    switch (e.live && s && (s.getCacheAge && (e.ageHeader = s.getCacheAge() || 0), (!s.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), c) {
      case ze.MANIFEST:
      case ze.LEVEL:
        o.trigger($.LEVEL_LOADED, {
          details: e,
          level: v || 0,
          id: u || 0,
          stats: n,
          networkDetails: a,
          deliveryDirectives: d
        });
        break;
      case ze.AUDIO_TRACK:
        o.trigger($.AUDIO_TRACK_LOADED, {
          details: e,
          id: u || 0,
          groupId: f || "",
          stats: n,
          networkDetails: a,
          deliveryDirectives: d
        });
        break;
      case ze.SUBTITLE_TRACK:
        o.trigger($.SUBTITLE_TRACK_LOADED, {
          details: e,
          id: u || 0,
          groupId: f || "",
          stats: n,
          networkDetails: a,
          deliveryDirectives: d
        });
        break
    }
  }
}

function bQ(t, e) {
  let r;
  try {
    r = new Event("addtrack")
  } catch {
    r = document.createEvent("Event"), r.initEvent("addtrack", !1, !1)
  }
  r.track = t, e.dispatchEvent(r)
}

function EQ(t, e) {
  const r = t.mode;
  if (r === "disabled" && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id)) try {
    if (t.addCue(e), !t.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`)
  } catch (n) {
    G.debug(`[texttrack-utils]: ${n}`);
    const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
    i.id = e.id, t.addCue(i)
  }
  r === "disabled" && (t.mode = r)
}

function _u(t) {
  const e = t.mode;
  if (e === "disabled" && (t.mode = "hidden"), t.cues)
    for (let r = t.cues.length; r--;) t.removeCue(t.cues[r]);
  e === "disabled" && (t.mode = e)
}

function HA(t, e, r, n) {
  const i = t.mode;
  if (i === "disabled" && (t.mode = "hidden"), t.cues && t.cues.length > 0) {
    const a = QHe(t.cues, e, r);
    for (let s = 0; s < a.length; s++)(!n || n(a[s])) && t.removeCue(a[s])
  }
  i === "disabled" && (t.mode = i)
}

function XHe(t, e) {
  if (e < t[0].startTime) return 0;
  const r = t.length - 1;
  if (e > t[r].endTime) return -1;
  let n = 0,
    i = r;
  for (; n <= i;) {
    const a = Math.floor((i + n) / 2);
    if (e < t[a].startTime) i = a - 1;
    else if (e > t[a].startTime && n < r) n = a + 1;
    else return a
  }
  return t[n].startTime - e < e - t[i].startTime ? n : i
}

function QHe(t, e, r) {
  const n = [],
    i = XHe(t, e);
  if (i > -1)
    for (let a = i, s = t.length; a < s; a++) {
      const o = t[a];
      if (o.startTime >= e && o.endTime <= r) n.push(o);
      else if (o.startTime > r) return n
    }
  return n
}
var Si = {
  audioId3: "org.id3",
  dateRange: "com.apple.quicktime.HLS",
  emsg: "https://aomedia.org/emsg/ID3"
};
const ZHe = .25;

function zA() {
  if (!(typeof self > "u")) return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
}
const Vm = (() => {
  const t = zA();
  try {
    new t(0, Number.POSITIVE_INFINITY, "")
  } catch {
    return Number.MAX_VALUE
  }
  return Number.POSITIVE_INFINITY
})();

function rw(t, e) {
  return t.getTime() / 1e3 - e
}

function JHe(t) {
  return Uint8Array.from(t.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer
}
class eze {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners()
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on($.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off($.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  onMediaAttached(e, r) {
    this.media = r.media
  }
  onMediaDetaching() {
    this.id3Track && (_u(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {}
  }
  createTrack(e) {
    const r = this.getID3Track(e.textTracks);
    return r.mode = "hidden", r
  }
  getID3Track(e) {
    if (this.media) {
      for (let r = 0; r < e.length; r++) {
        const n = e[r];
        if (n.kind === "metadata" && n.label === "id3") return bQ(n, this.media), n
      }
      return this.media.addTextTrack("metadata", "id3")
    }
  }
  onFragParsingMetadata(e, r) {
    if (!this.media) return;
    const {
      hls: {
        config: {
          enableEmsgMetadataCues: n,
          enableID3MetadataCues: i
        }
      }
    } = this;
    if (!n && !i) return;
    const {
      samples: a
    } = r;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const s = zA();
    for (let o = 0; o < a.length; o++) {
      const c = a[o].type;
      if (c === Si.emsg && !n || !i) continue;
      const l = fQ(a[o].data);
      if (l) {
        const u = a[o].pts;
        let f = u + a[o].duration;
        f > Vm && (f = Vm), f - u <= 0 && (f = u + ZHe);
        for (let h = 0; h < l.length; h++) {
          const p = l[h];
          if (!uQ(p)) {
            this.updateId3CueEnds(u);
            const v = new s(u, f, "");
            v.value = p, c && (v.type = c), this.id3Track.addCue(v)
          }
        }
      }
    }
  }
  updateId3CueEnds(e) {
    var r;
    const n = (r = this.id3Track) == null ? void 0 : r.cues;
    if (n)
      for (let i = n.length; i--;) {
        const a = n[i];
        a.startTime < e && a.endTime === Vm && (a.endTime = e)
      }
  }
  onBufferFlushing(e, {
    startOffset: r,
    endOffset: n,
    type: i
  }) {
    const {
      id3Track: a,
      hls: s
    } = this;
    if (!s) return;
    const {
      config: {
        enableEmsgMetadataCues: o,
        enableID3MetadataCues: c
      }
    } = s;
    if (a && (o || c)) {
      let l;
      i === "audio" ? l = u => u.type === Si.audioId3 && c : i === "video" ? l = u => u.type === Si.emsg && o : l = u => u.type === Si.audioId3 && c || u.type === Si.emsg && o, HA(a, r, n, l)
    }
  }
  onLevelUpdated(e, {
    details: r
  }) {
    if (!this.media || !r.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
    const {
      dateRangeCuesAppended: n,
      id3Track: i
    } = this, {
      dateRanges: a
    } = r, s = Object.keys(a);
    if (i) {
      const u = Object.keys(n).filter(f => !s.includes(f));
      for (let f = u.length; f--;) {
        const d = u[f];
        Object.keys(n[d].cues).forEach(h => {
          i.removeCue(n[d].cues[h])
        }), delete n[d]
      }
    }
    const o = r.fragments[r.fragments.length - 1];
    if (s.length === 0 || !ge(o == null ? void 0 : o.programDateTime)) return;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const c = o.programDateTime / 1e3 - o.start,
      l = zA();
    for (let u = 0; u < s.length; u++) {
      const f = s[u],
        d = a[f],
        h = n[f],
        p = (h == null ? void 0 : h.cues) || {};
      let v = (h == null ? void 0 : h.durationKnown) || !1;
      const g = rw(d.startDate, c);
      let m = Vm;
      const y = d.endDate;
      if (y) m = rw(y, c), v = !0;
      else if (d.endOnNext && !v) {
        const b = s.reduce((_, S) => {
          const T = a[S];
          return T.class === d.class && T.id !== S && T.startDate > d.startDate && _.push(T), _
        }, []).sort((_, S) => _.startDate.getTime() - S.startDate.getTime())[0];
        b && (m = rw(b.startDate, c), v = !0)
      }
      const x = Object.keys(d.attr);
      for (let b = 0; b < x.length; b++) {
        const _ = x[b];
        if (!oHe(_)) continue;
        let S = p[_];
        if (S) v && !h.durationKnown && (S.endTime = m);
        else {
          let T = d.attr[_];
          S = new l(g, m, ""), lHe(_) && (T = JHe(T)), S.value = {
            key: _,
            data: T
          }, S.type = Si.dateRange, S.id = f, this.id3Track.addCue(S), p[_] = S
        }
      }
      n[f] = {
        cues: p,
        dateRange: d,
        durationKnown: v
      }
    }
  }
}
class tze {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners()
  }
  get latency() {
    return this._latency || 0
  }
  get maxLatency() {
    const {
      config: e,
      levelDetails: r
    } = this;
    return e.liveMaxLatencyDuration !== void 0 ? e.liveMaxLatencyDuration : r ? e.liveMaxLatencyDurationCount * r.targetduration : 0
  }
  get targetLatency() {
    const {
      levelDetails: e
    } = this;
    if (e === null) return null;
    const {
      holdBack: r,
      partHoldBack: n,
      targetduration: i
    } = e, {
      liveSyncDuration: a,
      liveSyncDurationCount: s,
      lowLatencyMode: o
    } = this.config, c = this.hls.userConfig;
    let l = o && n || r;
    (c.liveSyncDuration || c.liveSyncDurationCount || l === 0) && (l = a !== void 0 ? a : s * i);
    const u = i,
      f = 1;
    return l + Math.min(this.stallCount * f, u)
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(),
      r = this.targetLatency,
      n = this.levelDetails;
    if (e === null || r === null || n === null) return null;
    const i = n.edge,
      a = e - r - this.edgeStalled,
      s = i - n.totalduration,
      o = i - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
    return Math.min(Math.max(s, a), o)
  }
  get drift() {
    const {
      levelDetails: e
    } = this;
    return e === null ? 1 : e.drift
  }
  get edgeStalled() {
    const {
      levelDetails: e
    } = this;
    if (e === null) return 0;
    const r = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - r, 0)
  }
  get forwardBufferLength() {
    const {
      media: e,
      levelDetails: r
    } = this;
    if (!e || !r) return 0;
    const n = e.buffered.length;
    return (n ? e.buffered.end(n - 1) : r.edge) - this.currentTime
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
  }
  registerListeners() {
    this.hls.on($.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on($.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on($.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on($.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on($.ERROR, this.onError, this)
  }
  unregisterListeners() {
    this.hls.off($.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off($.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off($.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off($.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off($.ERROR, this.onError, this)
  }
  onMediaAttached(e, r) {
    this.media = r.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
  }
  onManifestLoading() {
    this.levelDetails = null, this._latency = null, this.stallCount = 0
  }
  onLevelUpdated(e, {
    details: r
  }) {
    this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
  }
  onError(e, r) {
    var n;
    r.details === q.BUFFER_STALLED_ERROR && (this.stallCount++, (n = this.levelDetails) != null && n.live && G.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
  }
  timeupdate() {
    const {
      media: e,
      levelDetails: r
    } = this;
    if (!e || !r) return;
    this.currentTime = e.currentTime;
    const n = this.computeLatency();
    if (n === null) return;
    this._latency = n;
    const {
      lowLatencyMode: i,
      maxLiveSyncPlaybackRate: a
    } = this.config;
    if (!i || a === 1) return;
    const s = this.targetLatency;
    if (s === null) return;
    const o = n - s,
      c = Math.min(this.maxLatency, s + r.targetduration),
      l = o < c;
    if (r.live && l && o > .05 && this.forwardBufferLength > 1) {
      const u = Math.min(2, Math.max(1, a)),
        f = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;
      e.playbackRate = Math.min(u, Math.max(1, f))
    } else e.playbackRate !== 1 && e.playbackRate !== 0 && (e.playbackRate = 1)
  }
  estimateLiveEdge() {
    const {
      levelDetails: e
    } = this;
    return e === null ? null : e.edge + e.age
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime
  }
}
const GA = ["NONE", "TYPE-0", "TYPE-1", null];
var s0 = {
  No: "",
  Yes: "YES",
  v2: "v2"
};

function rze(t, e) {
  const {
    canSkipUntil: r,
    canSkipDateRanges: n,
    endSN: i
  } = t, a = e !== void 0 ? e - i : 0;
  return r && a < r ? n ? s0.v2 : s0.Yes : s0.No
}
class W5 {
  constructor(e, r, n) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = r, this.skip = n
  }
  addDirectives(e) {
    const r = new self.URL(e);
    return this.msn !== void 0 && r.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && r.searchParams.set("_HLS_part", this.part.toString()), this.skip && r.searchParams.set("_HLS_skip", this.skip), r.href
  }
}
class ep {
  constructor(e) {
    this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter(r => r).join(",").replace(/\.[^.,]+/g, "")
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate)
  }
  get attrs() {
    return this._attrs[this._urlId]
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || "."
  }
  get uri() {
    return this.url[this._urlId] || ""
  }
  get urlId() {
    return this._urlId
  }
  set urlId(e) {
    const r = e % this.url.length;
    this._urlId !== r && (this.fragmentError = 0, this.loadError = 0, this.details = void 0, this._urlId = r)
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroupIds) == null ? void 0 : e[this.urlId]
  }
  get textGroupId() {
    var e;
    return (e = this.textGroupIds) == null ? void 0 : e[this.urlId]
  }
  addFallback(e) {
    this.url.push(e.url), this._attrs.push(e.attrs)
  }
}

function nw(t, e) {
  const r = e.startPTS;
  if (ge(r)) {
    let n = 0,
      i;
    e.sn > t.sn ? (n = r - t.start, i = t) : (n = t.start - r, i = e), i.duration !== n && (i.duration = n)
  } else e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration : e.start = Math.max(t.start - e.duration, 0)
}

function SQ(t, e, r, n, i, a) {
  n - r <= 0 && (G.warn("Fragment should have a positive duration", e), n = r + e.duration, a = i + e.duration);
  let o = r,
    c = n;
  const l = e.startPTS,
    u = e.endPTS;
  if (ge(l)) {
    const g = Math.abs(l - r);
    ge(e.deltaPTS) ? e.deltaPTS = Math.max(g, e.deltaPTS) : e.deltaPTS = g, o = Math.max(r, l), r = Math.min(r, l), i = Math.min(i, e.startDTS), c = Math.min(n, u), n = Math.max(n, u), a = Math.max(a, e.endDTS)
  }
  const f = r - e.start;
  e.start !== 0 && (e.start = r), e.duration = n - e.start, e.startPTS = r, e.maxStartPTS = o, e.startDTS = i, e.endPTS = n, e.minEndPTS = c, e.endDTS = a;
  const d = e.sn;
  if (!t || d < t.startSN || d > t.endSN) return 0;
  let h;
  const p = d - t.startSN,
    v = t.fragments;
  for (v[p] = e, h = p; h > 0; h--) nw(v[h], v[h - 1]);
  for (h = p; h < v.length - 1; h++) nw(v[h], v[h + 1]);
  return t.fragmentHint && nw(v[v.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, f
}

function nze(t, e) {
  let r = null;
  const n = t.fragments;
  for (let c = n.length - 1; c >= 0; c--) {
    const l = n[c].initSegment;
    if (l) {
      r = l;
      break
    }
  }
  t.fragmentHint && delete t.fragmentHint.endPTS;
  let i = 0,
    a;
  if (sze(t, e, (c, l) => {
      c.relurl && (i = c.cc - l.cc), ge(c.startPTS) && ge(c.endPTS) && (l.start = l.startPTS = c.startPTS, l.startDTS = c.startDTS, l.maxStartPTS = c.maxStartPTS, l.endPTS = c.endPTS, l.endDTS = c.endDTS, l.minEndPTS = c.minEndPTS, l.duration = c.endPTS - c.startPTS, l.duration && (a = l), e.PTSKnown = e.alignedSliding = !0), l.elementaryStreams = c.elementaryStreams, l.loader = c.loader, l.stats = c.stats, l.urlId = c.urlId, c.initSegment && (l.initSegment = c.initSegment, r = c.initSegment)
    }), r && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach(l => {
      var u;
      (!l.initSegment || l.initSegment.relurl === ((u = r) == null ? void 0 : u.relurl)) && (l.initSegment = r)
    }), e.skippedSegments)
    if (e.deltaUpdateFailed = e.fragments.some(c => !c), e.deltaUpdateFailed) {
      G.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let c = e.skippedSegments; c--;) e.fragments.shift();
      e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc
    } else e.canSkipDateRanges && (e.dateRanges = ize(t.dateRanges, e.dateRanges, e.recentlyRemovedDateranges));
  const s = e.fragments;
  if (i) {
    G.warn("discontinuity sliding from playlist, take drift into account");
    for (let c = 0; c < s.length; c++) s[c].cc += i
  }
  e.skippedSegments && (e.startCC = e.fragments[0].cc), aze(t.partList, e.partList, (c, l) => {
    l.elementaryStreams = c.elementaryStreams, l.stats = c.stats
  }), a ? SQ(e, a, a.startPTS, a.endPTS, a.startDTS, a.endDTS) : _Q(t, e), s.length && (e.totalduration = e.edge - s[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
  const o = e.advancedDateTime;
  if (e.advanced && o) {
    const c = e.edge;
    e.driftStart || (e.driftStartTime = o, e.driftStart = c), e.driftEndTime = o, e.driftEnd = c
  } else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime
}

function ize(t, e, r) {
  const n = Nt({}, t);
  return r && r.forEach(i => {
    delete n[i]
  }), Object.keys(e).forEach(i => {
    const a = new iQ(e[i].attr, n[i]);
    a.isValid ? n[i] = a : G.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[i].attr)}"`)
  }), n
}

function aze(t, e, r) {
  if (t && e) {
    let n = 0;
    for (let i = 0, a = t.length; i <= a; i++) {
      const s = t[i],
        o = e[i + n];
      s && o && s.index === o.index && s.fragment.sn === o.fragment.sn ? r(s, o) : n--
    }
  }
}

function sze(t, e, r) {
  const n = e.skippedSegments,
    i = Math.max(t.startSN, e.startSN) - e.startSN,
    a = (t.fragmentHint ? 1 : 0) + (n ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN,
    s = e.startSN - t.startSN,
    o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments,
    c = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments;
  for (let l = i; l <= a; l++) {
    const u = c[s + l];
    let f = o[l];
    n && !f && l < n && (f = e.fragments[l] = u), u && f && r(u, f)
  }
}

function _Q(t, e) {
  const r = e.startSN + e.skippedSegments - t.startSN,
    n = t.fragments;
  r < 0 || r >= n.length || VA(e, n[r].start)
}

function VA(t, e) {
  if (e) {
    const r = t.fragments;
    for (let n = t.skippedSegments; n < r.length; n++) r[n].start += e;
    t.fragmentHint && (t.fragmentHint.start += e)
  }
}

function oze(t, e = 1 / 0) {
  let r = 1e3 * t.targetduration;
  if (t.updated) {
    const n = t.fragments,
      i = 4;
    if (n.length && r * i > e) {
      const a = n[n.length - 1].duration * 1e3;
      a < r && (r = a)
    }
  } else r /= 2;
  return Math.round(r)
}

function lze(t, e, r) {
  if (!(t != null && t.details)) return null;
  const n = t.details;
  let i = n.fragments[e - n.startSN];
  return i || (i = n.fragmentHint, i && i.sn === e) ? i : e < n.startSN && r && r.sn === e ? r : null
}

function K5(t, e, r) {
  var n;
  return t != null && t.details ? TQ((n = t.details) == null ? void 0 : n.partList, e, r) : null
}

function TQ(t, e, r) {
  if (t)
    for (let n = t.length; n--;) {
      const i = t[n];
      if (i.index === r && i.fragment.sn === e) return i
    }
  return null
}

function L1(t) {
  switch (t.details) {
    case q.FRAG_LOAD_TIMEOUT:
    case q.KEY_LOAD_TIMEOUT:
    case q.LEVEL_LOAD_TIMEOUT:
    case q.MANIFEST_LOAD_TIMEOUT:
      return !0
  }
  return !1
}

function Y5(t, e) {
  const r = L1(e);
  return t.default[`${r?"timeout":"error"}Retry`]
}

function $O(t, e) {
  const r = t.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(r * t.retryDelayMs, t.maxRetryDelayMs)
}

function q5(t) {
  return an(an({}, t), {
    errorRetry: null,
    timeoutRetry: null
  })
}

function P1(t, e, r, n) {
  return !!t && e < t.maxNumRetry && (cze(n) || !!r)
}

function cze(t) {
  return t === 0 && navigator.onLine === !1 || !!t && (t < 400 || t > 499)
}
const wQ = {
  search: function (t, e) {
    let r = 0,
      n = t.length - 1,
      i = null,
      a = null;
    for (; r <= n;) {
      i = (r + n) / 2 | 0, a = t[i];
      const s = e(a);
      if (s > 0) r = i + 1;
      else if (s < 0) n = i - 1;
      else return a
    }
    return null
  }
};

function uze(t, e, r) {
  if (e === null || !Array.isArray(t) || !t.length || !ge(e)) return null;
  const n = t[0].programDateTime;
  if (e < (n || 0)) return null;
  const i = t[t.length - 1].endProgramDateTime;
  if (e >= (i || 0)) return null;
  r = r || 0;
  for (let a = 0; a < t.length; ++a) {
    const s = t[a];
    if (fze(e, r, s)) return s
  }
  return null
}

function tp(t, e, r = 0, n = 0) {
  let i = null;
  if (t ? i = e[t.sn - e[0].sn + 1] || null : r === 0 && e[0].start === 0 && (i = e[0]), i && WA(r, n, i) === 0) return i;
  const a = wQ.search(e, WA.bind(null, r, n));
  return a && (a !== t || !i) ? a : i
}

function WA(t = 0, e = 0, r) {
  if (r.start <= t && r.start + r.duration > t) return 0;
  const n = Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
  return r.start + r.duration - n <= t ? 1 : r.start - n > t && r.start ? -1 : 0
}

function fze(t, e, r) {
  const n = Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0)) * 1e3;
  return (r.endProgramDateTime || 0) - n > t
}

function dze(t, e) {
  return wQ.search(t, r => r.cc < e ? 1 : r.cc > e ? -1 : 0)
}
const hze = 3e5;
var Hr = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  },
  Bn = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
  };
class pze {
  constructor(e) {
    this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = G.log.bind(G, "[info]:"), this.warn = G.warn.bind(G, "[warning]:"), this.error = G.error.bind(G, "[error]:"), this.registerListeners()
  }
  registerListeners() {
    const e = this.hls;
    e.on($.ERROR, this.onError, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this)
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off($.ERROR, this.onError, this), e.off($.ERROR, this.onErrorOut, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this))
  }
  destroy() {
    this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
  }
  startLoad(e) {
    this.playlistError = 0
  }
  stopLoad() {}
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === ye.MAIN ? e.level : this.hls.loadLevel
  }
  onManifestLoading() {
    this.playlistError = 0, this.penalizedRenditions = {}
  }
  onError(e, r) {
    var n;
    if (r.fatal) return;
    const i = this.hls,
      a = r.context;
    switch (r.details) {
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        r.errorAction = this.getFragRetryOrSwitchAction(r);
        return;
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR: {
        r.errorAction = this.getFragRetryOrSwitchAction(r), r.errorAction.action = Hr.SendAlternateToPenaltyBox;
        return
      }
      case q.LEVEL_EMPTY_ERROR:
      case q.LEVEL_PARSING_ERROR: {
        var s, o;
        const c = r.parent === ye.MAIN ? r.level : i.loadLevel;
        r.details === q.LEVEL_EMPTY_ERROR && ((s = r.context) != null && (o = s.levelDetails) != null && o.live) ? r.errorAction = this.getPlaylistRetryOrSwitchAction(r, c) : (r.levelRetry = !1, r.errorAction = this.getLevelSwitchAction(r, c))
      }
      return;
    case q.LEVEL_LOAD_ERROR:
    case q.LEVEL_LOAD_TIMEOUT:
      typeof (a == null ? void 0 : a.level) == "number" && (r.errorAction = this.getPlaylistRetryOrSwitchAction(r, a.level));
      return;
    case q.AUDIO_TRACK_LOAD_ERROR:
    case q.AUDIO_TRACK_LOAD_TIMEOUT:
    case q.SUBTITLE_LOAD_ERROR:
    case q.SUBTITLE_TRACK_LOAD_TIMEOUT:
      if (a) {
        const c = i.levels[i.loadLevel];
        if (c && (a.type === ze.AUDIO_TRACK && a.groupId === c.audioGroupId || a.type === ze.SUBTITLE_TRACK && a.groupId === c.textGroupId)) {
          r.errorAction = this.getPlaylistRetryOrSwitchAction(r, i.loadLevel), r.errorAction.action = Hr.SendAlternateToPenaltyBox, r.errorAction.flags = Bn.MoveAllAlternatesMatchingHost;
          return
        }
      }
      return;
    case q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: {
      const c = i.levels[i.loadLevel],
        l = c == null ? void 0 : c.attrs["HDCP-LEVEL"];
      l && (r.errorAction = {
        action: Hr.SendAlternateToPenaltyBox,
        flags: Bn.MoveAllAlternatesMatchingHDCP,
        hdcpLevel: l
      })
    }
    return;
    case q.BUFFER_ADD_CODEC_ERROR:
    case q.REMUX_ALLOC_ERROR:
      r.errorAction = this.getLevelSwitchAction(r, (n = r.level) != null ? n : i.loadLevel);
      return;
    case q.INTERNAL_EXCEPTION:
    case q.BUFFER_APPENDING_ERROR:
    case q.BUFFER_APPEND_ERROR:
    case q.BUFFER_FULL_ERROR:
    case q.LEVEL_SWITCH_ERROR:
    case q.BUFFER_STALLED_ERROR:
    case q.BUFFER_SEEK_OVER_HOLE:
    case q.BUFFER_NUDGE_ON_STALL:
      r.errorAction = {
        action: Hr.DoNothing,
        flags: Bn.None
      };
      return
    }
    if (r.type === ve.KEY_SYSTEM_ERROR) {
      const c = this.getVariantLevelIndex(r.frag);
      r.levelRetry = !1, r.errorAction = this.getLevelSwitchAction(r, c);
      return
    }
  }
  getPlaylistRetryOrSwitchAction(e, r) {
    var n, i;
    const a = this.hls,
      s = Y5(a.config.playlistLoadPolicy, e),
      o = this.playlistError++,
      c = (n = e.response) == null ? void 0 : n.code;
    return P1(s, o, L1(e), c) ? {
      action: Hr.RetryRequest,
      flags: Bn.None,
      retryConfig: s,
      retryCount: o
    } : (i = e.context) != null && i.deliveryDirectives ? {
      action: Hr.DoNothing,
      flags: Bn.None,
      retryConfig: s || {
        maxNumRetry: 0,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      retryCount: o
    } : this.getLevelSwitchAction(e, r)
  }
  getFragRetryOrSwitchAction(e) {
    const r = this.hls,
      n = this.getVariantLevelIndex(e.frag),
      i = r.levels[n],
      {
        fragLoadPolicy: a,
        keyLoadPolicy: s
      } = r.config,
      o = Y5(e.details.startsWith("key") ? s : a, e),
      c = r.levels.reduce((f, d) => f + d.fragmentError, 0);
    if (i) {
      var l;
      e.details !== q.FRAG_GAP && i.fragmentError++;
      const f = (l = e.response) == null ? void 0 : l.code;
      if (P1(o, c, L1(e), f)) return {
        action: Hr.RetryRequest,
        flags: Bn.None,
        retryConfig: o,
        retryCount: c
      }
    }
    const u = this.getLevelSwitchAction(e, n);
    return o && (u.retryConfig = o, u.retryCount = c), u
  }
  getLevelSwitchAction(e, r) {
    const n = this.hls;
    r == null && (r = n.loadLevel);
    const i = this.hls.levels[r];
    if (i && (i.loadError++, n.autoLevelEnabled)) {
      var a, s;
      let o = -1;
      const c = n.levels,
        l = (a = e.frag) == null ? void 0 : a.type,
        {
          type: u,
          groupId: f
        } = (s = e.context) != null ? s : {};
      for (let d = c.length; d--;) {
        const h = (d + n.loadLevel) % c.length;
        if (h !== n.loadLevel && c[h].loadError === 0) {
          const p = c[h];
          if (e.details === q.FRAG_GAP && e.frag) {
            const v = c[h].details;
            if (v) {
              const g = tp(e.frag, v.fragments, e.frag.start);
              if (g != null && g.gap) continue
            }
          } else {
            if (u === ze.AUDIO_TRACK && f === p.audioGroupId || u === ze.SUBTITLE_TRACK && f === p.textGroupId) continue;
            if (l === ye.AUDIO && i.audioGroupId === p.audioGroupId || l === ye.SUBTITLE && i.textGroupId === p.textGroupId) continue
          }
          o = h;
          break
        }
      }
      if (o > -1 && n.loadLevel !== o) return e.levelRetry = !0, {
        action: Hr.SendAlternateToPenaltyBox,
        flags: Bn.None,
        nextAutoLevel: o
      }
    }
    return {
      action: Hr.SendAlternateToPenaltyBox,
      flags: Bn.MoveAllAlternatesMatchingHost
    }
  }
  onErrorOut(e, r) {
    var n;
    switch ((n = r.errorAction) == null ? void 0 : n.action) {
      case Hr.DoNothing:
        break;
      case Hr.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(r), !r.errorAction.resolved && r.details !== q.FRAG_GAP && (r.fatal = !0);
        break
    }
    if (r.fatal) {
      this.hls.stopLoad();
      return
    }
  }
  sendAlternateToPenaltyBox(e) {
    const r = this.hls,
      n = e.errorAction;
    if (!n) return;
    const {
      flags: i,
      hdcpLevel: a,
      nextAutoLevel: s
    } = n;
    switch (i) {
      case Bn.None:
        this.switchLevel(e, s);
        break;
      case Bn.MoveAllAlternatesMatchingHost:
        n.resolved || (n.resolved = this.redundantFailover(e));
        break;
      case Bn.MoveAllAlternatesMatchingHDCP:
        a && (r.maxHdcpLevel = GA[GA.indexOf(a) - 1], n.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${r.maxHdcpLevel}" or lower`);
        break
    }
    n.resolved || this.switchLevel(e, s)
  }
  switchLevel(e, r) {
    r !== void 0 && e.errorAction && (this.warn(`switching to level ${r} after ${e.details}`), this.hls.nextAutoLevel = r, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel)
  }
  redundantFailover(e) {
    const {
      hls: r,
      penalizedRenditions: n
    } = this, i = e.parent === ye.MAIN ? e.level : r.loadLevel, a = r.levels[i], s = a.url.length, o = e.frag ? e.frag.urlId : a.urlId;
    a.urlId === o && (!e.frag || a.details) && this.penalizeRendition(a, e);
    for (let c = 1; c < s; c++) {
      const l = (o + c) % s,
        u = n[l];
      if (!u || gze(u, e, n[o])) return this.warn(`Switching to Redundant Stream ${l+1}/${s}: "${a.url[l]}" after ${e.details}`), this.playlistError = 0, r.levels.forEach(f => {
        f.urlId = l
      }), r.nextLoadLevel = i, !0
    }
    return !1
  }
  penalizeRendition(e, r) {
    const {
      penalizedRenditions: n
    } = this, i = n[e.urlId] || {
      lastErrorPerfMs: 0,
      errors: [],
      details: void 0
    };
    i.lastErrorPerfMs = performance.now(), i.errors.push(r), i.details = e.details, n[e.urlId] = i
  }
}

function gze(t, e, r) {
  if (performance.now() - t.lastErrorPerfMs > hze) return !0;
  const n = t.details;
  if (e.details === q.FRAG_GAP && n && e.frag) {
    const i = e.frag.start,
      a = tp(null, n.fragments, i);
    if (a && !a.gap) return !0
  }
  if (r && t.errors.length < r.errors.length) {
    const i = t.errors[t.errors.length - 1];
    if (n && i.frag && e.frag && Math.abs(i.frag.start - e.frag.start) > n.targetduration * 3) return !0
  }
  return !1
}
class CO {
  constructor(e, r) {
    this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = G.log.bind(G, `${r}:`), this.warn = G.warn.bind(G, `${r}:`), this.hls = e
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null
  }
  clearTimer() {
    clearTimeout(this.timer), this.timer = -1
  }
  startLoad() {
    this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist()
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer()
  }
  switchParams(e, r) {
    const n = r == null ? void 0 : r.renditionReports;
    if (n) {
      let i = -1;
      for (let a = 0; a < n.length; a++) {
        const s = n[a];
        let o;
        try {
          o = new self.URL(s.URI, r.url).href
        } catch (c) {
          G.warn(`Could not construct new URL for Rendition Report: ${c}`), o = s.URI || ""
        }
        if (o === e) {
          i = a;
          break
        } else o === e.substring(0, o.length) && (i = a)
      }
      if (i !== -1) {
        const a = n[i],
          s = parseInt(a["LAST-MSN"]) || (r == null ? void 0 : r.lastPartSn);
        let o = parseInt(a["LAST-PART"]) || (r == null ? void 0 : r.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const c = Math.min(r.age - r.partTarget, r.targetduration);
          o >= 0 && c > r.partTarget && (o += 1)
        }
        return new W5(s, o >= 0 ? o : void 0, s0.No)
      }
    }
  }
  loadPlaylist(e) {
    this.requestScheduled === -1 && (this.requestScheduled = self.performance.now())
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
  }
  shouldReloadPlaylist(e) {
    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(e)
  }
  playlistLoaded(e, r, n) {
    const {
      details: i,
      stats: a
    } = r, s = self.performance.now(), o = a.loading.first ? Math.max(0, s - a.loading.first) : 0;
    if (i.advancedDateTime = Date.now() - o, i.live || n != null && n.live) {
      if (i.reloaded(n), n && this.log(`live playlist ${e} ${i.advanced?"REFRESHED "+i.lastPartSn+"-"+i.lastPartIndex:"MISSED"}`), n && i.fragments.length > 0 && nze(n, i), !this.canLoad || !i.live) return;
      let c, l, u;
      if (i.canBlockReload && i.endSN && i.advanced) {
        const g = this.hls.config.lowLatencyMode,
          m = i.lastPartSn,
          y = i.endSN,
          x = i.lastPartIndex,
          b = x !== -1,
          _ = m === y,
          S = g ? 0 : x;
        b ? (l = _ ? y + 1 : m, u = _ ? S : x + 1) : l = y + 1;
        const T = i.age,
          R = T + i.ageHeader;
        let I = Math.min(R - i.partTarget, i.targetduration * 1.5);
        if (I > 0) {
          if (n && I > n.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${I} with playlist age: ${i.age}`), I = 0;
          else {
            const w = Math.floor(I / i.targetduration);
            if (l += w, u !== void 0) {
              const C = Math.round(I % i.targetduration / i.partTarget);
              u += C
            }
            this.log(`CDN Tune-in age: ${i.ageHeader}s last advanced ${T.toFixed(2)}s goal: ${I} skip sn ${w} to part ${u}`)
          }
          i.tuneInGoal = I
        }
        if (c = this.getDeliveryDirectives(i, r.deliveryDirectives, l, u), g || !_) {
          this.loadPlaylist(c);
          return
        }
      } else i.canBlockReload && (c = this.getDeliveryDirectives(i, r.deliveryDirectives, l, u));
      const f = this.hls.mainForwardBufferInfo,
        d = f ? f.end - f.len : 0,
        h = (i.edge - d) * 1e3,
        p = oze(i, h);
      i.updated && s > this.requestScheduled + p && (this.requestScheduled = a.loading.start), l !== void 0 && i.canBlockReload ? this.requestScheduled = a.loading.first + p - (i.partTarget * 1e3 || 1e3) : this.requestScheduled === -1 || this.requestScheduled + p < s ? this.requestScheduled = s : this.requestScheduled - s <= 0 && (this.requestScheduled += p);
      let v = this.requestScheduled - s;
      v = Math.max(0, v), this.log(`reload live playlist ${e} in ${Math.round(v)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(c), v)
    } else this.clearTimer()
  }
  getDeliveryDirectives(e, r, n, i) {
    let a = rze(e, n);
    return r != null && r.skip && e.deltaUpdateFailed && (n = r.msn, i = r.part, a = s0.No), new W5(n, i, a)
  }
  checkRetry(e) {
    const r = e.details,
      n = L1(e),
      i = e.errorAction,
      {
        action: a,
        retryCount: s = 0,
        retryConfig: o
      } = i || {},
      c = a === Hr.RetryRequest && !!i && !!o;
    if (c) {
      var l;
      if (this.requestScheduled = -1, n && (l = e.context) != null && l.deliveryDirectives) this.warn(`Retrying playlist loading ${s+1}/${o.maxNumRetry} after "${r}" without delivery-directives`), this.loadPlaylist();
      else {
        const u = $O(o, s);
        this.timer = self.setTimeout(() => this.loadPlaylist(), u), this.warn(`Retrying playlist loading ${s+1}/${o.maxNumRetry} after "${r}" in ${u}ms`)
      }
      e.levelRetry = !0, i.resolved = !0
    }
    return c
  }
}
let iw;
class mze extends CO {
  constructor(e, r) {
    super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = r, this._registerListeners()
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_LOADED, this.onManifestLoaded, this), e.on($.LEVEL_LOADED, this.onLevelLoaded, this), e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on($.FRAG_LOADED, this.onFragLoaded, this), e.on($.ERROR, this.onError, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_LOADED, this.onManifestLoaded, this), e.off($.LEVEL_LOADED, this.onLevelLoaded, this), e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off($.FRAG_LOADED, this.onFragLoaded, this), e.off($.ERROR, this.onError, this)
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
  }
  startLoad() {
    this._levels.forEach(r => {
      r.loadError = 0, r.fragmentError = 0
    }), super.startLoad()
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = []
  }
  onManifestLoading(e, r) {
    this.resetLevels()
  }
  onManifestLoaded(e, r) {
    const n = [],
      i = {};
    let a;
    r.levels.forEach(s => {
      var o;
      const c = s.attrs;
      ((o = s.audioCodec) == null ? void 0 : o.indexOf("mp4a.40.34")) !== -1 && (iw || (iw = /chrome|firefox/i.test(navigator.userAgent)), iw && (s.audioCodec = void 0));
      const {
        AUDIO: l,
        CODECS: u,
        "FRAME-RATE": f,
        "PATHWAY-ID": d,
        RESOLUTION: h,
        SUBTITLES: p
      } = c, g = `${`${d||"."}-`}${s.bitrate}-${h}-${f}-${u}`;
      a = i[g], a ? a.addFallback(s) : (a = new ep(s), i[g] = a, n.push(a)), N1(a, "audio", l), N1(a, "text", p)
    }), this.filterAndSortMediaOptions(n, r)
  }
  filterAndSortMediaOptions(e, r) {
    let n = [],
      i = [],
      a = !1,
      s = !1,
      o = !1,
      c = e.filter(({
        audioCodec: h,
        videoCodec: p,
        width: v,
        height: g,
        unknownCodecs: m
      }) => (a || (a = !!(v && g)), s || (s = !!p), o || (o = !!h), !(m != null && m.length) && (!h || ew(h, "audio")) && (!p || ew(p, "video"))));
    if ((a || s) && o && (c = c.filter(({
        videoCodec: h,
        width: p,
        height: v
      }) => !!h || !!(p && v))), c.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          const h = new Error("no level with compatible codecs found in manifest");
          this.hls.trigger($.ERROR, {
            type: ve.MEDIA_ERROR,
            details: q.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: r.url,
            error: h,
            reason: h.message
          })
        }
      });
      return
    }
    r.audioTracks && (n = r.audioTracks.filter(h => !h.audioCodec || ew(h.audioCodec, "audio")), X5(n)), r.subtitles && (i = r.subtitles, X5(i));
    const l = c.slice(0);
    c.sort((h, p) => h.attrs["HDCP-LEVEL"] !== p.attrs["HDCP-LEVEL"] ? (h.attrs["HDCP-LEVEL"] || "") > (p.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : h.bitrate !== p.bitrate ? h.bitrate - p.bitrate : h.attrs["FRAME-RATE"] !== p.attrs["FRAME-RATE"] ? h.attrs.decimalFloatingPoint("FRAME-RATE") - p.attrs.decimalFloatingPoint("FRAME-RATE") : h.attrs.SCORE !== p.attrs.SCORE ? h.attrs.decimalFloatingPoint("SCORE") - p.attrs.decimalFloatingPoint("SCORE") : a && h.height !== p.height ? h.height - p.height : 0);
    let u = l[0];
    if (this.steering && (c = this.steering.filterParsedLevels(c), c.length !== l.length)) {
      for (let h = 0; h < l.length; h++)
        if (l[h].pathwayId === c[0].pathwayId) {
          u = l[h];
          break
        }
    }
    this._levels = c;
    for (let h = 0; h < c.length; h++)
      if (c[h] === u) {
        this._firstLevel = h, this.log(`manifest loaded, ${c.length} level(s) found, first bitrate: ${u.bitrate}`);
        break
      } const f = o && !s,
      d = {
        levels: c,
        audioTracks: n,
        subtitleTracks: i,
        sessionData: r.sessionData,
        sessionKeys: r.sessionKeys,
        firstLevel: this._firstLevel,
        stats: r.stats,
        audio: o,
        video: s,
        altAudio: !f && n.some(h => !!h.url)
      };
    this.hls.trigger($.MANIFEST_PARSED, d), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels
  }
  get level() {
    return this.currentLevelIndex
  }
  set level(e) {
    const r = this._levels;
    if (r.length === 0) return;
    if (e < 0 || e >= r.length) {
      const u = new Error("invalid level idx"),
        f = e < 0;
      if (this.hls.trigger($.ERROR, {
          type: ve.OTHER_ERROR,
          details: q.LEVEL_SWITCH_ERROR,
          level: e,
          fatal: f,
          error: u,
          reason: u.message
        }), f) return;
      e = Math.min(e, r.length - 1)
    }
    const n = this.currentLevelIndex,
      i = this.currentLevel,
      a = i ? i.attrs["PATHWAY-ID"] : void 0,
      s = r[e],
      o = s.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = s, n === e && s.details && i && a === o) return;
    this.log(`Switching to level ${e}${o?" with Pathway "+o:""} from level ${n}${a?" with Pathway "+a:""}`);
    const c = Nt({}, s, {
      level: e,
      maxBitrate: s.maxBitrate,
      attrs: s.attrs,
      uri: s.uri,
      urlId: s.urlId
    });
    delete c._attrs, delete c._urlId, this.hls.trigger($.LEVEL_SWITCHING, c);
    const l = s.details;
    if (!l || l.live) {
      const u = this.switchParams(s.uri, i == null ? void 0 : i.details);
      this.loadPlaylist(u)
    }
  }
  get manualLevel() {
    return this.manualLevelIndex
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e)
  }
  get firstLevel() {
    return this._firstLevel
  }
  set firstLevel(e) {
    this._firstLevel = e
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this._firstLevel
    } else return this._startLevel
  }
  set startLevel(e) {
    this._startLevel = e
  }
  onError(e, r) {
    r.fatal || !r.context || r.context.type === ze.LEVEL && r.context.level === this.level && this.checkRetry(r)
  }
  onFragLoaded(e, {
    frag: r
  }) {
    if (r !== void 0 && r.type === ye.MAIN) {
      const n = this._levels[r.level];
      n !== void 0 && (n.loadError = 0)
    }
  }
  onLevelLoaded(e, r) {
    var n;
    const {
      level: i,
      details: a
    } = r, s = this._levels[i];
    if (!s) {
      var o;
      this.warn(`Invalid level index ${i}`), (o = r.deliveryDirectives) != null && o.skip && (a.deltaUpdateFailed = !0);
      return
    }
    i === this.currentLevelIndex ? (s.fragmentError === 0 && (s.loadError = 0), this.playlistLoaded(i, r, s.details)) : (n = r.deliveryDirectives) != null && n.skip && (a.deltaUpdateFailed = !0)
  }
  onAudioTrackSwitched(e, r) {
    const n = this.currentLevel;
    if (!n) return;
    const i = this.hls.audioTracks[r.id].groupId;
    if (n.audioGroupIds && n.audioGroupId !== i) {
      let a = -1;
      for (let s = 0; s < n.audioGroupIds.length; s++)
        if (n.audioGroupIds[s] === i) {
          a = s;
          break
        } a !== -1 && a !== n.urlId && (n.urlId = a, this.canLoad && this.startLoad())
    }
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const r = this.currentLevelIndex,
      n = this.currentLevel;
    if (n && this.shouldLoadPlaylist(n)) {
      const i = n.urlId;
      let a = n.uri;
      if (e) try {
        a = e.addDirectives(a)
      } catch (o) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`)
      }
      const s = n.attrs["PATHWAY-ID"];
      this.log(`Loading level index ${r}${(e==null?void 0:e.msn)!==void 0?" at sn "+e.msn+" part "+e.part:""} with${s?" Pathway "+s:""} URI ${i+1}/${n.url.length} ${a}`), this.clearTimer(), this.hls.trigger($.LEVEL_LOADING, {
        url: a,
        level: r,
        id: i,
        deliveryDirectives: e || null
      })
    }
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e)
  }
  removeLevel(e, r) {
    const n = (a, s) => s !== r,
      i = this._levels.filter((a, s) => s !== e ? !0 : a.url.length > 1 && r !== void 0 ? (a.url = a.url.filter(n), a.audioGroupIds && (a.audioGroupIds = a.audioGroupIds.filter(n)), a.textGroupIds && (a.textGroupIds = a.textGroupIds.filter(n)), a.urlId = 0, !0) : (this.steering && this.steering.removeLevel(a), !1));
    this.hls.trigger($.LEVELS_UPDATED, {
      levels: i
    })
  }
  onLevelsUpdated(e, {
    levels: r
  }) {
    r.forEach((n, i) => {
      const {
        details: a
      } = n;
      a != null && a.fragments && a.fragments.forEach(s => {
        s.level = i
      })
    }), this._levels = r
  }
}

function N1(t, e, r) {
  r && (e === "audio" ? (t.audioGroupIds || (t.audioGroupIds = []), t.audioGroupIds[t.url.length - 1] = r) : e === "text" && (t.textGroupIds || (t.textGroupIds = []), t.textGroupIds[t.url.length - 1] = r))
}

function X5(t) {
  const e = {};
  t.forEach(r => {
    const n = r.groupId || "";
    r.id = e[n] = e[n] || 0, e[n]++
  })
}
var Tr = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class vze {
  constructor(e) {
    this.mainFragEntity = null, this.activeParts = null, this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners()
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.BUFFER_APPENDED, this.onBufferAppended, this), e.on($.FRAG_BUFFERED, this.onFragBuffered, this), e.on($.FRAG_LOADED, this.onFragLoaded, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.BUFFER_APPENDED, this.onBufferAppended, this), e.off($.FRAG_BUFFERED, this.onFragBuffered, this), e.off($.FRAG_LOADED, this.onFragLoaded, this)
  }
  destroy() {
    this._unregisterListeners(), this.fragments = this.endListFragments = this.timeRanges = this.mainFragEntity = this.activeParts = null
  }
  getAppendedFrag(e, r) {
    if (r === ye.MAIN) {
      const {
        mainFragEntity: n,
        activeParts: i
      } = this;
      if (n) {
        if (n && i)
          for (let a = i.length; a--;) {
            const s = i[a],
              o = s ? s.end : n.appendedPTS;
            if (s.start <= e && o !== null && e <= o) return a > 9 && (this.activeParts = i.slice(a - 9)), s
          } else if (n.body.start <= e && n.appendedPTS !== null && e <= n.appendedPTS) return n.body
      }
    }
    return this.getBufferedFrag(e, r)
  }
  getBufferedFrag(e, r) {
    const {
      fragments: n
    } = this, i = Object.keys(n);
    for (let a = i.length; a--;) {
      const s = n[i[a]];
      if ((s == null ? void 0 : s.body.type) === r && s.buffered) {
        const o = s.body;
        if (o.start <= e && e <= o.end) return o
      }
    }
    return null
  }
  detectEvictedFragments(e, r, n) {
    this.timeRanges && (this.timeRanges[e] = r), Object.keys(this.fragments).forEach(i => {
      const a = this.fragments[i];
      if (!a) return;
      if (!a.buffered && !a.loaded) {
        a.body.type === n && this.removeFragment(a.body);
        return
      }
      const s = a.range[e];
      s && s.time.some(o => {
        const c = !this.isTimeBuffered(o.startPTS, o.endPTS, r);
        return c && this.removeFragment(a.body), c
      })
    })
  }
  detectPartialFragments(e) {
    const r = this.timeRanges,
      {
        frag: n,
        part: i
      } = e;
    if (!r || n.sn === "initSegment") return;
    const a = Fs(n),
      s = this.fragments[a];
    s && (Object.keys(r).forEach(o => {
      const c = n.elementaryStreams[o];
      if (!c) return;
      const l = r[o],
        u = i !== null || c.partial === !0;
      s.range[o] = this.getBufferedTimes(n, i, u, l)
    }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, s.body.endList && (this.endListFragments[s.body.type] = s)) : this.removeFragment(s.body))
  }
  fragBuffered(e, r) {
    const n = Fs(e);
    let i = this.fragments[n];
    !i && r && (i = this.fragments[n] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: Object.create(null)
    }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0)
  }
  getBufferedTimes(e, r, n, i) {
    const a = {
        time: [],
        partial: n
      },
      s = r ? r.start : e.start,
      o = r ? r.end : e.end,
      c = e.minEndPTS || o,
      l = e.maxStartPTS || s;
    for (let u = 0; u < i.length; u++) {
      const f = i.start(u) - this.bufferPadding,
        d = i.end(u) + this.bufferPadding;
      if (l >= f && c <= d) {
        a.time.push({
          startPTS: Math.max(s, i.start(u)),
          endPTS: Math.min(o, i.end(u))
        });
        break
      } else if (s < d && o > f) a.partial = !0, a.time.push({
        startPTS: Math.max(s, i.start(u)),
        endPTS: Math.min(o, i.end(u))
      });
      else if (o <= f) break
    }
    return a
  }
  getPartialFragment(e) {
    let r = null,
      n, i, a, s = 0;
    const {
      bufferPadding: o,
      fragments: c
    } = this;
    return Object.keys(c).forEach(l => {
      const u = c[l];
      u && aw(u) && (i = u.body.start - o, a = u.body.end + o, e >= i && e <= a && (n = Math.min(e - i, a - e), s <= n && (r = u.body, s = n)))
    }), r
  }
  isEndListAppended(e) {
    const r = this.endListFragments[e];
    return r !== void 0 && (r.buffered || aw(r))
  }
  getState(e) {
    const r = Fs(e),
      n = this.fragments[r];
    return n ? n.buffered ? aw(n) ? Tr.PARTIAL : Tr.OK : Tr.APPENDING : Tr.NOT_LOADED
  }
  isTimeBuffered(e, r, n) {
    let i, a;
    for (let s = 0; s < n.length; s++) {
      if (i = n.start(s) - this.bufferPadding, a = n.end(s) + this.bufferPadding, e >= i && r <= a) return !0;
      if (r <= i) return !1
    }
    return !1
  }
  onFragLoaded(e, r) {
    const {
      frag: n,
      part: i
    } = r;
    if (n.sn === "initSegment" || n.bitrateTest || i) return;
    const a = Fs(n);
    this.fragments[a] = {
      body: n,
      appendedPTS: null,
      loaded: r,
      buffered: !1,
      range: Object.create(null)
    }
  }
  onBufferAppended(e, r) {
    const {
      frag: n,
      part: i,
      timeRanges: a
    } = r;
    let s = this.mainFragEntity;
    if (n.type === ye.MAIN) {
      const o = s ? s.body : null;
      if (o !== n) {
        s && o && o.sn !== n.sn && (s.buffered = !0, this.fragments[Fs(o)] = s);
        const c = Fs(n);
        s = this.mainFragEntity = this.fragments[c] || {
          body: n,
          appendedPTS: null,
          loaded: null,
          buffered: !1,
          range: Object.create(null)
        }
      }
      if (i) {
        let c = this.activeParts;
        c || (this.activeParts = c = []), c.push(i)
      } else this.activeParts = null
    }
    this.timeRanges = a, Object.keys(a).forEach(o => {
      const c = a[o];
      if (this.detectEvictedFragments(o, c), !i && s) {
        const l = n.elementaryStreams[o];
        if (!l) return;
        for (let u = 0; u < c.length; u++) {
          const f = c.end(u);
          f <= l.endPTS && f > l.startPTS ? s.appendedPTS = Math.max(f, s.appendedPTS || 0) : s.appendedPTS = l.endPTS
        }
      }
    })
  }
  onFragBuffered(e, r) {
    this.detectPartialFragments(r)
  }
  hasFragment(e) {
    const r = Fs(e);
    return !!this.fragments[r]
  }
  removeFragmentsInRange(e, r, n, i, a) {
    i && !this.hasGaps || Object.keys(this.fragments).forEach(s => {
      const o = this.fragments[s];
      if (!o) return;
      const c = o.body;
      c.type !== n || i && !c.gap || c.start < r && c.end > e && (o.buffered || a) && this.removeFragment(c)
    })
  }
  removeFragment(e) {
    const r = Fs(e);
    e.stats.loaded = 0, e.clearElementaryStreamInfo(), this.mainFragEntity === this.fragments[r] && (this.mainFragEntity = null), delete this.fragments[r], e.endList && delete this.endListFragments[e.type]
  }
  removeAllFragments() {
    this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.mainFragEntity = null, this.activeParts = null, this.hasGaps = !1
  }
}

function aw(t) {
  var e, r;
  return t.buffered && (t.body.gap || ((e = t.range.video) == null ? void 0 : e.partial) || ((r = t.range.audio) == null ? void 0 : r.partial))
}

function Fs(t) {
  return `${t.type}_${t.level}_${t.urlId}_${t.sn}`
}
const Q5 = Math.pow(2, 17);
class yze {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null)
  }
  abort() {
    this.loader && this.loader.abort()
  }
  load(e, r) {
    const n = e.url;
    if (!n) return Promise.reject(new Ua({
      type: ve.NETWORK_ERROR,
      details: q.FRAG_LOAD_ERROR,
      fatal: !1,
      frag: e,
      error: new Error(`Fragment does not have a ${n?"part list":"url"}`),
      networkDetails: null
    }));
    this.abort();
    const i = this.config,
      a = i.fLoader,
      s = i.loader;
    return new Promise((o, c) => {
      if (this.loader && this.loader.destroy(), e.gap) {
        c(J5(e));
        return
      }
      const l = this.loader = e.loader = a ? new a(i) : new s(i),
        u = Z5(e),
        f = q5(i.fragLoadPolicy.default),
        d = {
          loadPolicy: f,
          timeout: f.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: e.sn === "initSegment" ? 1 / 0 : Q5
        };
      e.stats = l.stats, l.load(u, d, {
        onSuccess: (h, p, v, g) => {
          this.resetLoader(e, l);
          let m = h.data;
          v.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(m.slice(0, 16)), m = m.slice(16)), o({
            frag: e,
            part: null,
            payload: m,
            networkDetails: g
          })
        },
        onError: (h, p, v, g) => {
          this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: an({
              url: n,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: v,
            stats: g
          }))
        },
        onAbort: (h, p, v) => {
          this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: v,
            stats: h
          }))
        },
        onTimeout: (h, p, v) => {
          this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${d.timeout}ms`),
            networkDetails: v,
            stats: h
          }))
        },
        onProgress: (h, p, v, g) => {
          r && r({
            frag: e,
            part: null,
            payload: v,
            networkDetails: g
          })
        }
      })
    })
  }
  loadPart(e, r, n) {
    this.abort();
    const i = this.config,
      a = i.fLoader,
      s = i.loader;
    return new Promise((o, c) => {
      if (this.loader && this.loader.destroy(), e.gap || r.gap) {
        c(J5(e, r));
        return
      }
      const l = this.loader = e.loader = a ? new a(i) : new s(i),
        u = Z5(e, r),
        f = q5(i.fragLoadPolicy.default),
        d = {
          loadPolicy: f,
          timeout: f.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: Q5
        };
      r.stats = l.stats, l.load(u, d, {
        onSuccess: (h, p, v, g) => {
          this.resetLoader(e, l), this.updateStatsFromPart(e, r);
          const m = {
            frag: e,
            part: r,
            payload: h.data,
            networkDetails: g
          };
          n(m), o(m)
        },
        onError: (h, p, v, g) => {
          this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: r,
            response: an({
              url: u.url,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: v,
            stats: g
          }))
        },
        onAbort: (h, p, v) => {
          e.stats.aborted = r.stats.aborted, this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: r,
            error: new Error("Aborted"),
            networkDetails: v,
            stats: h
          }))
        },
        onTimeout: (h, p, v) => {
          this.resetLoader(e, l), c(new Ua({
            type: ve.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: r,
            error: new Error(`Timeout after ${d.timeout}ms`),
            networkDetails: v,
            stats: h
          }))
        }
      })
    })
  }
  updateStatsFromPart(e, r) {
    const n = e.stats,
      i = r.stats,
      a = i.total;
    if (n.loaded += i.loaded, a) {
      const c = Math.round(e.duration / r.duration),
        l = Math.min(Math.round(n.loaded / a), c),
        f = (c - l) * Math.round(n.loaded / l);
      n.total = n.loaded + f
    } else n.total = Math.max(n.loaded, n.total);
    const s = n.loading,
      o = i.loading;
    s.start ? s.first += o.first - o.start : (s.start = o.start, s.first = o.first), s.end = o.end
  }
  resetLoader(e, r) {
    e.loader = null, this.loader === r && (self.clearTimeout(this.partLoadTimeout), this.loader = null), r.destroy()
  }
}

function Z5(t, e = null) {
  const r = e || t,
    n = {
      frag: t,
      part: e,
      responseType: "arraybuffer",
      url: r.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    },
    i = r.byteRangeStartOffset,
    a = r.byteRangeEndOffset;
  if (ge(i) && ge(a)) {
    var s;
    let o = i,
      c = a;
    if (t.sn === "initSegment" && ((s = t.decryptdata) == null ? void 0 : s.method) === "AES-128") {
      const l = a - i;
      l % 16 && (c = a + (16 - l % 16)), i !== 0 && (n.resetIV = !0, o = i - 16)
    }
    n.rangeStart = o, n.rangeEnd = c
  }
  return n
}

function J5(t, e) {
  const r = new Error(`GAP ${t.gap?"tag":"attribute"} found`),
    n = {
      type: ve.MEDIA_ERROR,
      details: q.FRAG_GAP,
      fatal: !1,
      frag: t,
      error: r,
      networkDetails: null
    };
  return e && (n.part = e), (e || t).stats.aborted = !0, new Ua(n)
}
class Ua extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e
  }
}
class xze {
  constructor(e) {
    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e
  }
  abort() {
    for (const e in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[e].loader;
      r && r.abort()
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[e];
      (r.mediaKeySessionContext || r.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[e].loader;
      r && r.destroy()
    }
    this.keyUriToKeyInfo = {}
  }
  createKeyLoadError(e, r = q.KEY_LOAD_ERROR, n, i, a) {
    return new Ua({
      type: ve.NETWORK_ERROR,
      details: r,
      fatal: !1,
      frag: e,
      response: a,
      error: n,
      networkDetails: i
    })
  }
  loadClear(e, r) {
    if (this.emeController && this.config.emeEnabled) {
      const {
        sn: n,
        cc: i
      } = e;
      for (let a = 0; a < r.length; a++) {
        const s = r[a];
        if (i <= s.cc && (n === "initSegment" || s.sn === "initSegment" || n < s.sn)) {
          this.emeController.selectKeySystemFormat(s).then(o => {
            s.setKeyFormat(o)
          });
          break
        }
      }
    }
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then(r => this.loadInternal(e, r)) : this.loadInternal(e)
  }
  loadInternal(e, r) {
    var n, i;
    r && e.setKeyFormat(r);
    const a = e.decryptdata;
    if (!a) {
      const l = new Error(r ? `Expected frag.decryptdata to be defined after setting format ${r}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, l))
    }
    const s = a.uri;
    if (!s) return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${s}"`)));
    let o = this.keyUriToKeyInfo[s];
    if ((n = o) != null && n.decryptdata.key) return a.key = o.decryptdata.key, Promise.resolve({
      frag: e,
      keyInfo: o
    });
    if ((i = o) != null && i.keyLoadPromise) {
      var c;
      switch ((c = o.mediaKeySessionContext) == null ? void 0 : c.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return o.keyLoadPromise.then(l => (a.key = l.keyInfo.decryptdata.key, {
            frag: e,
            keyInfo: o
          }))
      }
    }
    switch (o = this.keyUriToKeyInfo[s] = {
      decryptdata: a,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, a.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return a.keyFormat === "identity" ? this.loadKeyHTTP(o, e) : this.loadKeyEME(o, e);
      case "AES-128":
        return this.loadKeyHTTP(o, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${a.method}"`)))
    }
  }
  loadKeyEME(e, r) {
    const n = {
      frag: r,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      const i = this.emeController.loadKey(n);
      if (i) return (e.keyLoadPromise = i.then(a => (e.mediaKeySessionContext = a, n))).catch(a => {
        throw e.keyLoadPromise = null, a
      })
    }
    return Promise.resolve(n)
  }
  loadKeyHTTP(e, r) {
    const n = this.config,
      i = n.loader,
      a = new i(n);
    return r.keyLoader = e.loader = a, e.keyLoadPromise = new Promise((s, o) => {
      const c = {
          keyInfo: e,
          frag: r,
          responseType: "arraybuffer",
          url: e.decryptdata.uri
        },
        l = n.keyLoadPolicy.default,
        u = {
          loadPolicy: l,
          timeout: l.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        },
        f = {
          onSuccess: (d, h, p, v) => {
            const {
              frag: g,
              keyInfo: m,
              url: y
            } = p;
            if (!g.decryptdata || m !== this.keyUriToKeyInfo[y]) return o(this.createKeyLoadError(g, q.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), v));
            m.decryptdata.key = g.decryptdata.key = new Uint8Array(d.data), g.keyLoader = null, m.loader = null, s({
              frag: g,
              keyInfo: m
            })
          },
          onError: (d, h, p, v) => {
            this.resetLoader(h), o(this.createKeyLoadError(r, q.KEY_LOAD_ERROR, new Error(`HTTP Error ${d.code} loading key ${d.text}`), p, an({
              url: c.url,
              data: void 0
            }, d)))
          },
          onTimeout: (d, h, p) => {
            this.resetLoader(h), o(this.createKeyLoadError(r, q.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), p))
          },
          onAbort: (d, h, p) => {
            this.resetLoader(h), o(this.createKeyLoadError(r, q.INTERNAL_ABORTED, new Error("key loading aborted"), p))
          }
        };
      a.load(c, u, f)
    })
  }
  resetLoader(e) {
    const {
      frag: r,
      keyInfo: n,
      url: i
    } = e, a = n.loader;
    r.keyLoader === a && (r.keyLoader = null, n.loader = null), delete this.keyUriToKeyInfo[i], a && a.destroy()
  }
}
class bze {
  constructor() {
    this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed()
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval()
  }
  onHandlerDestroyed() {}
  hasInterval() {
    return !!this._tickInterval
  }
  hasNextTick() {
    return !!this._tickTimer
  }
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0)
  }
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1
  }
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1
  }
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
  }
  doTick() {}
}
const Eze = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class ct {
  static isBuffered(e, r) {
    try {
      if (e) {
        const n = ct.getBuffered(e);
        for (let i = 0; i < n.length; i++)
          if (r >= n.start(i) && r <= n.end(i)) return !0
      }
    } catch {}
    return !1
  }
  static bufferInfo(e, r, n) {
    try {
      if (e) {
        const i = ct.getBuffered(e),
          a = [];
        let s;
        for (s = 0; s < i.length; s++) a.push({
          start: i.start(s),
          end: i.end(s)
        });
        return this.bufferedInfo(a, r, n)
      }
    } catch {}
    return {
      len: 0,
      start: r,
      end: r,
      nextStart: void 0
    }
  }
  static bufferedInfo(e, r, n) {
    r = Math.max(0, r), e.sort(function (l, u) {
      const f = l.start - u.start;
      return f || u.end - l.end
    });
    let i = [];
    if (n)
      for (let l = 0; l < e.length; l++) {
        const u = i.length;
        if (u) {
          const f = i[u - 1].end;
          e[l].start - f < n ? e[l].end > f && (i[u - 1].end = e[l].end) : i.push(e[l])
        } else i.push(e[l])
      } else i = e;
    let a = 0,
      s, o = r,
      c = r;
    for (let l = 0; l < i.length; l++) {
      const u = i[l].start,
        f = i[l].end;
      if (r + n >= u && r < f) o = u, c = f, a = c - r;
      else if (r + n < u) {
        s = u;
        break
      }
    }
    return {
      len: a,
      start: o || 0,
      end: c || 0,
      nextStart: s
    }
  }
  static getBuffered(e) {
    try {
      return e.buffered
    } catch (r) {
      return G.log("failed to get media.buffered", r), Eze
    }
  }
}
class kO {
  constructor(e, r, n, i = 0, a = -1, s = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = Wm(), this.buffering = {
      audio: Wm(),
      video: Wm(),
      audiovideo: Wm()
    }, this.level = e, this.sn = r, this.id = n, this.size = i, this.part = a, this.partial = s
  }
}

function Wm() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  }
}

function RQ(t, e) {
  let r = null;
  for (let n = 0, i = t.length; n < i; n++) {
    const a = t[n];
    if (a && a.cc === e) {
      r = a;
      break
    }
  }
  return r
}

function Sze(t, e, r) {
  return !!(e.details && (r.endCC > r.startCC || t && t.cc < r.startCC))
}

function _ze(t, e, r = 0) {
  const n = t.fragments,
    i = e.fragments;
  if (!i.length || !n.length) {
    G.log("No fragments to align");
    return
  }
  const a = RQ(n, i[0].cc);
  if (!a || a && !a.startPTS) {
    G.log("No frag in previous level to align on");
    return
  }
  return a
}

function eB(t, e) {
  if (t) {
    const r = t.start + e;
    t.start = t.startPTS = r, t.endPTS = r + t.duration
  }
}

function OO(t, e) {
  const r = e.fragments;
  for (let n = 0, i = r.length; n < i; n++) eB(r[n], t);
  e.fragmentHint && eB(e.fragmentHint, t), e.alignedSliding = !0
}

function Tze(t, e, r) {
  e && (wze(t, r, e), !r.alignedSliding && e.details && Rze(r, e.details), !r.alignedSliding && e.details && !r.skippedSegments && _Q(e.details, r))
}

function wze(t, e, r) {
  if (Sze(t, r, e)) {
    const n = _ze(r.details, e);
    n && ge(n.start) && (G.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`), OO(n.start, e))
  }
}

function Rze(t, e) {
  if (!e.fragments.length || !t.hasProgramDateTime || !e.hasProgramDateTime) return;
  const r = e.fragments[0].programDateTime,
    n = t.fragments[0].programDateTime,
    i = (n - r) / 1e3 + e.fragments[0].start;
  i && ge(i) && (G.log(`Adjusting PTS using programDateTime delta ${n-r}ms, sliding:${i.toFixed(3)} ${t.url} `), OO(i, t))
}

function AQ(t, e) {
  if (!t.hasProgramDateTime || !e.hasProgramDateTime) return;
  const r = t.fragments,
    n = e.fragments;
  if (!r.length || !n.length) return;
  const i = Math.round(n.length / 2) - 1,
    a = n[i],
    s = RQ(r, a.cc) || r[Math.round(r.length / 2) - 1],
    o = a.programDateTime,
    c = s.programDateTime;
  if (o === null || c === null) return;
  const l = (c - o) / 1e3 - (s.start - a.start);
  OO(l, t)
}
class Aze {
  constructor(e, r) {
    this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = r
  }
  decrypt(e, r) {
    return this.subtle.decrypt({
      name: "AES-CBC",
      iv: this.aesIV
    }, r, e)
  }
}
class Ize {
  constructor(e, r) {
    this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = r
  }
  expandKey() {
    return this.subtle.importKey("raw", this.key, {
      name: "AES-CBC"
    }, !1, ["encrypt", "decrypt"])
  }
}

function $ze(t) {
  const e = t.byteLength,
    r = e && new DataView(t.buffer).getUint8(e - 1);
  return r ? Hl(t, 0, e - r) : t
}
class Cze {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
  }
  uint8ArrayToUint32Array_(e) {
    const r = new DataView(e),
      n = new Uint32Array(4);
    for (let i = 0; i < 4; i++) n[i] = r.getUint32(i * 4);
    return n
  }
  initTable() {
    const e = this.sBox,
      r = this.invSBox,
      n = this.subMix,
      i = n[0],
      a = n[1],
      s = n[2],
      o = n[3],
      c = this.invSubMix,
      l = c[0],
      u = c[1],
      f = c[2],
      d = c[3],
      h = new Uint32Array(256);
    let p = 0,
      v = 0,
      g = 0;
    for (g = 0; g < 256; g++) g < 128 ? h[g] = g << 1 : h[g] = g << 1 ^ 283;
    for (g = 0; g < 256; g++) {
      let m = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4;
      m = m >>> 8 ^ m & 255 ^ 99, e[p] = m, r[m] = p;
      const y = h[p],
        x = h[y],
        b = h[x];
      let _ = h[m] * 257 ^ m * 16843008;
      i[p] = _ << 24 | _ >>> 8, a[p] = _ << 16 | _ >>> 16, s[p] = _ << 8 | _ >>> 24, o[p] = _, _ = b * 16843009 ^ x * 65537 ^ y * 257 ^ p * 16843008, l[m] = _ << 24 | _ >>> 8, u[m] = _ << 16 | _ >>> 16, f[m] = _ << 8 | _ >>> 24, d[m] = _, p ? (p = y ^ h[h[h[b ^ y]]], v ^= h[h[v]]) : p = v = 1
    }
  }
  expandKey(e) {
    const r = this.uint8ArrayToUint32Array_(e);
    let n = !0,
      i = 0;
    for (; i < r.length && n;) n = r[i] === this.key[i], i++;
    if (n) return;
    this.key = r;
    const a = this.keySize = r.length;
    if (a !== 4 && a !== 6 && a !== 8) throw new Error("Invalid aes key size=" + a);
    const s = this.ksRows = (a + 6 + 1) * 4;
    let o, c;
    const l = this.keySchedule = new Uint32Array(s),
      u = this.invKeySchedule = new Uint32Array(s),
      f = this.sBox,
      d = this.rcon,
      h = this.invSubMix,
      p = h[0],
      v = h[1],
      g = h[2],
      m = h[3];
    let y, x;
    for (o = 0; o < s; o++) {
      if (o < a) {
        y = l[o] = r[o];
        continue
      }
      x = y, o % a === 0 ? (x = x << 8 | x >>> 24, x = f[x >>> 24] << 24 | f[x >>> 16 & 255] << 16 | f[x >>> 8 & 255] << 8 | f[x & 255], x ^= d[o / a | 0] << 24) : a > 6 && o % a === 4 && (x = f[x >>> 24] << 24 | f[x >>> 16 & 255] << 16 | f[x >>> 8 & 255] << 8 | f[x & 255]), l[o] = y = (l[o - a] ^ x) >>> 0
    }
    for (c = 0; c < s; c++) o = s - c, c & 3 ? x = l[o] : x = l[o - 4], c < 4 || o <= 4 ? u[c] = x : u[c] = p[f[x >>> 24]] ^ v[f[x >>> 16 & 255]] ^ g[f[x >>> 8 & 255]] ^ m[f[x & 255]], u[c] = u[c] >>> 0
  }
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24
  }
  decrypt(e, r, n) {
    const i = this.keySize + 6,
      a = this.invKeySchedule,
      s = this.invSBox,
      o = this.invSubMix,
      c = o[0],
      l = o[1],
      u = o[2],
      f = o[3],
      d = this.uint8ArrayToUint32Array_(n);
    let h = d[0],
      p = d[1],
      v = d[2],
      g = d[3];
    const m = new Int32Array(e),
      y = new Int32Array(m.length);
    let x, b, _, S, T, R, I, w, C, L, H, N, P, B;
    const V = this.networkToHostOrderSwap;
    for (; r < m.length;) {
      for (C = V(m[r]), L = V(m[r + 1]), H = V(m[r + 2]), N = V(m[r + 3]), T = C ^ a[0], R = N ^ a[1], I = H ^ a[2], w = L ^ a[3], P = 4, B = 1; B < i; B++) x = c[T >>> 24] ^ l[R >> 16 & 255] ^ u[I >> 8 & 255] ^ f[w & 255] ^ a[P], b = c[R >>> 24] ^ l[I >> 16 & 255] ^ u[w >> 8 & 255] ^ f[T & 255] ^ a[P + 1], _ = c[I >>> 24] ^ l[w >> 16 & 255] ^ u[T >> 8 & 255] ^ f[R & 255] ^ a[P + 2], S = c[w >>> 24] ^ l[T >> 16 & 255] ^ u[R >> 8 & 255] ^ f[I & 255] ^ a[P + 3], T = x, R = b, I = _, w = S, P = P + 4;
      x = s[T >>> 24] << 24 ^ s[R >> 16 & 255] << 16 ^ s[I >> 8 & 255] << 8 ^ s[w & 255] ^ a[P], b = s[R >>> 24] << 24 ^ s[I >> 16 & 255] << 16 ^ s[w >> 8 & 255] << 8 ^ s[T & 255] ^ a[P + 1], _ = s[I >>> 24] << 24 ^ s[w >> 16 & 255] << 16 ^ s[T >> 8 & 255] << 8 ^ s[R & 255] ^ a[P + 2], S = s[w >>> 24] << 24 ^ s[T >> 16 & 255] << 16 ^ s[R >> 8 & 255] << 8 ^ s[I & 255] ^ a[P + 3], y[r] = V(x ^ h), y[r + 1] = V(S ^ p), y[r + 2] = V(_ ^ v), y[r + 3] = V(b ^ g), h = C, p = L, v = H, g = N, r = r + 4
    }
    return y.buffer
  }
}
const kze = 16;
class LO {
  constructor(e, {
    removePKCS7Padding: r = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = r, r) try {
      const n = self.crypto;
      n && (this.subtle = n.subtle || n.webkitSubtle)
    } catch {}
    this.subtle === null && (this.useSoftware = !0)
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
  }
  isSync() {
    return this.useSoftware
  }
  flush() {
    const {
      currentResult: e,
      remainderData: r
    } = this;
    if (!e || r) return this.reset(), null;
    const n = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? $ze(n) : n
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
  }
  decrypt(e, r, n) {
    return this.useSoftware ? new Promise((i, a) => {
      this.softwareDecrypt(new Uint8Array(e), r, n);
      const s = this.flush();
      s ? i(s.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"))
    }) : this.webCryptoDecrypt(new Uint8Array(e), r, n)
  }
  softwareDecrypt(e, r, n) {
    const {
      currentIV: i,
      currentResult: a,
      remainderData: s
    } = this;
    this.logOnce("JS AES decrypt"), s && (e = tc(s, e), this.remainderData = null);
    const o = this.getValidChunk(e);
    if (!o.length) return null;
    i && (n = i);
    let c = this.softwareDecrypter;
    c || (c = this.softwareDecrypter = new Cze), c.expandKey(r);
    const l = a;
    return this.currentResult = c.decrypt(o.buffer, 0, n), this.currentIV = Hl(o, -16).buffer, l || null
  }
  webCryptoDecrypt(e, r, n) {
    const i = this.subtle;
    return (this.key !== r || !this.fastAesKey) && (this.key = r, this.fastAesKey = new Ize(i, r)), this.fastAesKey.expandKey().then(a => i ? (this.logOnce("WebCrypto AES decrypt"), new Aze(i, new Uint8Array(n)).decrypt(e.buffer, a)) : Promise.reject(new Error("web crypto not initialized"))).catch(a => (G.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${a.name}: ${a.message}`), this.onWebCryptoError(e, r, n)))
  }
  onWebCryptoError(e, r, n) {
    this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, r, n);
    const i = this.flush();
    if (i) return i.buffer;
    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
  }
  getValidChunk(e) {
    let r = e;
    const n = e.length - e.length % kze;
    return n !== e.length && (r = Hl(e, 0, n), this.remainderData = Hl(e, n)), r
  }
  logOnce(e) {
    this.logEnabled && (G.log(`[decrypter]: ${e}`), this.logEnabled = !1)
  }
}
const Oze = {
    toString: function (t) {
      let e = "";
      const r = t.length;
      for (let n = 0; n < r; n++) e += `[${t.start(n).toFixed(3)}-${t.end(n).toFixed(3)}]`;
      return e
    }
  },
  X = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
  };
class PO extends bze {
  constructor(e, r, n, i, a) {
    super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = X.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = a, this.logPrefix = i, this.log = G.log.bind(G, `${i}:`), this.warn = G.warn.bind(G, `${i}:`), this.hls = e, this.fragmentLoader = new yze(e.config), this.keyLoader = n, this.fragmentTracker = r, this.config = e.config, this.decrypter = new LO(e.config), e.on($.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  doTick() {
    this.onTickEnd()
  }
  onTickEnd() {}
  startLoad(e) {}
  stopLoad() {
    this.fragmentLoader.abort(), this.keyLoader.abort();
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = X.STOPPED
  }
  _streamEnded(e, r) {
    if (r.live || e.nextStart || !e.end || !this.media) return !1;
    const n = r.partList;
    if (n != null && n.length) {
      const a = n[n.length - 1];
      return ct.isBuffered(this.media, a.start + a.duration / 2)
    }
    const i = r.fragments[r.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(i)
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var e;
      return (e = this.levels[this.levelLastLoaded]) == null ? void 0 : e.details
    }
  }
  onMediaAttached(e, r) {
    const n = this.media = this.mediaBuffer = r.media;
    this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), n.addEventListener("seeking", this.onvseeking), n.addEventListener("ended", this.onvended);
    const i = this.config;
    this.levels && i.autoStartLoad && this.state === X.STOPPED && this.startLoad(i.startPosition)
  }
  onMediaDetaching() {
    const e = this.media;
    e != null && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
  }
  onMediaSeeking() {
    const {
      config: e,
      fragCurrent: r,
      media: n,
      mediaBuffer: i,
      state: a
    } = this, s = n ? n.currentTime : 0, o = ct.bufferInfo(i || n, s, e.maxBufferHole);
    if (this.log(`media seeking to ${ge(s)?s.toFixed(3):s}, state: ${a}`), this.state === X.ENDED) this.resetLoadingState();
    else if (r) {
      const c = e.maxFragLookUpTolerance,
        l = r.start - c,
        u = r.start + r.duration + c;
      if (!o.len || u < o.start || l > o.end) {
        const f = s > u;
        (s < l || f) && (f && r.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), r.abortRequests()), this.resetLoadingState())
      }
    }
    n && (this.fragmentTracker.removeFragmentsInRange(s, 1 / 0, this.playlistType, !0), this.lastCurrentTime = s), !this.loadedmetadata && !o.len && (this.nextLoadPosition = this.startPosition = s), this.tickImmediate()
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0
  }
  onManifestLoaded(e, r) {
    this.startTimeOffset = r.startTimeOffset, this.initPTS = []
  }
  onHandlerDestroying() {
    this.stopLoad(), super.onHandlerDestroying()
  }
  onHandlerDestroyed() {
    this.state = X.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
  }
  loadFragment(e, r, n) {
    this._loadFragForPlayback(e, r, n)
  }
  _loadFragForPlayback(e, r, n) {
    const i = a => {
      if (this.fragContextChanged(e)) {
        this.warn(`Fragment ${e.sn}${a.part?" p: "+a.part.index:""} of level ${e.level} was dropped during download.`), this.fragmentTracker.removeFragment(e);
        return
      }
      e.stats.chunkCount++, this._handleFragmentLoadProgress(a)
    };
    this._doFragLoad(e, r, n, i).then(a => {
      if (!a) return;
      const s = this.state;
      if (this.fragContextChanged(e)) {
        (s === X.FRAG_LOADING || !this.fragCurrent && s === X.PARSING) && (this.fragmentTracker.removeFragment(e), this.state = X.IDLE);
        return
      }
      "payload" in a && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger($.FRAG_LOADED, a)), this._handleFragmentLoadComplete(a)
    }).catch(a => {
      this.state === X.STOPPED || this.state === X.ERROR || (this.warn(a), this.resetFragmentLoading(e))
    })
  }
  clearTrackerIfNeeded(e) {
    var r;
    if (this.fragmentTracker.getState(e) === Tr.APPENDING) {
      const i = e.type,
        a = this.getFwdBufferInfo(this.mediaBuffer, i),
        s = Math.max(e.duration, a ? a.len : this.config.maxBufferLength);
      this.reduceMaxBufferLength(s) && this.fragmentTracker.removeFragment(e)
    } else((r = this.mediaBuffer) == null ? void 0 : r.buffered.length) === 0 && this.fragmentTracker.removeAllFragments()
  }
  flushMainBuffer(e, r, n = null) {
    if (!(e - r)) return;
    const i = {
      startOffset: e,
      endOffset: r,
      type: n
    };
    this.hls.trigger($.BUFFER_FLUSHING, i)
  }
  _loadInitSegment(e, r) {
    this._doFragLoad(e, r).then(n => {
      if (!n || this.fragContextChanged(e) || !this.levels) throw new Error("init load aborted");
      return n
    }).then(n => {
      const {
        hls: i
      } = this, {
        payload: a
      } = n, s = e.decryptdata;
      if (a && a.byteLength > 0 && s && s.key && s.iv && s.method === "AES-128") {
        const o = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(a), s.key.buffer, s.iv.buffer).catch(c => {
          throw i.trigger($.ERROR, {
            type: ve.MEDIA_ERROR,
            details: q.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: c,
            reason: c.message,
            frag: e
          }), c
        }).then(c => {
          const l = self.performance.now();
          return i.trigger($.FRAG_DECRYPTED, {
            frag: e,
            payload: c,
            stats: {
              tstart: o,
              tdecrypt: l
            }
          }), n.payload = c, n
        })
      }
      return n
    }).then(n => {
      const {
        fragCurrent: i,
        hls: a,
        levels: s
      } = this;
      if (!s) throw new Error("init load aborted, missing levels");
      const o = e.stats;
      this.state = X.IDLE, r.fragmentError = 0, e.data = new Uint8Array(n.payload), o.parsing.start = o.buffering.start = self.performance.now(), o.parsing.end = o.buffering.end = self.performance.now(), n.frag === i && a.trigger($.FRAG_BUFFERED, {
        stats: o,
        frag: i,
        part: null,
        id: e.type
      }), this.tick()
    }).catch(n => {
      this.state === X.STOPPED || this.state === X.ERROR || (this.warn(n), this.resetFragmentLoading(e))
    })
  }
  fragContextChanged(e) {
    const {
      fragCurrent: r
    } = this;
    return !e || !r || e.level !== r.level || e.sn !== r.sn || e.urlId !== r.urlId
  }
  fragBufferedComplete(e, r) {
    var n, i, a, s;
    const o = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log(`Buffered ${e.type} sn: ${e.sn}${r?" part: "+r.index:""} of ${this.logPrefix==="[stream-controller]"?"level":"track"} ${e.level} (frag:[${((n=e.startPTS)!=null?n:NaN).toFixed(3)}-${((i=e.endPTS)!=null?i:NaN).toFixed(3)}] > buffer:${o?Oze.toString(ct.getBuffered(o)):"(detached)"})`), this.state = X.IDLE, o && (!this.loadedmetadata && e.type == ye.MAIN && o.buffered.length && ((a = this.fragCurrent) == null ? void 0 : a.sn) === ((s = this.fragPrevious) == null ? void 0 : s.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
  }
  seekToStartPos() {}
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: r
    } = this;
    if (!r) return;
    const {
      frag: n,
      part: i,
      partsLoaded: a
    } = e, s = !a || a.length === 0 || a.some(c => !c), o = new kO(n.level, n.sn, n.stats.chunkCount + 1, 0, i ? i.index : -1, !s);
    r.flush(o)
  }
  _handleFragmentLoadProgress(e) {}
  _doFragLoad(e, r, n = null, i) {
    var a;
    const s = r == null ? void 0 : r.details;
    if (!this.levels || !s) throw new Error(`frag load aborted, missing level${s?"":" detail"}s`);
    let o = null;
    if (e.encrypted && !((a = e.decryptdata) != null && a.key) ? (this.log(`Loading key for ${e.sn} of [${s.startSN}-${s.endSN}], ${this.logPrefix==="[stream-controller]"?"level":"track"} ${e.level}`), this.state = X.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then(u => {
        if (!this.fragContextChanged(u.frag)) return this.hls.trigger($.KEY_LOADED, u), this.state === X.KEY_LOADING && (this.state = X.IDLE), u
      }), this.hls.trigger($.KEY_LOADING, {
        frag: e
      }), this.fragCurrent === null && (o = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))) : !e.encrypted && s.encryptedFragments.length && this.keyLoader.loadClear(e, s.encryptedFragments), n = Math.max(e.start, n || 0), this.config.lowLatencyMode) {
      const u = s.partList;
      if (u && i) {
        n > e.end && s.fragmentHint && (e = s.fragmentHint);
        const f = this.getNextPart(u, e, n);
        if (f > -1) {
          const d = u[f];
          this.log(`Loading part sn: ${e.sn} p: ${d.index} cc: ${e.cc} of playlist [${s.startSN}-${s.endSN}] parts [0-${f}-${u.length-1}] ${this.logPrefix==="[stream-controller]"?"level":"track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`), this.nextLoadPosition = d.start + d.duration, this.state = X.FRAG_LOADING;
          let h;
          return o ? h = o.then(p => !p || this.fragContextChanged(p.frag) ? null : this.doFragPartsLoad(e, d, r, i)).catch(p => this.handleFragLoadError(p)) : h = this.doFragPartsLoad(e, d, r, i).catch(p => this.handleFragLoadError(p)), this.hls.trigger($.FRAG_LOADING, {
            frag: e,
            part: d,
            targetBufferTime: n
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : h
        } else if (!e.url || this.loadedEndOfParts(u, n)) return Promise.resolve(null)
      }
    }
    this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${s?"of ["+s.startSN+"-"+s.endSN+"] ":""}${this.logPrefix==="[stream-controller]"?"level":"track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`), ge(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = X.FRAG_LOADING;
    const c = this.config.progressive;
    let l;
    return c && o ? l = o.then(u => !u || this.fragContextChanged(u == null ? void 0 : u.frag) ? null : this.fragmentLoader.load(e, i)).catch(u => this.handleFragLoadError(u)) : l = Promise.all([this.fragmentLoader.load(e, c ? i : void 0), o]).then(([u]) => (!c && u && i && i(u), u)).catch(u => this.handleFragLoadError(u)), this.hls.trigger($.FRAG_LOADING, {
      frag: e,
      targetBufferTime: n
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : l
  }
  doFragPartsLoad(e, r, n, i) {
    return new Promise((a, s) => {
      var o;
      const c = [],
        l = (o = n.details) == null ? void 0 : o.partList,
        u = f => {
          this.fragmentLoader.loadPart(e, f, i).then(d => {
            c[f.index] = d;
            const h = d.part;
            this.hls.trigger($.FRAG_LOADED, d);
            const p = K5(n, e.sn, f.index + 1) || TQ(l, e.sn, f.index + 1);
            if (p) u(p);
            else return a({
              frag: e,
              part: h,
              partsLoaded: c
            })
          }).catch(s)
        };
      u(r)
    })
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const r = e.data;
      e.data && r.details === q.INTERNAL_ABORTED ? this.handleFragLoadAborted(r.frag, r.part) : this.hls.trigger($.ERROR, r)
    } else this.hls.trigger($.ERROR, {
      type: ve.OTHER_ERROR,
      details: q.INTERNAL_EXCEPTION,
      err: e,
      error: e,
      fatal: !0
    });
    return null
  }
  _handleTransmuxerFlush(e) {
    const r = this.getCurrentContext(e);
    if (!r || this.state !== X.PARSING) {
      !this.fragCurrent && this.state !== X.STOPPED && this.state !== X.ERROR && (this.state = X.IDLE);
      return
    }
    const {
      frag: n,
      part: i,
      level: a
    } = r, s = self.performance.now();
    n.stats.parsing.end = s, i && (i.stats.parsing.end = s), this.updateLevelTiming(n, i, a, e.partial)
  }
  getCurrentContext(e) {
    const {
      levels: r,
      fragCurrent: n
    } = this, {
      level: i,
      sn: a,
      part: s
    } = e;
    if (!(r != null && r[i])) return this.warn(`Levels object was unset while buffering fragment ${a} of level ${i}. The current chunk will not be buffered.`), null;
    const o = r[i],
      c = s > -1 ? K5(o, a, s) : null,
      l = c ? c.fragment : lze(o, a, n);
    return l ? (n && n !== l && (l.stats = n.stats), {
      frag: l,
      part: c,
      level: o
    }) : null
  }
  bufferFragmentData(e, r, n, i) {
    var a;
    if (!e || this.state !== X.PARSING) return;
    const {
      data1: s,
      data2: o
    } = e;
    let c = s;
    if (s && o && (c = tc(s, o)), !((a = c) != null && a.length)) return;
    const l = {
      type: e.type,
      frag: r,
      part: n,
      chunkMeta: i,
      parent: r.type,
      data: c
    };
    this.hls.trigger($.BUFFER_APPENDING, l), e.dropped && e.independent && !n && this.flushBufferGap(r)
  }
  flushBufferGap(e) {
    const r = this.media;
    if (!r) return;
    if (!ct.isBuffered(r, r.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return
    }
    const n = r.currentTime,
      i = ct.bufferInfo(r, n, 0),
      a = e.duration,
      s = Math.min(this.config.maxFragLookUpTolerance * 2, a * .25),
      o = Math.max(Math.min(e.start - s, i.end - s), n + s);
    e.start - o > s && this.flushMainBuffer(o, e.start)
  }
  getFwdBufferInfo(e, r) {
    const n = this.getLoadPosition();
    return ge(n) ? this.getFwdBufferInfoAtPos(e, n, r) : null
  }
  getFwdBufferInfoAtPos(e, r, n) {
    const {
      config: {
        maxBufferHole: i
      }
    } = this, a = ct.bufferInfo(e, r, i);
    if (a.len === 0 && a.nextStart !== void 0) {
      const s = this.fragmentTracker.getBufferedFrag(r, n);
      if (s && a.nextStart < s.end) return ct.bufferInfo(e, r, Math.max(a.nextStart, i))
    }
    return a
  }
  getMaxBufferLength(e) {
    const {
      config: r
    } = this;
    let n;
    return e ? n = Math.max(8 * r.maxBufferSize / e, r.maxBufferLength) : n = r.maxBufferLength, Math.min(n, r.maxMaxBufferLength)
  }
  reduceMaxBufferLength(e) {
    const r = this.config,
      n = e || r.maxBufferLength;
    return r.maxMaxBufferLength >= n ? (r.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${r.maxMaxBufferLength}s`), !0) : !1
  }
  getNextFragment(e, r) {
    const n = r.fragments,
      i = n.length;
    if (!i) return null;
    const {
      config: a
    } = this, s = n[0].start;
    let o;
    if (r.live) {
      const c = a.initialLiveManifestSize;
      if (i < c) return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${c})`), null;
      !r.PTSKnown && !this.startFragRequested && this.startPosition === -1 && (o = this.getInitialLiveFragment(r, n), this.startPosition = o ? this.hls.liveSyncPosition || o.start : e)
    } else e <= s && (o = n[0]);
    if (!o) {
      const c = a.lowLatencyMode ? r.partEnd : r.fragmentEnd;
      o = this.getFragmentAtPosition(e, c, r)
    }
    return this.mapToInitFragWhenRequired(o)
  }
  isLoopLoading(e, r) {
    const n = this.fragmentTracker.getState(e);
    return (n === Tr.OK || n === Tr.PARTIAL && !!e.gap) && this.nextLoadPosition > r
  }
  getNextFragmentLoopLoading(e, r, n, i, a) {
    const s = e.gap,
      o = this.getNextFragment(this.nextLoadPosition, r);
    if (o === null) return o;
    if (e = o, s && e && !e.gap && n.nextStart) {
      const c = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, i);
      if (c !== null && n.len + c.len >= a) return this.log(`buffer full after gaps in "${i}" playlist starting at sn: ${e.sn}`), null
    }
    return e
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest ? e.initSegment : e
  }
  getNextPart(e, r, n) {
    let i = -1,
      a = !1,
      s = !0;
    for (let o = 0, c = e.length; o < c; o++) {
      const l = e[o];
      if (s = s && !l.independent, i > -1 && n < l.start) break;
      const u = l.loaded;
      u ? i = -1 : (a || l.independent || s) && l.fragment === r && (i = o), a = u
    }
    return i
  }
  loadedEndOfParts(e, r) {
    const n = e[e.length - 1];
    return n && r > n.start && n.loaded
  }
  getInitialLiveFragment(e, r) {
    const n = this.fragPrevious;
    let i = null;
    if (n) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`), i = uze(r, n.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {
        const a = n.sn + 1;
        if (a >= e.startSN && a <= e.endSN) {
          const s = r[a - e.startSN];
          n.cc === s.cc && (i = s, this.log(`Live playlist, switching playlist, load frag with next SN: ${i.sn}`))
        }
        i || (i = dze(r, n.cc), i && this.log(`Live playlist, switching playlist, load frag with same CC: ${i.sn}`))
      }
    } else {
      const a = this.hls.liveSyncPosition;
      a !== null && (i = this.getFragmentAtPosition(a, this.bitrateTest ? e.fragmentEnd : e.edge, e))
    }
    return i
  }
  getFragmentAtPosition(e, r, n) {
    const {
      config: i
    } = this;
    let {
      fragPrevious: a
    } = this, {
      fragments: s,
      endSN: o
    } = n;
    const {
      fragmentHint: c
    } = n, l = i.maxFragLookUpTolerance, u = !!(i.lowLatencyMode && n.partList && c);
    u && c && !this.bitrateTest && (s = s.concat(c), o = c.sn);
    let f;
    if (e < r) {
      const d = e > r - l ? 0 : l;
      f = tp(a, s, e, d)
    } else f = s[s.length - 1];
    if (f) {
      const d = f.sn - n.startSN,
        h = this.fragmentTracker.getState(f);
      if ((h === Tr.OK || h === Tr.PARTIAL && f.gap) && (a = f), a && f.sn === a.sn && !u && a && f.level === a.level) {
        const v = s[d + 1];
        f.sn < o && this.fragmentTracker.getState(v) !== Tr.OK ? f = v : f = null
      }
    }
    return f
  }
  synchronizeToLiveEdge(e) {
    const {
      config: r,
      media: n
    } = this;
    if (!n) return;
    const i = this.hls.liveSyncPosition,
      a = n.currentTime,
      s = e.fragments[0].start,
      o = e.edge,
      c = a >= s - r.maxFragLookUpTolerance && a <= o;
    if (i !== null && n.duration > i && (a < i || !c)) {
      const l = r.liveMaxLatencyDuration !== void 0 ? r.liveMaxLatencyDuration : r.liveMaxLatencyDurationCount * e.targetduration;
      (!c && n.readyState < 4 || a < o - l) && (this.loadedmetadata || (this.nextLoadPosition = i), n.readyState && (this.warn(`Playback: ${a.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${i.toFixed(3)}`), n.currentTime = i))
    }
  }
  alignPlaylists(e, r) {
    const {
      levels: n,
      levelLastLoaded: i,
      fragPrevious: a
    } = this, s = i !== null ? n[i] : null, o = e.fragments.length;
    if (!o) return this.warn("No fragments in live playlist"), 0;
    const c = e.fragments[0].start,
      l = !r,
      u = e.alignedSliding && ge(c);
    if (l || !u && !c) {
      Tze(a, s, e);
      const f = e.fragments[0].start;
      return this.log(`Live playlist sliding: ${f.toFixed(2)} start-sn: ${r?r.startSN:"na"}->${e.startSN} prev-sn: ${a?a.sn:"na"} fragments: ${o}`), f
    }
    return c
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3)
  }
  setStartPosition(e, r) {
    let n = this.startPosition;
    if (n < r && (n = -1), n === -1 || this.lastCurrentTime === -1) {
      const i = this.startTimeOffset !== null,
        a = i ? this.startTimeOffset : e.startTimeOffset;
      a !== null && ge(a) ? (n = r + a, a < 0 && (n += e.totalduration), n = Math.min(Math.max(r, n), r + e.totalduration), this.log(`Start time offset ${a} found in ${i?"multivariant":"media"} playlist, adjust startPosition to ${n}`), this.startPosition = n) : e.live ? n = this.hls.liveSyncPosition || r : this.startPosition = n = 0, this.lastCurrentTime = n
    }
    this.nextLoadPosition = n
  }
  getLoadPosition() {
    const {
      media: e
    } = this;
    let r = 0;
    return this.loadedmetadata && e ? r = e.currentTime : this.nextLoadPosition && (r = this.nextLoadPosition), r
  }
  handleFragLoadAborted(e, r) {
    this.transmuxer && e.sn !== "initSegment" && e.stats.aborted && (this.warn(`Fragment ${e.sn}${r?" part"+r.index:""} of level ${e.level} was aborted`), this.resetFragmentLoading(e))
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== X.FRAG_LOADING_WAITING_RETRY) && (this.state = X.IDLE)
  }
  onFragmentOrKeyLoadError(e, r) {
    if (r.chunkMeta && !r.frag) {
      const u = this.getCurrentContext(r.chunkMeta);
      u && (r.frag = u.frag)
    }
    const n = r.frag;
    if (!n || n.type !== e || !this.levels) return;
    if (this.fragContextChanged(n)) {
      var i;
      this.warn(`Frag load error must match current frag to retry ${n.url} > ${(i=this.fragCurrent)==null?void 0:i.url}`);
      return
    }
    const a = r.details === q.FRAG_GAP;
    a && this.fragmentTracker.fragBuffered(n, !0);
    const s = r.errorAction,
      {
        action: o,
        retryCount: c = 0,
        retryConfig: l
      } = s || {};
    if (s && o === Hr.RetryRequest && l) {
      this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition);
      const u = $O(l, c);
      this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${r.details}, retrying loading ${c+1}/${l.maxNumRetry} in ${u}ms`), s.resolved = !0, this.retryDate = self.performance.now() + u, this.state = X.FRAG_LOADING_WAITING_RETRY
    } else l && s ? (this.resetFragmentErrors(e), c < l.maxNumRetry ? a || (s.resolved = !0) : G.warn(`${r.details} reached or exceeded max retry (${c})`)) : this.state = X.ERROR;
    this.tickImmediate()
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === X.PARSING || this.state === X.PARSED) {
      const r = e.parent,
        n = this.getFwdBufferInfo(this.mediaBuffer, r),
        i = n && n.len > .5;
      i && this.reduceMaxBufferLength(n.len);
      const a = !i;
      return a && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${r} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), a
    }
    return !1
  }
  resetFragmentErrors(e) {
    e === ye.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== X.STOPPED && (this.state = X.IDLE)
  }
  afterBufferFlushed(e, r, n) {
    if (!e) return;
    const i = ct.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(r, i, n), this.state === X.ENDED && this.resetLoadingState()
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = X.IDLE
  }
  resetStartWhenNotLoaded(e) {
    if (!this.loadedmetadata) {
      this.startFragRequested = !1;
      const r = this.levels ? this.levels[e].details : null;
      r != null && r.live ? (this.startPosition = -1, this.setStartPosition(r, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
    }
  }
  resetWhenMissingContext(e) {
    this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(e.level), this.resetLoadingState()
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
  }
  updateLevelTiming(e, r, n, i) {
    var a;
    const s = n.details;
    if (!s) {
      this.warn("level.details undefined");
      return
    }
    if (Object.keys(e.elementaryStreams).reduce((c, l) => {
        const u = e.elementaryStreams[l];
        if (u) {
          const f = u.endPTS - u.startPTS;
          if (f <= 0) return this.warn(`Could not parse fragment ${e.sn} ${l} duration reliably (${f})`), c || !1;
          const d = i ? 0 : SQ(s, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS);
          return this.hls.trigger($.LEVEL_PTS_UPDATED, {
            details: s,
            level: n,
            drift: d,
            type: l,
            frag: e,
            start: u.startPTS,
            end: u.endPTS
          }), !0
        }
        return c
      }, !1)) n.fragmentError = 0;
    else if (((a = this.transmuxer) == null ? void 0 : a.error) === null) {
      const c = new Error(`Found no media in fragment ${e.sn} of level ${n.id} resetting transmuxer to fallback to playlist timing`);
      if (this.warn(c.message), this.hls.trigger($.ERROR, {
          type: ve.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          error: c,
          frag: e,
          reason: `Found no media in msn ${e.sn} of level "${n.url}"`
        }), !this.hls) return;
      this.resetTransmuxer()
    }
    this.state = X.PARSED, this.hls.trigger($.FRAG_PARSED, {
      frag: e,
      part: r
    })
  }
  resetTransmuxer() {
    this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.resetTransmuxer(), this.resetLoadingState())
  }
  set state(e) {
    const r = this._state;
    r !== e && (this._state = e, this.log(`${r}->${e}`))
  }
  get state() {
    return this._state
  }
}

function NO() {
  if (!(typeof self > "u")) return self.MediaSource || self.WebKitMediaSource
}

function IQ() {
  return self.SourceBuffer || self.WebKitSourceBuffer
}

function Lze() {
  const t = NO();
  if (!t) return !1;
  const e = IQ(),
    r = t && typeof t.isTypeSupported == "function" && t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
    n = !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
  return !!r && !!n
}

function Pze() {
  var t;
  const e = IQ();
  return typeof (e == null || (t = e.prototype) == null ? void 0 : t.changeType) == "function"
}

function Nze() {
  return typeof __HLS_WORKER_BUNDLE__ == "function"
}

function Dze() {
  const t = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
      type: "text/javascript"
    }),
    e = self.URL.createObjectURL(t);
  return {
    worker: new self.Worker(e),
    objectURL: e
  }
}

function Mze(t) {
  const e = new self.URL(t, self.location.href).href;
  return {
    worker: new self.Worker(e),
    scriptURL: e
  }
}

function ta(t = "", e = 9e4) {
  return {
    type: t,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  }
}
class $Q {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
  }
  resetInitSegment(e, r, n, i) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    }
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity()
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
  }
  canParse(e, r) {
    return !1
  }
  appendFrame(e, r, n) {}
  demux(e, r) {
    this.cachedData && (e = tc(this.cachedData, e), this.cachedData = null);
    let n = k1(e, 0),
      i = n ? n.length : 0,
      a;
    const s = this._audioTrack,
      o = this._id3Track,
      c = n ? xHe(n) : void 0,
      l = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && ge(c)) && (this.basePTS = Fze(c, r, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), n && n.length > 0 && o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: n,
        type: Si.audioId3,
        duration: Number.POSITIVE_INFINITY
      }); i < l;) {
      if (this.canParse(e, i)) {
        const u = this.appendFrame(s, e, i);
        u ? (this.frameIndex++, this.lastPTS = u.sample.pts, i += u.length, a = i) : i = l
      } else yHe(e, i) ? (n = k1(e, i), o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: n,
        type: Si.audioId3,
        duration: Number.POSITIVE_INFINITY
      }), i += n.length, a = i) : i++;
      if (i === l && a !== l) {
        const u = Hl(e, a);
        this.cachedData ? this.cachedData = tc(this.cachedData, u) : this.cachedData = u
      }
    }
    return {
      audioTrack: s,
      videoTrack: ta(),
      id3Track: o,
      textTrack: ta()
    }
  }
  demuxSampleAes(e, r, n) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
  }
  flush(e) {
    const r = this.cachedData;
    return r && (this.cachedData = null, this.demux(r, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: ta(),
      id3Track: this._id3Track,
      textTrack: ta()
    }
  }
  destroy() {}
}
const Fze = (t, e, r) => {
  if (ge(t)) return t * 90;
  const n = r ? r.baseTime * 9e4 / r.timescale : 0;
  return e * 9e4 + n
};

function Bze(t, e, r, n) {
  let i, a, s, o;
  const c = navigator.userAgent.toLowerCase(),
    l = n,
    u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  i = ((e[r + 2] & 192) >>> 6) + 1;
  const f = (e[r + 2] & 60) >>> 2;
  if (f > u.length - 1) {
    t.trigger($.ERROR, {
      type: ve.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      fatal: !0,
      reason: `invalid ADTS sampling index:${f}`
    });
    return
  }
  return s = (e[r + 2] & 1) << 2, s |= (e[r + 3] & 192) >>> 6, G.log(`manifest codec:${n}, ADTS type:${i}, samplingIndex:${f}`), /firefox/i.test(c) ? f >= 6 ? (i = 5, o = new Array(4), a = f - 3) : (i = 2, o = new Array(2), a = f) : c.indexOf("android") !== -1 ? (i = 2, o = new Array(2), a = f) : (i = 5, o = new Array(4), n && (n.indexOf("mp4a.40.29") !== -1 || n.indexOf("mp4a.40.5") !== -1) || !n && f >= 6 ? a = f - 3 : ((n && n.indexOf("mp4a.40.2") !== -1 && (f >= 6 && s === 1 || /vivaldi/i.test(c)) || !n && s === 1) && (i = 2, o = new Array(2)), a = f)), o[0] = i << 3, o[0] |= (f & 14) >> 1, o[1] |= (f & 1) << 7, o[1] |= s << 3, i === 5 && (o[1] |= (a & 14) >> 1, o[2] = (a & 1) << 7, o[2] |= 2 << 2, o[3] = 0), {
    config: o,
    samplerate: u[f],
    channelCount: s,
    codec: "mp4a.40." + i,
    manifestCodec: l
  }
}

function CQ(t, e) {
  return t[e] === 255 && (t[e + 1] & 246) === 240
}

function kQ(t, e) {
  return t[e + 1] & 1 ? 7 : 9
}

function DO(t, e) {
  return (t[e + 3] & 3) << 11 | t[e + 4] << 3 | (t[e + 5] & 224) >>> 5
}

function Uze(t, e) {
  return e + 5 < t.length
}

function D1(t, e) {
  return e + 1 < t.length && CQ(t, e)
}

function jze(t, e) {
  return Uze(t, e) && CQ(t, e) && DO(t, e) <= t.length - e
}

function Hze(t, e) {
  if (D1(t, e)) {
    const r = kQ(t, e);
    if (e + r >= t.length) return !1;
    const n = DO(t, e);
    if (n <= r) return !1;
    const i = e + n;
    return i === t.length || D1(t, i)
  }
  return !1
}

function OQ(t, e, r, n, i) {
  if (!t.samplerate) {
    const a = Bze(e, r, n, i);
    if (!a) return;
    t.config = a.config, t.samplerate = a.samplerate, t.channelCount = a.channelCount, t.codec = a.codec, t.manifestCodec = a.manifestCodec, G.log(`parsed codec:${t.codec}, rate:${a.samplerate}, channels:${a.channelCount}`)
  }
}

function LQ(t) {
  return 1024 * 9e4 / t
}

function zze(t, e) {
  const r = kQ(t, e);
  if (e + r <= t.length) {
    const n = DO(t, e) - r;
    if (n > 0) return {
      headerLength: r,
      frameLength: n
    }
  }
}

function PQ(t, e, r, n, i) {
  const a = LQ(t.samplerate),
    s = n + i * a,
    o = zze(e, r);
  let c;
  if (o) {
    const {
      frameLength: f,
      headerLength: d
    } = o, h = d + f, p = Math.max(0, r + h - e.length);
    p ? (c = new Uint8Array(h - d), c.set(e.subarray(r + d, e.length), 0)) : c = e.subarray(r + d, r + h);
    const v = {
      unit: c,
      pts: s
    };
    return p || t.samples.push(v), {
      sample: v,
      length: h,
      missing: p
    }
  }
  const l = e.length - r;
  return c = new Uint8Array(l), c.set(e.subarray(r, e.length), 0), {
    sample: {
      unit: c,
      pts: s
    },
    length: l,
    missing: -1
  }
}
class Gze extends $Q {
  constructor(e, r) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = r
  }
  resetInitSegment(e, r, n, i) {
    super.resetInitSegment(e, r, n, i), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: r,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    }
  }
  static probe(e) {
    if (!e) return !1;
    let n = (k1(e, 0) || []).length;
    for (let i = e.length; n < i; n++)
      if (Hze(e, n)) return G.log("ADTS sync word found !"), !0;
    return !1
  }
  canParse(e, r) {
    return jze(e, r)
  }
  appendFrame(e, r, n) {
    OQ(e, this.observer, r, n, e.manifestCodec);
    const i = PQ(e, r, n, this.basePTS, this.frameIndex);
    if (i && i.missing === 0) return i
  }
}
const Vze = /\/emsg[-/]ID3/i;
class Wze {
  constructor(e, r) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = r
  }
  resetTimeStamp() {}
  resetInitSegment(e, r, n, i) {
    const a = this.videoTrack = ta("video", 1),
      s = this.audioTrack = ta("audio", 1),
      o = this.txtTrack = ta("text", 1);
    if (this.id3Track = ta("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength)) return;
    const c = gQ(e);
    if (c.video) {
      const {
        id: l,
        timescale: u,
        codec: f
      } = c.video;
      a.id = l, a.timescale = o.timescale = u, a.codec = f
    }
    if (c.audio) {
      const {
        id: l,
        timescale: u,
        codec: f
      } = c.audio;
      s.id = l, s.timescale = u, s.codec = f
    }
    o.id = dQ.text, a.sampleDuration = 0, a.duration = s.duration = i
  }
  resetContiguity() {}
  static probe(e) {
    return e = e.length > 16384 ? e.subarray(0, 16384) : e, Ue(e, ["moof"]).length > 0
  }
  demux(e, r) {
    this.timeOffset = r;
    let n = e;
    const i = this.videoTrack,
      a = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (n = tc(this.remainderData, e));
      const o = PHe(n);
      this.remainderData = o.remainder, i.samples = o.valid || new Uint8Array
    } else i.samples = n;
    const s = this.extractID3Track(i, r);
    return a.samples = L5(r, i), {
      videoTrack: i,
      audioTrack: this.audioTrack,
      id3Track: s,
      textTrack: this.txtTrack
    }
  }
  flush() {
    const e = this.timeOffset,
      r = this.videoTrack,
      n = this.txtTrack;
    r.samples = this.remainderData || new Uint8Array, this.remainderData = null;
    const i = this.extractID3Track(r, this.timeOffset);
    return n.samples = L5(e, r), {
      videoTrack: r,
      audioTrack: ta(),
      id3Track: i,
      textTrack: ta()
    }
  }
  extractID3Track(e, r) {
    const n = this.id3Track;
    if (e.samples.length) {
      const i = Ue(e.samples, ["emsg"]);
      i && i.forEach(a => {
        const s = MHe(a);
        if (Vze.test(s.schemeIdUri)) {
          const o = ge(s.presentationTime) ? s.presentationTime / s.timeScale : r + s.presentationTimeDelta / s.timeScale;
          let c = s.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : s.eventDuration / s.timeScale;
          c <= .001 && (c = Number.POSITIVE_INFINITY);
          const l = s.payload;
          n.samples.push({
            data: l,
            len: l.byteLength,
            dts: o,
            pts: o,
            type: Si.emsg,
            duration: c
          })
        }
      })
    }
    return n
  }
  demuxSampleAes(e, r, n) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
  }
  destroy() {}
}
let Km = null;
const Kze = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
  Yze = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
  qze = [
    [0, 72, 144, 12],
    [0, 0, 0, 0],
    [0, 72, 144, 12],
    [0, 144, 144, 12]
  ],
  Xze = [0, 1, 1, 4];

function NQ(t, e, r, n, i) {
  if (r + 24 > e.length) return;
  const a = DQ(e, r);
  if (a && r + a.frameLength <= e.length) {
    const s = a.samplesPerFrame * 9e4 / a.sampleRate,
      o = n + i * s,
      c = {
        unit: e.subarray(r, r + a.frameLength),
        pts: o,
        dts: o
      };
    return t.config = [], t.channelCount = a.channelCount, t.samplerate = a.sampleRate, t.samples.push(c), {
      sample: c,
      length: a.frameLength,
      missing: 0
    }
  }
}

function DQ(t, e) {
  const r = t[e + 1] >> 3 & 3,
    n = t[e + 1] >> 1 & 3,
    i = t[e + 2] >> 4 & 15,
    a = t[e + 2] >> 2 & 3;
  if (r !== 1 && i !== 0 && i !== 15 && a !== 3) {
    const s = t[e + 2] >> 1 & 1,
      o = t[e + 3] >> 6,
      c = r === 3 ? 3 - n : n === 3 ? 3 : 4,
      l = Kze[c * 14 + i - 1] * 1e3,
      f = Yze[(r === 3 ? 0 : r === 2 ? 1 : 2) * 3 + a],
      d = o === 3 ? 1 : 2,
      h = qze[r][n],
      p = Xze[n],
      v = h * 8 * p,
      g = Math.floor(h * l / f + s) * p;
    if (Km === null) {
      const x = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Km = x ? parseInt(x[1]) : 0
    }
    return !!Km && Km <= 87 && n === 2 && l >= 224e3 && o === 0 && (t[e + 3] = t[e + 3] | 128), {
      sampleRate: f,
      channelCount: d,
      frameLength: g,
      samplesPerFrame: v
    }
  }
}

function MO(t, e) {
  return t[e] === 255 && (t[e + 1] & 224) === 224 && (t[e + 1] & 6) !== 0
}

function MQ(t, e) {
  return e + 1 < t.length && MO(t, e)
}

function Qze(t, e) {
  return MO(t, e) && 4 <= t.length - e
}

function Zze(t, e) {
  if (e + 1 < t.length && MO(t, e)) {
    const n = DQ(t, e);
    let i = 4;
    n != null && n.frameLength && (i = n.frameLength);
    const a = e + i;
    return a === t.length || MQ(t, a)
  }
  return !1
}
class tB {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
  }
  loadWord() {
    const e = this.data,
      r = this.bytesAvailable,
      n = e.byteLength - r,
      i = new Uint8Array(4),
      a = Math.min(4, r);
    if (a === 0) throw new Error("no bytes available");
    i.set(e.subarray(n, n + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = a * 8, this.bytesAvailable -= a
  }
  skipBits(e) {
    let r;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, r = e >> 3, e -= r << 3, this.bytesAvailable -= r, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
  }
  readBits(e) {
    let r = Math.min(this.bitsAvailable, e);
    const n = this.word >>> 32 - r;
    if (e > 32 && G.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= r, this.bitsAvailable > 0) this.word <<= r;
    else if (this.bytesAvailable > 0) this.loadWord();
    else throw new Error("no bits available");
    return r = e - r, r > 0 && this.bitsAvailable ? n << r | this.readBits(r) : n
  }
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if (this.word & 2147483648 >>> e) return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ()
  }
  skipUEG() {
    this.skipBits(1 + this.skipLZ())
  }
  skipEG() {
    this.skipBits(1 + this.skipLZ())
  }
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1
  }
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
  }
  readBoolean() {
    return this.readBits(1) === 1
  }
  readUByte() {
    return this.readBits(8)
  }
  readUShort() {
    return this.readBits(16)
  }
  readUInt() {
    return this.readBits(32)
  }
  skipScalingList(e) {
    let r = 8,
      n = 8,
      i;
    for (let a = 0; a < e; a++) n !== 0 && (i = this.readEG(), n = (r + i + 256) % 256), r = n === 0 ? r : n
  }
  readSPS() {
    let e = 0,
      r = 0,
      n = 0,
      i = 0,
      a, s, o;
    const c = this.readUByte.bind(this),
      l = this.readBits.bind(this),
      u = this.readUEG.bind(this),
      f = this.readBoolean.bind(this),
      d = this.skipBits.bind(this),
      h = this.skipEG.bind(this),
      p = this.skipUEG.bind(this),
      v = this.skipScalingList.bind(this);
    c();
    const g = c();
    if (l(5), d(3), c(), p(), g === 100 || g === 110 || g === 122 || g === 244 || g === 44 || g === 83 || g === 86 || g === 118 || g === 128) {
      const S = u();
      if (S === 3 && d(1), p(), p(), d(1), f())
        for (s = S !== 3 ? 8 : 12, o = 0; o < s; o++) f() && (o < 6 ? v(16) : v(64))
    }
    p();
    const m = u();
    if (m === 0) u();
    else if (m === 1)
      for (d(1), h(), h(), a = u(), o = 0; o < a; o++) h();
    p(), d(1);
    const y = u(),
      x = u(),
      b = l(1);
    b === 0 && d(1), d(1), f() && (e = u(), r = u(), n = u(), i = u());
    let _ = [1, 1];
    if (f() && f()) switch (c()) {
      case 1:
        _ = [1, 1];
        break;
      case 2:
        _ = [12, 11];
        break;
      case 3:
        _ = [10, 11];
        break;
      case 4:
        _ = [16, 11];
        break;
      case 5:
        _ = [40, 33];
        break;
      case 6:
        _ = [24, 11];
        break;
      case 7:
        _ = [20, 11];
        break;
      case 8:
        _ = [32, 11];
        break;
      case 9:
        _ = [80, 33];
        break;
      case 10:
        _ = [18, 11];
        break;
      case 11:
        _ = [15, 11];
        break;
      case 12:
        _ = [64, 33];
        break;
      case 13:
        _ = [160, 99];
        break;
      case 14:
        _ = [4, 3];
        break;
      case 15:
        _ = [3, 2];
        break;
      case 16:
        _ = [2, 1];
        break;
      case 255: {
        _ = [c() << 8 | c(), c() << 8 | c()];
        break
      }
    }
    return {
      width: Math.ceil((y + 1) * 16 - e * 2 - r * 2),
      height: (2 - b) * (x + 1) * 16 - (b ? 2 : 4) * (n + i),
      pixelRatio: _
    }
  }
  readSliceType() {
    return this.readUByte(), this.readUEG(), this.readUEG()
  }
}
class Jze {
  constructor(e, r, n) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = n, this.decrypter = new LO(r, {
      removePKCS7Padding: !1
    })
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
  }
  decryptAacSample(e, r, n) {
    const i = e[r].unit;
    if (i.length <= 16) return;
    const a = i.subarray(16, i.length - i.length % 16),
      s = a.buffer.slice(a.byteOffset, a.byteOffset + a.length);
    this.decryptBuffer(s).then(o => {
      const c = new Uint8Array(o);
      i.set(c, 16), this.decrypter.isSync() || this.decryptAacSamples(e, r + 1, n)
    })
  }
  decryptAacSamples(e, r, n) {
    for (;; r++) {
      if (r >= e.length) {
        n();
        return
      }
      if (!(e[r].unit.length < 32) && (this.decryptAacSample(e, r, n), !this.decrypter.isSync())) return
    }
  }
  getAvcEncryptedData(e) {
    const r = Math.floor((e.length - 48) / 160) * 16 + 16,
      n = new Int8Array(r);
    let i = 0;
    for (let a = 32; a < e.length - 16; a += 160, i += 16) n.set(e.subarray(a, a + 16), i);
    return n
  }
  getAvcDecryptedUnit(e, r) {
    const n = new Uint8Array(r);
    let i = 0;
    for (let a = 32; a < e.length - 16; a += 160, i += 16) e.set(n.subarray(i, i + 16), a);
    return e
  }
  decryptAvcSample(e, r, n, i, a) {
    const s = yQ(a.data),
      o = this.getAvcEncryptedData(s);
    this.decryptBuffer(o.buffer).then(c => {
      a.data = this.getAvcDecryptedUnit(s, c), this.decrypter.isSync() || this.decryptAvcSamples(e, r, n + 1, i)
    })
  }
  decryptAvcSamples(e, r, n, i) {
    if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
    for (;; r++, n = 0) {
      if (r >= e.length) {
        i();
        return
      }
      const a = e[r].units;
      for (; !(n >= a.length); n++) {
        const s = a[n];
        if (!(s.data.length <= 48 || s.type !== 1 && s.type !== 5) && (this.decryptAvcSample(e, r, n, i, s), !this.decrypter.isSync())) return
      }
    }
  }
}
const Fr = 188;
class Hs {
  constructor(e, r, n) {
    this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = r, this.typeSupported = n
  }
  static probe(e) {
    const r = Hs.syncOffset(e);
    return r > 0 && G.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1
  }
  static syncOffset(e) {
    const r = e.length,
      n = Math.min(Fr * 5, e.length - Fr) + 1;
    let i = 0;
    for (; i < n;) {
      let a = !1;
      for (let s = i; s < r && e[s] === 71; s += Fr)
        if (!a && KA(e, s) === 0 && (a = !0), a && s + Fr > n) return i;
      i++
    }
    return -1
  }
  static createTrack(e, r) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: dQ[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? r : void 0
    }
  }
  resetInitSegment(e, r, n, i) {
    this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = Hs.createTrack("video"), this._audioTrack = Hs.createTrack("audio", i), this._id3Track = Hs.createTrack("id3"), this._txtTrack = Hs.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = r, this.videoCodec = n, this._duration = i
  }
  resetTimeStamp() {}
  resetContiguity() {
    const {
      _audioTrack: e,
      _avcTrack: r,
      _id3Track: n
    } = this;
    e && (e.pesData = null), r && (r.pesData = null), n && (n.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
  }
  demux(e, r, n = !1, i = !1) {
    n || (this.sampleAes = null);
    let a;
    const s = this._avcTrack,
      o = this._audioTrack,
      c = this._id3Track,
      l = this._txtTrack;
    let u = s.pid,
      f = s.pesData,
      d = o.pid,
      h = c.pid,
      p = o.pesData,
      v = c.pesData,
      g = null,
      m = this.pmtParsed,
      y = this._pmtId,
      x = e.length;
    if (this.remainderData && (e = tc(this.remainderData, e), x = e.length, this.remainderData = null), x < Fr && !i) return this.remainderData = e, {
      audioTrack: o,
      videoTrack: s,
      id3Track: c,
      textTrack: l
    };
    const b = Math.max(0, Hs.syncOffset(e));
    x -= (x - b) % Fr, x < e.byteLength && !i && (this.remainderData = new Uint8Array(e.buffer, x, e.buffer.byteLength - x));
    let _ = 0;
    for (let T = b; T < x; T += Fr)
      if (e[T] === 71) {
        const R = !!(e[T + 1] & 64),
          I = KA(e, T),
          w = (e[T + 3] & 48) >> 4;
        let C;
        if (w > 1) {
          if (C = T + 5 + e[T + 4], C === T + Fr) continue
        } else C = T + 4;
        switch (I) {
          case u:
            R && (f && (a = Wc(f)) && this.parseAVCPES(s, l, a, !1), f = {
              data: [],
              size: 0
            }), f && (f.data.push(e.subarray(C, T + Fr)), f.size += T + Fr - C);
            break;
          case d:
            if (R) {
              if (p && (a = Wc(p))) switch (o.segmentCodec) {
                case "aac":
                  this.parseAACPES(o, a);
                  break;
                case "mp3":
                  this.parseMPEGPES(o, a);
                  break
              }
              p = {
                data: [],
                size: 0
              }
            }
            p && (p.data.push(e.subarray(C, T + Fr)), p.size += T + Fr - C);
            break;
          case h:
            R && (v && (a = Wc(v)) && this.parseID3PES(c, a), v = {
              data: [],
              size: 0
            }), v && (v.data.push(e.subarray(C, T + Fr)), v.size += T + Fr - C);
            break;
          case 0:
            R && (C += e[C] + 1), y = this._pmtId = eGe(e, C);
            break;
          case y: {
            R && (C += e[C] + 1);
            const L = tGe(e, C, this.typeSupported, n);
            u = L.avc, u > 0 && (s.pid = u), d = L.audio, d > 0 && (o.pid = d, o.segmentCodec = L.segmentCodec), h = L.id3, h > 0 && (c.pid = h), g !== null && !m && (G.warn(`MPEG-TS PMT found at ${T} after unknown PID '${g}'. Backtracking to sync byte @${b} to parse all TS packets.`), g = null, T = b - 188), m = this.pmtParsed = !0;
            break
          }
          case 17:
          case 8191:
            break;
          default:
            g = I;
            break
        }
      } else _++;
    if (_ > 0) {
      const T = new Error(`Found ${_} TS packet/s that do not start with 0x47`);
      this.observer.emit($.ERROR, $.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.FRAG_PARSING_ERROR,
        fatal: !1,
        error: T,
        reason: T.message
      })
    }
    s.pesData = f, o.pesData = p, c.pesData = v;
    const S = {
      audioTrack: o,
      videoTrack: s,
      id3Track: c,
      textTrack: l
    };
    return i && this.extractRemainingSamples(S), S
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let r;
    return e ? r = this.demux(e, -1, !1, !0) : r = {
      videoTrack: this._avcTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(r), this.sampleAes ? this.decrypt(r, this.sampleAes) : r
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: r,
      videoTrack: n,
      id3Track: i,
      textTrack: a
    } = e, s = n.pesData, o = r.pesData, c = i.pesData;
    let l;
    if (s && (l = Wc(s)) ? (this.parseAVCPES(n, a, l, !0), n.pesData = null) : n.pesData = s, o && (l = Wc(o))) {
      switch (r.segmentCodec) {
        case "aac":
          this.parseAACPES(r, l);
          break;
        case "mp3":
          this.parseMPEGPES(r, l);
          break
      }
      r.pesData = null
    } else o != null && o.size && G.log("last AAC PES packet truncated,might overlap between fragments"), r.pesData = o;
    c && (l = Wc(c)) ? (this.parseID3PES(i, l), i.pesData = null) : i.pesData = c
  }
  demuxSampleAes(e, r, n) {
    const i = this.demux(e, n, !0, !this.config.progressive),
      a = this.sampleAes = new Jze(this.observer, this.config, r);
    return this.decrypt(i, a)
  }
  decrypt(e, r) {
    return new Promise(n => {
      const {
        audioTrack: i,
        videoTrack: a
      } = e;
      i.samples && i.segmentCodec === "aac" ? r.decryptAacSamples(i.samples, 0, () => {
        a.samples ? r.decryptAvcSamples(a.samples, 0, 0, () => {
          n(e)
        }) : n(e)
      }) : a.samples && r.decryptAvcSamples(a.samples, 0, 0, () => {
        n(e)
      })
    })
  }
  destroy() {
    this._duration = 0
  }
  parseAVCPES(e, r, n, i) {
    const a = this.parseAVCNALu(e, n.data);
    let s = this.avcSample,
      o, c = !1;
    n.data = null, s && a.length && !e.audFound && (sw(s, e), s = this.avcSample = Ym(!1, n.pts, n.dts, "")), a.forEach(l => {
      switch (l.type) {
        case 1: {
          o = !0, s || (s = this.avcSample = Ym(!0, n.pts, n.dts, "")), s.frame = !0;
          const u = l.data;
          if (c && u.length > 4) {
            const f = new tB(u).readSliceType();
            (f === 2 || f === 4 || f === 7 || f === 9) && (s.key = !0)
          }
          break
        }
        case 5:
          o = !0, s || (s = this.avcSample = Ym(!0, n.pts, n.dts, "")), s.key = !0, s.frame = !0;
          break;
        case 6: {
          o = !0, vQ(l.data, 1, n.pts, r.samples);
          break
        }
        case 7:
          if (o = !0, c = !0, !e.sps) {
            const u = l.data,
              d = new tB(u).readSPS();
            e.width = d.width, e.height = d.height, e.pixelRatio = d.pixelRatio, e.sps = [u], e.duration = this._duration;
            const h = u.subarray(1, 4);
            let p = "avc1.";
            for (let v = 0; v < 3; v++) {
              let g = h[v].toString(16);
              g.length < 2 && (g = "0" + g), p += g
            }
            e.codec = p
          }
          break;
        case 8:
          o = !0, e.pps || (e.pps = [l.data]);
          break;
        case 9:
          o = !1, e.audFound = !0, s && sw(s, e), s = this.avcSample = Ym(!1, n.pts, n.dts, "");
          break;
        case 12:
          o = !0;
          break;
        default:
          o = !1, s && (s.debug += "unknown NAL " + l.type + " ");
          break
      }
      s && o && s.units.push(l)
    }), i && s && (sw(s, e), this.avcSample = null)
  }
  getLastNalUnit(e) {
    var r;
    let n = this.avcSample,
      i;
    if ((!n || n.units.length === 0) && (n = e[e.length - 1]), (r = n) != null && r.units) {
      const a = n.units;
      i = a[a.length - 1]
    }
    return i
  }
  parseAVCNALu(e, r) {
    const n = r.byteLength;
    let i = e.naluState || 0;
    const a = i,
      s = [];
    let o = 0,
      c, l, u, f = -1,
      d = 0;
    for (i === -1 && (f = 0, d = r[0] & 31, i = 0, o = 1); o < n;) {
      if (c = r[o++], !i) {
        i = c ? 0 : 1;
        continue
      }
      if (i === 1) {
        i = c ? 0 : 2;
        continue
      }
      if (!c) i = 3;
      else if (c === 1) {
        if (f >= 0) {
          const h = {
            data: r.subarray(f, o - i - 1),
            type: d
          };
          s.push(h)
        } else {
          const h = this.getLastNalUnit(e.samples);
          if (h && (a && o <= 4 - a && h.state && (h.data = h.data.subarray(0, h.data.byteLength - a)), l = o - i - 1, l > 0)) {
            const p = new Uint8Array(h.data.byteLength + l);
            p.set(h.data, 0), p.set(r.subarray(0, l), h.data.byteLength), h.data = p, h.state = 0
          }
        }
        o < n ? (u = r[o] & 31, f = o, d = u, i = 0) : i = -1
      } else i = 0
    }
    if (f >= 0 && i >= 0) {
      const h = {
        data: r.subarray(f, n),
        type: d,
        state: i
      };
      s.push(h)
    }
    if (s.length === 0) {
      const h = this.getLastNalUnit(e.samples);
      if (h) {
        const p = new Uint8Array(h.data.byteLength + r.byteLength);
        p.set(h.data, 0), p.set(r, h.data.byteLength), h.data = p
      }
    }
    return e.naluState = i, s
  }
  parseAACPES(e, r) {
    let n = 0;
    const i = this.aacOverFlow;
    let a = r.data;
    if (i) {
      this.aacOverFlow = null;
      const f = i.missing,
        d = i.sample.unit.byteLength;
      if (f === -1) {
        const h = new Uint8Array(d + a.byteLength);
        h.set(i.sample.unit, 0), h.set(a, d), a = h
      } else {
        const h = d - f;
        i.sample.unit.set(a.subarray(0, f), h), e.samples.push(i.sample), n = i.missing
      }
    }
    let s, o;
    for (s = n, o = a.length; s < o - 1 && !D1(a, s); s++);
    if (s !== n) {
      let f;
      const d = s < o - 1;
      d ? f = `AAC PES did not start with ADTS header,offset:${s}` : f = "No ADTS header found in AAC PES";
      const h = new Error(f);
      if (G.warn(`parsing error: ${f}`), this.observer.emit($.ERROR, $.ERROR, {
          type: ve.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          levelRetry: d,
          error: h,
          reason: f
        }), !d) return
    }
    OQ(e, this.observer, a, s, this.audioCodec);
    let c;
    if (r.pts !== void 0) c = r.pts;
    else if (i) {
      const f = LQ(e.samplerate);
      c = i.sample.pts + f
    } else {
      G.warn("[tsdemuxer]: AAC PES unknown PTS");
      return
    }
    let l = 0,
      u;
    for (; s < o;)
      if (u = PQ(e, a, s, c, l), s += u.length, u.missing) {
        this.aacOverFlow = u;
        break
      } else
        for (l++; s < o - 1 && !D1(a, s); s++);
  }
  parseMPEGPES(e, r) {
    const n = r.data,
      i = n.length;
    let a = 0,
      s = 0;
    const o = r.pts;
    if (o === void 0) {
      G.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return
    }
    for (; s < i;)
      if (MQ(n, s)) {
        const c = NQ(e, n, s, o, a);
        if (c) s += c.length, a++;
        else break
      } else s++
  }
  parseID3PES(e, r) {
    if (r.pts === void 0) {
      G.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return
    }
    const n = Nt({}, r, {
      type: this._avcTrack ? Si.emsg : Si.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(n)
  }
}

function Ym(t, e, r, n) {
  return {
    key: t,
    frame: !1,
    pts: e,
    dts: r,
    units: [],
    debug: n,
    length: 0
  }
}

function KA(t, e) {
  return ((t[e + 1] & 31) << 8) + t[e + 2]
}

function eGe(t, e) {
  return (t[e + 10] & 31) << 8 | t[e + 11]
}

function tGe(t, e, r, n) {
  const i = {
      audio: -1,
      avc: -1,
      id3: -1,
      segmentCodec: "aac"
    },
    a = (t[e + 1] & 15) << 8 | t[e + 2],
    s = e + 3 + a - 4,
    o = (t[e + 10] & 15) << 8 | t[e + 11];
  for (e += 12 + o; e < s;) {
    const c = KA(t, e);
    switch (t[e]) {
      case 207:
        if (!n) {
          G.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
          break
        }
        case 15:
          i.audio === -1 && (i.audio = c);
          break;
        case 21:
          i.id3 === -1 && (i.id3 = c);
          break;
        case 219:
          if (!n) {
            G.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
            break
          }
          case 27:
            i.avc === -1 && (i.avc = c);
            break;
          case 3:
          case 4:
            r.mpeg !== !0 && r.mp3 !== !0 ? G.log("MPEG audio found, not supported in this browser") : i.audio === -1 && (i.audio = c, i.segmentCodec = "mp3");
            break;
          case 36:
            G.warn("Unsupported HEVC stream type found");
            break
    }
    e += ((t[e + 3] & 15) << 8 | t[e + 4]) + 5
  }
  return i
}

function Wc(t) {
  let e = 0,
    r, n, i, a, s;
  const o = t.data;
  if (!t || t.size === 0) return null;
  for (; o[0].length < 19 && o.length > 1;) {
    const l = new Uint8Array(o[0].length + o[1].length);
    l.set(o[0]), l.set(o[1], o[0].length), o[0] = l, o.splice(1, 1)
  }
  if (r = o[0], (r[0] << 16) + (r[1] << 8) + r[2] === 1) {
    if (n = (r[4] << 8) + r[5], n && n > t.size - 6) return null;
    const l = r[7];
    l & 192 && (a = (r[9] & 14) * 536870912 + (r[10] & 255) * 4194304 + (r[11] & 254) * 16384 + (r[12] & 255) * 128 + (r[13] & 254) / 2, l & 64 ? (s = (r[14] & 14) * 536870912 + (r[15] & 255) * 4194304 + (r[16] & 254) * 16384 + (r[17] & 255) * 128 + (r[18] & 254) / 2, a - s > 60 * 9e4 && (G.warn(`${Math.round((a-s)/9e4)}s delta between PTS and DTS, align them`), a = s)) : s = a), i = r[8];
    let u = i + 9;
    if (t.size <= u) return null;
    t.size -= u;
    const f = new Uint8Array(t.size);
    for (let d = 0, h = o.length; d < h; d++) {
      r = o[d];
      let p = r.byteLength;
      if (u)
        if (u > p) {
          u -= p;
          continue
        } else r = r.subarray(u), p -= u, u = 0;
      f.set(r, e), e += p
    }
    return n && (n -= i + 3), {
      data: f,
      pts: a,
      dts: s,
      len: n
    }
  }
  return null
}

function sw(t, e) {
  if (t.units.length && t.frame) {
    if (t.pts === void 0) {
      const r = e.samples,
        n = r.length;
      if (n) {
        const i = r[n - 1];
        t.pts = i.pts, t.dts = i.dts
      } else {
        e.dropped++;
        return
      }
    }
    e.samples.push(t)
  }
  t.debug.length && G.log(t.pts + "/" + t.dts + ":" + t.debug)
}
class rGe extends $Q {
  resetInitSegment(e, r, n, i) {
    super.resetInitSegment(e, r, n, i), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: r,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    }
  }
  static probe(e) {
    if (!e) return !1;
    let n = (k1(e, 0) || []).length;
    for (let i = e.length; n < i; n++)
      if (Zze(e, n)) return G.log("MPEG Audio sync word found !"), !0;
    return !1
  }
  canParse(e, r) {
    return Qze(e, r)
  }
  appendFrame(e, r, n) {
    if (this.basePTS !== null) return NQ(e, r, n, this.basePTS, this.frameIndex)
  }
}
class rB {
  static getSilentFrame(e, r) {
    switch (e) {
      case "mp4a.40.2":
        if (r === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (r === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (r === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (r === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (r === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (r === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      default:
        if (r === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (r === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (r === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break
    }
  }
}
const Bs = Math.pow(2, 32) - 1;
class K {
  static init() {
    K.types = {
      avc1: [],
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in K.types) K.types.hasOwnProperty(e) && (K.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
      n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
    K.HDLR_TYPES = {
      video: r,
      audio: n
    };
    const i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
      a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
    K.STTS = K.STSC = K.STCO = a, K.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), K.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), K.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), K.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
    const s = new Uint8Array([105, 115, 111, 109]),
      o = new Uint8Array([97, 118, 99, 49]),
      c = new Uint8Array([0, 0, 0, 1]);
    K.FTYP = K.box(K.types.ftyp, s, c, s, o), K.DINF = K.box(K.types.dinf, K.box(K.types.dref, i))
  }
  static box(e, ...r) {
    let n = 8,
      i = r.length;
    const a = i;
    for (; i--;) n += r[i].byteLength;
    const s = new Uint8Array(n);
    for (s[0] = n >> 24 & 255, s[1] = n >> 16 & 255, s[2] = n >> 8 & 255, s[3] = n & 255, s.set(e, 4), i = 0, n = 8; i < a; i++) s.set(r[i], n), n += r[i].byteLength;
    return s
  }
  static hdlr(e) {
    return K.box(K.types.hdlr, K.HDLR_TYPES[e])
  }
  static mdat(e) {
    return K.box(K.types.mdat, e)
  }
  static mdhd(e, r) {
    r *= e;
    const n = Math.floor(r / (Bs + 1)),
      i = Math.floor(r % (Bs + 1));
    return K.box(K.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, 85, 196, 0, 0]))
  }
  static mdia(e) {
    return K.box(K.types.mdia, K.mdhd(e.timescale, e.duration), K.hdlr(e.type), K.minf(e))
  }
  static mfhd(e) {
    return K.box(K.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, e & 255]))
  }
  static minf(e) {
    return e.type === "audio" ? K.box(K.types.minf, K.box(K.types.smhd, K.SMHD), K.DINF, K.stbl(e)) : K.box(K.types.minf, K.box(K.types.vmhd, K.VMHD), K.DINF, K.stbl(e))
  }
  static moof(e, r, n) {
    return K.box(K.types.moof, K.mfhd(e), K.traf(n, r))
  }
  static moov(e) {
    let r = e.length;
    const n = [];
    for (; r--;) n[r] = K.trak(e[r]);
    return K.box.apply(null, [K.types.moov, K.mvhd(e[0].timescale, e[0].duration)].concat(n).concat(K.mvex(e)))
  }
  static mvex(e) {
    let r = e.length;
    const n = [];
    for (; r--;) n[r] = K.trex(e[r]);
    return K.box.apply(null, [K.types.mvex, ...n])
  }
  static mvhd(e, r) {
    r *= e;
    const n = Math.floor(r / (Bs + 1)),
      i = Math.floor(r % (Bs + 1)),
      a = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
    return K.box(K.types.mvhd, a)
  }
  static sdtp(e) {
    const r = e.samples || [],
      n = new Uint8Array(4 + r.length);
    let i, a;
    for (i = 0; i < r.length; i++) a = r[i].flags, n[i + 4] = a.dependsOn << 4 | a.isDependedOn << 2 | a.hasRedundancy;
    return K.box(K.types.sdtp, n)
  }
  static stbl(e) {
    return K.box(K.types.stbl, K.stsd(e), K.box(K.types.stts, K.STTS), K.box(K.types.stsc, K.STSC), K.box(K.types.stsz, K.STSZ), K.box(K.types.stco, K.STCO))
  }
  static avc1(e) {
    let r = [],
      n = [],
      i, a, s;
    for (i = 0; i < e.sps.length; i++) a = e.sps[i], s = a.byteLength, r.push(s >>> 8 & 255), r.push(s & 255), r = r.concat(Array.prototype.slice.call(a));
    for (i = 0; i < e.pps.length; i++) a = e.pps[i], s = a.byteLength, n.push(s >>> 8 & 255), n.push(s & 255), n = n.concat(Array.prototype.slice.call(a));
    const o = K.box(K.types.avcC, new Uint8Array([1, r[3], r[4], r[5], 255, 224 | e.sps.length].concat(r).concat([e.pps.length]).concat(n))),
      c = e.width,
      l = e.height,
      u = e.pixelRatio[0],
      f = e.pixelRatio[1];
    return K.box(K.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, c >> 8 & 255, c & 255, l >> 8 & 255, l & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, K.box(K.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), K.box(K.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, u & 255, f >> 24, f >> 16 & 255, f >> 8 & 255, f & 255])))
  }
  static esds(e) {
    const r = e.config.length;
    return new Uint8Array([0, 0, 0, 0, 3, 23 + r, 0, 1, 0, 4, 15 + r, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([r]).concat(e.config).concat([6, 1, 2]))
  }
  static mp4a(e) {
    const r = e.samplerate;
    return K.box(K.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, r & 255, 0, 0]), K.box(K.types.esds, K.esds(e)))
  }
  static mp3(e) {
    const r = e.samplerate;
    return K.box(K.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, r & 255, 0, 0]))
  }
  static stsd(e) {
    return e.type === "audio" ? e.segmentCodec === "mp3" && e.codec === "mp3" ? K.box(K.types.stsd, K.STSD, K.mp3(e)) : K.box(K.types.stsd, K.STSD, K.mp4a(e)) : K.box(K.types.stsd, K.STSD, K.avc1(e))
  }
  static tkhd(e) {
    const r = e.id,
      n = e.duration * e.timescale,
      i = e.width,
      a = e.height,
      s = Math.floor(n / (Bs + 1)),
      o = Math.floor(n % (Bs + 1));
    return K.box(K.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i >> 8 & 255, i & 255, 0, 0, a >> 8 & 255, a & 255, 0, 0]))
  }
  static traf(e, r) {
    const n = K.sdtp(e),
      i = e.id,
      a = Math.floor(r / (Bs + 1)),
      s = Math.floor(r % (Bs + 1));
    return K.box(K.types.traf, K.box(K.types.tfhd, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255])), K.box(K.types.tfdt, new Uint8Array([1, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255])), K.trun(e, n.length + 16 + 20 + 8 + 16 + 8 + 8), n)
  }
  static trak(e) {
    return e.duration = e.duration || 4294967295, K.box(K.types.trak, K.tkhd(e), K.mdia(e))
  }
  static trex(e) {
    const r = e.id;
    return K.box(K.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
  }
  static trun(e, r) {
    const n = e.samples || [],
      i = n.length,
      a = 12 + 16 * i,
      s = new Uint8Array(a);
    let o, c, l, u, f, d;
    for (r += 8 + a, s.set([e.type === "video" ? 1 : 0, 0, 15, 1, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, r & 255], 0), o = 0; o < i; o++) c = n[o], l = c.duration, u = c.size, f = c.flags, d = c.cts, s.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, l & 255, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u & 255, f.isLeading << 2 | f.dependsOn, f.isDependedOn << 6 | f.hasRedundancy << 4 | f.paddingValue << 1 | f.isNonSync, f.degradPrio & 240 << 8, f.degradPrio & 15, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, d & 255], 12 + 16 * o);
    return K.box(K.types.trun, s)
  }
  static initSegment(e) {
    K.types || K.init();
    const r = K.moov(e),
      n = new Uint8Array(K.FTYP.byteLength + r.byteLength);
    return n.set(K.FTYP), n.set(r, K.FTYP.byteLength), n
  }
}
K.types = void 0;
K.HDLR_TYPES = void 0;
K.STTS = void 0;
K.STSC = void 0;
K.STCO = void 0;
K.STSZ = void 0;
K.VMHD = void 0;
K.SMHD = void 0;
K.STSD = void 0;
K.FTYP = void 0;
K.DINF = void 0;
const FQ = 9e4;

function FO(t, e, r = 1, n = !1) {
  const i = t * e * r;
  return n ? Math.round(i) : i
}

function nGe(t, e, r = 1, n = !1) {
  return FO(t, e, 1 / r, n)
}

function sh(t, e = !1) {
  return FO(t, 1e3, 1 / FQ, e)
}

function iGe(t, e = 1) {
  return FO(t, FQ, 1 / e)
}
const aGe = 10 * 1e3,
  nB = 1024,
  sGe = 1152;
let qm = null,
  ow = null;
class lw {
  constructor(e, r, n, i = "") {
    if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = r, this.typeSupported = n, this.ISGenerated = !1, qm === null) {
      const s = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      qm = s ? parseInt(s[1]) : 0
    }
    if (ow === null) {
      const a = navigator.userAgent.match(/Safari\/(\d+)/i);
      ow = a ? parseInt(a[1]) : 0
    }
  }
  destroy() {}
  resetTimeStamp(e) {
    G.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
  }
  resetNextTimestamp() {
    G.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
  }
  resetInitSegment() {
    G.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
  }
  getVideoStartPts(e) {
    let r = !1;
    const n = e.reduce((i, a) => {
      const s = a.pts - i;
      return s < -4294967296 ? (r = !0, jn(i, a.pts)) : s > 0 ? i : a.pts
    }, e[0].pts);
    return r && G.debug("PTS rollover detected"), n
  }
  remux(e, r, n, i, a, s, o, c) {
    let l, u, f, d, h, p, v = a,
      g = a;
    const m = e.pid > -1,
      y = r.pid > -1,
      x = r.samples.length,
      b = e.samples.length > 0,
      _ = o && x > 0 || x > 1;
    if ((!m || b) && (!y || _) || this.ISGenerated || o) {
      this.ISGenerated || (f = this.generateIS(e, r, a, s));
      const T = this.isVideoContiguous;
      let R = -1,
        I;
      if (_ && (R = oGe(r.samples), !T && this.config.forceKeyFrameOnDiscontinuity))
        if (p = !0, R > 0) {
          G.warn(`[mp4-remuxer]: Dropped ${R} out of ${x} video samples due to a missing keyframe`);
          const w = this.getVideoStartPts(r.samples);
          r.samples = r.samples.slice(R), r.dropped += R, g += (r.samples[0].pts - w) / r.inputTimeScale, I = g
        } else R === -1 && (G.warn(`[mp4-remuxer]: No keyframe found out of ${x} video samples`), p = !1);
      if (this.ISGenerated) {
        if (b && _) {
          const w = this.getVideoStartPts(r.samples),
            L = (jn(e.samples[0].pts, w) - w) / r.inputTimeScale;
          v += Math.max(0, L), g += Math.max(0, -L)
        }
        if (b) {
          if (e.samplerate || (G.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), f = this.generateIS(e, r, a, s)), u = this.remuxAudio(e, v, this.isAudioContiguous, s, y || _ || c === ye.AUDIO ? g : void 0), _) {
            const w = u ? u.endPTS - u.startPTS : 0;
            r.inputTimeScale || (G.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), f = this.generateIS(e, r, a, s)), l = this.remuxVideo(r, g, T, w)
          }
        } else _ && (l = this.remuxVideo(r, g, T, 0));
        l && (l.firstKeyFrame = R, l.independent = R !== -1, l.firstKeyFramePTS = I)
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (h = BQ(n, a, this._initPTS, this._initDTS)), i.samples.length && (d = UQ(i, a, this._initPTS))), {
      audio: u,
      video: l,
      initSegment: f,
      independent: p,
      text: d,
      id3: h
    }
  }
  generateIS(e, r, n, i) {
    const a = e.samples,
      s = r.samples,
      o = this.typeSupported,
      c = {},
      l = this._initPTS;
    let u = !l || i,
      f = "audio/mp4",
      d, h, p;
    if (u && (d = h = 1 / 0), e.config && a.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          o.mpeg ? (f = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3");
          break
      }
      c.audio = {
        id: "audio",
        container: f,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : K.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, u && (p = e.inputTimeScale, !l || p !== l.timescale ? d = h = a[0].pts - Math.round(p * n) : u = !1)
    }
    if (r.sps && r.pps && s.length && (r.timescale = r.inputTimeScale, c.video = {
        id: "main",
        container: "video/mp4",
        codec: r.codec,
        initSegment: K.initSegment([r]),
        metadata: {
          width: r.width,
          height: r.height
        }
      }, u))
      if (p = r.inputTimeScale, !l || p !== l.timescale) {
        const v = this.getVideoStartPts(s),
          g = Math.round(p * n);
        h = Math.min(h, jn(s[0].dts, v) - g), d = Math.min(d, v - g)
      } else u = !1;
    if (Object.keys(c).length) return this.ISGenerated = !0, u ? (this._initPTS = {
      baseTime: d,
      timescale: p
    }, this._initDTS = {
      baseTime: h,
      timescale: p
    }) : d = p = void 0, {
      tracks: c,
      initPTS: d,
      timescale: p
    }
  }
  remuxVideo(e, r, n, i) {
    const a = e.inputTimeScale,
      s = e.samples,
      o = [],
      c = s.length,
      l = this._initPTS;
    let u = this.nextAvcDts,
      f = 8,
      d = this.videoSampleDuration,
      h, p, v = Number.POSITIVE_INFINITY,
      g = Number.NEGATIVE_INFINITY,
      m = !1;
    if (!n || u === null) {
      const M = r * a,
        U = s[0].pts - jn(s[0].dts, s[0].pts);
      u = M - U
    }
    const y = l.baseTime * a / l.timescale;
    for (let M = 0; M < c; M++) {
      const U = s[M];
      U.pts = jn(U.pts - y, u), U.dts = jn(U.dts - y, u), U.dts < s[M > 0 ? M - 1 : M].dts && (m = !0)
    }
    m && s.sort(function (M, U) {
      const W = M.dts - U.dts,
        k = M.pts - U.pts;
      return W || k
    }), h = s[0].dts, p = s[s.length - 1].dts;
    const x = p - h,
      b = x ? Math.round(x / (c - 1)) : d || e.inputTimeScale / 30;
    if (n) {
      const M = h - u,
        U = M > b,
        W = M < -1;
      if ((U || W) && (U ? G.warn(`AVC: ${sh(M,!0)} ms (${M}dts) hole between fragments detected, filling it`) : G.warn(`AVC: ${sh(-M,!0)} ms (${M}dts) overlapping between fragments detected`), !W || u > s[0].pts)) {
        h = u;
        const k = s[0].pts - M;
        s[0].dts = h, s[0].pts = k, G.log(`Video: First PTS/DTS adjusted: ${sh(k,!0)}/${sh(h,!0)}, delta: ${sh(M,!0)} ms`)
      }
    }
    h = Math.max(0, h);
    let _ = 0,
      S = 0;
    for (let M = 0; M < c; M++) {
      const U = s[M],
        W = U.units,
        k = W.length;
      let O = 0;
      for (let F = 0; F < k; F++) O += W[F].data.length;
      S += O, _ += k, U.length = O, U.dts = Math.max(U.dts, h), v = Math.min(U.pts, v), g = Math.max(U.pts, g)
    }
    p = s[c - 1].dts;
    const T = S + 4 * _ + 8;
    let R;
    try {
      R = new Uint8Array(T)
    } catch (M) {
      this.observer.emit($.ERROR, $.ERROR, {
        type: ve.MUX_ERROR,
        details: q.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: M,
        bytes: T,
        reason: `fail allocating video mdat ${T}`
      });
      return
    }
    const I = new DataView(R.buffer);
    I.setUint32(0, T), R.set(K.types.mdat, 4);
    let w = !1,
      C = Number.POSITIVE_INFINITY,
      L = Number.POSITIVE_INFINITY,
      H = Number.NEGATIVE_INFINITY,
      N = Number.NEGATIVE_INFINITY;
    for (let M = 0; M < c; M++) {
      const U = s[M],
        W = U.units;
      let k = 0;
      for (let D = 0, Q = W.length; D < Q; D++) {
        const ee = W[D],
          de = ee.data,
          oe = ee.data.byteLength;
        I.setUint32(f, oe), f += 4, R.set(de, f), f += oe, k += 4 + oe
      }
      let O;
      if (M < c - 1) d = s[M + 1].dts - U.dts, O = s[M + 1].pts - U.pts;
      else {
        const D = this.config,
          Q = M > 0 ? U.dts - s[M - 1].dts : b;
        if (O = M > 0 ? U.pts - s[M - 1].pts : b, D.stretchShortVideoTrack && this.nextAudioPts !== null) {
          const ee = Math.floor(D.maxBufferHole * a),
            de = (i ? v + i * a : this.nextAudioPts) - U.pts;
          de > ee ? (d = de - Q, d < 0 ? d = Q : w = !0, G.log(`[mp4-remuxer]: It is approximately ${de/90} ms to the next segment; using duration ${d/90} ms for the last video frame.`)) : d = Q
        } else d = Q
      }
      const F = Math.round(U.pts - U.dts);
      C = Math.min(C, d), H = Math.max(H, d), L = Math.min(L, O), N = Math.max(N, O), o.push(new iB(U.key, d, k, F))
    }
    if (o.length) {
      if (qm) {
        if (qm < 70) {
          const M = o[0].flags;
          M.dependsOn = 2, M.isNonSync = 0
        }
      } else if (ow && N - L < H - C && b / H < .025 && o[0].cts === 0) {
        G.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let M = h;
        for (let U = 0, W = o.length; U < W; U++) {
          const k = M + o[U].duration,
            O = M + o[U].cts;
          if (U < W - 1) {
            const F = k + o[U + 1].cts;
            o[U].duration = F - O
          } else o[U].duration = U ? o[U - 1].duration : b;
          o[U].cts = 0, M = k
        }
      }
    }
    d = w || !d ? b : d, this.nextAvcDts = u = p + d, this.videoSampleDuration = d, this.isVideoContiguous = !0;
    const P = K.moof(e.sequenceNumber++, h, Nt({}, e, {
        samples: o
      })),
      B = "video",
      V = {
        data1: P,
        data2: R,
        startPTS: v / a,
        endPTS: (g + d) / a,
        startDTS: h / a,
        endDTS: u / a,
        type: B,
        hasAudio: !1,
        hasVideo: !0,
        nb: o.length,
        dropped: e.dropped
      };
    return e.samples = [], e.dropped = 0, V
  }
  remuxAudio(e, r, n, i, a) {
    const s = e.inputTimeScale,
      o = e.samplerate ? e.samplerate : s,
      c = s / o,
      l = e.segmentCodec === "aac" ? nB : sGe,
      u = l * c,
      f = this._initPTS,
      d = e.segmentCodec === "mp3" && this.typeSupported.mpeg,
      h = [],
      p = a !== void 0;
    let v = e.samples,
      g = d ? 0 : 8,
      m = this.nextAudioPts || -1;
    const y = r * s,
      x = f.baseTime * s / f.timescale;
    if (this.isAudioContiguous = n = n || v.length && m > 0 && (i && Math.abs(y - m) < 9e3 || Math.abs(jn(v[0].pts - x, y) - m) < 20 * u), v.forEach(function (B) {
        B.pts = jn(B.pts - x, y)
      }), !n || m < 0) {
      if (v = v.filter(B => B.pts >= 0), !v.length) return;
      a === 0 ? m = 0 : i && !p ? m = Math.max(0, y) : m = v[0].pts
    }
    if (e.segmentCodec === "aac") {
      const B = this.config.maxAudioFramesDrift;
      for (let V = 0, M = m; V < v.length; V++) {
        const U = v[V],
          W = U.pts,
          k = W - M,
          O = Math.abs(1e3 * k / s);
        if (k <= -B * u && p) V === 0 && (G.warn(`Audio frame @ ${(W/s).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3*k/s)} ms.`), this.nextAudioPts = m = M = W);
        else if (k >= B * u && O < aGe && p) {
          let F = Math.round(k / u);
          M = W - F * u, M < 0 && (F--, M += u), V === 0 && (this.nextAudioPts = m = M), G.warn(`[mp4-remuxer]: Injecting ${F} audio frame @ ${(M/s).toFixed(3)}s due to ${Math.round(1e3*k/s)} ms gap.`);
          for (let D = 0; D < F; D++) {
            const Q = Math.max(M, 0);
            let ee = rB.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
            ee || (G.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), ee = U.unit.subarray()), v.splice(V, 0, {
              unit: ee,
              pts: Q
            }), M += u, V++
          }
        }
        U.pts = M, M += u
      }
    }
    let b = null,
      _ = null,
      S, T = 0,
      R = v.length;
    for (; R--;) T += v[R].unit.byteLength;
    for (let B = 0, V = v.length; B < V; B++) {
      const M = v[B],
        U = M.unit;
      let W = M.pts;
      if (_ !== null) {
        const O = h[B - 1];
        O.duration = Math.round((W - _) / c)
      } else if (n && e.segmentCodec === "aac" && (W = m), b = W, T > 0) {
        T += g;
        try {
          S = new Uint8Array(T)
        } catch (O) {
          this.observer.emit($.ERROR, $.ERROR, {
            type: ve.MUX_ERROR,
            details: q.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: O,
            bytes: T,
            reason: `fail allocating audio mdat ${T}`
          });
          return
        }
        d || (new DataView(S.buffer).setUint32(0, T), S.set(K.types.mdat, 4))
      } else return;
      S.set(U, g);
      const k = U.byteLength;
      g += k, h.push(new iB(!0, l, k, 0)), _ = W
    }
    const I = h.length;
    if (!I) return;
    const w = h[h.length - 1];
    this.nextAudioPts = m = _ + c * w.duration;
    const C = d ? new Uint8Array(0) : K.moof(e.sequenceNumber++, b / c, Nt({}, e, {
      samples: h
    }));
    e.samples = [];
    const L = b / s,
      H = m / s,
      P = {
        data1: C,
        data2: S,
        startPTS: L,
        endPTS: H,
        startDTS: L,
        endDTS: H,
        type: "audio",
        hasAudio: !0,
        hasVideo: !1,
        nb: I
      };
    return this.isAudioContiguous = !0, P
  }
  remuxEmptyAudio(e, r, n, i) {
    const a = e.inputTimeScale,
      s = e.samplerate ? e.samplerate : a,
      o = a / s,
      c = this.nextAudioPts,
      l = this._initDTS,
      u = l.baseTime * 9e4 / l.timescale,
      f = (c !== null ? c : i.startDTS * a) + u,
      d = i.endDTS * a + u,
      h = o * nB,
      p = Math.ceil((d - f) / h),
      v = rB.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
    if (G.warn("[mp4-remuxer]: remux empty Audio"), !v) {
      G.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
      return
    }
    const g = [];
    for (let m = 0; m < p; m++) {
      const y = f + m * h;
      g.push({
        unit: v,
        pts: y,
        dts: y
      })
    }
    return e.samples = g, this.remuxAudio(e, r, n, !1)
  }
}

function jn(t, e) {
  let r;
  if (e === null) return t;
  for (e < t ? r = -8589934592 : r = 8589934592; Math.abs(t - e) > 4294967296;) t += r;
  return t
}

function oGe(t) {
  for (let e = 0; e < t.length; e++)
    if (t[e].key) return e;
  return -1
}

function BQ(t, e, r, n) {
  const i = t.samples.length;
  if (!i) return;
  const a = t.inputTimeScale;
  for (let o = 0; o < i; o++) {
    const c = t.samples[o];
    c.pts = jn(c.pts - r.baseTime * 9e4 / r.timescale, e * a) / a, c.dts = jn(c.dts - n.baseTime * 9e4 / n.timescale, e * a) / a
  }
  const s = t.samples;
  return t.samples = [], {
    samples: s
  }
}

function UQ(t, e, r) {
  const n = t.samples.length;
  if (!n) return;
  const i = t.inputTimeScale;
  for (let s = 0; s < n; s++) {
    const o = t.samples[s];
    o.pts = jn(o.pts - r.baseTime * 9e4 / r.timescale, e * i) / i
  }
  t.samples.sort((s, o) => s.pts - o.pts);
  const a = t.samples;
  return t.samples = [], {
    samples: a
  }
}
class iB {
  constructor(e, r, n, i) {
    this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = r, this.size = n, this.cts = i, this.flags = new lGe(e)
  }
}
class lGe {
  constructor(e) {
    this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1
  }
}
class cGe {
  constructor() {
    this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null
  }
  destroy() {}
  resetTimeStamp(e) {
    this.initPTS = e, this.lastEndTime = null
  }
  resetNextTimestamp() {
    this.lastEndTime = null
  }
  resetInitSegment(e, r, n, i) {
    this.audioCodec = r, this.videoCodec = n, this.generateInitSegment($He(e, i)), this.emitInitSegment = !0
  }
  generateInitSegment(e) {
    let {
      audioCodec: r,
      videoCodec: n
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return
    }
    const i = this.initData = gQ(e);
    r || (r = aB(i.audio, Qe.AUDIO)), n || (n = aB(i.video, Qe.VIDEO));
    const a = {};
    i.audio && i.video ? a.audiovideo = {
      container: "video/mp4",
      codec: r + "," + n,
      initSegment: e,
      id: "main"
    } : i.audio ? a.audio = {
      container: "audio/mp4",
      codec: r,
      initSegment: e,
      id: "audio"
    } : i.video ? a.video = {
      container: "video/mp4",
      codec: n,
      initSegment: e,
      id: "main"
    } : G.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = a
  }
  remux(e, r, n, i, a, s) {
    var o, c;
    let {
      initPTS: l,
      lastEndTime: u
    } = this;
    const f = {
      audio: void 0,
      video: void 0,
      text: i,
      id3: n,
      initSegment: void 0
    };
    ge(u) || (u = this.lastEndTime = a || 0);
    const d = r.samples;
    if (!(d != null && d.length)) return f;
    const h = {
      initPTS: void 0,
      timescale: 1
    };
    let p = this.initData;
    if ((o = p) != null && o.length || (this.generateInitSegment(d), p = this.initData), !((c = p) != null && c.length)) return G.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), f;
    this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
    const v = CHe(p, d),
      g = v === null ? a : v;
    (uGe(l, g, a) || h.timescale !== l.timescale && s) && (h.initPTS = g - a, this.initPTS = l = {
      baseTime: h.initPTS,
      timescale: 1
    });
    const m = kHe(d, p),
      y = e ? g - l.baseTime / l.timescale : u,
      x = y + m;
    LHe(p, d, l.baseTime / l.timescale), m > 0 ? this.lastEndTime = x : (G.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const b = !!p.audio,
      _ = !!p.video;
    let S = "";
    b && (S += "audio"), _ && (S += "video");
    const T = {
      data1: d,
      startPTS: y,
      startDTS: y,
      endPTS: x,
      endDTS: x,
      type: S,
      hasAudio: b,
      hasVideo: _,
      nb: 1,
      dropped: 0
    };
    return f.audio = T.type === "audio" ? T : void 0, f.video = T.type !== "audio" ? T : void 0, f.initSegment = h, f.id3 = BQ(n, a, l, l), i.samples.length && (f.text = UQ(i, a, l)), f
  }
}

function uGe(t, e, r) {
  if (t === null) return !0;
  const n = e - t.baseTime / t.timescale;
  return n < 0 && Math.abs(n - r) > 1
}

function aB(t, e) {
  const r = t == null ? void 0 : t.codec;
  return r && r.length > 4 ? r : r === "hvc1" || r === "hev1" ? "hvc1.1.c.L120.90" : r === "av01" ? "av01.0.04M.08" : r === "avc1" || e === Qe.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
}
let ja;
try {
  ja = self.performance.now.bind(self.performance)
} catch {
  G.debug("Unable to use Performance API on this environment"), ja = typeof self < "u" && self.Date.now
}
const cw = [{
  demux: Wze,
  remux: cGe
}, {
  demux: Hs,
  remux: lw
}, {
  demux: Gze,
  remux: lw
}, {
  demux: rGe,
  remux: lw
}];
class sB {
  constructor(e, r, n, i, a) {
    this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = r, this.config = n, this.vendor = i, this.id = a
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
  }
  push(e, r, n, i) {
    const a = n.transmuxing;
    a.executeStart = ja();
    let s = new Uint8Array(e);
    const {
      currentTransmuxState: o,
      transmuxConfig: c
    } = this;
    i && (this.currentTransmuxState = i);
    const {
      contiguous: l,
      discontinuity: u,
      trackSwitch: f,
      accurateTimeOffset: d,
      timeOffset: h,
      initSegmentChange: p
    } = i || o, {
      audioCodec: v,
      videoCodec: g,
      defaultInitPts: m,
      duration: y,
      initSegmentData: x
    } = c, b = fGe(s, r);
    if (b && b.method === "AES-128") {
      const R = this.getDecrypter();
      if (R.isSync()) {
        let I = R.softwareDecrypt(s, b.key.buffer, b.iv.buffer);
        if (n.part > -1 && (I = R.flush()), !I) return a.executeEnd = ja(), uw(n);
        s = new Uint8Array(I)
      } else return this.decryptionPromise = R.webCryptoDecrypt(s, b.key.buffer, b.iv.buffer).then(I => {
        const w = this.push(I, null, n);
        return this.decryptionPromise = null, w
      }), this.decryptionPromise
    }
    const _ = this.needsProbing(u, f);
    if (_) {
      const R = this.configureTransmuxer(s);
      if (R) return G.warn(`[transmuxer] ${R.message}`), this.observer.emit($.ERROR, $.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.FRAG_PARSING_ERROR,
        fatal: !1,
        error: R,
        reason: R.message
      }), a.executeEnd = ja(), uw(n)
    }(u || f || p || _) && this.resetInitSegment(x, v, g, y, r), (u || p || _) && this.resetInitialTimestamp(m), l || this.resetContiguity();
    const S = this.transmux(s, b, h, d, n),
      T = this.currentTransmuxState;
    return T.contiguous = !0, T.discontinuity = !1, T.trackSwitch = !1, a.executeEnd = ja(), S
  }
  flush(e) {
    const r = e.transmuxing;
    r.executeStart = ja();
    const {
      decrypter: n,
      currentTransmuxState: i,
      decryptionPromise: a
    } = this;
    if (a) return a.then(() => this.flush(e));
    const s = [],
      {
        timeOffset: o
      } = i;
    if (n) {
      const f = n.flush();
      f && s.push(this.push(f, null, e))
    }
    const {
      demuxer: c,
      remuxer: l
    } = this;
    if (!c || !l) return r.executeEnd = ja(), [uw(e)];
    const u = c.flush(o);
    return ry(u) ? u.then(f => (this.flushRemux(s, f, e), s)) : (this.flushRemux(s, u, e), s)
  }
  flushRemux(e, r, n) {
    const {
      audioTrack: i,
      videoTrack: a,
      id3Track: s,
      textTrack: o
    } = r, {
      accurateTimeOffset: c,
      timeOffset: l
    } = this.currentTransmuxState;
    G.log(`[transmuxer.ts]: Flushed fragment ${n.sn}${n.part>-1?" p: "+n.part:""} of level ${n.level}`);
    const u = this.remuxer.remux(i, a, s, o, l, c, !0, this.id);
    e.push({
      remuxResult: u,
      chunkMeta: n
    }), n.transmuxing.executeEnd = ja()
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: r,
      remuxer: n
    } = this;
    !r || !n || (r.resetTimeStamp(e), n.resetTimeStamp(e))
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: r
    } = this;
    !e || !r || (e.resetContiguity(), r.resetNextTimestamp())
  }
  resetInitSegment(e, r, n, i, a) {
    const {
      demuxer: s,
      remuxer: o
    } = this;
    !s || !o || (s.resetInitSegment(e, r, n, i), o.resetInitSegment(e, r, n, a))
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
  }
  transmux(e, r, n, i, a) {
    let s;
    return r && r.method === "SAMPLE-AES" ? s = this.transmuxSampleAes(e, r, n, i, a) : s = this.transmuxUnencrypted(e, n, i, a), s
  }
  transmuxUnencrypted(e, r, n, i) {
    const {
      audioTrack: a,
      videoTrack: s,
      id3Track: o,
      textTrack: c
    } = this.demuxer.demux(e, r, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(a, s, o, c, r, n, !1, this.id),
      chunkMeta: i
    }
  }
  transmuxSampleAes(e, r, n, i, a) {
    return this.demuxer.demuxSampleAes(e, r, n).then(s => ({
      remuxResult: this.remuxer.remux(s.audioTrack, s.videoTrack, s.id3Track, s.textTrack, n, i, !1, this.id),
      chunkMeta: a
    }))
  }
  configureTransmuxer(e) {
    const {
      config: r,
      observer: n,
      typeSupported: i,
      vendor: a
    } = this;
    let s;
    for (let f = 0, d = cw.length; f < d; f++)
      if (cw[f].demux.probe(e)) {
        s = cw[f];
        break
      } if (!s) return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer,
      c = this.remuxer,
      l = s.remux,
      u = s.demux;
    (!c || !(c instanceof l)) && (this.remuxer = new l(n, r, i, a)), (!o || !(o instanceof u)) && (this.demuxer = new u(n, r, i), this.probe = u.probe)
  }
  needsProbing(e, r) {
    return !this.demuxer || !this.remuxer || e || r
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new LO(this.config)), e
  }
}

function fGe(t, e) {
  let r = null;
  return t.byteLength > 0 && e != null && e.key != null && e.iv !== null && e.method != null && (r = e), r
}
const uw = t => ({
  remuxResult: {},
  chunkMeta: t
});

function ry(t) {
  return "then" in t && t.then instanceof Function
}
class dGe {
  constructor(e, r, n, i, a) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = r, this.initSegmentData = n, this.duration = i, this.defaultInitPts = a || null
  }
}
class hGe {
  constructor(e, r, n, i, a, s) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = r, this.accurateTimeOffset = n, this.trackSwitch = i, this.timeOffset = a, this.initSegmentChange = s
  }
}
var rp = {},
  pGe = {
    get exports() {
      return rp
    },
    set exports(t) {
      rp = t
    }
  };
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    r = "~";

  function n() {}
  Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1));

  function i(c, l, u) {
    this.fn = c, this.context = l, this.once = u || !1
  }

  function a(c, l, u, f, d) {
    if (typeof u != "function") throw new TypeError("The listener must be a function");
    var h = new i(u, f || c, d),
      p = r ? r + l : l;
    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], h] : c._events[p].push(h) : (c._events[p] = h, c._eventsCount++), c
  }

  function s(c, l) {
    --c._eventsCount === 0 ? c._events = new n : delete c._events[l]
  }

  function o() {
    this._events = new n, this._eventsCount = 0
  }
  o.prototype.eventNames = function () {
    var l = [],
      u, f;
    if (this._eventsCount === 0) return l;
    for (f in u = this._events) e.call(u, f) && l.push(r ? f.slice(1) : f);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
  }, o.prototype.listeners = function (l) {
    var u = r ? r + l : l,
      f = this._events[u];
    if (!f) return [];
    if (f.fn) return [f.fn];
    for (var d = 0, h = f.length, p = new Array(h); d < h; d++) p[d] = f[d].fn;
    return p
  }, o.prototype.listenerCount = function (l) {
    var u = r ? r + l : l,
      f = this._events[u];
    return f ? f.fn ? 1 : f.length : 0
  }, o.prototype.emit = function (l, u, f, d, h, p) {
    var v = r ? r + l : l;
    if (!this._events[v]) return !1;
    var g = this._events[v],
      m = arguments.length,
      y, x;
    if (g.fn) {
      switch (g.once && this.removeListener(l, g.fn, void 0, !0), m) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, u), !0;
        case 3:
          return g.fn.call(g.context, u, f), !0;
        case 4:
          return g.fn.call(g.context, u, f, d), !0;
        case 5:
          return g.fn.call(g.context, u, f, d, h), !0;
        case 6:
          return g.fn.call(g.context, u, f, d, h, p), !0
      }
      for (x = 1, y = new Array(m - 1); x < m; x++) y[x - 1] = arguments[x];
      g.fn.apply(g.context, y)
    } else {
      var b = g.length,
        _;
      for (x = 0; x < b; x++) switch (g[x].once && this.removeListener(l, g[x].fn, void 0, !0), m) {
        case 1:
          g[x].fn.call(g[x].context);
          break;
        case 2:
          g[x].fn.call(g[x].context, u);
          break;
        case 3:
          g[x].fn.call(g[x].context, u, f);
          break;
        case 4:
          g[x].fn.call(g[x].context, u, f, d);
          break;
        default:
          if (!y)
            for (_ = 1, y = new Array(m - 1); _ < m; _++) y[_ - 1] = arguments[_];
          g[x].fn.apply(g[x].context, y)
      }
    }
    return !0
  }, o.prototype.on = function (l, u, f) {
    return a(this, l, u, f, !1)
  }, o.prototype.once = function (l, u, f) {
    return a(this, l, u, f, !0)
  }, o.prototype.removeListener = function (l, u, f, d) {
    var h = r ? r + l : l;
    if (!this._events[h]) return this;
    if (!u) return s(this, h), this;
    var p = this._events[h];
    if (p.fn) p.fn === u && (!d || p.once) && (!f || p.context === f) && s(this, h);
    else {
      for (var v = 0, g = [], m = p.length; v < m; v++)(p[v].fn !== u || d && !p[v].once || f && p[v].context !== f) && g.push(p[v]);
      g.length ? this._events[h] = g.length === 1 ? g[0] : g : s(this, h)
    }
    return this
  }, o.prototype.removeAllListeners = function (l) {
    var u;
    return l ? (u = r ? r + l : l, this._events[u] && s(this, u)) : (this._events = new n, this._eventsCount = 0), this
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, t.exports = o
})(pGe);
const fw = NO() || {
  isTypeSupported: () => !1
};
class jQ {
  constructor(e, r, n, i) {
    this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
    const a = e.config;
    this.hls = e, this.id = r, this.useWorker = !!a.enableWorker, this.onTransmuxComplete = n, this.onFlush = i;
    const s = (l, u) => {
      u = u || {}, u.frag = this.frag, u.id = this.id, l === $.ERROR && (this.error = u.error), this.hls.trigger(l, u)
    };
    this.observer = new rp, this.observer.on($.FRAG_DECRYPTED, s), this.observer.on($.ERROR, s);
    const o = {
        mp4: fw.isTypeSupported("video/mp4"),
        mpeg: fw.isTypeSupported("audio/mpeg"),
        mp3: fw.isTypeSupported('audio/mp4; codecs="mp3"')
      },
      c = navigator.vendor;
    if (this.useWorker && typeof Worker < "u" && (a.workerPath || Nze())) {
      try {
        a.workerPath ? (G.log(`loading Web Worker ${a.workerPath} for "${r}"`), this.workerContext = Mze(a.workerPath)) : (G.log(`injecting Web Worker for "${r}"`), this.workerContext = Dze()), this.onwmsg = f => this.onWorkerMessage(f);
        const {
          worker: u
        } = this.workerContext;
        u.addEventListener("message", this.onwmsg), u.onerror = f => {
          const d = new Error(`${f.message}  (${f.filename}:${f.lineno})`);
          a.enableWorker = !1, G.warn(`Error in "${r}" Web Worker, fallback to inline`), this.hls.trigger($.ERROR, {
            type: ve.OTHER_ERROR,
            details: q.INTERNAL_EXCEPTION,
            fatal: !1,
            event: "demuxerWorker",
            error: d
          })
        }, u.postMessage({
          cmd: "init",
          typeSupported: o,
          vendor: c,
          id: r,
          config: JSON.stringify(a)
        })
      } catch (u) {
        G.warn(`Error setting up "${r}" Web Worker, fallback to inline`, u), this.resetWorker(), this.error = null, this.transmuxer = new sB(this.observer, o, a, c, r)
      }
      return
    }
    this.transmuxer = new sB(this.observer, o, a, c, r)
  }
  resetWorker() {
    if (this.workerContext) {
      const {
        worker: e,
        objectURL: r
      } = this.workerContext;
      r && self.URL.revokeObjectURL(r), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null
    }
  }
  destroy() {
    if (this.workerContext) this.resetWorker(), this.onwmsg = void 0;
    else {
      const r = this.transmuxer;
      r && (r.destroy(), this.transmuxer = null)
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
  }
  push(e, r, n, i, a, s, o, c, l, u) {
    var f, d;
    l.transmuxing.start = self.performance.now();
    const {
      transmuxer: h
    } = this, p = s ? s.start : a.start, v = a.decryptdata, g = this.frag, m = !(g && a.cc === g.cc), y = !(g && l.level === g.level), x = g ? l.sn - g.sn : -1, b = this.part ? l.part - this.part.index : -1, _ = x === 0 && l.id > 1 && l.id === (g == null ? void 0 : g.stats.chunkCount), S = !y && (x === 1 || x === 0 && (b === 1 || _ && b <= 0)), T = self.performance.now();
    (y || x || a.stats.parsing.start === 0) && (a.stats.parsing.start = T), s && (b || !S) && (s.stats.parsing.start = T);
    const R = !(g && ((f = a.initSegment) == null ? void 0 : f.url) === ((d = g.initSegment) == null ? void 0 : d.url)),
      I = new hGe(m, S, c, y, p, R);
    if (!S || m || R) {
      G.log(`[transmuxer-interface, ${a.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}
        discontinuity: ${m}
        trackSwitch: ${y}
        contiguous: ${S}
        accurateTimeOffset: ${c}
        timeOffset: ${p}
        initSegmentChange: ${R}`);
      const w = new dGe(n, i, r, o, u);
      this.configureTransmuxer(w)
    }
    if (this.frag = a, this.part = s, this.workerContext) this.workerContext.worker.postMessage({
      cmd: "demux",
      data: e,
      decryptdata: v,
      chunkMeta: l,
      state: I
    }, e instanceof ArrayBuffer ? [e] : []);
    else if (h) {
      const w = h.push(e, v, l, I);
      ry(w) ? (h.async = !0, w.then(C => {
        this.handleTransmuxComplete(C)
      }).catch(C => {
        this.transmuxerError(C, l, "transmuxer-interface push error")
      })) : (h.async = !1, this.handleTransmuxComplete(w))
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      transmuxer: r
    } = this;
    if (this.workerContext) this.workerContext.worker.postMessage({
      cmd: "flush",
      chunkMeta: e
    });
    else if (r) {
      let n = r.flush(e);
      ry(n) || r.async ? (ry(n) || (n = Promise.resolve(n)), n.then(a => {
        this.handleFlushResult(a, e)
      }).catch(a => {
        this.transmuxerError(a, e, "transmuxer-interface flush error")
      })) : this.handleFlushResult(n, e)
    }
  }
  transmuxerError(e, r, n) {
    this.hls && (this.error = e, this.hls.trigger($.ERROR, {
      type: ve.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      chunkMeta: r,
      fatal: !1,
      error: e,
      err: e,
      reason: n
    }))
  }
  handleFlushResult(e, r) {
    e.forEach(n => {
      this.handleTransmuxComplete(n)
    }), this.onFlush(r)
  }
  onWorkerMessage(e) {
    const r = e.data,
      n = this.hls;
    switch (r.event) {
      case "init": {
        var i;
        const a = (i = this.workerContext) == null ? void 0 : i.objectURL;
        a && self.URL.revokeObjectURL(a);
        break
      }
      case "transmuxComplete": {
        this.handleTransmuxComplete(r.data);
        break
      }
      case "flush": {
        this.onFlush(r.data);
        break
      }
      case "workerLog":
        G[r.data.logType] && G[r.data.logType](r.data.message);
        break;
      default: {
        r.data = r.data || {}, r.data.frag = this.frag, r.data.id = this.id, n.trigger(r.event, r.data);
        break
      }
    }
  }
  configureTransmuxer(e) {
    const {
      transmuxer: r
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      cmd: "configure",
      config: e
    }) : r && r.configure(e)
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
  }
}
const gGe = 250,
  dw = 2,
  mGe = .1,
  vGe = .05;
class yGe {
  constructor(e, r, n, i) {
    this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = r, this.fragmentTracker = n, this.hls = i
  }
  destroy() {
    this.media = null, this.hls = this.fragmentTracker = null
  }
  poll(e, r) {
    const {
      config: n,
      media: i,
      stalled: a
    } = this;
    if (i === null) return;
    const {
      currentTime: s,
      seeking: o
    } = i, c = this.seeking && !o, l = !this.seeking && o;
    if (this.seeking = o, s !== e) {
      if (this.moved = !0, a !== null) {
        if (this.stallReported) {
          const m = self.performance.now() - a;
          G.warn(`playback not stuck anymore @${s}, after ${Math.round(m)}ms`), this.stallReported = !1
        }
        this.stalled = null, this.nudgeRetry = 0
      }
      return
    }
    if (l || c) {
      this.stalled = null;
      return
    }
    if (i.paused && !o || i.ended || i.playbackRate === 0 || !ct.getBuffered(i).length) return;
    const u = ct.bufferInfo(i, s, 0),
      f = u.len > 0,
      d = u.nextStart || 0;
    if (!f && !d) return;
    if (o) {
      const m = u.len > dw,
        y = !d || r && r.start <= s || d - s > dw && !this.fragmentTracker.getPartialFragment(s);
      if (m || y) return;
      this.moved = !1
    }
    if (!this.moved && this.stalled !== null) {
      var h;
      const m = Math.max(d, u.start || 0) - s,
        y = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
        b = (y == null || (h = y.details) == null ? void 0 : h.live) ? y.details.targetduration * 2 : dw,
        _ = this.fragmentTracker.getPartialFragment(s);
      if (m > 0 && (m <= b || _)) {
        this._trySkipBufferHole(_);
        return
      }
    }
    const p = self.performance.now();
    if (a === null) {
      this.stalled = p;
      return
    }
    const v = p - a;
    if (!o && v >= gGe && (this._reportStall(u), !this.media)) return;
    const g = ct.bufferInfo(i, s, n.maxBufferHole);
    this._tryFixBufferStall(g, v)
  }
  _tryFixBufferStall(e, r) {
    const {
      config: n,
      fragmentTracker: i,
      media: a
    } = this;
    if (a === null) return;
    const s = a.currentTime,
      o = i.getPartialFragment(s);
    o && (this._trySkipBufferHole(o) || !this.media) || (e.len > n.maxBufferHole || e.nextStart && e.nextStart - s < n.maxBufferHole) && r > n.highBufferWatchdogPeriod * 1e3 && (G.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
  }
  _reportStall(e) {
    const {
      hls: r,
      media: n,
      stallReported: i
    } = this;
    if (!i && n) {
      this.stallReported = !0;
      const a = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${JSON.stringify(e)})`);
      G.warn(a.message), r.trigger($.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: a,
        buffer: e.len
      })
    }
  }
  _trySkipBufferHole(e) {
    const {
      config: r,
      hls: n,
      media: i
    } = this;
    if (i === null) return 0;
    const a = i.currentTime,
      s = ct.bufferInfo(i, a, 0),
      o = a < s.start ? s.start : s.nextStart;
    if (o) {
      const c = s.len <= r.maxBufferHole,
        l = s.len > 0 && s.len < 1 && i.readyState < 3,
        u = o - a;
      if (u > 0 && (c || l)) {
        if (u > r.maxBufferHole) {
          const {
            fragmentTracker: d
          } = this;
          let h = !1;
          if (a === 0) {
            const p = d.getAppendedFrag(0, ye.MAIN);
            p && o < p.end && (h = !0)
          }
          if (!h) {
            const p = e || d.getAppendedFrag(a, ye.MAIN);
            if (p) {
              let v = !1,
                g = p.end;
              for (; g < o;) {
                const m = d.getPartialFragment(g);
                if (m) g += m.duration;
                else {
                  v = !0;
                  break
                }
              }
              if (v) return 0
            }
          }
        }
        const f = Math.max(o + vGe, a + mGe);
        if (G.warn(`skipping hole, adjusting currentTime from ${a} to ${f}`), this.moved = !0, this.stalled = null, i.currentTime = f, e && !e.gap) {
          const d = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${f}`);
          n.trigger($.ERROR, {
            type: ve.MEDIA_ERROR,
            details: q.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: d,
            reason: d.message,
            frag: e
          })
        }
        return f
      }
    }
    return 0
  }
  _tryNudgeBuffer() {
    const {
      config: e,
      hls: r,
      media: n,
      nudgeRetry: i
    } = this;
    if (n === null) return;
    const a = n.currentTime;
    if (this.nudgeRetry++, i < e.nudgeMaxRetry) {
      const s = a + (i + 1) * e.nudgeOffset,
        o = new Error(`Nudging 'currentTime' from ${a} to ${s}`);
      G.warn(o.message), n.currentTime = s, r.trigger($.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.BUFFER_NUDGE_ON_STALL,
        error: o,
        fatal: !1
      })
    } else {
      const s = new Error(`Playhead still not moving while enough data buffered @${a} after ${e.nudgeMaxRetry} nudges`);
      G.error(s.message), r.trigger($.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        error: s,
        fatal: !0
      })
    }
  }
}
const xGe = 100;
class bGe extends PO {
  constructor(e, r, n) {
    super(e, r, n, "[stream-controller]", ye.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners()
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.LEVEL_LOADING, this.onLevelLoading, this), e.on($.LEVEL_LOADED, this.onLevelLoaded, this), e.on($.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on($.ERROR, this.onError, this), e.on($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on($.BUFFER_CREATED, this.onBufferCreated, this), e.on($.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.LEVEL_LOADED, this.onLevelLoaded, this), e.off($.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off($.ERROR, this.onError, this), e.off($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off($.BUFFER_CREATED, this.onBufferCreated, this), e.off($.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.onMediaDetaching()
  }
  startLoad(e) {
    if (this.levels) {
      const {
        lastCurrentTime: r,
        hls: n
      } = this;
      if (this.stopLoad(), this.setInterval(xGe), this.level = -1, !this.startFragRequested) {
        let i = n.startLevel;
        i === -1 && (n.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = n.nextAutoLevel), this.level = n.nextLoadLevel = i, this.loadedmetadata = !1
      }
      r > 0 && e === -1 && (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = X.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
    } else this._forceStartLoad = !0, this.state = X.STOPPED
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad()
  }
  doTick() {
    switch (this.state) {
      case X.WAITING_LEVEL: {
        var e;
        const {
          levels: n,
          level: i
        } = this, a = n == null || (e = n[i]) == null ? void 0 : e.details;
        if (a && (!a.live || this.levelLastLoaded === this.level)) {
          if (this.waitForCdnTuneIn(a)) break;
          this.state = X.IDLE;
          break
        }
        break
      }
      case X.FRAG_LOADING_WAITING_RETRY: {
        var r;
        const n = self.performance.now(),
          i = this.retryDate;
        (!i || n >= i || (r = this.media) != null && r.seeking) && (this.resetStartWhenNotLoaded(this.level), this.state = X.IDLE)
      }
      break
    }
    this.state === X.IDLE && this.doTickIdle(), this.onTickEnd()
  }
  onTickEnd() {
    super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: r,
      levels: n,
      media: i
    } = this, {
      config: a,
      nextLoadLevel: s
    } = e;
    if (r === null || !i && (this.startFragRequested || !a.startFragPrefetch) || this.altAudio && this.audioOnly || !(n != null && n[s])) return;
    const o = n[s],
      c = this.getMainFwdBufferInfo();
    if (c === null) return;
    const l = this.getLevelDetails();
    if (l && this._streamEnded(c, l)) {
      const g = {};
      this.altAudio && (g.type = "video"), this.hls.trigger($.BUFFER_EOS, g), this.state = X.ENDED;
      return
    }
    e.loadLevel !== s && e.manualLevel === -1 && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
    const u = o.details;
    if (!u || this.state === X.WAITING_LEVEL || u.live && this.levelLastLoaded !== s) {
      this.level = s, this.state = X.WAITING_LEVEL;
      return
    }
    const f = c.len,
      d = this.getMaxBufferLength(o.maxBitrate);
    if (f >= d) return;
    this.backtrackFragment && this.backtrackFragment.start > c.end && (this.backtrackFragment = null);
    const h = this.backtrackFragment ? this.backtrackFragment.start : c.end;
    let p = this.getNextFragment(h, u);
    if (this.couldBacktrack && !this.fragPrevious && p && p.sn !== "initSegment" && this.fragmentTracker.getState(p) !== Tr.OK) {
      var v;
      const m = ((v = this.backtrackFragment) != null ? v : p).sn - u.startSN,
        y = u.fragments[m - 1];
      y && p.cc === y.cc && (p = y, this.fragmentTracker.removeFragment(y))
    } else this.backtrackFragment && c.len && (this.backtrackFragment = null);
    if (p && this.isLoopLoading(p, h)) {
      if (!p.gap) {
        const m = this.audioOnly && !this.altAudio ? Qe.AUDIO : Qe.VIDEO,
          y = (m === Qe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        y && this.afterBufferFlushed(y, m, ye.MAIN)
      }
      p = this.getNextFragmentLoopLoading(p, u, c, ye.MAIN, d)
    }
    p && (p.initSegment && !p.initSegment.data && !this.bitrateTest && (p = p.initSegment), this.loadFragment(p, o, h))
  }
  loadFragment(e, r, n) {
    const i = this.fragmentTracker.getState(e);
    this.fragCurrent = e, i === Tr.NOT_LOADED ? e.sn === "initSegment" ? this._loadInitSegment(e, r) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, r)) : (this.startFragRequested = !0, super.loadFragment(e, r, n)) : this.clearTrackerIfNeeded(e)
  }
  getAppendedFrag(e) {
    const r = this.fragmentTracker.getAppendedFrag(e, ye.MAIN);
    return r && "fragment" in r ? r.fragment : r
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, ye.MAIN)
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + .5) : null
  }
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
  }
  nextLevelSwitch() {
    const {
      levels: e,
      media: r
    } = this;
    if (r != null && r.readyState) {
      let n;
      const i = this.getAppendedFrag(r.currentTime);
      if (i && i.start > 1 && this.flushMainBuffer(0, i.start - 1), !r.paused && e) {
        const s = this.hls.nextLoadLevel,
          o = e[s],
          c = this.fragLastKbps;
        c && this.fragCurrent ? n = this.fragCurrent.duration * o.maxBitrate / (1e3 * c) + 1 : n = 0
      } else n = 0;
      const a = this.getBufferedFrag(r.currentTime + n);
      if (a) {
        const s = this.followingBufferedFrag(a);
        if (s) {
          this.abortCurrentFrag();
          const o = s.maxStartPTS ? s.maxStartPTS : s.start,
            c = s.duration,
            l = Math.max(a.end, o + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * .5), c * .75));
          this.flushMainBuffer(l, Number.POSITIVE_INFINITY)
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case X.KEY_LOADING:
      case X.FRAG_LOADING:
      case X.FRAG_LOADING_WAITING_RETRY:
      case X.PARSING:
      case X.PARSED:
        this.state = X.IDLE;
        break
    }
    this.nextLoadPosition = this.getLoadPosition()
  }
  flushMainBuffer(e, r) {
    super.flushMainBuffer(e, r, this.altAudio ? "video" : null)
  }
  onMediaAttached(e, r) {
    super.onMediaAttached(e, r);
    const n = r.media;
    this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), n.addEventListener("playing", this.onvplaying), n.addEventListener("seeked", this.onvseeked), this.gapController = new yGe(this.config, n, this.fragmentTracker, this.hls)
  }
  onMediaDetaching() {
    const {
      media: e
    } = this;
    e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching()
  }
  onMediaPlaying() {
    this.tick()
  }
  onMediaSeeked() {
    const e = this.media,
      r = e ? e.currentTime : null;
    ge(r) && this.log(`Media seeked to ${r.toFixed(3)}`);
    const n = this.getMainFwdBufferInfo();
    if (n === null || n.len === 0) {
      this.warn(`Main forward buffer length on "seeked" event ${n?n.len:"empty"})`);
      return
    }
    this.tick()
  }
  onManifestLoading() {
    this.log("Trigger BUFFER_RESET"), this.hls.trigger($.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null, this.backtrackFragment = null
  }
  onManifestParsed(e, r) {
    let n = !1,
      i = !1,
      a;
    r.levels.forEach(s => {
      a = s.audioCodec, a && (a.indexOf("mp4a.40.2") !== -1 && (n = !0), a.indexOf("mp4a.40.5") !== -1 && (i = !0))
    }), this.audioCodecSwitch = n && i && !Pze(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = r.levels, this.startFragRequested = !1
  }
  onLevelLoading(e, r) {
    const {
      levels: n
    } = this;
    if (!n || this.state !== X.IDLE) return;
    const i = n[r.level];
    (!i.details || i.details.live && this.levelLastLoaded !== r.level || this.waitForCdnTuneIn(i.details)) && (this.state = X.WAITING_LEVEL)
  }
  onLevelLoaded(e, r) {
    var n;
    const {
      levels: i
    } = this, a = r.level, s = r.details, o = s.totalduration;
    if (!i) {
      this.warn(`Levels were reset while loading level ${a}`);
      return
    }
    this.log(`Level ${a} loaded [${s.startSN},${s.endSN}], cc [${s.startCC}, ${s.endCC}] duration:${o}`);
    const c = i[a],
      l = this.fragCurrent;
    l && (this.state === X.FRAG_LOADING || this.state === X.FRAG_LOADING_WAITING_RETRY) && (l.level !== r.level || l.urlId !== c.urlId) && l.loader && this.abortCurrentFrag();
    let u = 0;
    if (s.live || (n = c.details) != null && n.live) {
      if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return;
      u = this.alignPlaylists(s, c.details)
    }
    if (c.details = s, this.levelLastLoaded = a, this.hls.trigger($.LEVEL_UPDATED, {
        details: s,
        level: a
      }), this.state === X.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(s)) return;
      this.state = X.IDLE
    }
    this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, u), this.tick()
  }
  _handleFragmentLoadProgress(e) {
    var r;
    const {
      frag: n,
      part: i,
      payload: a
    } = e, {
      levels: s
    } = this;
    if (!s) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
      return
    }
    const o = s[n.level],
      c = o.details;
    if (!c) {
      this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`), this.fragmentTracker.removeFragment(n);
      return
    }
    const l = o.videoCodec,
      u = c.PTSKnown || !c.live,
      f = (r = n.initSegment) == null ? void 0 : r.data,
      d = this._getAudioCodec(o),
      h = this.transmuxer = this.transmuxer || new jQ(this.hls, ye.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
      p = i ? i.index : -1,
      v = p !== -1,
      g = new kO(n.level, n.sn, n.stats.chunkCount, a.byteLength, p, v),
      m = this.initPTS[n.cc];
    h.push(a, f, d, l, n, i, c.totalduration, u, g, m)
  }
  onAudioTrackSwitching(e, r) {
    const n = this.altAudio;
    if (!!!r.url) {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const s = this.fragCurrent;
        s && (this.log("Switching to main audio track, cancel main fragment load"), s.abortRequests(), this.fragmentTracker.removeFragment(s)), this.resetTransmuxer(), this.resetLoadingState()
      } else this.audioOnly && this.resetTransmuxer();
      const a = this.hls;
      n && (a.trigger($.BUFFER_FLUSHING, {
        startOffset: 0,
        endOffset: Number.POSITIVE_INFINITY,
        type: null
      }), this.fragmentTracker.removeAllFragments()), a.trigger($.AUDIO_TRACK_SWITCHED, r)
    }
  }
  onAudioTrackSwitched(e, r) {
    const n = r.id,
      i = !!this.hls.audioTracks[n].url;
    if (i) {
      const a = this.videoBuffer;
      a && this.mediaBuffer !== a && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = a)
    }
    this.altAudio = i, this.tick()
  }
  onBufferCreated(e, r) {
    const n = r.tracks;
    let i, a, s = !1;
    for (const o in n) {
      const c = n[o];
      if (c.id === "main") {
        if (a = o, i = c, o === "video") {
          const l = n[o];
          l && (this.videoBuffer = l.buffer)
        }
      } else s = !0
    }
    s && i ? (this.log(`Alternate track found, use ${a}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media
  }
  onFragBuffered(e, r) {
    const {
      frag: n,
      part: i
    } = r;
    if (n && n.type !== ye.MAIN) return;
    if (this.fragContextChanged(n)) {
      this.warn(`Fragment ${n.sn}${i?" p: "+i.index:""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`), this.state === X.PARSED && (this.state = X.IDLE);
      return
    }
    const a = i ? i.stats : n.stats;
    this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), n.sn !== "initSegment" && (this.fragPrevious = n), this.fragBufferedComplete(n, i)
  }
  onError(e, r) {
    var n;
    if (r.fatal) {
      this.state = X.ERROR;
      return
    }
    switch (r.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ye.MAIN, r);
        break;
      case q.LEVEL_LOAD_ERROR:
      case q.LEVEL_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !r.levelRetry && this.state === X.WAITING_LEVEL && ((n = r.context) == null ? void 0 : n.type) === ze.LEVEL && (this.state = X.IDLE);
        break;
      case q.BUFFER_FULL_ERROR:
        if (!r.parent || r.parent !== "main") return;
        this.reduceLengthAndFlushBuffer(r) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(r);
        break
    }
  }
  checkBuffer() {
    const {
      media: e,
      gapController: r
    } = this;
    if (!(!e || !r || !e.readyState)) {
      if (this.loadedmetadata || !ct.getBuffered(e).length) {
        const n = this.state !== X.IDLE ? this.fragCurrent : null;
        r.poll(this.lastCurrentTime, n)
      }
      this.lastCurrentTime = e.currentTime
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = X.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
  }
  onBufferFlushed(e, {
    type: r
  }) {
    if (r !== Qe.AUDIO || this.audioOnly && !this.altAudio) {
      const n = (r === Qe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      this.afterBufferFlushed(n, r, ye.MAIN)
    }
  }
  onLevelsUpdated(e, r) {
    this.levels = r.levels
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap
  }
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e) return;
    const r = e.currentTime;
    let n = this.startPosition;
    if (n >= 0 && r < n) {
      if (e.seeking) {
        this.log(`could not seek to ${n}, already seeking at ${r}`);
        return
      }
      const i = ct.getBuffered(e),
        s = (i.length ? i.start(0) : 0) - n;
      s > 0 && (s < this.config.maxBufferHole || s < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${s} to match buffer start`), n += s, this.startPosition = n), this.log(`seek to target start position ${n} from current time ${r}`), e.currentTime = n
    }
  }
  _getAudioCodec(e) {
    let r = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && r && (this.log("Swapping audio codec"), r.indexOf("mp4a.40.5") !== -1 ? r = "mp4a.40.2" : r = "mp4a.40.5"), r
  }
  _loadBitrateTestFrag(e, r) {
    e.bitrateTest = !0, this._doFragLoad(e, r).then(n => {
      const {
        hls: i
      } = this;
      if (!n || this.fragContextChanged(e)) return;
      r.fragmentError = 0, this.state = X.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const a = e.stats;
      a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger($.FRAG_LOADED, n), e.bitrateTest = !1
    })
  }
  _handleTransmuxComplete(e) {
    var r;
    const n = "main",
      {
        hls: i
      } = this,
      {
        remuxResult: a,
        chunkMeta: s
      } = e,
      o = this.getCurrentContext(s);
    if (!o) {
      this.resetWhenMissingContext(s);
      return
    }
    const {
      frag: c,
      part: l,
      level: u
    } = o, {
      video: f,
      text: d,
      id3: h,
      initSegment: p
    } = a, {
      details: v
    } = u, g = this.altAudio ? void 0 : a.audio;
    if (this.fragContextChanged(c)) {
      this.fragmentTracker.removeFragment(c);
      return
    }
    if (this.state = X.PARSING, p) {
      p.tracks && (this._bufferInitSegment(u, p.tracks, c, s), i.trigger($.FRAG_PARSING_INIT_SEGMENT, {
        frag: c,
        id: n,
        tracks: p.tracks
      }));
      const m = p.initPTS,
        y = p.timescale;
      ge(m) && (this.initPTS[c.cc] = {
        baseTime: m,
        timescale: y
      }, i.trigger($.INIT_PTS_FOUND, {
        frag: c,
        id: n,
        initPTS: m,
        timescale: y
      }))
    }
    if (f && a.independent !== !1) {
      if (v) {
        const {
          startPTS: m,
          endPTS: y,
          startDTS: x,
          endDTS: b
        } = f;
        if (l) l.elementaryStreams[f.type] = {
          startPTS: m,
          endPTS: y,
          startDTS: x,
          endDTS: b
        };
        else if (f.firstKeyFrame && f.independent && s.id === 1 && (this.couldBacktrack = !0), f.dropped && f.independent) {
          const _ = this.getMainFwdBufferInfo(),
            S = (_ ? _.end : this.getLoadPosition()) + this.config.maxBufferHole,
            T = f.firstKeyFramePTS ? f.firstKeyFramePTS : m;
          if (S < T - this.config.maxBufferHole) {
            this.backtrack(c);
            return
          }
          c.setElementaryStreamInfo(f.type, c.start, y, c.start, b, !0)
        }
        c.setElementaryStreamInfo(f.type, m, y, x, b), this.backtrackFragment && (this.backtrackFragment = c), this.bufferFragmentData(f, c, l, s)
      }
    } else if (a.independent === !1) {
      this.backtrack(c);
      return
    }
    if (g) {
      const {
        startPTS: m,
        endPTS: y,
        startDTS: x,
        endDTS: b
      } = g;
      l && (l.elementaryStreams[Qe.AUDIO] = {
        startPTS: m,
        endPTS: y,
        startDTS: x,
        endDTS: b
      }), c.setElementaryStreamInfo(Qe.AUDIO, m, y, x, b), this.bufferFragmentData(g, c, l, s)
    }
    if (v && h != null && (r = h.samples) != null && r.length) {
      const m = {
        id: n,
        frag: c,
        details: v,
        samples: h.samples
      };
      i.trigger($.FRAG_PARSING_METADATA, m)
    }
    if (v && d) {
      const m = {
        id: n,
        frag: c,
        details: v,
        samples: d.samples
      };
      i.trigger($.FRAG_PARSING_USERDATA, m)
    }
  }
  _bufferInitSegment(e, r, n, i) {
    if (this.state !== X.PARSING) return;
    this.audioOnly = !!r.audio && !r.video, this.altAudio && !this.audioOnly && delete r.audio;
    const {
      audio: a,
      video: s,
      audiovideo: o
    } = r;
    if (a) {
      let c = e.audioCodec;
      const l = navigator.userAgent.toLowerCase();
      this.audioCodecSwitch && (c && (c.indexOf("mp4a.40.5") !== -1 ? c = "mp4a.40.2" : c = "mp4a.40.5"), a.metadata.channelCount !== 1 && l.indexOf("firefox") === -1 && (c = "mp4a.40.5")), l.indexOf("android") !== -1 && a.container !== "audio/mpeg" && (c = "mp4a.40.2", this.log(`Android: force audio codec to ${c}`)), e.audioCodec && e.audioCodec !== c && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${c}"`), a.levelCodec = c, a.id = "main", this.log(`Init audio buffer, container:${a.container}, codecs[selected/level/parsed]=[${c||""}/${e.audioCodec||""}/${a.codec}]`)
    }
    s && (s.levelCodec = e.videoCodec, s.id = "main", this.log(`Init video buffer, container:${s.container}, codecs[level/parsed]=[${e.videoCodec||""}/${s.codec}]`)), o && this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.attrs.CODECS||""}/${o.codec}]`), this.hls.trigger($.BUFFER_CODECS, r), Object.keys(r).forEach(c => {
      const u = r[c].initSegment;
      u != null && u.byteLength && this.hls.trigger($.BUFFER_APPENDING, {
        type: c,
        data: u,
        frag: n,
        part: null,
        chunkMeta: i,
        parent: n.type
      })
    }), this.tick()
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, ye.MAIN)
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = X.IDLE
  }
  checkFragmentChanged() {
    const e = this.media;
    let r = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const n = e.currentTime;
      if (ct.isBuffered(e, n) ? r = this.getAppendedFrag(n) : ct.isBuffered(e, n + .1) && (r = this.getAppendedFrag(n + .1)), r) {
        this.backtrackFragment = null;
        const i = this.fragPlaying,
          a = r.level;
        (!i || r.sn !== i.sn || i.level !== a || r.urlId !== i.urlId) && (this.fragPlaying = r, this.hls.trigger($.FRAG_CHANGED, {
          frag: r
        }), (!i || i.level !== a) && this.hls.trigger($.LEVEL_SWITCHED, {
          level: a
        }))
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1
  }
  get currentFrag() {
    const e = this.media;
    return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
  }
  get currentProgramDateTime() {
    const e = this.media;
    if (e) {
      const r = e.currentTime,
        n = this.currentFrag;
      if (n && ge(r) && ge(n.programDateTime)) {
        const i = n.programDateTime + (r - n.start) * 1e3;
        return new Date(i)
      }
    }
    return null
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null
  }
  get forceStartLoad() {
    return this._forceStartLoad
  }
}
class Kc {
  constructor(e, r = 0, n = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = r, this.totalWeight_ = n
  }
  sample(e, r) {
    const n = Math.pow(this.alpha_, e);
    this.estimate_ = r * (1 - n) + n * this.estimate_, this.totalWeight_ += e
  }
  getTotalWeight() {
    return this.totalWeight_
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e) return this.estimate_ / e
    }
    return this.estimate_
  }
}
class EGe {
  constructor(e, r, n, i = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = n, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Kc(e), this.fast_ = new Kc(r), this.defaultTTFB_ = i, this.ttfb_ = new Kc(e)
  }
  update(e, r) {
    const {
      slow_: n,
      fast_: i,
      ttfb_: a
    } = this;
    n.halfLife !== e && (this.slow_ = new Kc(e, n.getEstimate(), n.getTotalWeight())), i.halfLife !== r && (this.fast_ = new Kc(r, i.getEstimate(), i.getTotalWeight())), a.halfLife !== e && (this.ttfb_ = new Kc(e, a.getEstimate(), a.getTotalWeight()))
  }
  sample(e, r) {
    e = Math.max(e, this.minDelayMs_);
    const n = 8 * r,
      i = e / 1e3,
      a = n / i;
    this.fast_.sample(i, a), this.slow_.sample(i, a)
  }
  sampleTTFB(e) {
    const r = e / 1e3,
      n = Math.sqrt(2) * Math.exp(-Math.pow(r, 2) / 2);
    this.ttfb_.sample(n, Math.max(e, 5))
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
  }
  destroy() {}
}
class SGe {
  constructor(e) {
    this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = -1, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e;
    const r = e.config;
    this.bwEstimator = new EGe(r.abrEwmaSlowVoD, r.abrEwmaFastVoD, r.abrEwmaDefaultEstimate), this.registerListeners()
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.FRAG_LOADING, this.onFragLoading, this), e.on($.FRAG_LOADED, this.onFragLoaded, this), e.on($.FRAG_BUFFERED, this.onFragBuffered, this), e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on($.LEVEL_LOADED, this.onLevelLoaded, this)
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.FRAG_LOADING, this.onFragLoading, this), e.off($.FRAG_LOADED, this.onFragLoaded, this), e.off($.FRAG_BUFFERED, this.onFragBuffered, this), e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off($.LEVEL_LOADED, this.onLevelLoaded, this)
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
  }
  onFragLoading(e, r) {
    var n;
    const i = r.frag;
    this.ignoreFragment(i) || (this.fragCurrent = i, this.partCurrent = (n = r.part) != null ? n : null, this.clearTimer(), this.timer = self.setInterval(this.onCheck, 100))
  }
  onLevelSwitching(e, r) {
    this.clearTimer()
  }
  getTimeToLoadFrag(e, r, n, i) {
    const a = e + n / r,
      s = i ? this.lastLevelLoadSec : 0;
    return a + s
  }
  onLevelLoaded(e, r) {
    const n = this.hls.config,
      {
        total: i,
        bwEstimate: a
      } = r.stats;
    ge(i) && ge(a) && (this.lastLevelLoadSec = 8 * i / a), r.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD)
  }
  _abandonRulesCheck() {
    const {
      fragCurrent: e,
      partCurrent: r,
      hls: n
    } = this, {
      autoLevelEnabled: i,
      media: a
    } = n;
    if (!e || !a) return;
    const s = performance.now(),
      o = r ? r.stats : e.stats,
      c = r ? r.duration : e.duration,
      l = s - o.loading.start;
    if (o.aborted || o.loaded && o.loaded === o.total || e.level === 0) {
      this.clearTimer(), this._nextAutoLevel = -1;
      return
    }
    if (!i || a.paused || !a.playbackRate || !a.readyState) return;
    const u = n.mainForwardBufferInfo;
    if (u === null) return;
    const f = this.bwEstimator.getEstimateTTFB(),
      d = Math.abs(a.playbackRate);
    if (l <= Math.max(f, 1e3 * (c / (d * 2)))) return;
    const h = u.len / d;
    if (h >= 2 * c / d) return;
    const p = o.loading.first ? o.loading.first - o.loading.start : -1,
      v = o.loaded && p > -1,
      g = this.bwEstimator.getEstimate(),
      {
        levels: m,
        minAutoLevel: y
      } = n,
      x = m[e.level],
      b = o.total || Math.max(o.loaded, Math.round(c * x.maxBitrate / 8));
    let _ = l - p;
    _ < 1 && v && (_ = Math.min(l, o.loaded * 8 / g));
    const S = v ? o.loaded * 1e3 / _ : 0,
      T = S ? (b - o.loaded) / S : b * 8 / g + f / 1e3;
    if (T <= h) return;
    const R = S ? S * 8 : g;
    let I = Number.POSITIVE_INFINITY,
      w;
    for (w = e.level - 1; w > y; w--) {
      const C = m[w].maxBitrate;
      if (I = this.getTimeToLoadFrag(f / 1e3, R, c * C, !m[w].details), I < h) break
    }
    I >= T || I > c * 10 || (n.nextLoadLevel = w, v ? this.bwEstimator.sample(l - Math.min(f, p), o.loaded) : this.bwEstimator.sampleTTFB(l), this.clearTimer(), G.warn(`[abr] Fragment ${e.sn}${r?" part "+r.index:""} of level ${e.level} is loading too slowly;
      Time to underbuffer: ${h.toFixed(3)} s
      Estimated load time for current fragment: ${T.toFixed(3)} s
      Estimated load time for down switch fragment: ${I.toFixed(3)} s
      TTFB estimate: ${p}
      Current BW estimate: ${ge(g)?(g/1024).toFixed(3):"Unknown"} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate()/1024).toFixed(3)} Kb/s
      Aborting and switching to level ${w}`), e.loader && (this.fragCurrent = this.partCurrent = null, e.abortRequests()), n.trigger($.FRAG_LOAD_EMERGENCY_ABORTED, {
      frag: e,
      part: r,
      stats: o
    }))
  }
  onFragLoaded(e, {
    frag: r,
    part: n
  }) {
    const i = n ? n.stats : r.stats;
    if (r.type === ye.MAIN && this.bwEstimator.sampleTTFB(i.loading.first - i.loading.start), !this.ignoreFragment(r)) {
      if (this.clearTimer(), this.lastLoadedFragLevel = r.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
        const a = n ? n.duration : r.duration,
          s = this.hls.levels[r.level],
          o = (s.loaded ? s.loaded.bytes : 0) + i.loaded,
          c = (s.loaded ? s.loaded.duration : 0) + a;
        s.loaded = {
          bytes: o,
          duration: c
        }, s.realBitrate = Math.round(8 * o / c)
      }
      if (r.bitrateTest) {
        const a = {
          stats: i,
          frag: r,
          part: n,
          id: r.type
        };
        this.onFragBuffered($.FRAG_BUFFERED, a), r.bitrateTest = !1
      }
    }
  }
  onFragBuffered(e, r) {
    const {
      frag: n,
      part: i
    } = r, a = i != null && i.stats.loaded ? i.stats : n.stats;
    if (a.aborted || this.ignoreFragment(n)) return;
    const s = a.parsing.end - a.loading.start - Math.min(a.loading.first - a.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(s, a.loaded), a.bwEstimate = this.bwEstimator.getEstimate(), n.bitrateTest ? this.bitrateTestDelay = s / 1e3 : this.bitrateTestDelay = 0
  }
  ignoreFragment(e) {
    return e.type !== ye.MAIN || e.sn === "initSegment"
  }
  clearTimer() {
    self.clearInterval(this.timer)
  }
  get nextAutoLevel() {
    const e = this._nextAutoLevel,
      r = this.bwEstimator;
    if (e !== -1 && !r.canEstimate()) return e;
    let n = this.getNextABRAutoLevel();
    if (e !== -1) {
      const i = this.hls.levels;
      if (i.length > Math.max(e, n) && i[e].loadError <= i[n].loadError) return e
    }
    return e !== -1 && (n = Math.min(e, n)), n
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: r,
      hls: n
    } = this, {
      maxAutoLevel: i,
      config: a,
      minAutoLevel: s,
      media: o
    } = n, c = r ? r.duration : e ? e.duration : 0, l = o && o.playbackRate !== 0 ? Math.abs(o.playbackRate) : 1, u = this.bwEstimator ? this.bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate, f = n.mainForwardBufferInfo, d = (f ? f.len : 0) / l;
    let h = this.findBestLevel(u, s, i, d, a.abrBandWidthFactor, a.abrBandWidthUpFactor);
    if (h >= 0) return h;
    G.trace(`[abr] ${d?"rebuffering expected":"buffer is empty"}, finding optimal quality level`);
    let p = c ? Math.min(c, a.maxStarvationDelay) : a.maxStarvationDelay,
      v = a.abrBandWidthFactor,
      g = a.abrBandWidthUpFactor;
    if (!d) {
      const m = this.bitrateTestDelay;
      m && (p = (c ? Math.min(c, a.maxLoadingDelay) : a.maxLoadingDelay) - m, G.trace(`[abr] bitrate test took ${Math.round(1e3*m)}ms, set first fragment max fetchDuration to ${Math.round(1e3*p)} ms`), v = g = 1)
    }
    return h = this.findBestLevel(u, s, i, d + p, v, g), Math.max(h, 0)
  }
  findBestLevel(e, r, n, i, a, s) {
    var o;
    const {
      fragCurrent: c,
      partCurrent: l,
      lastLoadedFragLevel: u
    } = this, {
      levels: f
    } = this.hls, d = f[u], h = !!(d != null && (o = d.details) != null && o.live), p = d == null ? void 0 : d.codecSet, v = l ? l.duration : c ? c.duration : 0, g = this.bwEstimator.getEstimateTTFB() / 1e3;
    let m = r,
      y = -1;
    for (let x = n; x >= r; x--) {
      const b = f[x];
      if (!b || p && b.codecSet !== p) {
        b && (m = Math.min(x, m), y = Math.max(x, y));
        continue
      }
      y !== -1 && G.trace(`[abr] Skipped level(s) ${m}-${y} with CODECS:"${f[y].attrs.CODECS}"; not compatible with "${d.attrs.CODECS}"`);
      const _ = b.details,
        S = (l ? _ == null ? void 0 : _.partTarget : _ == null ? void 0 : _.averagetargetduration) || v;
      let T;
      x <= u ? T = a * e : T = s * e;
      const R = f[x].maxBitrate,
        I = this.getTimeToLoadFrag(g, T, R * S, _ === void 0);
      if (G.trace(`[abr] level:${x} adjustedbw-bitrate:${Math.round(T-R)} avgDuration:${S.toFixed(1)} maxFetchDuration:${i.toFixed(1)} fetchDuration:${I.toFixed(1)}`), T > R && (I === 0 || !ge(I) || h && !this.bitrateTestDelay || I < i)) return x
    }
    return -1
  }
  set nextAutoLevel(e) {
    this._nextAutoLevel = e
  }
}
class HQ {
  constructor() {
    this.chunks = [], this.dataLength = 0
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length
  }
  flush() {
    const {
      chunks: e,
      dataLength: r
    } = this;
    let n;
    if (e.length) e.length === 1 ? n = e[0] : n = _Ge(e, r);
    else return new Uint8Array(0);
    return this.reset(), n
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0
  }
}

function _Ge(t, e) {
  const r = new Uint8Array(e);
  let n = 0;
  for (let i = 0; i < t.length; i++) {
    const a = t[i];
    r.set(a, n), n += a.length
  }
  return r
}
const oB = 100;
class TGe extends PO {
  constructor(e, r, n) {
    super(e, r, n, "[audio-stream-controller]", ye.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners()
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.LEVEL_LOADED, this.onLevelLoaded, this), e.on($.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on($.ERROR, this.onError, this), e.on($.BUFFER_RESET, this.onBufferReset, this), e.on($.BUFFER_CREATED, this.onBufferCreated, this), e.on($.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on($.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.LEVEL_LOADED, this.onLevelLoaded, this), e.off($.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off($.ERROR, this.onError, this), e.off($.BUFFER_RESET, this.onBufferReset, this), e.off($.BUFFER_CREATED, this.onBufferCreated, this), e.off($.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off($.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  onInitPtsFound(e, {
    frag: r,
    id: n,
    initPTS: i,
    timescale: a
  }) {
    if (n === "main") {
      const s = r.cc;
      this.initPTS[r.cc] = {
        baseTime: i,
        timescale: a
      }, this.log(`InitPTS for cc: ${s} found from main: ${i}`), this.videoTrackCC = s, this.state === X.WAITING_INIT_PTS && this.tick()
    }
  }
  startLoad(e) {
    if (!this.levels) {
      this.startPosition = e, this.state = X.STOPPED;
      return
    }
    const r = this.lastCurrentTime;
    this.stopLoad(), this.setInterval(oB), r > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = X.IDLE) : (this.loadedmetadata = !1, this.state = X.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
  }
  doTick() {
    switch (this.state) {
      case X.IDLE:
        this.doTickIdle();
        break;
      case X.WAITING_TRACK: {
        var e;
        const {
          levels: n,
          trackId: i
        } = this, a = n == null || (e = n[i]) == null ? void 0 : e.details;
        if (a) {
          if (this.waitForCdnTuneIn(a)) break;
          this.state = X.WAITING_INIT_PTS
        }
        break
      }
      case X.FRAG_LOADING_WAITING_RETRY: {
        var r;
        const n = performance.now(),
          i = this.retryDate;
        (!i || n >= i || (r = this.media) != null && r.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = X.IDLE);
        break
      }
      case X.WAITING_INIT_PTS: {
        const n = this.waitingData;
        if (n) {
          const {
            frag: i,
            part: a,
            cache: s,
            complete: o
          } = n;
          if (this.initPTS[i.cc] !== void 0) {
            this.waitingData = null, this.waitingVideoCC = -1, this.state = X.FRAG_LOADING;
            const c = s.flush(),
              l = {
                frag: i,
                part: a,
                payload: c,
                networkDetails: null
              };
            this._handleFragmentLoadProgress(l), o && super._handleFragmentLoadComplete(l)
          } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${i.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment();
          else {
            const c = this.getLoadPosition(),
              l = ct.bufferInfo(this.mediaBuffer, c, this.config.maxBufferHole);
            WA(l.end, this.config.maxFragLookUpTolerance, i) < 0 && (this.log(`Waiting fragment cc (${i.cc}) @ ${i.start} cancelled because another fragment at ${l.end} is needed`), this.clearWaitingFragment())
          }
        } else this.state = X.IDLE
      }
    }
    this.onTickEnd()
  }
  clearWaitingFragment() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = X.IDLE)
  }
  resetLoadingState() {
    this.clearWaitingFragment(), super.resetLoadingState()
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime)
  }
  doTickIdle() {
    const {
      hls: e,
      levels: r,
      media: n,
      trackId: i
    } = this, a = e.config;
    if (!(r != null && r[i]) || !n && (this.startFragRequested || !a.startFragPrefetch)) return;
    const s = r[i],
      o = s.details;
    if (!o || o.live && this.levelLastLoaded !== i || this.waitForCdnTuneIn(o)) {
      this.state = X.WAITING_TRACK;
      return
    }
    const c = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && c && (this.bufferFlushed = !1, this.afterBufferFlushed(c, Qe.AUDIO, ye.AUDIO));
    const l = this.getFwdBufferInfo(c, ye.AUDIO);
    if (l === null) return;
    const {
      bufferedTrack: u,
      switchingTrack: f
    } = this;
    if (!f && this._streamEnded(l, o)) {
      e.trigger($.BUFFER_EOS, {
        type: "audio"
      }), this.state = X.ENDED;
      return
    }
    const d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, ye.MAIN),
      h = l.len,
      p = this.getMaxBufferLength(d == null ? void 0 : d.len);
    if (h >= p && !f) return;
    const g = o.fragments[0].start;
    let m = l.end;
    if (f && n) {
      const _ = this.getLoadPosition();
      u && f.attrs !== u.attrs && (m = _), o.PTSKnown && _ < g && (l.end > g || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), n.currentTime = g + .05)
    }
    let y = this.getNextFragment(m, o),
      x = !1;
    if (y && this.isLoopLoading(y, m) && (x = !!y.gap, y = this.getNextFragmentLoopLoading(y, o, l, ye.MAIN, p)), !y) {
      this.bufferFlushed = !0;
      return
    }
    const b = d && y.start > d.end + o.targetduration;
    if (b || !(d != null && d.len) && l.len) {
      const _ = this.fragmentTracker.getBufferedFrag(y.start, ye.MAIN);
      if (_ === null || (x || (x = !!_.gap || !!b && d.len === 0), b && !x || x && l.nextStart && l.nextStart < _.end)) return
    }
    this.loadFragment(y, s, m)
  }
  getMaxBufferLength(e) {
    const r = super.getMaxBufferLength();
    return e ? Math.min(Math.max(r, e), this.config.maxMaxBufferLength) : r
  }
  onMediaDetaching() {
    this.videoBuffer = null, super.onMediaDetaching()
  }
  onAudioTracksUpdated(e, {
    audioTracks: r
  }) {
    this.resetTransmuxer(), this.levels = r.map(n => new ep(n))
  }
  onAudioTrackSwitching(e, r) {
    const n = !!r.url;
    this.trackId = r.id;
    const {
      fragCurrent: i
    } = this;
    i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), n ? this.setInterval(oB) : this.resetTransmuxer(), n ? (this.switchingTrack = r, this.state = X.IDLE) : (this.switchingTrack = null, this.bufferedTrack = r, this.state = X.STOPPED), this.tick()
  }
  onManifestLoading() {
    this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1, this.bufferedTrack = null, this.switchingTrack = null
  }
  onLevelLoaded(e, r) {
    this.mainDetails = r.details, this.cachedTrackLoadedData !== null && (this.hls.trigger($.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
  }
  onAudioTrackLoaded(e, r) {
    var n;
    if (this.mainDetails == null) {
      this.cachedTrackLoadedData = r;
      return
    }
    const {
      levels: i
    } = this, {
      details: a,
      id: s
    } = r;
    if (!i) {
      this.warn(`Audio tracks were reset while loading level ${s}`);
      return
    }
    this.log(`Track ${s} loaded [${a.startSN},${a.endSN}],duration:${a.totalduration}`);
    const o = i[s];
    let c = 0;
    if (a.live || (n = o.details) != null && n.live) {
      const l = this.mainDetails;
      if (a.fragments[0] || (a.deltaUpdateFailed = !0), a.deltaUpdateFailed || !l) return;
      !o.details && a.hasProgramDateTime && l.hasProgramDateTime ? (AQ(a, l), c = a.fragments[0].start) : c = this.alignPlaylists(a, o.details)
    }
    o.details = a, this.levelLastLoaded = s, !this.startFragRequested && (this.mainDetails || !a.live) && this.setStartPosition(o.details, c), this.state === X.WAITING_TRACK && !this.waitForCdnTuneIn(a) && (this.state = X.IDLE), this.tick()
  }
  _handleFragmentLoadProgress(e) {
    var r;
    const {
      frag: n,
      part: i,
      payload: a
    } = e, {
      config: s,
      trackId: o,
      levels: c
    } = this;
    if (!c) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
      return
    }
    const l = c[o];
    if (!l) {
      this.warn("Audio track is undefined on fragment load progress");
      return
    }
    const u = l.details;
    if (!u) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(n.start);
      return
    }
    const f = s.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
    let d = this.transmuxer;
    d || (d = this.transmuxer = new jQ(this.hls, ye.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const h = this.initPTS[n.cc],
      p = (r = n.initSegment) == null ? void 0 : r.data;
    if (h !== void 0) {
      const g = i ? i.index : -1,
        m = g !== -1,
        y = new kO(n.level, n.sn, n.stats.chunkCount, a.byteLength, g, m);
      d.push(a, p, f, "", n, i, u.totalduration, !1, y, h)
    } else {
      this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${u.startSN} ,${u.endSN}],track ${o}`);
      const {
        cache: v
      } = this.waitingData = this.waitingData || {
        frag: n,
        part: i,
        cache: new HQ,
        complete: !1
      };
      v.push(new Uint8Array(a)), this.waitingVideoCC = this.videoTrackCC, this.state = X.WAITING_INIT_PTS
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return
    }
    super._handleFragmentLoadComplete(e)
  }
  onBufferReset() {
    this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
  }
  onBufferCreated(e, r) {
    const n = r.tracks.audio;
    n && (this.mediaBuffer = n.buffer || null), r.tracks.video && (this.videoBuffer = r.tracks.video.buffer || null)
  }
  onFragBuffered(e, r) {
    const {
      frag: n,
      part: i
    } = r;
    if (n.type !== ye.AUDIO) {
      if (!this.loadedmetadata && n.type === ye.MAIN) {
        var a;
        (a = this.videoBuffer || this.media) != null && a.buffered.length && (this.loadedmetadata = !0)
      }
      return
    }
    if (this.fragContextChanged(n)) {
      this.warn(`Fragment ${n.sn}${i?" p: "+i.index:""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack?this.switchingTrack.name:"false"}`);
      return
    }
    if (n.sn !== "initSegment") {
      this.fragPrevious = n;
      const s = this.switchingTrack;
      s && (this.bufferedTrack = s, this.switchingTrack = null, this.hls.trigger($.AUDIO_TRACK_SWITCHED, an({}, s)))
    }
    this.fragBufferedComplete(n, i)
  }
  onError(e, r) {
    var n;
    if (r.fatal) {
      this.state = X.ERROR;
      return
    }
    switch (r.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ye.AUDIO, r);
        break;
      case q.AUDIO_TRACK_LOAD_ERROR:
      case q.AUDIO_TRACK_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !r.levelRetry && this.state === X.WAITING_TRACK && ((n = r.context) == null ? void 0 : n.type) === ze.AUDIO_TRACK && (this.state = X.IDLE);
        break;
      case q.BUFFER_FULL_ERROR:
        if (!r.parent || r.parent !== "audio") return;
        this.reduceLengthAndFlushBuffer(r) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(r);
        break
    }
  }
  onBufferFlushed(e, {
    type: r
  }) {
    r === Qe.AUDIO && (this.bufferFlushed = !0, this.state === X.ENDED && (this.state = X.IDLE))
  }
  _handleTransmuxComplete(e) {
    var r;
    const n = "audio",
      {
        hls: i
      } = this,
      {
        remuxResult: a,
        chunkMeta: s
      } = e,
      o = this.getCurrentContext(s);
    if (!o) {
      this.resetWhenMissingContext(s);
      return
    }
    const {
      frag: c,
      part: l,
      level: u
    } = o, {
      details: f
    } = u, {
      audio: d,
      text: h,
      id3: p,
      initSegment: v
    } = a;
    if (this.fragContextChanged(c) || !f) {
      this.fragmentTracker.removeFragment(c);
      return
    }
    if (this.state = X.PARSING, this.switchingTrack && d && this.completeAudioSwitch(this.switchingTrack), v != null && v.tracks && (this._bufferInitSegment(v.tracks, c, s), i.trigger($.FRAG_PARSING_INIT_SEGMENT, {
        frag: c,
        id: n,
        tracks: v.tracks
      })), d) {
      const {
        startPTS: g,
        endPTS: m,
        startDTS: y,
        endDTS: x
      } = d;
      l && (l.elementaryStreams[Qe.AUDIO] = {
        startPTS: g,
        endPTS: m,
        startDTS: y,
        endDTS: x
      }), c.setElementaryStreamInfo(Qe.AUDIO, g, m, y, x), this.bufferFragmentData(d, c, l, s)
    }
    if (p != null && (r = p.samples) != null && r.length) {
      const g = Nt({
        id: n,
        frag: c,
        details: f
      }, p);
      i.trigger($.FRAG_PARSING_METADATA, g)
    }
    if (h) {
      const g = Nt({
        id: n,
        frag: c,
        details: f
      }, h);
      i.trigger($.FRAG_PARSING_USERDATA, g)
    }
  }
  _bufferInitSegment(e, r, n) {
    if (this.state !== X.PARSING) return;
    e.video && delete e.video;
    const i = e.audio;
    if (!i) return;
    i.levelCodec = i.codec, i.id = "audio", this.log(`Init audio buffer, container:${i.container}, codecs[parsed]=[${i.codec}]`), this.hls.trigger($.BUFFER_CODECS, e);
    const a = i.initSegment;
    if (a != null && a.byteLength) {
      const s = {
        type: "audio",
        frag: r,
        part: null,
        chunkMeta: n,
        parent: r.type,
        data: a
      };
      this.hls.trigger($.BUFFER_APPENDING, s)
    }
    this.tick()
  }
  loadFragment(e, r, n) {
    const i = this.fragmentTracker.getState(e);
    if (this.fragCurrent = e, this.switchingTrack || i === Tr.NOT_LOADED || i === Tr.PARTIAL) {
      var a;
      e.sn === "initSegment" ? this._loadInitSegment(e, r) : (a = r.details) != null && a.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = X.WAITING_INIT_PTS) : (this.startFragRequested = !0, super.loadFragment(e, r, n))
    } else this.clearTrackerIfNeeded(e)
  }
  completeAudioSwitch(e) {
    const {
      hls: r,
      media: n,
      bufferedTrack: i
    } = this, a = i == null ? void 0 : i.attrs, s = e.attrs;
    n && a && (a.CHANNELS !== s.CHANNELS || a.NAME !== s.NAME || a.LANGUAGE !== s.LANGUAGE) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")), this.bufferedTrack = e, this.switchingTrack = null, r.trigger($.AUDIO_TRACK_SWITCHED, an({}, e))
  }
}
class wGe extends CO {
  constructor(e) {
    super(e, "[audio-track-controller]"), this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.LEVEL_LOADING, this.onLevelLoading, this), e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on($.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.LEVEL_LOADING, this.onLevelLoading, this), e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off($.ERROR, this.onError, this)
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
  }
  onManifestLoading() {
    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
  }
  onManifestParsed(e, r) {
    this.tracks = r.audioTracks || []
  }
  onAudioTrackLoaded(e, r) {
    const {
      id: n,
      groupId: i,
      details: a
    } = r, s = this.tracksInGroup[n];
    if (!s || s.groupId !== i) {
      this.warn(`Track with id:${n} and group:${i} not found in active group ${s.groupId}`);
      return
    }
    const o = s.details;
    s.details = r.details, this.log(`audio-track ${n} "${s.name}" lang:${s.lang} group:${i} loaded [${a.startSN}-${a.endSN}]`), n === this.trackId && this.playlistLoaded(n, r, o)
  }
  onLevelLoading(e, r) {
    this.switchLevel(r.level)
  }
  onLevelSwitching(e, r) {
    this.switchLevel(r.level)
  }
  switchLevel(e) {
    const r = this.hls.levels[e];
    if (!(r != null && r.audioGroupIds)) return;
    const n = r.audioGroupIds[r.urlId];
    if (this.groupId !== n) {
      this.groupId = n || null;
      const i = this.tracks.filter(s => !n || s.groupId === n);
      this.selectDefaultTrack && !i.some(s => s.default) && (this.selectDefaultTrack = !1), this.tracksInGroup = i;
      const a = {
        audioTracks: i
      };
      this.log(`Updating audio tracks, ${i.length} track(s) found in group:${n}`), this.hls.trigger($.AUDIO_TRACKS_UPDATED, a), this.selectInitialTrack()
    } else this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId)
  }
  onError(e, r) {
    r.fatal || !r.context || r.context.type === ze.AUDIO_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && (this.requestScheduled = -1, this.checkRetry(r))
  }
  get audioTracks() {
    return this.tracksInGroup
  }
  get audioTrack() {
    return this.trackId
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e)
  }
  setAudioTrack(e) {
    const r = this.tracksInGroup;
    if (e < 0 || e >= r.length) {
      this.warn("Invalid id passed to audio-track controller");
      return
    }
    this.clearTimer();
    const n = this.currentTrack;
    r[this.trackId];
    const i = r[e],
      {
        groupId: a,
        name: s
      } = i;
    if (this.log(`Switching to audio-track ${e} "${s}" lang:${i.lang} group:${a}`), this.trackId = e, this.currentTrack = i, this.selectDefaultTrack = !1, this.hls.trigger($.AUDIO_TRACK_SWITCHING, an({}, i)), i.details && !i.details.live) return;
    const o = this.switchParams(i.url, n == null ? void 0 : n.details);
    this.loadPlaylist(o)
  }
  selectInitialTrack() {
    const e = this.tracksInGroup,
      r = this.findTrackId(this.currentTrack) | this.findTrackId(null);
    if (r !== -1) this.setAudioTrack(r);
    else {
      const n = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`);
      this.warn(n.message), this.hls.trigger($.ERROR, {
        type: ve.MEDIA_ERROR,
        details: q.AUDIO_TRACK_LOAD_ERROR,
        fatal: !0,
        error: n
      })
    }
  }
  findTrackId(e) {
    const r = this.tracksInGroup;
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if ((!this.selectDefaultTrack || i.default) && (!e || e.attrs["STABLE-RENDITION-ID"] === i.attrs["STABLE-RENDITION-ID"] || e.name === i.name && e.lang === i.lang)) return i.id
    }
    return -1
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const r = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(r)) {
      const n = r.id,
        i = r.groupId;
      let a = r.url;
      if (e) try {
        a = e.addDirectives(a)
      } catch (s) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${s}`)
      }
      this.log(`loading audio-track playlist ${n} "${r.name}" lang:${r.lang} group:${i}`), this.clearTimer(), this.hls.trigger($.AUDIO_TRACK_LOADING, {
        url: a,
        id: n,
        groupId: i,
        deliveryDirectives: e || null
      })
    }
  }
}

function zQ(t, e) {
  if (t.length !== e.length) return !1;
  for (let r = 0; r < t.length; r++)
    if (!RGe(t[r].attrs, e[r].attrs)) return !1;
  return !0
}

function RGe(t, e) {
  const r = t["STABLE-RENDITION-ID"];
  return r ? r === e["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some(n => t[n] !== e[n])
}
const lB = 500;
class AGe extends PO {
  constructor(e, r, n) {
    super(e, r, n, "[subtitle-stream-controller]", ye.SUBTITLE), this.levels = [], this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners()
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.mainDetails = null
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.LEVEL_LOADED, this.onLevelLoaded, this), e.on($.ERROR, this.onError, this), e.on($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on($.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.LEVEL_LOADED, this.onLevelLoaded, this), e.off($.ERROR, this.onError, this), e.off($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off($.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off($.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  startLoad(e) {
    this.stopLoad(), this.state = X.IDLE, this.setInterval(lB), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
  }
  onManifestLoading() {
    this.mainDetails = null, this.fragmentTracker.removeAllFragments()
  }
  onMediaDetaching() {
    this.tracksBuffered = [], super.onMediaDetaching()
  }
  onLevelLoaded(e, r) {
    this.mainDetails = r.details
  }
  onSubtitleFragProcessed(e, r) {
    const {
      frag: n,
      success: i
    } = r;
    if (this.fragPrevious = n, this.state = X.IDLE, !i) return;
    const a = this.tracksBuffered[this.currentTrackId];
    if (!a) return;
    let s;
    const o = n.start;
    for (let l = 0; l < a.length; l++)
      if (o >= a[l].start && o <= a[l].end) {
        s = a[l];
        break
      } const c = n.start + n.duration;
    s ? s.end = c : (s = {
      start: o,
      end: c
    }, a.push(s)), this.fragmentTracker.fragBuffered(n)
  }
  onBufferFlushing(e, r) {
    const {
      startOffset: n,
      endOffset: i
    } = r;
    if (n === 0 && i !== Number.POSITIVE_INFINITY) {
      const {
        currentTrackId: a,
        levels: s
      } = this;
      if (!s.length || !s[a] || !s[a].details) return;
      const c = s[a].details.targetduration,
        l = i - c;
      if (l <= 0) return;
      r.endOffsetSubtitles = Math.max(0, l), this.tracksBuffered.forEach(u => {
        for (let f = 0; f < u.length;) {
          if (u[f].end <= l) {
            u.shift();
            continue
          } else if (u[f].start < l) u[f].start = l;
          else break;
          f++
        }
      }), this.fragmentTracker.removeFragmentsInRange(n, l, ye.SUBTITLE)
    }
  }
  onFragBuffered(e, r) {
    if (!this.loadedmetadata && r.frag.type === ye.MAIN) {
      var n;
      (n = this.media) != null && n.buffered.length && (this.loadedmetadata = !0)
    }
  }
  onError(e, r) {
    const n = r.frag;
    (n == null ? void 0 : n.type) === ye.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== X.STOPPED && (this.state = X.IDLE))
  }
  onSubtitleTracksUpdated(e, {
    subtitleTracks: r
  }) {
    if (zQ(this.levels, r)) {
      this.levels = r.map(n => new ep(n));
      return
    }
    this.tracksBuffered = [], this.levels = r.map(n => {
      const i = new ep(n);
      return this.tracksBuffered[i.id] = [], i
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, ye.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null
  }
  onSubtitleTrackSwitch(e, r) {
    if (this.currentTrackId = r.id, !this.levels.length || this.currentTrackId === -1) {
      this.clearInterval();
      return
    }
    const n = this.levels[this.currentTrackId];
    n != null && n.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, n && this.setInterval(lB)
  }
  onSubtitleTrackLoaded(e, r) {
    var n;
    const {
      details: i,
      id: a
    } = r, {
      currentTrackId: s,
      levels: o
    } = this;
    if (!o.length) return;
    const c = o[s];
    if (a >= o.length || a !== s || !c) return;
    this.mediaBuffer = this.mediaBufferTimeRanges;
    let l = 0;
    if (i.live || (n = c.details) != null && n.live) {
      const u = this.mainDetails;
      if (i.deltaUpdateFailed || !u) return;
      const f = u.fragments[0];
      c.details ? (l = this.alignPlaylists(i, c.details), l === 0 && f && (l = f.start, VA(i, l))) : i.hasProgramDateTime && u.hasProgramDateTime ? (AQ(i, u), l = i.fragments[0].start) : f && (l = f.start, VA(i, l))
    }
    c.details = i, this.levelLastLoaded = a, !this.startFragRequested && (this.mainDetails || !i.live) && this.setStartPosition(c.details, l), this.tick(), i.live && !this.fragCurrent && this.media && this.state === X.IDLE && (tp(null, i.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), c.details = void 0))
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: r,
      payload: n
    } = e, i = r.decryptdata, a = this.hls;
    if (!this.fragContextChanged(r) && n && n.byteLength > 0 && i && i.key && i.iv && i.method === "AES-128") {
      const s = performance.now();
      this.decrypter.decrypt(new Uint8Array(n), i.key.buffer, i.iv.buffer).catch(o => {
        throw a.trigger($.ERROR, {
          type: ve.MEDIA_ERROR,
          details: q.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: o,
          reason: o.message,
          frag: r
        }), o
      }).then(o => {
        const c = performance.now();
        a.trigger($.FRAG_DECRYPTED, {
          frag: r,
          payload: o,
          stats: {
            tstart: s,
            tdecrypt: c
          }
        })
      }).catch(o => {
        this.warn(`${o.name}: ${o.message}`), this.state = X.IDLE
      })
    }
  }
  doTick() {
    if (!this.media) {
      this.state = X.IDLE;
      return
    }
    if (this.state === X.IDLE) {
      const {
        currentTrackId: e,
        levels: r
      } = this, n = r[e];
      if (!r.length || !n || !n.details) return;
      const i = n.details,
        a = i.targetduration,
        {
          config: s
        } = this,
        o = this.getLoadPosition(),
        c = ct.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], o - a, s.maxBufferHole),
        {
          end: l,
          len: u
        } = c,
        f = this.getFwdBufferInfo(this.media, ye.MAIN),
        d = this.getMaxBufferLength(f == null ? void 0 : f.len) + a;
      if (u > d) return;
      const h = i.fragments,
        p = h.length,
        v = i.edge;
      let g = null;
      const m = this.fragPrevious;
      if (l < v) {
        const {
          maxFragLookUpTolerance: y
        } = s;
        g = tp(m, h, Math.max(h[0].start, l), y), !g && m && m.start < h[0].start && (g = h[0])
      } else g = h[p - 1];
      if (!g) return;
      g = this.mapToInitFragWhenRequired(g), this.fragmentTracker.getState(g) === Tr.NOT_LOADED && this.loadFragment(g, n, l)
    }
  }
  getMaxBufferLength(e) {
    const r = super.getMaxBufferLength();
    return e ? Math.max(r, e) : r
  }
  loadFragment(e, r, n) {
    this.fragCurrent = e, e.sn === "initSegment" ? this._loadInitSegment(e, r) : (this.startFragRequested = !0, super.loadFragment(e, r, n))
  }
  get mediaBufferTimeRanges() {
    return new IGe(this.tracksBuffered[this.currentTrackId] || [])
  }
}
class IGe {
  constructor(e) {
    this.buffered = void 0;
    const r = (n, i, a) => {
      if (i = i >>> 0, i > a - 1) throw new DOMException(`Failed to execute '${n}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${a})`);
      return e[i][n]
    };
    this.buffered = {
      get length() {
        return e.length
      },
      end(n) {
        return r("end", n, e.length)
      },
      start(n) {
        return r("start", n, e.length)
      }
    }
  }
}
class $Ge extends CO {
  constructor(e) {
    super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.trackChangeListener = () => this.onTextTracksChanged(), this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.registerListeners()
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, super.destroy()
  }
  get subtitleDisplay() {
    return this._subtitleDisplay
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes(this.trackId)
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.LEVEL_LOADING, this.onLevelLoading, this), e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on($.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.LEVEL_LOADING, this.onLevelLoading, this), e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off($.ERROR, this.onError, this)
  }
  onMediaAttached(e, r) {
    this.media = r.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
  }
  onMediaDetaching() {
    if (!this.media) return;
    self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), hw(this.media.textTracks).forEach(r => {
      _u(r)
    }), this.subtitleTrack = -1, this.media = null
  }
  onManifestLoading() {
    this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
  }
  onManifestParsed(e, r) {
    this.tracks = r.subtitleTracks
  }
  onSubtitleTrackLoaded(e, r) {
    const {
      id: n,
      details: i
    } = r, {
      trackId: a
    } = this, s = this.tracksInGroup[a];
    if (!s) {
      this.warn(`Invalid subtitle track id ${n}`);
      return
    }
    const o = s.details;
    s.details = r.details, this.log(`subtitle track ${n} loaded [${i.startSN}-${i.endSN}]`), n === this.trackId && this.playlistLoaded(n, r, o)
  }
  onLevelLoading(e, r) {
    this.switchLevel(r.level)
  }
  onLevelSwitching(e, r) {
    this.switchLevel(r.level)
  }
  switchLevel(e) {
    const r = this.hls.levels[e];
    if (!(r != null && r.textGroupIds)) return;
    const n = r.textGroupIds[r.urlId],
      i = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    if (this.groupId !== n) {
      const a = this.tracks.filter(c => !n || c.groupId === n);
      this.tracksInGroup = a;
      const s = this.findTrackId(i == null ? void 0 : i.name) || this.findTrackId();
      this.groupId = n || null;
      const o = {
        subtitleTracks: a
      };
      this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${n}" group-id`), this.hls.trigger($.SUBTITLE_TRACKS_UPDATED, o), s !== -1 && this.setSubtitleTrack(s, i)
    } else this.shouldReloadPlaylist(i) && this.setSubtitleTrack(this.trackId, i)
  }
  findTrackId(e) {
    const r = this.tracksInGroup;
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if ((!this.selectDefaultTrack || i.default) && (!e || e === i.name)) return i.id
    }
    return -1
  }
  onError(e, r) {
    r.fatal || !r.context || r.context.type === ze.SUBTITLE_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && this.checkRetry(r)
  }
  get subtitleTracks() {
    return this.tracksInGroup
  }
  get subtitleTrack() {
    return this.trackId
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1;
    const r = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    this.setSubtitleTrack(e, r)
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const r = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(r)) {
      const n = r.id,
        i = r.groupId;
      let a = r.url;
      if (e) try {
        a = e.addDirectives(a)
      } catch (s) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${s}`)
      }
      this.log(`Loading subtitle playlist for id ${n}`), this.hls.trigger($.SUBTITLE_TRACK_LOADING, {
        url: a,
        id: n,
        groupId: i,
        deliveryDirectives: e || null
      })
    }
  }
  toggleTrackModes(e) {
    const {
      media: r,
      trackId: n
    } = this;
    if (!r) return;
    const i = hw(r.textTracks),
      a = i.filter(o => o.groupId === this.groupId);
    if (e === -1)[].slice.call(i).forEach(o => {
      o.mode = "disabled"
    });
    else {
      const o = a[n];
      o && (o.mode = "disabled")
    }
    const s = a[e];
    s && (s.mode = this.subtitleDisplay ? "showing" : "hidden")
  }
  setSubtitleTrack(e, r) {
    var n;
    const i = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return
    }
    if (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (e === -1 || (n = i[e]) != null && n.details) || e < -1 || e >= i.length) return;
    this.clearTimer();
    const a = i[e];
    if (this.log(`Switching to subtitle-track ${e}` + (a ? ` "${a.name}" lang:${a.lang} group:${a.groupId}` : "")), this.trackId = e, a) {
      const {
        id: s,
        groupId: o = "",
        name: c,
        type: l,
        url: u
      } = a;
      this.hls.trigger($.SUBTITLE_TRACK_SWITCH, {
        id: s,
        groupId: o,
        name: c,
        type: l,
        url: u
      });
      const f = this.switchParams(a.url, r == null ? void 0 : r.details);
      this.loadPlaylist(f)
    } else this.hls.trigger($.SUBTITLE_TRACK_SWITCH, {
      id: e
    })
  }
  onTextTracksChanged() {
    if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
    let e = -1;
    const r = hw(this.media.textTracks);
    for (let n = 0; n < r.length; n++)
      if (r[n].mode === "hidden") e = n;
      else if (r[n].mode === "showing") {
      e = n;
      break
    }
    this.subtitleTrack !== e && (this.subtitleTrack = e)
  }
}

function hw(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    (n.kind === "subtitles" || n.kind === "captions") && n.label && e.push(t[r])
  }
  return e
}
class CGe {
  constructor(e) {
    this.buffers = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.buffers = e
  }
  append(e, r) {
    const n = this.queues[r];
    n.push(e), n.length === 1 && this.buffers[r] && this.executeNext(r)
  }
  insertAbort(e, r) {
    this.queues[r].unshift(e), this.executeNext(r)
  }
  appendBlocker(e) {
    let r;
    const n = new Promise(a => {
        r = a
      }),
      i = {
        execute: r,
        onStart: () => {},
        onComplete: () => {},
        onError: () => {}
      };
    return this.append(i, e), n
  }
  executeNext(e) {
    const {
      buffers: r,
      queues: n
    } = this, i = r[e], a = n[e];
    if (a.length) {
      const s = a[0];
      try {
        s.execute()
      } catch (o) {
        G.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), s.onError(o), i != null && i.updating || (a.shift(), this.executeNext(e))
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues[e].shift(), this.executeNext(e)
  }
  current(e) {
    return this.queues[e][0]
  }
}
const cB = NO(),
  uB = /([ha]vc.)(?:\.[^.,]+)+/;
class kGe {
  constructor(e) {
    this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = () => {
      const {
        media: r,
        mediaSource: n
      } = this;
      G.log("[buffer-controller]: Media source opened"), r && (r.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger($.MEDIA_ATTACHED, {
        media: r
      })), n && n.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks()
    }, this._onMediaSourceClose = () => {
      G.log("[buffer-controller]: Media source closed")
    }, this._onMediaSourceEnded = () => {
      G.log("[buffer-controller]: Media source ended")
    }, this._onMediaEmptied = () => {
      const {
        media: r,
        _objectUrl: n
      } = this;
      r && r.src !== n && G.error(`Media element src was set while attaching MediaSource (${n} > ${r.src})`)
    }, this.hls = e, this._initSourceBuffer(), this.registerListeners()
  }
  hasSourceTypes() {
    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.BUFFER_RESET, this.onBufferReset, this), e.on($.BUFFER_APPENDING, this.onBufferAppending, this), e.on($.BUFFER_CODECS, this.onBufferCodecs, this), e.on($.BUFFER_EOS, this.onBufferEos, this), e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on($.LEVEL_UPDATED, this.onLevelUpdated, this), e.on($.FRAG_PARSED, this.onFragParsed, this), e.on($.FRAG_CHANGED, this.onFragChanged, this)
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.BUFFER_RESET, this.onBufferReset, this), e.off($.BUFFER_APPENDING, this.onBufferAppending, this), e.off($.BUFFER_CODECS, this.onBufferCodecs, this), e.off($.BUFFER_EOS, this.onBufferEos, this), e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off($.LEVEL_UPDATED, this.onLevelUpdated, this), e.off($.FRAG_PARSED, this.onFragParsed, this), e.off($.FRAG_CHANGED, this.onFragChanged, this)
  }
  _initSourceBuffer() {
    this.sourceBuffer = {}, this.operationQueue = new CGe(this.sourceBuffer), this.listeners = {
      audio: [],
      video: [],
      audiovideo: []
    }, this.lastMpegAudioChunk = null
  }
  onManifestParsed(e, r) {
    let n = 2;
    (r.audio && !r.video || !r.altAudio) && (n = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = n, this.details = null, G.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
  }
  onMediaAttaching(e, r) {
    const n = this.media = r.media;
    if (n && cB) {
      const i = this.mediaSource = new cB;
      i.addEventListener("sourceopen", this._onMediaSourceOpen), i.addEventListener("sourceended", this._onMediaSourceEnded), i.addEventListener("sourceclose", this._onMediaSourceClose), n.src = self.URL.createObjectURL(i), this._objectUrl = n.src, n.addEventListener("emptied", this._onMediaEmptied)
    }
  }
  onMediaDetaching() {
    const {
      media: e,
      mediaSource: r,
      _objectUrl: n
    } = this;
    if (r) {
      if (G.log("[buffer-controller]: media source detaching"), r.readyState === "open") try {
        r.endOfStream()
      } catch (i) {
        G.warn(`[buffer-controller]: onMediaDetaching: ${i.message} while calling endOfStream`)
      }
      this.onBufferReset(), r.removeEventListener("sourceopen", this._onMediaSourceOpen), r.removeEventListener("sourceended", this._onMediaSourceEnded), r.removeEventListener("sourceclose", this._onMediaSourceClose), e && (e.removeEventListener("emptied", this._onMediaEmptied), n && self.URL.revokeObjectURL(n), e.src === n ? (e.removeAttribute("src"), e.load()) : G.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
    }
    this.hls.trigger($.MEDIA_DETACHED, void 0)
  }
  onBufferReset() {
    this.getSourceBufferTypes().forEach(e => {
      const r = this.sourceBuffer[e];
      try {
        r && (this.removeBufferListeners(e), this.mediaSource && this.mediaSource.removeSourceBuffer(r), this.sourceBuffer[e] = void 0)
      } catch (n) {
        G.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, n)
      }
    }), this._initSourceBuffer()
  }
  onBufferCodecs(e, r) {
    const n = this.getSourceBufferTypes().length;
    Object.keys(r).forEach(i => {
      if (n) {
        const a = this.tracks[i];
        if (a && typeof a.buffer.changeType == "function") {
          const {
            id: s,
            codec: o,
            levelCodec: c,
            container: l,
            metadata: u
          } = r[i], f = (a.levelCodec || a.codec).replace(uB, "$1"), d = (c || o).replace(uB, "$1");
          if (f !== d) {
            const h = `${l};codecs=${c||o}`;
            this.appendChangeType(i, h), G.log(`[buffer-controller]: switching codec ${f} to ${d}`), this.tracks[i] = {
              buffer: a.buffer,
              codec: o,
              container: l,
              levelCodec: c,
              metadata: u,
              id: s
            }
          }
        }
      } else this.pendingTracks[i] = r[i]
    }), !n && (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && this.mediaSource.readyState === "open" && this.checkPendingTracks())
  }
  appendChangeType(e, r) {
    const {
      operationQueue: n
    } = this, i = {
      execute: () => {
        const a = this.sourceBuffer[e];
        a && (G.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${r}`), a.changeType(r)), n.shiftAndExecuteNext(e)
      },
      onStart: () => {},
      onComplete: () => {},
      onError: a => {
        G.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, a)
      }
    };
    n.append(i, e)
  }
  onBufferAppending(e, r) {
    const {
      hls: n,
      operationQueue: i,
      tracks: a
    } = this, {
      data: s,
      type: o,
      frag: c,
      part: l,
      chunkMeta: u
    } = r, f = u.buffering[o], d = self.performance.now();
    f.start = d;
    const h = c.stats.buffering,
      p = l ? l.stats.buffering : null;
    h.start === 0 && (h.start = d), p && p.start === 0 && (p.start = d);
    const v = a.audio;
    let g = !1;
    o === "audio" && (v == null ? void 0 : v.container) === "audio/mpeg" && (g = !this.lastMpegAudioChunk || u.id === 1 || this.lastMpegAudioChunk.sn !== u.sn, this.lastMpegAudioChunk = u);
    const m = c.start,
      y = {
        execute: () => {
          if (f.executeStart = self.performance.now(), g) {
            const x = this.sourceBuffer[o];
            if (x) {
              const b = m - x.timestampOffset;
              Math.abs(b) >= .1 && (G.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${m} (delta: ${b}) sn: ${c.sn})`), x.timestampOffset = m)
            }
          }
          this.appendExecutor(s, o)
        },
        onStart: () => {},
        onComplete: () => {
          const x = self.performance.now();
          f.executeEnd = f.end = x, h.first === 0 && (h.first = x), p && p.first === 0 && (p.first = x);
          const {
            sourceBuffer: b
          } = this, _ = {};
          for (const S in b) _[S] = ct.getBuffered(b[S]);
          this.appendError = 0, this.hls.trigger($.BUFFER_APPENDED, {
            type: o,
            frag: c,
            part: l,
            chunkMeta: u,
            parent: c.type,
            timeRanges: _
          })
        },
        onError: x => {
          G.error(`[buffer-controller]: Error encountered while trying to append to the ${o} SourceBuffer`, x);
          const b = {
            type: ve.MEDIA_ERROR,
            parent: c.type,
            details: q.BUFFER_APPEND_ERROR,
            frag: c,
            part: l,
            chunkMeta: u,
            error: x,
            err: x,
            fatal: !1
          };
          x.code === DOMException.QUOTA_EXCEEDED_ERR ? b.details = q.BUFFER_FULL_ERROR : (this.appendError++, b.details = q.BUFFER_APPEND_ERROR, this.appendError > n.config.appendErrorMaxRetry && (G.error(`[buffer-controller]: Failed ${n.config.appendErrorMaxRetry} times to append segment in sourceBuffer`), b.fatal = !0)), n.trigger($.ERROR, b)
        }
      };
    i.append(y, o)
  }
  onBufferFlushing(e, r) {
    const {
      operationQueue: n
    } = this, i = a => ({
      execute: this.removeExecutor.bind(this, a, r.startOffset, r.endOffset),
      onStart: () => {},
      onComplete: () => {
        this.hls.trigger($.BUFFER_FLUSHED, {
          type: a
        })
      },
      onError: s => {
        G.warn(`[buffer-controller]: Failed to remove from ${a} SourceBuffer`, s)
      }
    });
    r.type ? n.append(i(r.type), r.type) : this.getSourceBufferTypes().forEach(a => {
      n.append(i(a), a)
    })
  }
  onFragParsed(e, r) {
    const {
      frag: n,
      part: i
    } = r, a = [], s = i ? i.elementaryStreams : n.elementaryStreams;
    s[Qe.AUDIOVIDEO] ? a.push("audiovideo") : (s[Qe.AUDIO] && a.push("audio"), s[Qe.VIDEO] && a.push("video"));
    const o = () => {
      const c = self.performance.now();
      n.stats.buffering.end = c, i && (i.stats.buffering.end = c);
      const l = i ? i.stats : n.stats;
      this.hls.trigger($.FRAG_BUFFERED, {
        frag: n,
        part: i,
        stats: l,
        id: n.type
      })
    };
    a.length === 0 && G.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`), this.blockBuffers(o, a)
  }
  onFragChanged(e, r) {
    this.flushBackBuffer()
  }
  onBufferEos(e, r) {
    this.getSourceBufferTypes().reduce((i, a) => {
      const s = this.sourceBuffer[a];
      return s && (!r.type || r.type === a) && (s.ending = !0, s.ended || (s.ended = !0, G.log(`[buffer-controller]: ${a} sourceBuffer now EOS`))), i && !!(!s || s.ended)
    }, !0) && (G.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers(() => {
      this.getSourceBufferTypes().forEach(a => {
        const s = this.sourceBuffer[a];
        s && (s.ending = !1)
      });
      const {
        mediaSource: i
      } = this;
      if (!i || i.readyState !== "open") {
        i && G.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${i.readyState}`);
        return
      }
      G.log("[buffer-controller]: Calling mediaSource.endOfStream()"), i.endOfStream()
    }))
  }
  onLevelUpdated(e, {
    details: r
  }) {
    r.fragments.length && (this.details = r, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
  }
  flushBackBuffer() {
    const {
      hls: e,
      details: r,
      media: n,
      sourceBuffer: i
    } = this;
    if (!n || r === null) return;
    const a = this.getSourceBufferTypes();
    if (!a.length) return;
    const s = r.live && e.config.liveBackBufferLength !== null ? e.config.liveBackBufferLength : e.config.backBufferLength;
    if (!ge(s) || s < 0) return;
    const o = n.currentTime,
      c = r.levelTargetDuration,
      l = Math.max(s, c),
      u = Math.floor(o / c) * c - l;
    a.forEach(f => {
      const d = i[f];
      if (d) {
        const h = ct.getBuffered(d);
        if (h.length > 0 && u > h.start(0)) {
          if (e.trigger($.BACK_BUFFER_REACHED, {
              bufferEnd: u
            }), r.live) e.trigger($.LIVE_BACK_BUFFER_REACHED, {
            bufferEnd: u
          });
          else if (d.ended && h.end(h.length - 1) - o < c * 2) {
            G.info(`[buffer-controller]: Cannot flush ${f} back buffer while SourceBuffer is in ended state`);
            return
          }
          e.trigger($.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: u,
            type: f
          })
        }
      }
    })
  }
  updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") return;
    const {
      details: e,
      hls: r,
      media: n,
      mediaSource: i
    } = this, a = e.fragments[0].start + e.totalduration, s = n.duration, o = ge(i.duration) ? i.duration : 0;
    e.live && r.config.liveDurationInfinity ? (G.log("[buffer-controller]: Media Source duration is set to Infinity"), i.duration = 1 / 0, this.updateSeekableRange(e)) : (a > o && a > s || !ge(s)) && (G.log(`[buffer-controller]: Updating Media Source duration to ${a.toFixed(3)}`), i.duration = a)
  }
  updateSeekableRange(e) {
    const r = this.mediaSource,
      n = e.fragments;
    if (n.length && e.live && r != null && r.setLiveSeekableRange) {
      const a = Math.max(0, n[0].start),
        s = Math.max(a, a + e.totalduration);
      r.setLiveSeekableRange(a, s)
    }
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsExpected: e,
      operationQueue: r,
      pendingTracks: n
    } = this, i = Object.keys(n).length;
    if (i && !e || i === 2) {
      this.createSourceBuffers(n), this.pendingTracks = {};
      const a = this.getSourceBufferTypes();
      if (a.length) this.hls.trigger($.BUFFER_CREATED, {
        tracks: this.tracks
      }), a.forEach(s => {
        r.executeNext(s)
      });
      else {
        const s = new Error("could not create source buffer for media codec(s)");
        this.hls.trigger($.ERROR, {
          type: ve.MEDIA_ERROR,
          details: q.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: !0,
          error: s,
          reason: s.message
        })
      }
    }
  }
  createSourceBuffers(e) {
    const {
      sourceBuffer: r,
      mediaSource: n
    } = this;
    if (!n) throw Error("createSourceBuffers called when mediaSource was null");
    for (const i in e)
      if (!r[i]) {
        const a = e[i];
        if (!a) throw Error(`source buffer exists for track ${i}, however track does not`);
        const s = a.levelCodec || a.codec,
          o = `${a.container};codecs=${s}`;
        G.log(`[buffer-controller]: creating sourceBuffer(${o})`);
        try {
          const c = r[i] = n.addSourceBuffer(o),
            l = i;
          this.addBufferListener(l, "updatestart", this._onSBUpdateStart), this.addBufferListener(l, "updateend", this._onSBUpdateEnd), this.addBufferListener(l, "error", this._onSBUpdateError), this.tracks[i] = {
            buffer: c,
            codec: s,
            container: a.container,
            levelCodec: a.levelCodec,
            metadata: a.metadata,
            id: a.id
          }
        } catch (c) {
          G.error(`[buffer-controller]: error while trying to add sourceBuffer: ${c.message}`), this.hls.trigger($.ERROR, {
            type: ve.MEDIA_ERROR,
            details: q.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: c,
            mimeType: o
          })
        }
      }
  }
  _onSBUpdateStart(e) {
    const {
      operationQueue: r
    } = this;
    r.current(e).onStart()
  }
  _onSBUpdateEnd(e) {
    const {
      operationQueue: r
    } = this;
    r.current(e).onComplete(), r.shiftAndExecuteNext(e)
  }
  _onSBUpdateError(e, r) {
    const n = new Error(`${e} SourceBuffer error`);
    G.error(`[buffer-controller]: ${n}`, r), this.hls.trigger($.ERROR, {
      type: ve.MEDIA_ERROR,
      details: q.BUFFER_APPENDING_ERROR,
      error: n,
      fatal: !1
    });
    const i = this.operationQueue.current(e);
    i && i.onError(r)
  }
  removeExecutor(e, r, n) {
    const {
      media: i,
      mediaSource: a,
      operationQueue: s,
      sourceBuffer: o
    } = this, c = o[e];
    if (!i || !a || !c) {
      G.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`), s.shiftAndExecuteNext(e);
      return
    }
    const l = ge(i.duration) ? i.duration : 1 / 0,
      u = ge(a.duration) ? a.duration : 1 / 0,
      f = Math.max(0, r),
      d = Math.min(n, l, u);
    d > f && !c.ending ? (c.ended = !1, G.log(`[buffer-controller]: Removing [${f},${d}] from the ${e} SourceBuffer`), c.remove(f, d)) : s.shiftAndExecuteNext(e)
  }
  appendExecutor(e, r) {
    const {
      operationQueue: n,
      sourceBuffer: i
    } = this, a = i[r];
    if (!a) {
      G.warn(`[buffer-controller]: Attempting to append to the ${r} SourceBuffer, but it does not exist`), n.shiftAndExecuteNext(r);
      return
    }
    a.ended = !1, a.appendBuffer(e)
  }
  blockBuffers(e, r = this.getSourceBufferTypes()) {
    if (!r.length) {
      G.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
      return
    }
    const {
      operationQueue: n
    } = this, i = r.map(a => n.appendBlocker(a));
    Promise.all(i).then(() => {
      e(), r.forEach(a => {
        const s = this.sourceBuffer[a];
        s != null && s.updating || n.shiftAndExecuteNext(a)
      })
    })
  }
  getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer)
  }
  addBufferListener(e, r, n) {
    const i = this.sourceBuffer[e];
    if (!i) return;
    const a = n.bind(this, e);
    this.listeners[e].push({
      event: r,
      listener: a
    }), i.addEventListener(r, a)
  }
  removeBufferListeners(e) {
    const r = this.sourceBuffer[e];
    r && this.listeners[e].forEach(n => {
      r.removeEventListener(n.event, n.listener)
    })
  }
}
const fB = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499
  },
  GQ = function (e) {
    let r = e;
    return fB.hasOwnProperty(e) && (r = fB[e]), String.fromCharCode(r)
  },
  yi = 15,
  Oa = 100,
  OGe = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
  },
  LGe = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
  },
  PGe = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
  },
  NGe = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
  },
  DGe = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class MGe {
  constructor() {
    this.time = null, this.verboseLevel = 0
  }
  log(e, r) {
    if (this.verboseLevel >= e) {
      const n = typeof r == "function" ? r() : r;
      G.log(`${this.time} [${e}] ${n}`)
    }
  }
}
const pl = function (e) {
  const r = [];
  for (let n = 0; n < e.length; n++) r.push(e[n].toString(16));
  return r
};
class VQ {
  constructor(e, r, n, i, a) {
    this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = r || !1, this.italics = n || !1, this.background = i || "black", this.flash = a || !1
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
  }
  setStyles(e) {
    const r = ["foreground", "underline", "italics", "background", "flash"];
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      e.hasOwnProperty(i) && (this[i] = e[i])
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
  }
}
class FGe {
  constructor(e, r, n, i, a, s) {
    this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new VQ(r, n, i, a, s)
  }
  reset() {
    this.uchar = " ", this.penState.reset()
  }
  setChar(e, r) {
    this.uchar = e, this.penState.copy(r)
  }
  setPenState(e) {
    this.penState.copy(e)
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState)
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState)
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault()
  }
}
class BGe {
  constructor(e) {
    this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
    for (let r = 0; r < Oa; r++) this.chars.push(new FGe);
    this.logger = e, this.pos = 0, this.currPenState = new VQ
  }
  equals(e) {
    let r = !0;
    for (let n = 0; n < Oa; n++)
      if (!this.chars[n].equals(e.chars[n])) {
        r = !1;
        break
      } return r
  }
  copy(e) {
    for (let r = 0; r < Oa; r++) this.chars[r].copy(e.chars[r])
  }
  isEmpty() {
    let e = !0;
    for (let r = 0; r < Oa; r++)
      if (!this.chars[r].isEmpty()) {
        e = !1;
        break
      } return e
  }
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Oa && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Oa)
  }
  moveCursor(e) {
    const r = this.pos + e;
    if (e > 1)
      for (let n = this.pos + 1; n < r + 1; n++) this.chars[n].setPenState(this.currPenState);
    this.setCursor(r)
  }
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const r = GQ(e);
    if (this.pos >= Oa) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + r + ") at position " + this.pos + ". Skipping it!");
      return
    }
    this.chars[this.pos].setChar(r, this.currPenState), this.moveCursor(1)
  }
  clearFromPos(e) {
    let r;
    for (r = e; r < Oa; r++) this.chars[r].reset()
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos)
  }
  getTextString() {
    const e = [];
    let r = !0;
    for (let n = 0; n < Oa; n++) {
      const i = this.chars[n].uchar;
      i !== " " && (r = !1), e.push(i)
    }
    return r ? "" : e.join("")
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
  }
}
class pw {
  constructor(e) {
    this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
    for (let r = 0; r < yi; r++) this.rows.push(new BGe(e));
    this.logger = e, this.currRow = yi - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
  }
  reset() {
    for (let e = 0; e < yi; e++) this.rows[e].clear();
    this.currRow = yi - 1
  }
  equals(e) {
    let r = !0;
    for (let n = 0; n < yi; n++)
      if (!this.rows[n].equals(e.rows[n])) {
        r = !1;
        break
      } return r
  }
  copy(e) {
    for (let r = 0; r < yi; r++) this.rows[r].copy(e.rows[r])
  }
  isEmpty() {
    let e = !0;
    for (let r = 0; r < yi; r++)
      if (!this.rows[r].isEmpty()) {
        e = !1;
        break
      } return e
  }
  backSpace() {
    this.rows[this.currRow].backSpace()
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow()
  }
  insertChar(e) {
    this.rows[this.currRow].insertChar(e)
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e)
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e)
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e)
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + JSON.stringify(e));
    let r = e.row - 1;
    if (this.nrRollUpRows && r < this.nrRollUpRows - 1 && (r = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== r) {
      for (let o = 0; o < yi; o++) this.rows[o].clear();
      const a = this.currRow + 1 - this.nrRollUpRows,
        s = this.lastOutputScreen;
      if (s) {
        const o = s.rows[a].cueStartTime,
          c = this.logger.time;
        if (o && c !== null && o < c)
          for (let l = 0; l < this.nrRollUpRows; l++) this.rows[r - this.nrRollUpRows + l + 1].copy(s.rows[a + l])
      }
    }
    this.currRow = r;
    const n = this.rows[this.currRow];
    if (e.indent !== null) {
      const a = e.indent,
        s = Math.max(a - 1, 0);
      n.setCursor(e.indent), e.color = n.chars[s].penState.foreground
    }
    const i = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(i)
  }
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32)
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows,
      r = this.rows.splice(e, 1)[0];
    r.clear(), this.rows.splice(this.currRow, 0, r), this.logger.log(2, "Rolling up")
  }
  getDisplayText(e) {
    e = e || !1;
    const r = [];
    let n = "",
      i = -1;
    for (let a = 0; a < yi; a++) {
      const s = this.rows[a].getTextString();
      s && (i = a + 1, e ? r.push("Row " + i + ": '" + s + "'") : r.push(s.trim()))
    }
    return r.length > 0 && (e ? n = "[" + r.join(" | ") + "]" : n = r.join(`
`)), n
  }
  getTextAndFormat() {
    return this.rows
  }
}
class dB {
  constructor(e, r, n) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = r, this.mode = null, this.verbose = 0, this.displayedMemory = new pw(n), this.nonDisplayedMemory = new pw(n), this.lastOutputScreen = new pw(n), this.currRollUpRow = this.displayedMemory.rows[yi - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = n
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[yi - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
  }
  getHandler() {
    return this.outputFilter
  }
  setHandler(e) {
    this.outputFilter = e
  }
  setPAC(e) {
    this.writeScreen.setPAC(e)
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e)
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
  }
  insertChars(e) {
    for (let n = 0; n < e.length; n++) this.writeScreen.insertChar(e[n]);
    const r = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => r + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate())
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
  }
  ccAOF() {}
  ccAON() {}
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    })
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText())
    }
    this.outputDataUpdate(!0)
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
  }
  ccMIDROW(e) {
    const r = {
      flash: !1
    };
    if (r.underline = e % 2 === 1, r.italics = e >= 46, r.italics) r.foreground = "white";
    else {
      const n = Math.floor(e / 2) - 16,
        i = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      r.foreground = i[n]
    }
    this.logger.log(2, "MIDROW: " + JSON.stringify(r)), this.writeScreen.setPen(r)
  }
  outputDataUpdate(e = !1) {
    const r = this.logger.time;
    r !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = r : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, r, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : r), this.lastOutputScreen.copy(this.displayedMemory))
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
  }
}
class hB {
  constructor(e, r, n) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
    const i = new MGe;
    this.channels = [null, new dB(e, r, i), new dB(e + 1, n, i)], this.cmdHistory = gB(), this.logger = i
  }
  getHandler(e) {
    return this.channels[e].getHandler()
  }
  setHandler(e, r) {
    this.channels[e].setHandler(r)
  }
  addData(e, r) {
    let n, i, a, s = !1;
    this.logger.time = e;
    for (let o = 0; o < r.length; o += 2)
      if (i = r[o] & 127, a = r[o + 1] & 127, !(i === 0 && a === 0)) {
        if (this.logger.log(3, "[" + pl([r[o], r[o + 1]]) + "] -> (" + pl([i, a]) + ")"), n = this.parseCmd(i, a), n || (n = this.parseMidrow(i, a)), n || (n = this.parsePAC(i, a)), n || (n = this.parseBackgroundAttributes(i, a)), !n && (s = this.parseChars(i, a), s)) {
          const c = this.currentChannel;
          c && c > 0 ? this.channels[c].insertChars(s) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
        }!n && !s && this.logger.log(2, "Couldn't parse cleaned data " + pl([i, a]) + " orig: " + pl([r[o], r[o + 1]]))
      }
  }
  parseCmd(e, r) {
    const {
      cmdHistory: n
    } = this, i = (e === 20 || e === 28 || e === 21 || e === 29) && r >= 32 && r <= 47, a = (e === 23 || e === 31) && r >= 33 && r <= 35;
    if (!(i || a)) return !1;
    if (pB(e, r, n)) return Yc(null, null, n), this.logger.log(3, "Repeated command (" + pl([e, r]) + ") is dropped"), !0;
    const s = e === 20 || e === 21 || e === 23 ? 1 : 2,
      o = this.channels[s];
    return e === 20 || e === 21 || e === 28 || e === 29 ? r === 32 ? o.ccRCL() : r === 33 ? o.ccBS() : r === 34 ? o.ccAOF() : r === 35 ? o.ccAON() : r === 36 ? o.ccDER() : r === 37 ? o.ccRU(2) : r === 38 ? o.ccRU(3) : r === 39 ? o.ccRU(4) : r === 40 ? o.ccFON() : r === 41 ? o.ccRDC() : r === 42 ? o.ccTR() : r === 43 ? o.ccRTD() : r === 44 ? o.ccEDM() : r === 45 ? o.ccCR() : r === 46 ? o.ccENM() : r === 47 && o.ccEOC() : o.ccTO(r - 32), Yc(e, r, n), this.currentChannel = s, !0
  }
  parseMidrow(e, r) {
    let n = 0;
    if ((e === 17 || e === 25) && r >= 32 && r <= 47) {
      if (e === 17 ? n = 1 : n = 2, n !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const i = this.channels[n];
      return i ? (i.ccMIDROW(r), this.logger.log(3, "MIDROW (" + pl([e, r]) + ")"), !0) : !1
    }
    return !1
  }
  parsePAC(e, r) {
    let n;
    const i = this.cmdHistory,
      a = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && r >= 64 && r <= 127,
      s = (e === 16 || e === 24) && r >= 64 && r <= 95;
    if (!(a || s)) return !1;
    if (pB(e, r, i)) return Yc(null, null, i), !0;
    const o = e <= 23 ? 1 : 2;
    r >= 64 && r <= 95 ? n = o === 1 ? OGe[e] : PGe[e] : n = o === 1 ? LGe[e] : NGe[e];
    const c = this.channels[o];
    return c ? (c.setPAC(this.interpretPAC(n, r)), Yc(e, r, i), this.currentChannel = o, !0) : !1
  }
  interpretPAC(e, r) {
    let n;
    const i = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return r > 95 ? n = r - 96 : n = r - 64, i.underline = (n & 1) === 1, n <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (i.italics = !0, i.color = "white") : i.indent = Math.floor((n - 16) / 2) * 4, i
  }
  parseChars(e, r) {
    let n, i = null,
      a = null;
    if (e >= 25 ? (n = 2, a = e - 8) : (n = 1, a = e), a >= 17 && a <= 19) {
      let s;
      a === 17 ? s = r + 80 : a === 18 ? s = r + 112 : s = r + 144, this.logger.log(2, "Special char '" + GQ(s) + "' in channel " + n), i = [s]
    } else e >= 32 && e <= 127 && (i = r === 0 ? [e] : [e, r]);
    if (i) {
      const s = pl(i);
      this.logger.log(3, "Char codes =  " + s.join(",")), Yc(e, r, this.cmdHistory)
    }
    return i
  }
  parseBackgroundAttributes(e, r) {
    const n = (e === 16 || e === 24) && r >= 32 && r <= 47,
      i = (e === 23 || e === 31) && r >= 45 && r <= 47;
    if (!(n || i)) return !1;
    let a;
    const s = {};
    e === 16 || e === 24 ? (a = Math.floor((r - 32) / 2), s.background = DGe[a], r % 2 === 1 && (s.background = s.background + "_semi")) : r === 45 ? s.background = "transparent" : (s.foreground = "black", r === 47 && (s.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(s), Yc(e, r, this.cmdHistory), !0
  }
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const r = this.channels[e];
      r && r.reset()
    }
    this.cmdHistory = gB()
  }
  cueSplitAtTime(e) {
    for (let r = 0; r < this.channels.length; r++) {
      const n = this.channels[r];
      n && n.cueSplitAtTime(e)
    }
  }
}

function Yc(t, e, r) {
  r.a = t, r.b = e
}

function pB(t, e, r) {
  return r.a === t && r.b === e
}

function gB() {
  return {
    a: null,
    b: null
  }
}
class Xm {
  constructor(e, r) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = r
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
  }
  newCue(e, r, n) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = r, this.screen = n, this.timelineController.createCaptionsTrack(this.trackName)
  }
  reset() {
    this.cueRanges = [], this.startTime = null
  }
}
var BO = function () {
  if (typeof self < "u" && self.VTTCue) return self.VTTCue;
  const t = ["", "lr", "rl"],
    e = ["start", "middle", "end", "left", "right"];

  function r(o, c) {
    if (typeof c != "string" || !Array.isArray(o)) return !1;
    const l = c.toLowerCase();
    return ~o.indexOf(l) ? l : !1
  }

  function n(o) {
    return r(t, o)
  }

  function i(o) {
    return r(e, o)
  }

  function a(o, ...c) {
    let l = 1;
    for (; l < arguments.length; l++) {
      const u = arguments[l];
      for (const f in u) o[f] = u[f]
    }
    return o
  }

  function s(o, c, l) {
    const u = this,
      f = {
        enumerable: !0
      };
    u.hasBeenReset = !1;
    let d = "",
      h = !1,
      p = o,
      v = c,
      g = l,
      m = null,
      y = "",
      x = !0,
      b = "auto",
      _ = "start",
      S = 50,
      T = "middle",
      R = 50,
      I = "middle";
    Object.defineProperty(u, "id", a({}, f, {
      get: function () {
        return d
      },
      set: function (w) {
        d = "" + w
      }
    })), Object.defineProperty(u, "pauseOnExit", a({}, f, {
      get: function () {
        return h
      },
      set: function (w) {
        h = !!w
      }
    })), Object.defineProperty(u, "startTime", a({}, f, {
      get: function () {
        return p
      },
      set: function (w) {
        if (typeof w != "number") throw new TypeError("Start time must be set to a number.");
        p = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "endTime", a({}, f, {
      get: function () {
        return v
      },
      set: function (w) {
        if (typeof w != "number") throw new TypeError("End time must be set to a number.");
        v = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "text", a({}, f, {
      get: function () {
        return g
      },
      set: function (w) {
        g = "" + w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "region", a({}, f, {
      get: function () {
        return m
      },
      set: function (w) {
        m = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "vertical", a({}, f, {
      get: function () {
        return y
      },
      set: function (w) {
        const C = n(w);
        if (C === !1) throw new SyntaxError("An invalid or illegal string was specified.");
        y = C, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "snapToLines", a({}, f, {
      get: function () {
        return x
      },
      set: function (w) {
        x = !!w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "line", a({}, f, {
      get: function () {
        return b
      },
      set: function (w) {
        if (typeof w != "number" && w !== "auto") throw new SyntaxError("An invalid number or illegal string was specified.");
        b = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "lineAlign", a({}, f, {
      get: function () {
        return _
      },
      set: function (w) {
        const C = i(w);
        if (!C) throw new SyntaxError("An invalid or illegal string was specified.");
        _ = C, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "position", a({}, f, {
      get: function () {
        return S
      },
      set: function (w) {
        if (w < 0 || w > 100) throw new Error("Position must be between 0 and 100.");
        S = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "positionAlign", a({}, f, {
      get: function () {
        return T
      },
      set: function (w) {
        const C = i(w);
        if (!C) throw new SyntaxError("An invalid or illegal string was specified.");
        T = C, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "size", a({}, f, {
      get: function () {
        return R
      },
      set: function (w) {
        if (w < 0 || w > 100) throw new Error("Size must be between 0 and 100.");
        R = w, this.hasBeenReset = !0
      }
    })), Object.defineProperty(u, "align", a({}, f, {
      get: function () {
        return I
      },
      set: function (w) {
        const C = i(w);
        if (!C) throw new SyntaxError("An invalid or illegal string was specified.");
        I = C, this.hasBeenReset = !0
      }
    })), u.displayState = void 0
  }
  return s.prototype.getCueAsHTML = function () {
    return self.WebVTT.convertCueToDOMTree(self, this.text)
  }, s
}();
class UGe {
  decode(e, r) {
    if (!e) return "";
    if (typeof e != "string") throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e))
  }
}

function WQ(t) {
  function e(n, i, a, s) {
    return (n | 0) * 3600 + (i | 0) * 60 + (a | 0) + parseFloat(s || 0)
  }
  const r = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return r ? parseFloat(r[2]) > 59 ? e(r[2], r[3], 0, r[4]) : e(r[1], r[2], r[3], r[4]) : null
}
class jGe {
  constructor() {
    this.values = Object.create(null)
  }
  set(e, r) {
    !this.get(e) && r !== "" && (this.values[e] = r)
  }
  get(e, r, n) {
    return n ? this.has(e) ? this.values[e] : r[n] : this.has(e) ? this.values[e] : r
  }
  has(e) {
    return e in this.values
  }
  alt(e, r, n) {
    for (let i = 0; i < n.length; ++i)
      if (r === n[i]) {
        this.set(e, r);
        break
      }
  }
  integer(e, r) {
    /^-?\d+$/.test(r) && this.set(e, parseInt(r, 10))
  }
  percent(e, r) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(r)) {
      const n = parseFloat(r);
      if (n >= 0 && n <= 100) return this.set(e, n), !0
    }
    return !1
  }
}

function KQ(t, e, r, n) {
  const i = n ? t.split(n) : [t];
  for (const a in i) {
    if (typeof i[a] != "string") continue;
    const s = i[a].split(r);
    if (s.length !== 2) continue;
    const o = s[0],
      c = s[1];
    e(o, c)
  }
}
const YA = new BO(0, 0, ""),
  Qm = YA.align === "middle" ? "middle" : "center";

function HGe(t, e, r) {
  const n = t;

  function i() {
    const o = WQ(t);
    if (o === null) throw new Error("Malformed timestamp: " + n);
    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), o
  }

  function a(o, c) {
    const l = new jGe;
    KQ(o, function (d, h) {
      let p;
      switch (d) {
        case "region":
          for (let v = r.length - 1; v >= 0; v--)
            if (r[v].id === h) {
              l.set(d, r[v].region);
              break
            } break;
        case "vertical":
          l.alt(d, h, ["rl", "lr"]);
          break;
        case "line":
          p = h.split(","), l.integer(d, p[0]), l.percent(d, p[0]) && l.set("snapToLines", !1), l.alt(d, p[0], ["auto"]), p.length === 2 && l.alt("lineAlign", p[1], ["start", Qm, "end"]);
          break;
        case "position":
          p = h.split(","), l.percent(d, p[0]), p.length === 2 && l.alt("positionAlign", p[1], ["start", Qm, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          l.percent(d, h);
          break;
        case "align":
          l.alt(d, h, ["start", Qm, "end", "left", "right"]);
          break
      }
    }, /:/, /\s/), c.region = l.get("region", null), c.vertical = l.get("vertical", "");
    let u = l.get("line", "auto");
    u === "auto" && YA.line === -1 && (u = -1), c.line = u, c.lineAlign = l.get("lineAlign", "start"), c.snapToLines = l.get("snapToLines", !0), c.size = l.get("size", 100), c.align = l.get("align", Qm);
    let f = l.get("position", "auto");
    f === "auto" && YA.position === 50 && (f = c.align === "start" || c.align === "left" ? 0 : c.align === "end" || c.align === "right" ? 100 : 50), c.position = f
  }

  function s() {
    t = t.replace(/^\s+/, "")
  }
  if (s(), e.startTime = i(), s(), t.slice(0, 3) !== "-->") throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + n);
  t = t.slice(3), s(), e.endTime = i(), s(), a(t, e)
}

function YQ(t) {
  return t.replace(/<br(?: \/)?>/gi, `
`)
}
class zGe {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new UGe, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
  }
  parse(e) {
    const r = this;
    e && (r.buffer += r.decoder.decode(e, {
      stream: !0
    }));

    function n() {
      let a = r.buffer,
        s = 0;
      for (a = YQ(a); s < a.length && a[s] !== "\r" && a[s] !== `
`;) ++s;
      const o = a.slice(0, s);
      return a[s] === "\r" && ++s, a[s] === `
` && ++s, r.buffer = a.slice(s), o
    }

    function i(a) {
      KQ(a, function (s, o) {}, /:/)
    }
    try {
      let a = "";
      if (r.state === "INITIAL") {
        if (!/\r\n|\n/.test(r.buffer)) return this;
        a = n();
        const o = a.match(/^(Ã¯Â»Â¿)?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0])) throw new Error("Malformed WebVTT signature.");
        r.state = "HEADER"
      }
      let s = !1;
      for (; r.buffer;) {
        if (!/\r\n|\n/.test(r.buffer)) return this;
        switch (s ? s = !1 : a = n(), r.state) {
          case "HEADER":
            /:/.test(a) ? i(a) : a || (r.state = "ID");
            continue;
          case "NOTE":
            a || (r.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(a)) {
              r.state = "NOTE";
              break
            }
            if (!a) continue;
            if (r.cue = new BO(0, 0, ""), r.state = "CUE", a.indexOf("-->") === -1) {
              r.cue.id = a;
              continue
            }
            case "CUE":
              if (!r.cue) {
                r.state = "BADCUE";
                continue
              }
              try {
                HGe(a, r.cue, r.regionList)
              } catch {
                r.cue = null, r.state = "BADCUE";
                continue
              }
              r.state = "CUETEXT";
              continue;
            case "CUETEXT": {
              const o = a.indexOf("-->") !== -1;
              if (!a || o && (s = !0)) {
                r.oncue && r.cue && r.oncue(r.cue), r.cue = null, r.state = "ID";
                continue
              }
              if (r.cue === null) continue;
              r.cue.text && (r.cue.text += `
`), r.cue.text += a
            }
            continue;
          case "BADCUE":
            a || (r.state = "ID")
        }
      }
    } catch {
      r.state === "CUETEXT" && r.cue && r.oncue && r.oncue(r.cue), r.cue = null, r.state = r.state === "INITIAL" ? "BADWEBVTT" : "BADCUE"
    }
    return this
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT") throw new Error("Malformed WebVTT signature.")
    } catch (r) {
      e.onparsingerror && e.onparsingerror(r)
    }
    return e.onflush && e.onflush(), this
  }
}
const GGe = /\r\n|\n\r|\n|\r/g,
  gw = function (e, r, n = 0) {
    return e.slice(n, n + r.length) === r
  },
  VGe = function (e) {
    let r = parseInt(e.slice(-3));
    const n = parseInt(e.slice(-6, -4)),
      i = parseInt(e.slice(-9, -7)),
      a = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
    if (!ge(r) || !ge(n) || !ge(i) || !ge(a)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
    return r += 1e3 * n, r += 60 * 1e3 * i, r += 60 * 60 * 1e3 * a, r
  },
  mw = function (e) {
    let r = 5381,
      n = e.length;
    for (; n;) r = r * 33 ^ e.charCodeAt(--n);
    return (r >>> 0).toString()
  };

function UO(t, e, r) {
  return mw(t.toString()) + mw(e.toString()) + mw(r)
}
const WGe = function (e, r, n) {
  let i = e[r],
    a = e[i.prevCC];
  if (!a || !a.new && i.new) {
    e.ccOffset = e.presentationOffset = i.start, i.new = !1;
    return
  }
  for (;
    (s = a) != null && s.new;) {
    var s;
    e.ccOffset += i.start - a.start, i.new = !1, i = a, a = e[i.prevCC]
  }
  e.presentationOffset = n
};

function KGe(t, e, r, n, i, a, s) {
  const o = new zGe,
    c = fa(new Uint8Array(t)).trim().replace(GGe, `
`).split(`
`),
    l = [],
    u = iGe(e.baseTime, e.timescale);
  let f = "00:00.000",
    d = 0,
    h = 0,
    p, v = !0;
  o.oncue = function (g) {
    const m = r[n];
    let y = r.ccOffset;
    const x = (d - u) / 9e4;
    m != null && m.new && (h !== void 0 ? y = r.ccOffset = m.start : WGe(r, n, x)), x && (y = x - r.presentationOffset);
    const b = g.endTime - g.startTime,
      _ = jn((g.startTime + y - h) * 9e4, i * 9e4) / 9e4;
    g.startTime = Math.max(_, 0), g.endTime = Math.max(_ + b, 0);
    const S = g.text.trim();
    g.text = decodeURIComponent(encodeURIComponent(S)), g.id || (g.id = UO(g.startTime, g.endTime, S)), g.endTime > 0 && l.push(g)
  }, o.onparsingerror = function (g) {
    p = g
  }, o.onflush = function () {
    if (p) {
      s(p);
      return
    }
    a(l)
  }, c.forEach(g => {
    if (v)
      if (gw(g, "X-TIMESTAMP-MAP=")) {
        v = !1, g.slice(16).split(",").forEach(m => {
          gw(m, "LOCAL:") ? f = m.slice(6) : gw(m, "MPEGTS:") && (d = parseInt(m.slice(7)))
        });
        try {
          h = VGe(f) / 1e3
        } catch (m) {
          p = m
        }
        return
      } else g === "" && (v = !1);
    o.parse(g + `
`)
  }), o.flush()
}
const vw = "stpp.ttml.im1t",
  qQ = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
  XQ = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
  YGe = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
  };

function mB(t, e, r, n) {
  const i = Ue(new Uint8Array(t), ["mdat"]);
  if (i.length === 0) {
    n(new Error("Could not parse IMSC1 mdat"));
    return
  }
  const a = i.map(o => fa(o)),
    s = nGe(e.baseTime, 1, e.timescale);
  try {
    a.forEach(o => r(qGe(o, s)))
  } catch (o) {
    n(o)
  }
}

function qGe(t, e) {
  const i = new DOMParser().parseFromString(t, "text/xml").getElementsByTagName("tt")[0];
  if (!i) throw new Error("Invalid ttml");
  const a = {
      frameRate: 30,
      subFrameRate: 1,
      frameRateMultiplier: 0,
      tickRate: 0
    },
    s = Object.keys(a).reduce((f, d) => (f[d] = i.getAttribute(`ttp:${d}`) || a[d], f), {}),
    o = i.getAttribute("xml:space") !== "preserve",
    c = vB(yw(i, "styling", "style")),
    l = vB(yw(i, "layout", "region")),
    u = yw(i, "body", "[begin]");
  return [].map.call(u, f => {
    const d = QQ(f, o);
    if (!d || !f.hasAttribute("begin")) return null;
    const h = bw(f.getAttribute("begin"), s),
      p = bw(f.getAttribute("dur"), s);
    let v = bw(f.getAttribute("end"), s);
    if (h === null) throw yB(f);
    if (v === null) {
      if (p === null) throw yB(f);
      v = h + p
    }
    const g = new BO(h - e, v - e, d);
    g.id = UO(g.startTime, g.endTime, g.text);
    const m = l[f.getAttribute("region")],
      y = c[f.getAttribute("style")],
      x = XGe(m, y, c),
      {
        textAlign: b
      } = x;
    if (b) {
      const _ = YGe[b];
      _ && (g.lineAlign = _), g.align = b
    }
    return Nt(g, x), g
  }).filter(f => f !== null)
}

function yw(t, e, r) {
  const n = t.getElementsByTagName(e)[0];
  return n ? [].slice.call(n.querySelectorAll(r)) : []
}

function vB(t) {
  return t.reduce((e, r) => {
    const n = r.getAttribute("xml:id");
    return n && (e[n] = r), e
  }, {})
}

function QQ(t, e) {
  return [].slice.call(t.childNodes).reduce((r, n, i) => {
    var a;
    return n.nodeName === "br" && i ? r + `
` : (a = n.childNodes) != null && a.length ? QQ(n, e) : e ? r + n.textContent.trim().replace(/\s+/g, " ") : r + n.textContent
  }, "")
}

function XGe(t, e, r) {
  const n = "http://www.w3.org/ns/ttml#styling";
  let i = null;
  const a = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"],
    s = t != null && t.hasAttribute("style") ? t.getAttribute("style") : null;
  return s && r.hasOwnProperty(s) && (i = r[s]), a.reduce((o, c) => {
    const l = xw(e, n, c) || xw(t, n, c) || xw(i, n, c);
    return l && (o[c] = l), o
  }, {})
}

function xw(t, e, r) {
  return t && t.hasAttributeNS(e, r) ? t.getAttributeNS(e, r) : null
}

function yB(t) {
  return new Error(`Could not parse ttml timestamp ${t}`)
}

function bw(t, e) {
  if (!t) return null;
  let r = WQ(t);
  return r === null && (qQ.test(t) ? r = QGe(t, e) : XQ.test(t) && (r = ZGe(t, e))), r
}

function QGe(t, e) {
  const r = qQ.exec(t),
    n = (r[4] | 0) + (r[5] | 0) / e.subFrameRate;
  return (r[1] | 0) * 3600 + (r[2] | 0) * 60 + (r[3] | 0) + n / e.frameRate
}

function ZGe(t, e) {
  const r = XQ.exec(t),
    n = Number(r[1]);
  switch (r[2]) {
    case "h":
      return n * 3600;
    case "m":
      return n * 60;
    case "ms":
      return n * 1e3;
    case "f":
      return n / e.frameRate;
    case "t":
      return n / e.tickRate
  }
  return n
}
class JGe {
  constructor(e) {
    if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = xB(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode
        }
      }, this.config.enableCEA708Captions) {
      const r = new Xm(this, "textTrack1"),
        n = new Xm(this, "textTrack2"),
        i = new Xm(this, "textTrack3"),
        a = new Xm(this, "textTrack4");
      this.cea608Parser1 = new hB(1, r, n), this.cea608Parser2 = new hB(3, i, a)
    }
    e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this), e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_LOADED, this.onManifestLoaded, this), e.on($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on($.FRAG_LOADING, this.onFragLoading, this), e.on($.FRAG_LOADED, this.onFragLoaded, this), e.on($.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on($.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on($.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on($.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this)
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this), e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_LOADED, this.onManifestLoaded, this), e.off($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off($.FRAG_LOADING, this.onFragLoading, this), e.off($.FRAG_LOADED, this.onFragLoaded, this), e.off($.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off($.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off($.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off($.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
  }
  addCues(e, r, n, i, a) {
    let s = !1;
    for (let o = a.length; o--;) {
      const c = a[o],
        l = tVe(c[0], c[1], r, n);
      if (l >= 0 && (c[0] = Math.min(c[0], r), c[1] = Math.max(c[1], n), s = !0, l / (n - r) > .5)) return
    }
    if (s || a.push([r, n]), this.config.renderTextTracksNatively) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, r, n, i)
    } else {
      const o = this.Cues.newCue(null, r, n, i);
      this.hls.trigger($.CUES_PARSED, {
        type: "captions",
        cues: o,
        track: e
      })
    }
  }
  onInitPtsFound(e, {
    frag: r,
    id: n,
    initPTS: i,
    timescale: a
  }) {
    const {
      unparsedVttFrags: s
    } = this;
    n === "main" && (this.initPTS[r.cc] = {
      baseTime: i,
      timescale: a
    }), s.length && (this.unparsedVttFrags = [], s.forEach(o => {
      this.onFragLoaded($.FRAG_LOADED, o)
    }))
  }
  getExistingTrack(e) {
    const {
      media: r
    } = this;
    if (r)
      for (let n = 0; n < r.textTracks.length; n++) {
        const i = r.textTracks[n];
        if (i[e]) return i
      }
    return null
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e]) return;
    const {
      captionsProperties: r,
      captionsTracks: n,
      media: i
    } = this, {
      label: a,
      languageCode: s
    } = r[e], o = this.getExistingTrack(e);
    if (o) n[e] = o, _u(n[e]), bQ(n[e], i);
    else {
      const c = this.createTextTrack("captions", a, s);
      c && (c[e] = !0, n[e] = c)
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e]) return;
    const r = this.captionsProperties[e];
    if (!r) return;
    const n = r.label,
      i = {
        _id: e,
        label: n,
        kind: "captions",
        default: r.media ? !!r.media.default : !1,
        closedCaptions: r.media
      };
    this.nonNativeCaptionsTracks[e] = i, this.hls.trigger($.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [i]
    })
  }
  createTextTrack(e, r, n) {
    const i = this.media;
    if (i) return i.addTextTrack(e, r, n)
  }
  onMediaAttaching(e, r) {
    this.media = r.media, this._cleanTracks()
  }
  onMediaDetaching() {
    const {
      captionsTracks: e
    } = this;
    Object.keys(e).forEach(r => {
      _u(e[r]), delete e[r]
    }), this.nonNativeCaptionsTracks = {}
  }
  onManifestLoading() {
    this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = xB(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e) return;
    const r = e.textTracks;
    if (r)
      for (let n = 0; n < r.length; n++) _u(r[n])
  }
  onSubtitleTracksUpdated(e, r) {
    const n = r.subtitleTracks || [],
      i = n.some(a => a.textCodec === vw);
    if (this.config.enableWebVTT || i && this.config.enableIMSC1) {
      if (zQ(this.tracks, n)) {
        this.tracks = n;
        return
      }
      if (this.textTracks = [], this.tracks = n, this.config.renderTextTracksNatively) {
        const s = this.media ? this.media.textTracks : null;
        this.tracks.forEach((o, c) => {
          let l;
          if (s && c < s.length) {
            let u = null;
            for (let f = 0; f < s.length; f++)
              if (eVe(s[f], o)) {
                u = s[f];
                break
              } u && (l = u)
          }
          if (l) _u(l);
          else {
            const u = this._captionsOrSubtitlesFromCharacteristics(o);
            l = this.createTextTrack(u, o.name, o.lang), l && (l.mode = "disabled")
          }
          l && (l.groupId = o.groupId, this.textTracks.push(l))
        })
      } else if (this.tracks.length) {
        const s = this.tracks.map(o => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }));
        this.hls.trigger($.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: s
        })
      }
    }
  }
  _captionsOrSubtitlesFromCharacteristics(e) {
    if (e.attrs.CHARACTERISTICS) {
      const r = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS),
        n = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
      if (r && n) return "captions"
    }
    return "subtitles"
  }
  onManifestLoaded(e, r) {
    this.config.enableCEA708Captions && r.captions && r.captions.forEach(n => {
      const i = /(?:CC|SERVICE)([1-4])/.exec(n.instreamId);
      if (!i) return;
      const a = `textTrack${i[1]}`,
        s = this.captionsProperties[a];
      s && (s.label = n.name, n.lang && (s.languageCode = n.lang), s.media = n)
    })
  }
  closedCaptionsForLevel(e) {
    const r = this.hls.levels[e.level];
    return r == null ? void 0 : r.attrs["CLOSED-CAPTIONS"]
  }
  onFragLoading(e, r) {
    const {
      cea608Parser1: n,
      cea608Parser2: i,
      lastSn: a,
      lastPartIndex: s
    } = this;
    if (!(!this.enabled || !(n && i)) && r.frag.type === ye.MAIN) {
      var o, c;
      const l = r.frag.sn,
        u = (o = r == null || (c = r.part) == null ? void 0 : c.index) != null ? o : -1;
      l === a + 1 || l === a && u === s + 1 || (n.reset(), i.reset()), this.lastSn = l, this.lastPartIndex = u
    }
  }
  onFragLoaded(e, r) {
    const {
      frag: n,
      payload: i
    } = r, {
      initPTS: a,
      unparsedVttFrags: s
    } = this;
    if (n.type === ye.SUBTITLE)
      if (i.byteLength) {
        if (!a[n.cc]) {
          s.push(r), a.length && this.hls.trigger($.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: n,
            error: new Error("Missing initial subtitle PTS")
          });
          return
        }
        const o = n.decryptdata,
          c = "stats" in r;
        if (o == null || !o.encrypted || c) {
          const l = this.tracks[n.level],
            u = this.vttCCs;
          u[n.cc] || (u[n.cc] = {
            start: n.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = n.cc), l && l.textCodec === vw ? this._parseIMSC1(n, i) : this._parseVTTs(n, i, u)
        }
      } else this.hls.trigger($.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: n,
        error: new Error("Empty subtitle payload")
      })
  }
  _parseIMSC1(e, r) {
    const n = this.hls;
    mB(r, this.initPTS[e.cc], i => {
      this._appendCues(i, e.level), n.trigger($.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      })
    }, i => {
      G.log(`Failed to parse IMSC1: ${i}`), n.trigger($.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: i
      })
    })
  }
  _parseVTTs(e, r, n) {
    var i;
    const a = this.hls,
      s = (i = e.initSegment) != null && i.data ? tc(e.initSegment.data, new Uint8Array(r)) : r;
    KGe(s, this.initPTS[e.cc], n, e.cc, e.start, o => {
      this._appendCues(o, e.level), a.trigger($.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      })
    }, o => {
      this._fallbackToIMSC1(e, r), G.log(`Failed to parse VTT cue: ${o}`), a.trigger($.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: o
      })
    })
  }
  _fallbackToIMSC1(e, r) {
    const n = this.tracks[e.level];
    n.textCodec || mB(r, this.initPTS[e.cc], () => {
      n.textCodec = vw, this._parseIMSC1(e, r)
    }, () => {
      n.textCodec = "wvtt"
    })
  }
  _appendCues(e, r) {
    const n = this.hls;
    if (this.config.renderTextTracksNatively) {
      const i = this.textTracks[r];
      if (!i || i.mode === "disabled") return;
      e.forEach(a => EQ(i, a))
    } else {
      const i = this.tracks[r];
      if (!i) return;
      const a = i.default ? "default" : "subtitles" + r;
      n.trigger($.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: a
      })
    }
  }
  onFragDecrypted(e, r) {
    const {
      frag: n
    } = r;
    if (n.type === ye.SUBTITLE) {
      if (!this.initPTS[n.cc]) {
        this.unparsedVttFrags.push(r);
        return
      }
      this.onFragLoaded($.FRAG_LOADED, r)
    }
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {}
  }
  onFragParsingUserdata(e, r) {
    const {
      cea608Parser1: n,
      cea608Parser2: i
    } = this;
    if (!this.enabled || !(n && i)) return;
    const {
      frag: a,
      samples: s
    } = r;
    if (!(a.type === ye.MAIN && this.closedCaptionsForLevel(a) === "NONE"))
      for (let o = 0; o < s.length; o++) {
        const c = s[o].bytes;
        if (c) {
          const l = this.extractCea608Data(c);
          n.addData(s[o].pts, l[0]), i.addData(s[o].pts, l[1])
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: r,
    endOffset: n,
    endOffsetSubtitles: i,
    type: a
  }) {
    const {
      media: s
    } = this;
    if (!(!s || s.currentTime < n)) {
      if (!a || a === "video") {
        const {
          captionsTracks: o
        } = this;
        Object.keys(o).forEach(c => HA(o[c], r, n))
      }
      if (this.config.renderTextTracksNatively && r === 0 && i !== void 0) {
        const {
          textTracks: o
        } = this;
        Object.keys(o).forEach(c => HA(o[c], r, i))
      }
    }
  }
  extractCea608Data(e) {
    const r = [
        [],
        []
      ],
      n = e[0] & 31;
    let i = 2;
    for (let a = 0; a < n; a++) {
      const s = e[i++],
        o = 127 & e[i++],
        c = 127 & e[i++];
      if (o === 0 && c === 0) continue;
      if ((4 & s) !== 0) {
        const u = 3 & s;
        (u === 0 || u === 1) && (r[u].push(o), r[u].push(c))
      }
    }
    return r
  }
}

function eVe(t, e) {
  return !!t && t.label === e.name && !(t.textTrack1 || t.textTrack2)
}

function tVe(t, e, r, n) {
  return Math.min(e, n) - Math.max(t, r)
}

function xB() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  }
}
class jO {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
  }
  setStreamController(e) {
    this.streamController = e
  }
  destroy() {
    this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on($.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.BUFFER_CODECS, this.onBufferCodecs, this), e.on($.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off($.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.BUFFER_CODECS, this.onBufferCodecs, this), e.off($.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  onFpsDropLevelCapping(e, r) {
    const n = this.hls.levels[r.droppedLevel];
    this.isLevelAllowed(n) && this.restrictedLevels.push({
      bitrate: n.bitrate,
      height: n.height,
      width: n.width
    })
  }
  onMediaAttaching(e, r) {
    this.media = r.media instanceof HTMLVideoElement ? r.media : null, this.clientRect = null
  }
  onManifestParsed(e, r) {
    const n = this.hls;
    this.restrictedLevels = [], this.firstLevel = r.firstLevel, n.config.capLevelToPlayerSize && r.video && this.startCapping()
  }
  onBufferCodecs(e, r) {
    this.hls.config.capLevelToPlayerSize && r.video && this.startCapping()
  }
  onMediaDetaching() {
    this.stopCapping()
  }
  detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      const e = this.hls.levels;
      if (e.length) {
        const r = this.hls;
        r.autoLevelCapping = this.getMaxLevel(e.length - 1), r.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = r.autoLevelCapping
      }
    }
  }
  getMaxLevel(e) {
    const r = this.hls.levels;
    if (!r.length) return -1;
    const n = r.filter((i, a) => this.isLevelAllowed(i) && a <= e);
    return this.clientRect = null, jO.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
  }
  getDimensions() {
    if (this.clientRect) return this.clientRect;
    const e = this.media,
      r = {
        width: 0,
        height: 0
      };
    if (e) {
      const n = e.getBoundingClientRect();
      r.width = n.width, r.height = n.height, !r.width && !r.height && (r.width = n.right - n.left || e.width || 0, r.height = n.bottom - n.top || e.height || 0)
    }
    return this.clientRect = r, r
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio) try {
      e = self.devicePixelRatio
    } catch {}
    return e
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some(n => e.bitrate === n.bitrate && e.width === n.width && e.height === n.height)
  }
  static getMaxLevelByMediaSize(e, r, n) {
    if (!(e != null && e.length)) return -1;
    const i = (s, o) => o ? s.width !== o.width || s.height !== o.height : !0;
    let a = e.length - 1;
    for (let s = 0; s < e.length; s += 1) {
      const o = e[s];
      if ((o.width >= r || o.height >= n) && i(o, e[s + 1])) {
        a = s;
        break
      }
    }
    return a
  }
}
class rVe {
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
  }
  setStreamController(e) {
    this.streamController = e
  }
  registerListeners() {
    this.hls.on($.MEDIA_ATTACHING, this.onMediaAttaching, this)
  }
  unregisterListeners() {
    this.hls.off($.MEDIA_ATTACHING, this.onMediaAttaching, this)
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
  }
  onMediaAttaching(e, r) {
    const n = this.hls.config;
    if (n.capLevelOnFPSDrop) {
      const i = r.media instanceof self.HTMLVideoElement ? r.media : null;
      this.media = i, i && typeof i.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod)
    }
  }
  checkFPS(e, r, n) {
    const i = performance.now();
    if (r) {
      if (this.lastTime) {
        const a = i - this.lastTime,
          s = n - this.lastDroppedFrames,
          o = r - this.lastDecodedFrames,
          c = 1e3 * s / a,
          l = this.hls;
        if (l.trigger($.FPS_DROP, {
            currentDropped: s,
            currentDecoded: o,
            totalDroppedFrames: n
          }), c > 0 && s > l.config.fpsDroppedMonitoringThreshold * o) {
          let u = l.currentLevel;
          G.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u), u > 0 && (l.autoLevelCapping === -1 || l.autoLevelCapping >= u) && (u = u - 1, l.trigger($.FPS_DROP_LEVEL_CAPPING, {
            level: u,
            droppedLevel: l.currentLevel
          }), l.autoLevelCapping = u, this.streamController.nextLevelSwitch())
        }
      }
      this.lastTime = i, this.lastDroppedFrames = n, this.lastDecodedFrames = r
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const r = e.getVideoPlaybackQuality();
        this.checkFPS(e, r.totalVideoFrames, r.droppedVideoFrames)
      } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
  }
}
const Zm = "[eme]";
class Yu {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = Yu.CDMCleanupPromise ? [Yu.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = G.debug.bind(G, Zm), this.log = G.log.bind(G, Zm), this.warn = G.warn.bind(G, Zm), this.error = G.error.bind(G, Zm), this.hls = e, this.config = e.config, this.registerListeners()
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null
  }
  registerListeners() {
    this.hls.on($.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on($.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on($.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  unregisterListeners() {
    this.hls.off($.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off($.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off($.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: r,
      widevineLicenseUrl: n
    } = this.config, i = r[e];
    if (i) return i.licenseUrl;
    if (e === vt.WIDEVINE && n) return n;
    throw new Error(`no license server URL configured for key-system "${e}"`)
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: r
    } = this.config, n = r[e];
    if (n) return n.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`)
  }
  attemptKeySystemAccess(e) {
    const r = this.hls.levels,
      n = (s, o, c) => !!s && c.indexOf(s) === o,
      i = r.map(s => s.audioCodec).filter(n),
      a = r.map(s => s.videoCodec).filter(n);
    return i.length + a.length === 0 && a.push("avc1.42e01e"), new Promise((s, o) => {
      const c = l => {
        const u = l.shift();
        this.getMediaKeysPromise(u, i, a).then(f => s({
          keySystem: u,
          mediaKeys: f
        })).catch(f => {
          l.length ? c(l) : f instanceof Mn ? o(f) : o(new Mn({
            type: ve.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_NO_ACCESS,
            error: f,
            fatal: !0
          }, f.message))
        })
      };
      c(e)
    })
  }
  requestMediaKeySystemAccess(e, r) {
    const {
      requestMediaKeySystemAccessFunc: n
    } = this.config;
    if (typeof n != "function") {
      let i = `Configured requestMediaKeySystemAccess is not a function ${n}`;
      return lQ === null && self.location.protocol === "http:" && (i = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(i))
    }
    return n(e, r)
  }
  getMediaKeysPromise(e, r, n) {
    const i = mHe(e, r, n, this.config.drmSystemOptions),
      a = this.keySystemAccessPromises[e];
    let s = a == null ? void 0 : a.keySystemAccess;
    if (!s) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(i)}`), s = this.requestMediaKeySystemAccess(e, i);
      const o = this.keySystemAccessPromises[e] = {
        keySystemAccess: s
      };
      return s.catch(c => {
        this.log(`Failed to obtain access to key-system "${e}": ${c}`)
      }), s.then(c => {
        this.log(`Access for key-system "${c.keySystem}" obtained`);
        const l = this.fetchServerCertificate(e);
        return this.log(`Create media-keys for "${e}"`), o.mediaKeys = c.createMediaKeys().then(u => (this.log(`Media-keys created for "${e}"`), l.then(f => f ? this.setMediaKeysServerCertificate(u, e, f) : u))), o.mediaKeys.catch(u => {
          this.error(`Failed to create media-keys for "${e}"}: ${u}`)
        }), o.mediaKeys
      })
    }
    return s.then(() => a.mediaKeys)
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: r,
    mediaKeys: n
  }) {
    this.log(`Creating key-system session "${r}" keyId: ${Ji.hexDump(e.keyId||[])}`);
    const i = n.createSession(),
      a = {
        decryptdata: e,
        keySystem: r,
        mediaKeys: n,
        mediaKeysSession: i,
        keyStatus: "status-pending"
      };
    return this.mediaKeySessions.push(a), a
  }
  renewKeySession(e) {
    const r = e.decryptdata;
    if (r.pssh) {
      const n = this.createMediaKeySessionContext(e),
        i = this.getKeyIdString(r),
        a = "cenc";
      this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(n, a, r.pssh, "expired")
    } else this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e)
  }
  getKeyIdString(e) {
    if (!e) throw new Error("Could not read keyId of undefined decryptdata");
    if (e.keyId === null) throw new Error("keyId is null");
    return Ji.hexDump(e.keyId)
  }
  updateKeySession(e, r) {
    var n;
    const i = e.mediaKeysSession;
    return this.log(`Updating key-session "${i.sessionId}" for keyID ${Ji.hexDump(((n=e.decryptdata)==null?void 0:n.keyId)||[])}
      } (data length: ${r&&r.byteLength})`), i.update(r)
  }
  selectKeySystemFormat(e) {
    const r = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r)), this.keyFormatPromise
  }
  getKeyFormatPromise(e) {
    return new Promise((r, n) => {
      const i = QT(this.config),
        a = e.map(k5).filter(s => !!s && i.indexOf(s) !== -1);
      return this.getKeySystemSelectionPromise(a).then(({
        keySystem: s
      }) => {
        const o = O5(s);
        o ? r(o) : n(new Error(`Unable to find format for key-system "${s}"`))
      }).catch(n)
    })
  }
  loadKey(e) {
    const r = e.keyInfo.decryptdata,
      n = this.getKeyIdString(r),
      i = `(keyId: ${n} format: "${r.keyFormat}" method: ${r.method} uri: ${r.uri})`;
    this.log(`Starting session for key ${i}`);
    let a = this.keyIdToKeySessionPromise[n];
    return a || (a = this.keyIdToKeySessionPromise[n] = this.getKeySystemForKeyPromise(r).then(({
      keySystem: s,
      mediaKeys: o
    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(s, o).then(() => {
      this.throwIfDestroyed();
      const c = this.createMediaKeySessionContext({
          keySystem: s,
          mediaKeys: o,
          decryptdata: r
        }),
        l = "cenc";
      return this.generateRequestWithPreferredKeySession(c, l, r.pssh, "playlist-key")
    }))), a.catch(s => this.handleError(s))), a
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls) throw new Error("invalid state")
  }
  handleError(e) {
    this.hls && (this.error(e.message), e instanceof Mn ? this.hls.trigger($.ERROR, e.data) : this.hls.trigger($.ERROR, {
      type: ve.KEY_SYSTEM_ERROR,
      details: q.KEY_SYSTEM_NO_KEYS,
      error: e,
      fatal: !0
    }))
  }
  getKeySystemForKeyPromise(e) {
    const r = this.getKeyIdString(e),
      n = this.keyIdToKeySessionPromise[r];
    if (!n) {
      const i = k5(e.keyFormat),
        a = i ? [i] : QT(this.config);
      return this.attemptKeySystemAccess(a)
    }
    return n
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = QT(this.config)), e.length === 0) throw new Mn({
      type: ve.KEY_SYSTEM_ERROR,
      details: q.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
      fatal: !0
    }, `Missing key-system license configuration options ${JSON.stringify({drmSystems:this.config.drmSystems})}`);
    return this.attemptKeySystemAccess(e)
  }
  _onMediaEncrypted(e) {
    const {
      initDataType: r,
      initData: n
    } = e;
    if (this.debug(`"${e.type}" event: init data type: "${r}"`), n === null) return;
    let i, a;
    if (r === "sinf" && this.config.drmSystems[vt.FAIRPLAY]) {
      const u = Qt(new Uint8Array(n));
      try {
        const f = AO(JSON.parse(u).sinf),
          d = mQ(new Uint8Array(f));
        if (!d) return;
        i = d.subarray(8, 24), a = vt.FAIRPLAY
      } catch {
        this.warn('Failed to parse sinf "encrypted" event message initData');
        return
      }
    } else {
      const u = UHe(n);
      if (u === null) return;
      u.version === 0 && u.systemId === oQ.WIDEVINE && u.data && (i = u.data.subarray(8, 24)), a = gHe(u.systemId)
    }
    if (!a || !i) return;
    const s = Ji.hexDump(i),
      {
        keyIdToKeySessionPromise: o,
        mediaKeySessions: c
      } = this;
    let l = o[s];
    for (let u = 0; u < c.length; u++) {
      const f = c[u],
        d = f.decryptdata;
      if (d.pssh || !d.keyId) continue;
      const h = Ji.hexDump(d.keyId);
      if (s === h || d.uri.replace(/-/g, "").indexOf(s) !== -1) {
        l = o[h], delete o[h], d.pssh = new Uint8Array(n), d.keyId = i, l = o[s] = l.then(() => this.generateRequestWithPreferredKeySession(f, r, n, "encrypted-event-key-match"));
        break
      }
    }
    l || (l = o[s] = this.getKeySystemSelectionPromise([a]).then(({
      keySystem: u,
      mediaKeys: f
    }) => {
      var d;
      this.throwIfDestroyed();
      const h = new J0("ISO-23001-7", s, (d = O5(u)) != null ? d : "");
      return h.pssh = new Uint8Array(n), h.keyId = i, this.attemptSetMediaKeys(u, f).then(() => {
        this.throwIfDestroyed();
        const p = this.createMediaKeySessionContext({
          decryptdata: h,
          keySystem: u,
          mediaKeys: f
        });
        return this.generateRequestWithPreferredKeySession(p, r, n, "encrypted-event-no-match")
      })
    })), l.catch(u => this.handleError(u))
  }
  _onWaitingForKey(e) {
    this.log(`"${e.type}" event`)
  }
  attemptSetMediaKeys(e, r) {
    const n = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const i = Promise.all(n).then(() => {
      if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
      return this.media.setMediaKeys(r)
    });
    return this.setMediaKeysQueue.push(i), i.then(() => {
      this.log(`Media-keys set for "${e}"`), n.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(a => n.indexOf(a) === -1)
    })
  }
  generateRequestWithPreferredKeySession(e, r, n, i) {
    var a, s;
    const o = (a = this.config.drmSystems) == null || (s = a[e.keySystem]) == null ? void 0 : s.generateRequest;
    if (o) try {
      const d = o.call(this.hls, r, n, e);
      if (!d) throw new Error("Invalid response from configured generateRequest filter");
      r = d.initDataType, n = e.decryptdata.pssh = d.initData ? new Uint8Array(d.initData) : null
    } catch (d) {
      var c;
      if (this.warn(d.message), (c = this.hls) != null && c.config.debug) throw d
    }
    if (n === null) return this.log(`Skipping key-session request for "${i}" (no initData)`), Promise.resolve(e);
    const l = this.getKeyIdString(e.decryptdata);
    this.log(`Generating key-session request for "${i}": ${l} (init data type: ${r} length: ${n?n.byteLength:null})`);
    const u = new rp;
    e.mediaKeysSession.onmessage = d => {
      const h = e.mediaKeysSession;
      if (!h) {
        u.emit("error", new Error("invalid state"));
        return
      }
      const {
        messageType: p,
        message: v
      } = d;
      this.log(`"${p}" message event for session "${h.sessionId}" message size: ${v.byteLength}`), p === "license-request" || p === "license-renewal" ? this.renewLicense(e, v).catch(g => {
        this.handleError(g), u.emit("error", g)
      }) : p === "license-release" ? e.keySystem === vt.FAIRPLAY && (this.updateKeySession(e, sQ("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${p}"`)
    }, e.mediaKeysSession.onkeystatuseschange = d => {
      if (!e.mediaKeysSession) {
        u.emit("error", new Error("invalid state"));
        return
      }
      this.onKeyStatusChange(e);
      const p = e.keyStatus;
      u.emit("keyStatus", p), p === "expired" && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e))
    };
    const f = new Promise((d, h) => {
      u.on("error", h), u.on("keyStatus", p => {
        p.startsWith("usable") ? d() : p === "output-restricted" ? h(new Mn({
          type: ve.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
          fatal: !1
        }, "HDCP level output restricted")) : p === "internal-error" ? h(new Mn({
          type: ve.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
          fatal: !0
        }, `key status changed to "${p}"`)) : p === "expired" ? h(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${p}"`)
      })
    });
    return e.mediaKeysSession.generateRequest(r, n).then(() => {
      var d;
      this.log(`Request generated for key-session "${(d=e.mediaKeysSession)==null?void 0:d.sessionId}" keyId: ${l}`)
    }).catch(d => {
      throw new Mn({
        type: ve.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_SESSION,
        error: d,
        fatal: !1
      }, `Error generating key-session request: ${d}`)
    }).then(() => f).catch(d => {
      throw u.removeAllListeners(), this.removeSession(e), d
    }).then(() => (u.removeAllListeners(), e))
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach((r, n) => {
      this.log(`key status change "${r}" for keyStatuses keyId: ${Ji.hexDump("buffer"in n?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):new Uint8Array(n))} session keyId: ${Ji.hexDump(new Uint8Array(e.decryptdata.keyId||[]))} uri: ${e.decryptdata.uri}`), e.keyStatus = r
    })
  }
  fetchServerCertificate(e) {
    const r = this.config,
      n = r.loader,
      i = new n(r),
      a = this.getServerCertificateUrl(e);
    return a ? (this.log(`Fetching serverCertificate for "${e}"`), new Promise((s, o) => {
      const c = {
          responseType: "arraybuffer",
          url: a
        },
        l = r.certLoadPolicy.default,
        u = {
          loadPolicy: l,
          timeout: l.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        },
        f = {
          onSuccess: (d, h, p, v) => {
            s(d.data)
          },
          onError: (d, h, p, v) => {
            o(new Mn({
              type: ve.KEY_SYSTEM_ERROR,
              details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: !0,
              networkDetails: p,
              response: an({
                url: c.url,
                data: void 0
              }, d)
            }, `"${e}" certificate request failed (${a}). Status: ${d.code} (${d.text})`))
          },
          onTimeout: (d, h, p) => {
            o(new Mn({
              type: ve.KEY_SYSTEM_ERROR,
              details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: !0,
              networkDetails: p,
              response: {
                url: c.url,
                data: void 0
              }
            }, `"${e}" certificate request timed out (${a})`))
          },
          onAbort: (d, h, p) => {
            o(new Error("aborted"))
          }
        };
      i.load(c, u, f)
    })) : Promise.resolve()
  }
  setMediaKeysServerCertificate(e, r, n) {
    return new Promise((i, a) => {
      e.setServerCertificate(n).then(s => {
        this.log(`setServerCertificate ${s?"success":"not supported by CDM"} (${n==null?void 0:n.byteLength}) on "${r}"`), i(e)
      }).catch(s => {
        a(new Mn({
          type: ve.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: s,
          fatal: !0
        }, s.message))
      })
    })
  }
  renewLicense(e, r) {
    return this.requestLicense(e, new Uint8Array(r)).then(n => this.updateKeySession(e, new Uint8Array(n)).catch(i => {
      throw new Mn({
        type: ve.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        error: i,
        fatal: !0
      }, i.message)
    }))
  }
  setupLicenseXHR(e, r, n, i) {
    const a = this.config.licenseXhrSetup;
    return a ? Promise.resolve().then(() => {
      if (!n.decryptdata) throw new Error("Key removed");
      return a.call(this.hls, e, r, n, i)
    }).catch(s => {
      if (!n.decryptdata) throw s;
      return e.open("POST", r, !0), a.call(this.hls, e, r, n, i)
    }).then(s => (e.readyState || e.open("POST", r, !0), {
      xhr: e,
      licenseChallenge: s || i
    })) : (e.open("POST", r, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: i
    }))
  }
  requestLicense(e, r) {
    const n = this.config.keyLoadPolicy.default;
    return new Promise((i, a) => {
      const s = this.getLicenseServerUrl(e.keySystem);
      this.log(`Sending license request to URL: ${s}`);
      const o = new XMLHttpRequest;
      o.responseType = "arraybuffer", o.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession) return a(new Error("invalid state"));
        if (o.readyState === 4)
          if (o.status === 200) {
            this._requestLicenseFailureCount = 0;
            let c = o.response;
            this.log(`License received ${c instanceof ArrayBuffer?c.byteLength:c}`);
            const l = this.config.licenseResponseCallback;
            if (l) try {
              c = l.call(this.hls, o, s, e)
            } catch (u) {
              this.error(u)
            }
            i(c)
          } else {
            const c = n.errorRetry,
              l = c ? c.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || o.status >= 400 && o.status < 500) a(new Mn({
              type: ve.KEY_SYSTEM_ERROR,
              details: q.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: !0,
              networkDetails: o,
              response: {
                url: s,
                data: void 0,
                code: o.status,
                text: o.statusText
              }
            }, `License Request XHR failed (${s}). Status: ${o.status} (${o.statusText})`));
            else {
              const u = l - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${u} attempts left`), this.requestLicense(e, r).then(i, a)
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, s, e, r).then(({
        xhr: c,
        licenseChallenge: l
      }) => {
        c.send(l)
      })
    })
  }
  onMediaAttached(e, r) {
    if (!this.config.emeEnabled) return;
    const n = r.media;
    this.media = n, n.addEventListener("encrypted", this.onMediaEncrypted), n.addEventListener("waitingforkey", this.onWaitingForKey)
  }
  onMediaDetached() {
    const e = this.media,
      r = this.mediaKeySessions;
    e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, J0.clearKeyUriToKeyIdMap();
    const n = r.length;
    Yu.CDMCleanupPromise = Promise.all(r.map(i => this.removeSession(i)).concat(e == null ? void 0 : e.setMediaKeys(null).catch(i => {
      this.log(`Could not clear media keys: ${i}. media.src: ${e==null?void 0:e.src}`)
    }))).then(() => {
      n && (this.log("finished closing key sessions and clearing media keys"), r.length = 0)
    }).catch(i => {
      this.log(`Could not close sessions and clear media keys: ${i}. media.src: ${e==null?void 0:e.src}`)
    })
  }
  onManifestLoaded(e, {
    sessionKeys: r
  }) {
    if (!(!r || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const n = r.reduce((i, a) => (i.indexOf(a.keyFormat) === -1 && i.push(a.keyFormat), i), []);
      this.log(`Selecting key-system from session-keys ${n.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(n)
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: r,
      licenseXhr: n
    } = e;
    if (r) {
      this.log(`Remove licenses and keys and close session ${r.sessionId}`), r.onmessage = null, r.onkeystatuseschange = null, n && n.readyState !== XMLHttpRequest.DONE && n.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const i = this.mediaKeySessions.indexOf(e);
      return i > -1 && this.mediaKeySessions.splice(i, 1), r.remove().catch(a => {
        this.log(`Could not remove session: ${a}`)
      }).then(() => r.close()).catch(a => {
        this.log(`Could not close session: ${a}`)
      })
    }
  }
}
Yu.CDMCleanupPromise = void 0;
class Mn extends Error {
  constructor(e, r) {
    super(r), this.data = void 0, e.error || (e.error = new Error(r)), this.data = e, e.err = e.error
  }
}
const nVe = 1;
var Br = {
  MANIFEST: "m",
  AUDIO: "a",
  VIDEO: "v",
  MUXED: "av",
  INIT: "i",
  CAPTION: "c",
  TIMED_TEXT: "tt",
  KEY: "k",
  OTHER: "o"
};
const iVe = "h";
class zs {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1
    }, this.applyPlaylistData = i => {
      try {
        this.apply(i, {
          ot: Br.MANIFEST,
          su: !this.initialized
        })
      } catch (a) {
        G.warn("Could not generate manifest CMCD data.", a)
      }
    }, this.applyFragmentData = i => {
      try {
        const a = i.frag,
          s = this.hls.levels[a.level],
          o = this.getObjectType(a),
          c = {
            d: a.duration * 1e3,
            ot: o
          };
        (o === Br.VIDEO || o === Br.AUDIO || o == Br.MUXED) && (c.br = s.bitrate / 1e3, c.tb = this.getTopBandwidth(o) / 1e3, c.bl = this.getBufferLength(o)), this.apply(i, c)
      } catch (a) {
        G.warn("Could not generate segment CMCD data.", a)
      }
    }, this.hls = e;
    const r = this.config = e.config,
      {
        cmcd: n
      } = r;
    n != null && (r.pLoader = this.createPlaylistLoader(), r.fLoader = this.createFragmentLoader(), this.sid = n.sessionId || zs.uuid(), this.cid = n.contentId, this.useHeaders = n.useHeaders === !0, this.registerListeners())
  }
  registerListeners() {
    const e = this.hls;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this), e.on($.MEDIA_DETACHED, this.onMediaDetached, this), e.on($.BUFFER_CREATED, this.onBufferCreated, this)
  }
  unregisterListeners() {
    const e = this.hls;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this), e.off($.MEDIA_DETACHED, this.onMediaDetached, this), e.off($.BUFFER_CREATED, this.onBufferCreated, this)
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
  }
  onMediaAttached(e, r) {
    this.media = r.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
  }
  onBufferCreated(e, r) {
    var n, i;
    this.audioBuffer = (n = r.tracks.audio) == null ? void 0 : n.buffer, this.videoBuffer = (i = r.tracks.video) == null ? void 0 : i.buffer
  }
  createData() {
    var e;
    return {
      v: nVe,
      sf: iVe,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    }
  }
  apply(e, r = {}) {
    Nt(r, this.createData());
    const n = r.ot === Br.INIT || r.ot === Br.VIDEO || r.ot === Br.MUXED;
    if (this.starved && n && (r.bs = !0, r.su = !0, this.starved = !1), r.su == null && (r.su = this.buffering), this.useHeaders) {
      const i = zs.toHeaders(r);
      if (!Object.keys(i).length) return;
      e.headers || (e.headers = {}), Nt(e.headers, i)
    } else {
      const i = zs.toQuery(r);
      if (!i) return;
      e.url = zs.appendQueryToUri(e.url, i)
    }
  }
  getObjectType(e) {
    const {
      type: r
    } = e;
    if (r === "subtitle") return Br.TIMED_TEXT;
    if (e.sn === "initSegment") return Br.INIT;
    if (r === "audio") return Br.AUDIO;
    if (r === "main") return this.hls.audioTracks.length ? Br.VIDEO : Br.MUXED
  }
  getTopBandwidth(e) {
    let r = 0,
      n;
    const i = this.hls;
    if (e === Br.AUDIO) n = i.audioTracks;
    else {
      const a = i.maxAutoLevel,
        s = a > -1 ? a + 1 : i.levels.length;
      n = i.levels.slice(0, s)
    }
    for (const a of n) a.bitrate > r && (r = a.bitrate);
    return r > 0 ? r : NaN
  }
  getBufferLength(e) {
    const r = this.hls.media,
      n = e === Br.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !n || !r ? NaN : ct.bufferInfo(n, r.currentTime, this.config.maxBufferHole).len * 1e3
  }
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, r = this.applyPlaylistData, n = e || this.config.loader;
    return class {
      constructor(a) {
        this.loader = void 0, this.loader = new n(a)
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(a, s, o) {
        r(a), this.loader.load(a, s, o)
      }
    }
  }
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, r = this.applyFragmentData, n = e || this.config.loader;
    return class {
      constructor(a) {
        this.loader = void 0, this.loader = new n(a)
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(a, s, o) {
        r(a), this.loader.load(a, s, o)
      }
    }
  }
  static uuid() {
    const e = URL.createObjectURL(new Blob),
      r = e.toString();
    return URL.revokeObjectURL(e), r.slice(r.lastIndexOf("/") + 1)
  }
  static serialize(e) {
    const r = [],
      n = l => !Number.isNaN(l) && l != null && l !== "" && l !== !1,
      i = l => Math.round(l),
      a = l => i(l / 100) * 100,
      o = {
        br: i,
        d: i,
        bl: a,
        dl: a,
        mtp: a,
        nor: l => encodeURIComponent(l),
        rtp: a,
        tb: i
      },
      c = Object.keys(e || {}).sort();
    for (const l of c) {
      let u = e[l];
      if (!n(u) || l === "v" && u === 1 || l == "pr" && u === 1) continue;
      const f = o[l];
      f && (u = f(u));
      const d = typeof u;
      let h;
      l === "ot" || l === "sf" || l === "st" ? h = `${l}=${u}` : d === "boolean" ? h = l : d === "number" ? h = `${l}=${u}` : h = `${l}=${JSON.stringify(u)}`, r.push(h)
    }
    return r.join(",")
  }
  static toHeaders(e) {
    const r = Object.keys(e),
      n = {},
      i = ["Object", "Request", "Session", "Status"],
      a = [{}, {}, {}, {}],
      s = {
        br: 0,
        d: 0,
        ot: 0,
        tb: 0,
        bl: 1,
        dl: 1,
        mtp: 1,
        nor: 1,
        nrr: 1,
        su: 1,
        cid: 2,
        pr: 2,
        sf: 2,
        sid: 2,
        st: 2,
        v: 2,
        bs: 3,
        rtp: 3
      };
    for (const o of r) {
      const c = s[o] != null ? s[o] : 1;
      a[c][o] = e[o]
    }
    for (let o = 0; o < a.length; o++) {
      const c = zs.serialize(a[o]);
      c && (n[`CMCD-${i[o]}`] = c)
    }
    return n
  }
  static toQuery(e) {
    return `CMCD=${encodeURIComponent(zs.serialize(e))}`
  }
  static appendQueryToUri(e, r) {
    if (!r) return e;
    const n = e.includes("?") ? "&" : "?";
    return `${e}${n}${r}`
  }
}
const aVe = 3e5;
class sVe {
  constructor(e) {
    this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = G.log.bind(G, "[content-steering]:"), this.registerListeners()
  }
  registerListeners() {
    const e = this.hls;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this), e.on($.MANIFEST_LOADED, this.onManifestLoaded, this), e.on($.MANIFEST_PARSED, this.onManifestParsed, this), e.on($.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off($.MANIFEST_LOADING, this.onManifestLoading, this), e.off($.MANIFEST_LOADED, this.onManifestLoaded, this), e.off($.MANIFEST_PARSED, this.onManifestParsed, this), e.off($.ERROR, this.onError, this))
  }
  startLoad() {
    if (this.started = !0, self.clearTimeout(this.reloadTimer), this.enabled && this.uri)
      if (this.updated) {
        const e = Math.max(this.timeToLoad * 1e3 - (performance.now() - this.updated), 0);
        this.scheduleRefresh(this.uri, e)
      } else this.loadSteeringManifest(this.uri)
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), self.clearTimeout(this.reloadTimer)
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
  }
  removeLevel(e) {
    const r = this.levels;
    r && (this.levels = r.filter(n => n !== e))
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
  }
  onManifestLoaded(e, r) {
    const {
      contentSteering: n
    } = r;
    n !== null && (this.pathwayId = n.pathwayId, this.uri = n.uri, this.started && this.startLoad())
  }
  onManifestParsed(e, r) {
    this.audioTracks = r.audioTracks, this.subtitleTracks = r.subtitleTracks
  }
  onError(e, r) {
    const {
      errorAction: n
    } = r;
    if ((n == null ? void 0 : n.action) === Hr.SendAlternateToPenaltyBox && n.flags === Bn.MoveAllAlternatesMatchingHost) {
      let i = this.pathwayPriority;
      const a = this.pathwayId;
      this.penalizedPathways[a] || (this.penalizedPathways[a] = performance.now()), !i && this.levels && (i = this.levels.reduce((s, o) => (s.indexOf(o.pathwayId) === -1 && s.push(o.pathwayId), s), [])), i && i.length > 1 && (this.updatePathwayPriority(i), n.resolved = this.pathwayId !== a)
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let r = this.getLevelsForPathway(this.pathwayId);
    if (r.length === 0) {
      const n = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`), r = this.getLevelsForPathway(n), this.pathwayId = n
    }
    return r.length !== e.length ? (this.log(`Found ${r.length}/${e.length} levels in Pathway "${this.pathwayId}"`), r) : e
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter(r => e === r.pathwayId)
  }
  updatePathwayPriority(e) {
    this.pathwayPriority = e;
    let r;
    const n = this.penalizedPathways,
      i = performance.now();
    Object.keys(n).forEach(a => {
      i - n[a] > aVe && delete n[a]
    });
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      if (n[s]) continue;
      if (s === this.pathwayId) return;
      const o = this.hls.nextLoadLevel,
        c = this.hls.levels[o];
      if (r = this.getLevelsForPathway(s), r.length > 0) {
        this.log(`Setting Pathway to "${s}"`), this.pathwayId = s, this.hls.trigger($.LEVELS_UPDATED, {
          levels: r
        });
        const l = this.hls.levels[o];
        c && l && this.levels && (l.attrs["STABLE-VARIANT-ID"] !== c.attrs["STABLE-VARIANT-ID"] && l.bitrate !== c.bitrate && this.log(`Unstable Pathways change from bitrate ${c.bitrate} to ${l.bitrate}`), this.hls.nextLoadLevel = o);
        break
      }
    }
  }
  clonePathways(e) {
    const r = this.levels;
    if (!r) return;
    const n = {},
      i = {};
    e.forEach(a => {
      const {
        ID: s,
        "BASE-ID": o,
        "URI-REPLACEMENT": c
      } = a;
      if (r.some(u => u.pathwayId === s)) return;
      const l = this.getLevelsForPathway(o).map(u => {
        const f = Nt({}, u);
        f.details = void 0, f.url = ZQ(u.uri, u.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", c);
        const d = new mt(u.attrs);
        d["PATHWAY-ID"] = s;
        const h = d.AUDIO && `${d.AUDIO}_clone_${s}`,
          p = d.SUBTITLES && `${d.SUBTITLES}_clone_${s}`;
        h && (n[d.AUDIO] = h, d.AUDIO = h), p && (i[d.SUBTITLES] = p, d.SUBTITLES = p), f.attrs = d;
        const v = new ep(f);
        return N1(v, "audio", h), N1(v, "text", p), v
      });
      r.push(...l), bB(this.audioTracks, n, c, s), bB(this.subtitleTracks, i, c, s)
    })
  }
  loadSteeringManifest(e) {
    const r = this.hls.config,
      n = r.loader;
    this.loader && this.loader.destroy(), this.loader = new n(r);
    let i;
    try {
      i = new self.URL(e)
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return
    }
    if (i.protocol !== "data:") {
      const u = (this.hls.bandwidthEstimate || r.abrEwmaDefaultEstimate) | 0;
      i.searchParams.set("_HLS_pathway", this.pathwayId), i.searchParams.set("_HLS_throughput", "" + u)
    }
    const a = {
        responseType: "json",
        url: i.href
      },
      s = r.steeringManifestLoadPolicy.default,
      o = s.errorRetry || s.timeoutRetry || {},
      c = {
        loadPolicy: s,
        timeout: s.maxLoadTimeMs,
        maxRetry: o.maxNumRetry || 0,
        retryDelay: o.retryDelayMs || 0,
        maxRetryDelay: o.maxRetryDelayMs || 0
      },
      l = {
        onSuccess: (u, f, d, h) => {
          this.log(`Loaded steering manifest: "${i}"`);
          const p = u.data;
          if (p.VERSION !== 1) {
            this.log(`Steering VERSION ${p.VERSION} not supported!`);
            return
          }
          this.updated = performance.now(), this.timeToLoad = p.TTL;
          const {
            "RELOAD-URI": v,
            "PATHWAY-CLONES": g,
            "PATHWAY-PRIORITY": m
          } = p;
          if (v) try {
            this.uri = new self.URL(v, i).href
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${v}`);
            return
          }
          this.scheduleRefresh(this.uri || d.url), g && this.clonePathways(g), m && this.updatePathwayPriority(m)
        },
        onError: (u, f, d, h) => {
          if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${f.url})`), this.stopLoad(), u.code === 410) {
            this.enabled = !1, this.log(`Steering manifest ${f.url} no longer available`);
            return
          }
          let p = this.timeToLoad * 1e3;
          if (u.code === 429) {
            const v = this.loader;
            if (typeof (v == null ? void 0 : v.getResponseHeader) == "function") {
              const g = v.getResponseHeader("Retry-After");
              g && (p = parseFloat(g) * 1e3)
            }
            this.log(`Steering manifest ${f.url} rate limited`);
            return
          }
          this.scheduleRefresh(this.uri || f.url, p)
        },
        onTimeout: (u, f, d) => {
          this.log(`Timeout loading steering manifest (${f.url})`), this.scheduleRefresh(this.uri || f.url)
        }
      };
    this.log(`Requesting steering manifest: ${i}`), this.loader.load(a, c, l)
  }
  scheduleRefresh(e, r = this.timeToLoad * 1e3) {
    self.clearTimeout(this.reloadTimer), this.reloadTimer = self.setTimeout(() => {
      this.loadSteeringManifest(e)
    }, r)
  }
}

function bB(t, e, r, n) {
  t && Object.keys(e).forEach(i => {
    const a = t.filter(s => s.groupId === i).map(s => {
      const o = Nt({}, s);
      return o.details = void 0, o.attrs = new mt(o.attrs), o.url = o.attrs.URI = ZQ(s.url, s.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", r), o.groupId = o.attrs["GROUP-ID"] = e[i], o.attrs["PATHWAY-ID"] = n, o
    });
    t.push(...a)
  })
}

function ZQ(t, e, r, n) {
  const {
    HOST: i,
    PARAMS: a,
    [r]: s
  } = n;
  let o;
  e && (o = s == null ? void 0 : s[e], o && (t = o));
  const c = new self.URL(t);
  return i && !o && (c.host = i), a && Object.keys(a).sort().forEach(l => {
    l && c.searchParams.set(l, a[l])
  }), c.href
}
const oVe = /^age:\s*[\d.]+\s*$/im;
class JQ {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new bE, this.retryDelay = 0
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()))
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
  }
  load(e, r, n) {
    if (this.stats.loading.start) throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = r, this.callbacks = n, this.loadInternal()
  }
  loadInternal() {
    const {
      config: e,
      context: r
    } = this;
    if (!e) return;
    const n = this.loader = new self.XMLHttpRequest,
      i = this.stats;
    i.loading.first = 0, i.loaded = 0;
    const a = this.xhrSetup;
    a ? Promise.resolve().then(() => {
      if (!this.stats.aborted) return a(n, r.url)
    }).catch(s => (n.open("GET", r.url, !0), a(n, r.url))).then(() => {
      this.stats.aborted || this.openAndSendXhr(n, r, e)
    }).catch(s => {
      this.callbacks.onError({
        code: n.status,
        text: s.message
      }, r, n, i)
    }) : this.openAndSendXhr(n, r, e)
  }
  openAndSendXhr(e, r, n) {
    e.readyState || e.open("GET", r.url, !0);
    const i = this.context.headers,
      {
        maxTimeToFirstByteMs: a,
        maxLoadTimeMs: s
      } = n.loadPolicy;
    if (i)
      for (const o in i) e.setRequestHeader(o, i[o]);
    r.rangeEnd && e.setRequestHeader("Range", "bytes=" + r.rangeStart + "-" + (r.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = r.responseType, self.clearTimeout(this.requestTimeout), n.timeout = a && ge(a) ? a : s, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout), e.send()
  }
  readystatechange() {
    const {
      context: e,
      loader: r,
      stats: n
    } = this;
    if (!e || !r) return;
    const i = r.readyState,
      a = this.config;
    if (!n.aborted && i >= 2 && (n.loading.first === 0 && (n.loading.first = Math.max(self.performance.now(), n.loading.start), a.timeout !== a.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), a.timeout = a.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))), i === 4)) {
      self.clearTimeout(this.requestTimeout), r.onreadystatechange = null, r.onprogress = null;
      const s = r.status,
        o = r.responseType !== "text";
      if (s >= 200 && s < 300 && (o && r.response || r.responseText !== null)) {
        n.loading.end = Math.max(self.performance.now(), n.loading.first);
        const c = o ? r.response : r.responseText,
          l = r.responseType === "arraybuffer" ? c.byteLength : c.length;
        if (n.loaded = n.total = l, n.bwEstimate = n.total * 8e3 / (n.loading.end - n.loading.first), !this.callbacks) return;
        const u = this.callbacks.onProgress;
        if (u && u(n, e, c, r), !this.callbacks) return;
        const f = {
          url: r.responseURL,
          data: c,
          code: s
        };
        this.callbacks.onSuccess(f, n, e, r)
      } else {
        const c = a.loadPolicy.errorRetry,
          l = n.retry;
        P1(c, l, !1, s) ? this.retry(c) : (G.error(`${s} while loading ${e.url}`), this.callbacks.onError({
          code: s,
          text: r.statusText
        }, e, r, n))
      }
    }
  }
  loadtimeout() {
    var e;
    const r = (e = this.config) == null ? void 0 : e.loadPolicy.timeoutRetry,
      n = this.stats.retry;
    if (P1(r, n, !0)) this.retry(r);
    else {
      G.warn(`timeout while loading ${this.context.url}`);
      const i = this.callbacks;
      i && (this.abortInternal(), i.onTimeout(this.stats, this.context, this.loader))
    }
  }
  retry(e) {
    const {
      context: r,
      stats: n
    } = this;
    this.retryDelay = $O(e, n.retry), n.retry++, G.warn(`${status?"HTTP Status "+status:"Timeout"} while loading ${r.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
  }
  loadprogress(e) {
    const r = this.stats;
    r.loaded = e.loaded, e.lengthComputable && (r.total = e.total)
  }
  getCacheAge() {
    let e = null;
    if (this.loader && oVe.test(this.loader.getAllResponseHeaders())) {
      const r = this.loader.getResponseHeader("age");
      e = r ? parseFloat(r) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
  }
}

function lVe() {
  if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
    return new self.ReadableStream({}), !0
  } catch {}
  return !1
}
const cVe = /(\d+)-(\d+)\/(\d+)/;
class EB {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || hVe, this.controller = new self.AbortController, this.stats = new bE
  }
  destroy() {
    this.loader = this.callbacks = null, this.abortInternal()
  }
  abortInternal() {
    const e = this.response;
    e != null && e.ok || (this.stats.aborted = !0, this.controller.abort())
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
  }
  load(e, r, n) {
    const i = this.stats;
    if (i.loading.start) throw new Error("Loader can only be used once.");
    i.loading.start = self.performance.now();
    const a = uVe(e, this.controller.signal),
      s = n.onProgress,
      o = e.responseType === "arraybuffer",
      c = o ? "byteLength" : "length",
      {
        maxTimeToFirstByteMs: l,
        maxLoadTimeMs: u
      } = r.loadPolicy;
    this.context = e, this.config = r, this.callbacks = n, this.request = this.fetchSetup(e, a), self.clearTimeout(this.requestTimeout), r.timeout = l && ge(l) ? l : u, this.requestTimeout = self.setTimeout(() => {
      this.abortInternal(), n.onTimeout(i, e, this.response)
    }, r.timeout), self.fetch(this.request).then(f => {
      this.response = this.loader = f;
      const d = Math.max(self.performance.now(), i.loading.start);
      if (self.clearTimeout(this.requestTimeout), r.timeout = u, this.requestTimeout = self.setTimeout(() => {
          this.abortInternal(), n.onTimeout(i, e, this.response)
        }, u - (d - i.loading.start)), !f.ok) {
        const {
          status: h,
          statusText: p
        } = f;
        throw new pVe(p || "fetch, bad network response", h, f)
      }
      return i.loading.first = d, i.total = dVe(f.headers) || i.total, s && ge(r.highWaterMark) ? this.loadProgressively(f, i, e, r.highWaterMark, s) : o ? f.arrayBuffer() : e.responseType === "json" ? f.json() : f.text()
    }).then(f => {
      const {
        response: d
      } = this;
      self.clearTimeout(this.requestTimeout), i.loading.end = Math.max(self.performance.now(), i.loading.first);
      const h = f[c];
      h && (i.loaded = i.total = h);
      const p = {
        url: d.url,
        data: f,
        code: d.status
      };
      s && !ge(r.highWaterMark) && s(i, e, f, d), n.onSuccess(p, i, e, d)
    }).catch(f => {
      if (self.clearTimeout(this.requestTimeout), i.aborted) return;
      const d = f && f.code || 0,
        h = f ? f.message : null;
      n.onError({
        code: d,
        text: h
      }, e, f ? f.details : null, i)
    })
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const r = this.response.headers.get("age");
      e = r ? parseFloat(r) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null
  }
  loadProgressively(e, r, n, i = 0, a) {
    const s = new HQ,
      o = e.body.getReader(),
      c = () => o.read().then(l => {
        if (l.done) return s.dataLength && a(r, n, s.flush(), e), Promise.resolve(new ArrayBuffer(0));
        const u = l.value,
          f = u.length;
        return r.loaded += f, f < i || s.dataLength ? (s.push(u), s.dataLength >= i && a(r, n, s.flush(), e)) : a(r, n, u, e), c()
      }).catch(() => Promise.reject());
    return c()
  }
}

function uVe(t, e) {
  const r = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Nt({}, t.headers))
  };
  return t.rangeEnd && r.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1)), r
}

function fVe(t) {
  const e = cVe.exec(t);
  if (e) return parseInt(e[2]) - parseInt(e[1]) + 1
}

function dVe(t) {
  const e = t.get("Content-Range");
  if (e) {
    const n = fVe(e);
    if (ge(n)) return n
  }
  const r = t.get("Content-Length");
  if (r) return parseInt(r)
}

function hVe(t, e) {
  return new self.Request(t.url, e)
}
class pVe extends Error {
  constructor(e, r, n) {
    super(e), this.code = void 0, this.details = void 0, this.code = r, this.details = n
  }
}
const gVe = /\s/,
  mVe = {
    newCue(t, e, r, n) {
      const i = [];
      let a, s, o, c, l;
      const u = self.VTTCue || self.TextTrackCue;
      for (let d = 0; d < n.rows.length; d++)
        if (a = n.rows[d], o = !0, c = 0, l = "", !a.isEmpty()) {
          var f;
          for (let v = 0; v < a.chars.length; v++) gVe.test(a.chars[v].uchar) && o ? c++ : (l += a.chars[v].uchar, o = !1);
          a.cueStartTime = e, e === r && (r += 1e-4), c >= 16 ? c-- : c++;
          const h = YQ(l.trim()),
            p = UO(e, r, h);
          t != null && (f = t.cues) != null && f.getCueById(p) || (s = new u(e, r, h), s.id = p, s.line = d + 1, s.align = "left", s.position = 10 + Math.min(80, Math.floor(c * 8 / 32) * 10), i.push(s))
        } return t && i.length && (i.sort((d, h) => d.line === "auto" || h.line === "auto" ? 0 : d.line > 8 && h.line > 8 ? h.line - d.line : d.line - h.line), i.forEach(d => EQ(t, d))), i
    }
  },
  vVe = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
  },
  yVe = an(an({
    autoStartLoad: !0,
    startPosition: -1,
    defaultAudioCodec: void 0,
    debug: !1,
    capLevelOnFPSDrop: !1,
    capLevelToPlayerSize: !1,
    ignoreDevicePixelRatio: !1,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    backBufferLength: 1 / 0,
    maxBufferSize: 60 * 1e3 * 1e3,
    maxBufferHole: .1,
    highBufferWatchdogPeriod: 2,
    nudgeOffset: .1,
    nudgeMaxRetry: 3,
    maxFragLookUpTolerance: .25,
    liveSyncDurationCount: 3,
    liveMaxLatencyDurationCount: 1 / 0,
    liveSyncDuration: void 0,
    liveMaxLatencyDuration: void 0,
    maxLiveSyncPlaybackRate: 1,
    liveDurationInfinity: !1,
    liveBackBufferLength: null,
    maxMaxBufferLength: 600,
    enableWorker: !0,
    workerPath: null,
    enableSoftwareAES: !0,
    startLevel: void 0,
    startFragPrefetch: !1,
    fpsDroppedMonitoringPeriod: 5e3,
    fpsDroppedMonitoringThreshold: .2,
    appendErrorMaxRetry: 3,
    loader: JQ,
    fLoader: void 0,
    pLoader: void 0,
    xhrSetup: void 0,
    licenseXhrSetup: void 0,
    licenseResponseCallback: void 0,
    abrController: SGe,
    bufferController: kGe,
    capLevelController: jO,
    errorController: pze,
    fpsController: rVe,
    stretchShortVideoTrack: !1,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: !0,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrBandWidthFactor: .95,
    abrBandWidthUpFactor: .7,
    abrMaxWithRealBitrate: !1,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: !1,
    widevineLicenseUrl: void 0,
    drmSystems: {},
    drmSystemOptions: {},
    requestMediaKeySystemAccessFunc: lQ,
    testBandwidth: !0,
    progressive: !1,
    lowLatencyMode: !0,
    cmcd: void 0,
    enableDateRangeMetadataCues: !0,
    enableEmsgMetadataCues: !0,
    enableID3MetadataCues: !0,
    certLoadPolicy: {
      default: vVe
    },
    keyLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 8e3,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        },
        errorRetry: {
          maxNumRetry: 8,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        }
      }
    },
    manifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1 / 0,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    playlistLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 2,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    fragLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 12e4,
        timeoutRetry: {
          maxNumRetry: 4,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 6,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    steeringManifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
  }, xVe()), {}, {
    subtitleStreamController: AGe,
    subtitleTrackController: $Ge,
    timelineController: JGe,
    audioStreamController: TGe,
    audioTrackController: wGe,
    emeController: Yu,
    cmcdController: zs,
    contentSteeringController: sVe
  });

function xVe() {
  return {
    cueHandler: mVe,
    enableWebVTT: !0,
    enableIMSC1: !0,
    enableCEA708Captions: !0,
    captionsTextTrack1Label: "English",
    captionsTextTrack1LanguageCode: "en",
    captionsTextTrack2Label: "Spanish",
    captionsTextTrack2LanguageCode: "es",
    captionsTextTrack3Label: "Unknown CC",
    captionsTextTrack3LanguageCode: "",
    captionsTextTrack4Label: "Unknown CC",
    captionsTextTrack4LanguageCode: "",
    renderTextTracksNatively: !0
  }
}

function bVe(t, e) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const r = qA(t),
    n = ["manifest", "level", "frag"],
    i = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return n.forEach(a => {
    const s = `${a==="level"?"playlist":a}LoadPolicy`,
      o = e[s] === void 0,
      c = [];
    i.forEach(l => {
      const u = `${a}Loading${l}`,
        f = e[u];
      if (f !== void 0 && o) {
        c.push(u);
        const d = r[s].default;
        switch (e[s] = {
          default: d
        }, l) {
          case "TimeOut":
            d.maxLoadTimeMs = f, d.maxTimeToFirstByteMs = f;
            break;
          case "MaxRetry":
            d.errorRetry.maxNumRetry = f, d.timeoutRetry.maxNumRetry = f;
            break;
          case "RetryDelay":
            d.errorRetry.retryDelayMs = f, d.timeoutRetry.retryDelayMs = f;
            break;
          case "MaxRetryTimeout":
            d.errorRetry.maxRetryDelayMs = f, d.timeoutRetry.maxRetryDelayMs = f;
            break
        }
      }
    }), c.length && G.warn(`hls.js config: "${c.join('", "')}" setting(s) are deprecated, use "${s}": ${JSON.stringify(e[s])}`)
  }), an(an({}, r), e)
}

function qA(t) {
  return t && typeof t == "object" ? Array.isArray(t) ? t.map(qA) : Object.keys(t).reduce((e, r) => (e[r] = qA(t[r]), e), {}) : t
}

function EVe(t) {
  const e = t.loader;
  e !== EB && e !== JQ ? (G.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1) : lVe() && (t.loader = EB, t.progressive = !0, t.enableSoftwareAES = !0, G.log("[config]: Progressive streaming enabled, using FetchLoader"))
}
class Za {
  static get version() {
    return "1.4.0"
  }
  static isSupported() {
    return Lze()
  }
  static get Events() {
    return $
  }
  static get ErrorTypes() {
    return ve
  }
  static get ErrorDetails() {
    return q
  }
  static get DefaultConfig() {
    return Za.defaultConfig ? Za.defaultConfig : yVe
  }
  static set DefaultConfig(e) {
    Za.defaultConfig = e
  }
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new rp, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, aHe(e.debug || !1, "Hls instance");
    const r = this.config = bVe(Za.DefaultConfig, e);
    this.userConfig = e, this._autoLevelCapping = -1, r.progressive && EVe(r);
    const {
      abrController: n,
      bufferController: i,
      capLevelController: a,
      errorController: s,
      fpsController: o
    } = r, c = new s(this), l = this.abrController = new n(this), u = this.bufferController = new i(this), f = this.capLevelController = new a(this), d = new o(this), h = new qHe(this), p = new eze(this), v = r.contentSteeringController, g = v ? new v(this) : null, m = this.levelController = new mze(this, g), y = new vze(this), x = new xze(this.config), b = this.streamController = new bGe(this, y, x);
    f.setStreamController(b), d.setStreamController(b);
    const _ = [h, m, b];
    g && _.splice(1, 0, g), this.networkControllers = _;
    const S = [l, u, f, d, p, y];
    this.audioTrackController = this.createController(r.audioTrackController, _);
    const T = r.audioStreamController;
    T && _.push(new T(this, y, x)), this.subtitleTrackController = this.createController(r.subtitleTrackController, _);
    const R = r.subtitleStreamController;
    R && _.push(new R(this, y, x)), this.createController(r.timelineController, S), x.emeController = this.emeController = this.createController(r.emeController, S), this.cmcdController = this.createController(r.cmcdController, S), this.latencyController = this.createController(tze, S), this.coreComponents = S, _.push(c);
    const I = c.onErrorOut;
    typeof I == "function" && this.on($.ERROR, I, c)
  }
  createController(e, r) {
    if (e) {
      const n = new e(this);
      return r && r.push(n), n
    }
    return null
  }
  on(e, r, n = this) {
    this._emitter.on(e, r, n)
  }
  once(e, r, n = this) {
    this._emitter.once(e, r, n)
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e)
  }
  off(e, r, n = this, i) {
    this._emitter.off(e, r, n, i)
  }
  listeners(e) {
    return this._emitter.listeners(e)
  }
  emit(e, r, n) {
    return this._emitter.emit(e, r, n)
  }
  trigger(e, r) {
    if (this.config.debug) return this.emit(e, e, r);
    try {
      return this.emit(e, e, r)
    } catch (n) {
      G.error("An internal error happened while handling event " + e + '. Error message: "' + n.message + '". Here is a stacktrace:', n), this.trigger($.ERROR, {
        type: ve.OTHER_ERROR,
        details: q.INTERNAL_EXCEPTION,
        fatal: !1,
        event: e,
        error: n
      })
    }
    return !1
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e)
  }
  destroy() {
    G.log("destroy"), this.trigger($.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(r => r.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(r => r.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null
  }
  attachMedia(e) {
    G.log("attachMedia"), this._media = e, this.trigger($.MEDIA_ATTACHING, {
      media: e
    })
  }
  detachMedia() {
    G.log("detachMedia"), this.trigger($.MEDIA_DETACHING, void 0), this._media = null
  }
  loadSource(e) {
    this.stopLoad();
    const r = this.media,
      n = this.url,
      i = this.url = Z0.buildAbsoluteURL(self.location.href, e, {
        alwaysNormalize: !0
      });
    G.log(`loadSource:${i}`), r && n && n !== i && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(r)), this.trigger($.MANIFEST_LOADING, {
      url: e
    })
  }
  startLoad(e = -1) {
    G.log(`startLoad(${e})`), this.networkControllers.forEach(r => {
      r.startLoad(e)
    })
  }
  stopLoad() {
    G.log("stopLoad"), this.networkControllers.forEach(e => {
      e.stopLoad()
    })
  }
  swapAudioCodec() {
    G.log("swapAudioCodec"), this.streamController.swapAudioCodec()
  }
  recoverMediaError() {
    G.log("recoverMediaError");
    const e = this._media;
    this.detachMedia(), e && this.attachMedia(e)
  }
  removeLevel(e, r = 0) {
    this.levelController.removeLevel(e, r)
  }
  get levels() {
    const e = this.levelController.levels;
    return e || []
  }
  get currentLevel() {
    return this.streamController.currentLevel
  }
  set currentLevel(e) {
    G.log(`set currentLevel:${e}`), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
  }
  get nextLevel() {
    return this.streamController.nextLevel
  }
  set nextLevel(e) {
    G.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
  }
  get loadLevel() {
    return this.levelController.level
  }
  set loadLevel(e) {
    G.log(`set loadLevel:${e}`), this.levelController.manualLevel = e
  }
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel
  }
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e
  }
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
  }
  set firstLevel(e) {
    G.log(`set firstLevel:${e}`), this.levelController.firstLevel = e
  }
  get startLevel() {
    return this.levelController.startLevel
  }
  set startLevel(e) {
    G.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
  }
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize
  }
  set capLevelToPlayerSize(e) {
    const r = !!e;
    r !== this.config.capLevelToPlayerSize && (r ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = r)
  }
  get autoLevelCapping() {
    return this._autoLevelCapping
  }
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN
  }
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN
  }
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (G.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e)
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel
  }
  set maxHdcpLevel(e) {
    GA.indexOf(e) > -1 && (this._maxHdcpLevel = e)
  }
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1
  }
  get manualLevel() {
    return this.levelController.manualLevel
  }
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: r
      }
    } = this;
    if (!e) return 0;
    const n = e.length;
    for (let i = 0; i < n; i++)
      if (e[i].maxBitrate >= r) return i;
    return 0
  }
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: r,
      maxHdcpLevel: n
    } = this;
    let i;
    if (r === -1 && e && e.length ? i = e.length - 1 : i = r, n)
      for (let a = i; a--;) {
        const s = e[a].attrs["HDCP-LEVEL"];
        if (s && s <= n) return a
      }
    return i
  }
  get nextAutoLevel() {
    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
  }
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
  }
  get playingDate() {
    return this.streamController.currentProgramDateTime
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo()
  }
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : []
  }
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1
  }
  set audioTrack(e) {
    const r = this.audioTrackController;
    r && (r.audioTrack = e)
  }
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : []
  }
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1
  }
  get media() {
    return this._media
  }
  set subtitleTrack(e) {
    const r = this.subtitleTrackController;
    r && (r.subtitleTrack = e)
  }
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1
  }
  set subtitleDisplay(e) {
    const r = this.subtitleTrackController;
    r && (r.subtitleDisplay = e)
  }
  get lowLatencyMode() {
    return this.config.lowLatencyMode
  }
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e
  }
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition
  }
  get latency() {
    return this.latencyController.latency
  }
  get maxLatency() {
    return this.latencyController.maxLatency
  }
  get targetLatency() {
    return this.latencyController.targetLatency
  }
  get drift() {
    return this.latencyController.drift
  }
  get forceStartLoad() {
    return this.streamController.forceStartLoad
  }
}
Za.defaultConfig = void 0;

function SVe(t) {
  switch (t.code) {
    case MediaError.MEDIA_ERR_ABORTED:
      return {
        code: "ABORTED", description: "Video was aborted"
      };
    case MediaError.MEDIA_ERR_NETWORK:
      return {
        code: "NETWORK_ERROR", description: "A network error occured, the video failed to stream"
      };
    case MediaError.MEDIA_ERR_DECODE:
      return {
        code: "DECODE_ERROR", description: "Video stream could not be decoded"
      };
    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
      return {
        code: "SRC_NOT_SUPPORTED", description: "The video type is not supported by your browser"
      };
    default:
      return {
        code: "UNKNOWN_ERROR", description: "Unknown media error occured"
      }
  }
}

function _Ve(t, e) {
  const r = e,
    n = br(t);
  return {
    getId() {
      return "video"
    },
    play() {
      r.play()
    },
    pause() {
      r.pause()
    },
    exitFullscreen() {
      xn.fullscreenElement && xn.exitFullscreen()
    },
    enterFullscreen() {
      if (!(!fO() || xn.fullscreenElement)) {
        if (cE()) {
          n.wrapperElement && xn.requestFullscreen(n.wrapperElement);
          return
        }
        uO() && r.webkitEnterFullscreen()
      }
    },
    startAirplay() {
      const i = r;
      i.webkitShowPlaybackTargetPicker && i.webkitShowPlaybackTargetPicker()
    },
    setTime(i) {
      let a = Math.min(i, r.duration);
      a = Math.max(0, a), !Number.isNaN(a) && (r.currentTime = a, n.progress.time = a, Xa(t, n))
    },
    setSeeking(i) {
      if (n.mediaPlaying.isSeeking = i, n.mediaPlaying.isDragSeeking = i, Jt(t, n), !i) {
        n.pausedWhenSeeking || this.play();
        return
      }
      n.pausedWhenSeeking = n.mediaPlaying.isPaused, this.pause()
    },
    async setVolume(i) {
      let a = Math.min(i, 1);
      a = Math.max(0, a), await z0() && (r.volume = a), n.mediaPlaying.volume = a, Jt(t, n), tQ(a)
    },
    setSource(i) {
      if (!i) {
        C1(t, n), r.removeAttribute("src"), r.load(), n.source = null, io(t, n);
        return
      }
      if (C1(t, n), (i == null ? void 0 : i.type) === Ct.HLS)
        if (r.canPlayType("application/vnd.apple.mpegurl")) r.src = i.source;
        else {
          if (!Za.isSupported()) {
            n.error = {
              name: "Not supported",
              description: "Your browser does not support HLS video"
            }, HT(t, n);
            return
          }
          const a = new Za({
            enableWorker: !1
          });
          n.hlsInstance = a, a.on(Za.Events.ERROR, (s, o) => {
            var c;
            o.fatal && (n.error = {
              name: `error ${o.details}`,
              description: ((c = o.error) == null ? void 0 : c.message) ? ? "Something went wrong"
            }, HT(t, n)), console.error("HLS error", o)
          }), a.attachMedia(r), a.loadSource(i.source)
        }
      else i.type === Ct.MP4 && (r.src = i.source);
      n.source = {
        quality: i.quality,
        type: i.type,
        url: i.source,
        caption: null,
        embedId: i.embedId,
        providerId: i.providerId
      }, io(t, n)
    },
    setCaption(i, a) {
      var s;
      n.source && (E1((s = n.source.caption) == null ? void 0 : s.url), n.source.caption = {
        id: i,
        url: a
      }, io(t, n))
    },
    clearCaption() {
      var i;
      n.source && (E1((i = n.source.caption) == null ? void 0 : i.url), n.source.caption = null, io(t, n))
    },
    togglePictureInPicture() {
      if (qq()) {
        const i = r;
        i.webkitSetPresentationMode(i.webkitPresentationMode === "picture-in-picture" ? "inline" : "picture-in-picture")
      }
      Yq() && (r !== document.pictureInPictureElement ? r.requestPictureInPicture() : document.exitPictureInPicture())
    },
    setPlaybackSpeed(i) {
      r.playbackRate = i, n.mediaPlaying.playbackSpeed = i, Jt(t, n)
    },
    providerStart() {
      var x, b, _;
      this.setVolume(eQ());
      const i = () => {
          n.mediaPlaying.isPaused = !0, n.mediaPlaying.isPlaying = !1, Jt(t, n)
        },
        a = () => {
          n.mediaPlaying.isPaused = !1, n.mediaPlaying.isPlaying = !0, n.mediaPlaying.isLoading = !1, n.mediaPlaying.hasPlayedOnce = !0, Jt(t, n)
        },
        s = () => {
          n.mediaPlaying.isLoading = !0, Jt(t, n)
        },
        o = () => {
          n.mediaPlaying.isSeeking = !0, Jt(t, n)
        },
        c = () => {
          n.mediaPlaying.isSeeking = !1, Jt(t, n)
        },
        l = () => {
          n.progress.duration = r.duration, Xa(t, n)
        },
        u = () => {
          n.progress.duration = r.duration, n.progress.time = r.currentTime, Xa(t, n)
        },
        f = () => {
          n.progress.buffered = Yje(r.currentTime, r.buffered), Xa(t, n)
        },
        d = () => {
          n.mediaPlaying.isFirstLoading = !1, n.mediaPlaying.isLoading = !1, Jt(t, n)
        },
        h = () => {
          n.mediaPlaying.playbackSpeed = r.playbackRate, Jt(t, n)
        },
        p = () => {
          n.interface.isFullscreen = !!document.fullscreenElement || !!document.webkitFullscreenElement, mn(t, n)
        },
        v = async () => {
          await z0() && (n.mediaPlaying.volume = r.volume, Jt(t, n))
        }, g = S => {
          n.interface.isFocused = S.type !== "mouseleave", mn(t, n)
        }, m = S => {
          S.availability === "available" && (n.canAirplay = !0, sd(t, n))
        }, y = () => {
          if (r.error) {
            const S = SVe(r.error);
            console.error("Native video player threw error", r.error), n.error = {
              description: S.description,
              name: `Error ${S.code}`
            }, this.pause()
          } else n.error = null;
          HT(t, n)
        };
      return (x = n.wrapperElement) == null || x.addEventListener("click", g), (b = n.wrapperElement) == null || b.addEventListener("mouseenter", g), (_ = n.wrapperElement) == null || _.addEventListener("mouseleave", g), r.addEventListener("volumechange", v), r.addEventListener("pause", i), r.addEventListener("playing", a), r.addEventListener("seeking", o), r.addEventListener("seeked", c), r.addEventListener("progress", f), r.addEventListener("waiting", s), r.addEventListener("timeupdate", u), r.addEventListener("loadedmetadata", l), r.addEventListener("canplay", d), r.addEventListener("ratechange", h), xn.addEventListener("fullscreenchange", p), r.addEventListener("error", y), r.addEventListener("webkitplaybacktargetavailabilitychanged", m), n.source && this.setSource({
        quality: n.source.quality,
        source: n.source.url,
        type: n.source.type,
        embedId: n.source.embedId,
        providerId: n.source.providerId
      }), {
        destroy: () => {
          var S, T, R;
          r.removeEventListener("pause", i), r.removeEventListener("playing", a), r.removeEventListener("seeking", o), r.removeEventListener("volumechange", v), r.removeEventListener("seeked", c), r.removeEventListener("timeupdate", u), r.removeEventListener("loadedmetadata", l), r.removeEventListener("progress", f), r.removeEventListener("waiting", s), r.removeEventListener("error", y), r.removeEventListener("canplay", d), xn.removeEventListener("fullscreenchange", p), (S = n.wrapperElement) == null || S.removeEventListener("click", g), (T = n.wrapperElement) == null || T.removeEventListener("mouseenter", g), (R = n.wrapperElement) == null || R.removeEventListener("mouseleave", g), r.removeEventListener("webkitplaybacktargetavailabilitychanged", m)
        }
      }
    }
  }
}

function TVe(t) {
  const e = Re(),
    r = Cn(e),
    n = Ss(e),
    i = A.useRef(null),
    a = A.useMemo(() => !!n.wrapperInitialized, [n]),
    s = A.useMemo(() => n.stateProviderId, [n]);
  return A.useEffect(() => {
    if (!a || !i.current) return;
    const o = _Ve(e, i.current);
    rQ(e, o);
    const {
      destroy: c
    } = o.providerStart();
    return () => {
      try {
        nQ(e, o.getId())
      } catch {}
      c()
    }
  }, [e, a, s]), E("video", {
    ref: i,
    autoPlay: t.autoPlay,
    muted: r.volume === 0,
    playsInline: !0,
    className: "z-0 h-full w-full"
  })
}

function wVe(t) {
  const e = Re();
  return Ss(e).stateProviderId !== "video" ? null : E(TVe, {
    ...t
  })
}

function RVe(t) {
  const e = A.useRef(null),
    r = Re(),
    n = Bi(r),
    i = ui(r),
    a = typeof t.children == "function" ? t.children({
      isFullscreen: n.isFullscreen
    }) : t.children;
  return E(Qje, {
    onGoBack: t.onGoBack,
    media: i == null ? void 0 : i.meta.meta,
    children: Y("div", {
      ref: e,
      className: ["is-video-player popout-location relative h-full w-full select-none overflow-hidden bg-black", t.includeSafeArea || n.isFullscreen ? "[border-left:env(safe-area-inset-left)_solid_transparent] [border-right:env(safe-area-inset-right)_solid_transparent]" : ""].join(" "),
      children: [E(Zje, {}), E(wVe, {
        autoPlay: t.autoPlay
      }), E(qje, {}), E(Xje, {
        wrapper: e.current
      }), E("div", {
        className: "absolute inset-0",
        children: a
      })]
    })
  })
}

function AVe(t) {
  return E(V6e, {
    children: E(RVe, {
      ...t
    })
  })
}

function eZ({
  text: t,
  scale: e
}) {
  const {
    captionSettings: r
  } = id(), n = (t || "").replaceAll(/\r?\n/g, "<br />"), i = $Be(n, {
    ALLOWED_TAGS: ["c", "b", "i", "u", "span", "ruby", "rt", "br"],
    ADD_TAGS: ["v", "lang"],
    ALLOWED_ATTR: ["title", "lang"]
  });
  return E("p", {
    className: "pointer-events-none mb-1 select-none rounded px-4 py-1 text-center [text-shadow:0_2px_4px_rgba(0,0,0,0.5)]",
    style: {
      ...r.style,
      fontSize: r.style.fontSize * (e ? ? 1)
    },
    children: E("span", {
      dangerouslySetInnerHTML: {
        __html: i
      },
      dir: "auto"
    })
  })
}

function IVe({
  isControlsShown: t
}) {
  var u, f;
  const e = Re(),
    r = vg(e).source,
    n = Xo(e).time,
    {
      captionSettings: i,
      setCaptionDelay: a
    } = id(),
    s = A.useRef([]),
    o = A.useRef(a);
  A.useEffect(() => {
    o.current = a
  }, [a]), kMe(async () => {
    var h;
    const d = (h = r == null ? void 0 : r.caption) == null ? void 0 : h.url;
    if (d) {
      const v = await (await fetch(d)).text();
      try {
        s.current = Oq(v)
      } catch {
        s.current = []
      }
      a(0)
    } else s.current = []
  }, [(u = r == null ? void 0 : r.caption) == null ? void 0 : u.url]), A.useEffect(() => {
    o.current(0)
  }, [(f = r == null ? void 0 : r.caption) == null ? void 0 : f.url]);
  const c = A.useCallback((d, h, p, v) => {
    const g = d / 1e3 + p,
      m = h / 1e3 + p;
    return Math.max(0, g) <= v && Math.max(0, m) >= v
  }, []);
  if (!s.current.length) return null;
  const l = s.current.filter(({
    start: d,
    end: h
  }) => c(d, h, i.delay, n));
  return E($i, {
    className: ["pointer-events-none absolute flex w-full flex-col items-center transition-[bottom]", t ? "bottom-24" : "bottom-12"].join(" "),
    animation: "slide-up",
    show: !0,
    children: l.map(({
      start: d,
      end: h,
      content: p
    }) => E(eZ, {
      text: p
    }, `${d}-${h}`))
  })
}

function $Ve() {
  const t = Re(),
    e = ui(t);
  return (e == null ? void 0 : e.meta.meta.type) !== ae.SERIES ? null : E("div", {
    className: "mx-2 h-6 w-px bg-white opacity-50"
  })
}

function SB(t) {
  const {
    t: e
  } = ke(), r = Re(), n = st(r), i = Bi(r), {
    isMobile: a
  } = Aa(!1);
  return E("div", {
    className: t.className,
    children: E("div", {
      className: "relative",
      children: E(nX, {
        id: "settings",
        children: E(Ts, {
          active: i.popout === "settings",
          className: t.className,
          onClick: () => n.openPopout("settings"),
          text: a ? e("videoPlayer.buttons.settings") : void 0,
          icon: ue.GEAR
        })
      })
    })
  })
}

function CVe() {
  const t = Re(),
    e = Bi(t),
    r = Cn(t);
  return Y("div", {
    className: [e.volumeChangedWithKeybind ? "mt-10 scale-100 opacity-100" : "mt-5 scale-75 opacity-0", "absolute left-1/2 z-[100] flex -translate-x-1/2 items-center space-x-4 rounded-full bg-bink-300 bg-opacity-50 px-5 py-2 transition-all duration-100"].join(" "),
    children: [E(Ve, {
      icon: r.volume > 0 ? ue.VOLUME : ue.VOLUME_X,
      className: "text-xl text-white"
    }), E("div", {
      className: "h-2 w-44 overflow-hidden rounded-full bg-denim-100",
      children: E("div", {
        className: "h-full rounded-r-full bg-bink-500 transition-[width] duration-100",
        style: {
          width: `${r.volume*100}%`
        }
      })
    })]
  })
}

function Ew(t) {
  return E("div", {
    className: "absolute inset-0 flex items-center justify-center",
    children: t.children
  })
}

function kVe() {
  const t = Re(),
    e = st(t),
    r = A.useCallback(() => {
      e.setLeftControlsHover(!0)
    }, [e]),
    n = A.useCallback(() => {
      e.setLeftControlsHover(!1)
    }, [e]);
  return Y(yr, {
    children: [Y("div", {
      className: "flex items-center px-2",
      onMouseLeave: n,
      onMouseEnter: r,
      children: [E(Zq, {}), E(YUe, {}), E(t7e, {
        className: "mr-2"
      }), E(iX, {})]
    }), E(JUe, {})]
  })
}

function OVe(t) {
  const [e, r] = A.useState(!1), {
    isMobile: n
  } = Aa(), i = A.useCallback(a => {
    r(a)
  }, [r]);
  return E(AVe, {
    autoPlay: t.autoPlay,
    includeSafeArea: t.includeSafeArea,
    onGoBack: t.onGoBack,
    children: ({
      isFullscreen: a
    }) => Y(yr, {
      children: [E(VUe, {}), E(XUe, {}), E(CVe, {}), Y(n7e, {
        onGoBack: t.onGoBack,
        children: [Y(UUe, {
          onBackdropChange: i,
          children: [E(Ew, {
            children: E(WUe, {})
          }), E(Ew, {
            children: E(jUe, {})
          }), E(Ew, {
            children: E(KUe, {})
          }), n ? E($i, {
            animation: "fade",
            show: e,
            className: "absolute inset-0 flex items-center justify-center",
            children: E(qUe, {})
          }) : "", E($i, {
            animation: "slide-down",
            show: e,
            className: "pointer-events-auto absolute inset-x-0 top-0 flex flex-col px-8 py-6 pb-2",
            children: E(GUe, {
              showControls: n,
              onClick: t.onGoBack,
              isFullScreen: !0
            })
          }), Y($i, {
            animation: "slide-up",
            show: e,
            className: ["pointer-events-auto absolute inset-x-0 bottom-0 flex flex-col px-4 pb-2", t.includeSafeArea || a ? "[margin-bottom:env(safe-area-inset-bottom)]" : ""].join(" "),
            children: [Y("div", {
              className: "flex w-full items-center space-x-3",
              children: [n && E(iX, {
                noDuration: !0
              }), E(ZUe, {})]
            }), E("div", {
              className: "flex items-center",
              children: n ? Y("div", {
                className: "grid w-full grid-cols-[56px,1fr,56px] items-center",
                children: [E("div", {}), Y("div", {
                  className: "flex items-center justify-center",
                  children: [E(V6, {}), E(G6, {}), E(SB, {})]
                }), E(z6, {})]
              }) : Y(yr, {
                children: [E(kVe, {}), E("div", {
                  className: "flex-1"
                }), E(V6, {}), E($Ve, {}), E(SB, {}), E(Nq, {}), E(Pq, {}), E(G6, {}), E(z6, {})]
              })
            })]
          }), e ? E(jje, {}) : null]
        }), E(IVe, {
          isControlsShown: e
        }), t.children]
      })]
    })
  })
}

function LVe() {
  const {
    t
  } = ke(), e = nE();
  return Y("div", {
    className: "flex-1",
    children: [E(va, {
      children: E("title", {
        children: t("media.errors.failedMeta")
      })
    }), E("div", {
      className: "fixed inset-x-0 top-0 px-8 py-6",
      children: E(Ec, {
        onClick: e
      })
    }), E(Gk, {
      children: E("p", {
        className: "my-6 max-w-lg",
        children: t("media.errors.mediaFailed")
      })
    })]
  })
}

function _B() {
  return E("div", {
    className: "h-9 w-[220px] rounded-full bg-slate-800 opacity-50"
  })
}

function PVe({
  event: t
}) {
  return Y("div", {
    className: "flex h-9 w-[220px] items-center rounded-full bg-slate-800 p-3 text-denim-700",
    children: [E("div", {
      className: "mr-2 flex w-[18px] items-center justify-center",
      children: t.errored ? E(Ve, {
        icon: ue.X,
        className: "text-[0.85em] text-rose-400"
      }) : E(VX, {
        className: "h-[18px] w-[18px] text-bink-700",
        percentage: t.percentage,
        radius: 40
      })
    }), E("div", {
      className: "flex-1 overflow-hidden",
      children: E("p", {
        className: `overflow-hidden text-ellipsis whitespace-nowrap ${t.errored?"text-rose-400":""}`,
        children: t.id
      })
    })]
  })
}

function NVe(t) {
  return Y("div", {
    className: "relative h-16 w-[400px] overflow-hidden",
    children: [E("div", {
      className: "absolute inset-0 flex items-center justify-center",
      children: E("div", {
        className: "relative flex h-full w-[220px] items-center",
        children: Y("div", {
          className: "absolute inset-y-0 left-0 flex items-center gap-[16px] transition-transform duration-200",
          style: {
            transform: `translateX(${-1*(220+16)*t.events.length}px)`
          },
          children: [E(_B, {}), t.events.map(e => E(PVe, {
            event: e
          }, e.eventId)), E(_B, {})]
        })
      })
    }), E("div", {
      className: "absolute inset-y-0 left-0 w-40 bg-gradient-to-r from-denim-100 to-transparent"
    }), E("div", {
      className: "absolute inset-y-0 right-0 w-40 bg-gradient-to-l from-denim-100 to-transparent"
    })]
  })
}

function TB(t) {
  return E("div", {
    className: "relative my-4 max-w-[18rem]",
    children: E(Um, {
      value: t.selectedItem,
      onChange: t.setSelectedItem,
      children: ({
        open: e
      }) => Y(yr, {
        children: [Y(Um.Button, {
          className: "relative w-full cursor-default rounded-lg bg-denim-500 py-2 pl-3 pr-10 text-left text-white shadow-md focus:outline-none focus-visible:border-indigo-500 focus-visible:ring-2 focus-visible:ring-bink-500  focus-visible:ring-opacity-75 focus-visible:ring-offset-2 focus-visible:ring-offset-bink-300 sm:text-sm",
          children: [E("span", {
            className: "block truncate",
            children: t.selectedItem.name
          }), E("span", {
            className: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2",
            children: E(Ve, {
              icon: ue.CHEVRON_DOWN,
              className: `transform transition-transform ${e?"rotate-180":""}`
            })
          })]
        }), E(TA, {
          as: A.Fragment,
          leave: "transition ease-in duration-100",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0",
          children: E(Um.Options, {
            className: "absolute left-0 right-0 top-10 z-10 mt-1 max-h-60 overflow-auto rounded-md bg-denim-500 py-1 text-white shadow-lg ring-1 ring-black ring-opacity-5 scrollbar-thin scrollbar-track-denim-400 scrollbar-thumb-denim-200 focus:outline-none sm:top-10 sm:text-sm",
            children: t.options.map(r => E(Um.Option, {
              className: ({
                active: n
              }) => `relative cursor-default select-none py-2 pl-10 pr-4 ${n?"bg-denim-400 text-bink-700":"text-white"}`,
              value: r,
              children: r.name
            }, r.id))
          })
        })]
      })
    })
  })
}

function DVe(t) {
  return Y(yr, {
    children: [E(va, {
      children: E("body", {
        "data-no-scroll": !0
      })
    }), Y("div", {
      className: "fixed inset-0 z-[99999]",
      children: [E($i, {
        animation: "fade",
        className: "absolute inset-0 bg-[rgba(8,6,18,0.85)]",
        isChild: !0
      }), t.children]
    })]
  })
}

function MVe(t) {
  return E($i, {
    className: "fixed inset-0 z-[9999]",
    animation: "none",
    show: t.show,
    children: E(DVe, {
      children: E($i, {
        isChild: !0,
        className: "flex h-full w-full items-center justify-center",
        animation: "slide-up",
        children: t.children
      })
    })
  })
}

function tZ(t) {
  return ql.createPortal(E(MVe, {
    show: t.show,
    children: t.children
  }), document.body)
}

function rZ(t) {
  return E("div", {
    className: ["relative mx-2 w-[500px] overflow-hidden rounded-lg bg-denim-300 px-10 py-10 sm:w-[500px] md:w-[500px] lg:w-[1000px]", t.className ? ? ""].join(" "),
    children: t.children
  })
}

function yo(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t
}

function SE(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && u1(t, e)
}

function yg(t, e) {
  if (e && (Vt(e) === "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return yo(t)
}

function xa(t) {
  return xa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (r) {
    return r.__proto__ || Object.getPrototypeOf(r)
  }, xa(t)
}

function FVe(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function BVe(t) {
  return UY(t) || FVe(t) || jY(t) || HY()
}

function wB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function RB(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? wB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : wB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}
var UVe = {
    type: "logger",
    log: function (e) {
      this.output("log", e)
    },
    warn: function (e) {
      this.output("warn", e)
    },
    error: function (e) {
      this.output("error", e)
    },
    output: function (e, r) {
      console && console[e] && console[e].apply(console, r)
    }
  },
  jVe = function () {
    function t(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Di(this, t), this.init(e, r)
    }
    return Mi(t, [{
      key: "init",
      value: function (r) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = n.prefix || "i18next:", this.logger = r || UVe, this.options = n, this.debug = n.debug
      }
    }, {
      key: "setDebug",
      value: function (r) {
        this.debug = r
      }
    }, {
      key: "log",
      value: function () {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return this.forward(n, "log", "", !0)
      }
    }, {
      key: "warn",
      value: function () {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return this.forward(n, "warn", "", !0)
      }
    }, {
      key: "error",
      value: function () {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return this.forward(n, "error", "")
      }
    }, {
      key: "deprecate",
      value: function () {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return this.forward(n, "warn", "WARNING DEPRECATED: ", !0)
      }
    }, {
      key: "forward",
      value: function (r, n, i, a) {
        return a && !this.debug ? null : (typeof r[0] == "string" && (r[0] = "".concat(i).concat(this.prefix, " ").concat(r[0])), this.logger[n](r))
      }
    }, {
      key: "create",
      value: function (r) {
        return new t(this.logger, RB(RB({}, {
          prefix: "".concat(this.prefix, ":").concat(r, ":")
        }), this.options))
      }
    }, {
      key: "clone",
      value: function (r) {
        return r = r || this.options, r.prefix = r.prefix || this.prefix, new t(this.logger, r)
      }
    }]), t
  }(),
  la = new jVe,
  Do = function () {
    function t() {
      Di(this, t), this.observers = {}
    }
    return Mi(t, [{
      key: "on",
      value: function (r, n) {
        var i = this;
        return r.split(" ").forEach(function (a) {
          i.observers[a] = i.observers[a] || [], i.observers[a].push(n)
        }), this
      }
    }, {
      key: "off",
      value: function (r, n) {
        if (this.observers[r]) {
          if (!n) {
            delete this.observers[r];
            return
          }
          this.observers[r] = this.observers[r].filter(function (i) {
            return i !== n
          })
        }
      }
    }, {
      key: "emit",
      value: function (r) {
        for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) i[a - 1] = arguments[a];
        if (this.observers[r]) {
          var s = [].concat(this.observers[r]);
          s.forEach(function (c) {
            c.apply(void 0, i)
          })
        }
        if (this.observers["*"]) {
          var o = [].concat(this.observers["*"]);
          o.forEach(function (c) {
            c.apply(c, [r].concat(i))
          })
        }
      }
    }]), t
  }();

function oh() {
  var t, e, r = new Promise(function (n, i) {
    t = n, e = i
  });
  return r.resolve = t, r.reject = e, r
}

function AB(t) {
  return t == null ? "" : "" + t
}

function HVe(t, e, r) {
  t.forEach(function (n) {
    e[n] && (r[n] = e[n])
  })
}

function HO(t, e, r) {
  function n(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o
  }

  function i() {
    return !t || typeof t == "string"
  }
  for (var a = typeof e != "string" ? [].concat(e) : e.split("."); a.length > 1;) {
    if (i()) return {};
    var s = n(a.shift());
    !t[s] && r && (t[s] = new r), Object.prototype.hasOwnProperty.call(t, s) ? t = t[s] : t = {}
  }
  return i() ? {} : {
    obj: t,
    k: n(a.shift())
  }
}

function IB(t, e, r) {
  var n = HO(t, e, Object),
    i = n.obj,
    a = n.k;
  i[a] = r
}

function zVe(t, e, r, n) {
  var i = HO(t, e, Object),
    a = i.obj,
    s = i.k;
  a[s] = a[s] || [], n && (a[s] = a[s].concat(r)), n || a[s].push(r)
}

function M1(t, e) {
  var r = HO(t, e),
    n = r.obj,
    i = r.k;
  if (n) return n[i]
}

function GVe(t, e, r) {
  var n = M1(t, r);
  return n !== void 0 ? n : M1(e, r)
}

function nZ(t, e, r) {
  for (var n in e) n !== "__proto__" && n !== "constructor" && (n in t ? typeof t[n] == "string" || t[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? r && (t[n] = e[n]) : nZ(t[n], e[n], r) : t[n] = e[n]);
  return t
}

function qc(t) {
  return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var VVe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};

function WVe(t) {
  return typeof t == "string" ? t.replace(/[&<>"'\/]/g, function (e) {
    return VVe[e]
  }) : t
}
var _E = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1,
  KVe = [" ", ",", "?", "!", ";"];

function YVe(t, e, r) {
  e = e || "", r = r || "";
  var n = KVe.filter(function (o) {
    return e.indexOf(o) < 0 && r.indexOf(o) < 0
  });
  if (n.length === 0) return !0;
  var i = new RegExp("(".concat(n.map(function (o) {
      return o === "?" ? "\\?" : o
    }).join("|"), ")")),
    a = !i.test(t);
  if (!a) {
    var s = t.indexOf(r);
    s > 0 && !i.test(t.substring(0, s)) && (a = !0)
  }
  return a
}

function F1(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (t) {
    if (t[e]) return t[e];
    for (var n = e.split(r), i = t, a = 0; a < n.length; ++a) {
      if (!i || typeof i[n[a]] == "string" && a + 1 < n.length) return;
      if (i[n[a]] === void 0) {
        for (var s = 2, o = n.slice(a, a + s).join(r), c = i[o]; c === void 0 && n.length > a + s;) s++, o = n.slice(a, a + s).join(r), c = i[o];
        if (c === void 0) return;
        if (c === null) return null;
        if (e.endsWith(o)) {
          if (typeof c == "string") return c;
          if (o && typeof c[o] == "string") return c[o]
        }
        var l = n.slice(a + s).join(r);
        return l ? F1(c, l, r) : void 0
      }
      i = i[n[a]]
    }
    return i
  }
}

function $B(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function Jm(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $B(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : $B(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function qVe(t) {
  var e = XVe();
  return function () {
    var n = xa(t),
      i;
    if (e) {
      var a = xa(this).constructor;
      i = Reflect.construct(n, arguments, a)
    } else i = n.apply(this, arguments);
    return yg(this, i)
  }
}

function XVe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
  } catch {
    return !1
  }
}
var QVe = function (t) {
    SE(r, t);
    var e = qVe(r);

    function r(n) {
      var i, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        ns: ["translation"],
        defaultNS: "translation"
      };
      return Di(this, r), i = e.call(this), _E && Do.call(yo(i)), i.data = n || {}, i.options = a, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.options.ignoreJSONStructure === void 0 && (i.options.ignoreJSONStructure = !0), i
    }
    return Mi(r, [{
      key: "addNamespaces",
      value: function (i) {
        this.options.ns.indexOf(i) < 0 && this.options.ns.push(i)
      }
    }, {
      key: "removeNamespaces",
      value: function (i) {
        var a = this.options.ns.indexOf(i);
        a > -1 && this.options.ns.splice(a, 1)
      }
    }, {
      key: "getResource",
      value: function (i, a, s) {
        var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
          c = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator,
          l = o.ignoreJSONStructure !== void 0 ? o.ignoreJSONStructure : this.options.ignoreJSONStructure,
          u = [i, a];
        s && typeof s != "string" && (u = u.concat(s)), s && typeof s == "string" && (u = u.concat(c ? s.split(c) : s)), i.indexOf(".") > -1 && (u = i.split("."));
        var f = M1(this.data, u);
        return f || !l || typeof s != "string" ? f : F1(this.data && this.data[i] && this.data[i][a], s, c)
      }
    }, {
      key: "addResource",
      value: function (i, a, s, o) {
        var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: !1
          },
          l = this.options.keySeparator;
        l === void 0 && (l = ".");
        var u = [i, a];
        s && (u = u.concat(l ? s.split(l) : s)), i.indexOf(".") > -1 && (u = i.split("."), o = a, a = u[1]), this.addNamespaces(a), IB(this.data, u, o), c.silent || this.emit("added", i, a, s, o)
      }
    }, {
      key: "addResources",
      value: function (i, a, s) {
        var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
          silent: !1
        };
        for (var c in s)(typeof s[c] == "string" || Object.prototype.toString.apply(s[c]) === "[object Array]") && this.addResource(i, a, c, s[c], {
          silent: !0
        });
        o.silent || this.emit("added", i, a, s)
      }
    }, {
      key: "addResourceBundle",
      value: function (i, a, s, o, c) {
        var l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: !1
          },
          u = [i, a];
        i.indexOf(".") > -1 && (u = i.split("."), o = s, s = a, a = u[1]), this.addNamespaces(a);
        var f = M1(this.data, u) || {};
        o ? nZ(f, s, c) : f = Jm(Jm({}, f), s), IB(this.data, u, f), l.silent || this.emit("added", i, a, s)
      }
    }, {
      key: "removeResourceBundle",
      value: function (i, a) {
        this.hasResourceBundle(i, a) && delete this.data[i][a], this.removeNamespaces(a), this.emit("removed", i, a)
      }
    }, {
      key: "hasResourceBundle",
      value: function (i, a) {
        return this.getResource(i, a) !== void 0
      }
    }, {
      key: "getResourceBundle",
      value: function (i, a) {
        return a || (a = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Jm(Jm({}, {}), this.getResource(i, a)) : this.getResource(i, a)
      }
    }, {
      key: "getDataByLanguage",
      value: function (i) {
        return this.data[i]
      }
    }, {
      key: "hasLanguageSomeTranslations",
      value: function (i) {
        var a = this.getDataByLanguage(i),
          s = a && Object.keys(a) || [];
        return !!s.find(function (o) {
          return a[o] && Object.keys(a[o]).length > 0
        })
      }
    }, {
      key: "toJSON",
      value: function () {
        return this.data
      }
    }]), r
  }(Do),
  iZ = {
    processors: {},
    addPostProcessor: function (e) {
      this.processors[e.name] = e
    },
    handle: function (e, r, n, i, a) {
      var s = this;
      return e.forEach(function (o) {
        s.processors[o] && (r = s.processors[o].process(r, n, i, a))
      }), r
    }
  };

function CB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function ur(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? CB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : CB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function ZVe(t) {
  var e = JVe();
  return function () {
    var n = xa(t),
      i;
    if (e) {
      var a = xa(this).constructor;
      i = Reflect.construct(n, arguments, a)
    } else i = n.apply(this, arguments);
    return yg(this, i)
  }
}

function JVe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
  } catch {
    return !1
  }
}
var kB = {},
  OB = function (t) {
    SE(r, t);
    var e = ZVe(r);

    function r(n) {
      var i, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return Di(this, r), i = e.call(this), _E && Do.call(yo(i)), HVe(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], n, yo(i)), i.options = a, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.logger = la.create("translator"), i
    }
    return Mi(r, [{
      key: "changeLanguage",
      value: function (i) {
        i && (this.language = i)
      }
    }, {
      key: "exists",
      value: function (i) {
        var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        if (i == null) return !1;
        var s = this.resolve(i, a);
        return s && s.res !== void 0
      }
    }, {
      key: "extractFromKey",
      value: function (i, a) {
        var s = a.nsSeparator !== void 0 ? a.nsSeparator : this.options.nsSeparator;
        s === void 0 && (s = ":");
        var o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator,
          c = a.ns || this.options.defaultNS || [],
          l = s && i.indexOf(s) > -1,
          u = !this.options.userDefinedKeySeparator && !a.keySeparator && !this.options.userDefinedNsSeparator && !a.nsSeparator && !YVe(i, s, o);
        if (l && !u) {
          var f = i.match(this.interpolator.nestingRegexp);
          if (f && f.length > 0) return {
            key: i,
            namespaces: c
          };
          var d = i.split(s);
          (s !== o || s === o && this.options.ns.indexOf(d[0]) > -1) && (c = d.shift()), i = d.join(o)
        }
        return typeof c == "string" && (c = [c]), {
          key: i,
          namespaces: c
        }
      }
    }, {
      key: "translate",
      value: function (i, a, s) {
        var o = this;
        if (Vt(a) !== "object" && this.options.overloadTranslationOptionHandler && (a = this.options.overloadTranslationOptionHandler(arguments)), Vt(a) === "object" && (a = ur({}, a)), a || (a = {}), i == null) return "";
        Array.isArray(i) || (i = [String(i)]);
        var c = a.returnDetails !== void 0 ? a.returnDetails : this.options.returnDetails,
          l = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator,
          u = this.extractFromKey(i[i.length - 1], a),
          f = u.key,
          d = u.namespaces,
          h = d[d.length - 1],
          p = a.lng || this.language,
          v = a.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (p && p.toLowerCase() === "cimode") {
          if (v) {
            var g = a.nsSeparator || this.options.nsSeparator;
            return c ? {
              res: "".concat(h).concat(g).concat(f),
              usedKey: f,
              exactUsedKey: f,
              usedLng: p,
              usedNS: h
            } : "".concat(h).concat(g).concat(f)
          }
          return c ? {
            res: f,
            usedKey: f,
            exactUsedKey: f,
            usedLng: p,
            usedNS: h
          } : f
        }
        var m = this.resolve(i, a),
          y = m && m.res,
          x = m && m.usedKey || f,
          b = m && m.exactUsedKey || f,
          _ = Object.prototype.toString.apply(y),
          S = ["[object Number]", "[object Function]", "[object RegExp]"],
          T = a.joinArrays !== void 0 ? a.joinArrays : this.options.joinArrays,
          R = !this.i18nFormat || this.i18nFormat.handleAsObject,
          I = typeof y != "string" && typeof y != "boolean" && typeof y != "number";
        if (R && y && I && S.indexOf(_) < 0 && !(typeof T == "string" && _ === "[object Array]")) {
          if (!a.returnObjects && !this.options.returnObjects) {
            this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            var w = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(x, y, ur(ur({}, a), {}, {
              ns: d
            })) : "key '".concat(f, " (").concat(this.language, ")' returned an object instead of string.");
            return c ? (m.res = w, m) : w
          }
          if (l) {
            var C = _ === "[object Array]",
              L = C ? [] : {},
              H = C ? b : x;
            for (var N in y)
              if (Object.prototype.hasOwnProperty.call(y, N)) {
                var P = "".concat(H).concat(l).concat(N);
                L[N] = this.translate(P, ur(ur({}, a), {
                  joinArrays: !1,
                  ns: d
                })), L[N] === P && (L[N] = y[N])
              } y = L
          }
        } else if (R && typeof T == "string" && _ === "[object Array]") y = y.join(T), y && (y = this.extendTranslation(y, i, a, s));
        else {
          var B = !1,
            V = !1,
            M = a.count !== void 0 && typeof a.count != "string",
            U = r.hasDefaultValue(a),
            W = M ? this.pluralResolver.getSuffix(p, a.count, a) : "",
            k = a["defaultValue".concat(W)] || a.defaultValue;
          !this.isValidLookup(y) && U && (B = !0, y = k), this.isValidLookup(y) || (V = !0, y = f);
          var O = a.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey,
            F = O && V ? void 0 : y,
            D = U && k !== y && this.options.updateMissing;
          if (V || B || D) {
            if (this.logger.log(D ? "updateKey" : "missingKey", p, h, f, D ? k : y), l) {
              var Q = this.resolve(f, ur(ur({}, a), {}, {
                keySeparator: !1
              }));
              Q && Q.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
            }
            var ee = [],
              de = this.languageUtils.getFallbackCodes(this.options.fallbackLng, a.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && de && de[0])
              for (var oe = 0; oe < de.length; oe++) ee.push(de[oe]);
            else this.options.saveMissingTo === "all" ? ee = this.languageUtils.toResolveHierarchy(a.lng || this.language) : ee.push(a.lng || this.language);
            var rt = function (Dr, un, Tt) {
              var wt = U && Tt !== y ? Tt : F;
              o.options.missingKeyHandler ? o.options.missingKeyHandler(Dr, h, un, wt, D, a) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing(Dr, h, un, wt, D, a), o.emit("missingKey", Dr, h, un, y)
            };
            this.options.saveMissing && (this.options.saveMissingPlurals && M ? ee.forEach(function (Ft) {
              o.pluralResolver.getSuffixes(Ft, a).forEach(function (Dr) {
                rt([Ft], f + Dr, a["defaultValue".concat(Dr)] || k)
              })
            }) : rt(ee, f, k))
          }
          y = this.extendTranslation(y, i, a, m, s), V && y === f && this.options.appendNamespaceToMissingKey && (y = "".concat(h, ":").concat(f)), (V || B) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? y = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(h, ":").concat(f) : f, B ? y : void 0) : y = this.options.parseMissingKeyHandler(y))
        }
        return c ? (m.res = y, m) : y
      }
    }, {
      key: "extendTranslation",
      value: function (i, a, s, o, c) {
        var l = this;
        if (this.i18nFormat && this.i18nFormat.parse) i = this.i18nFormat.parse(i, ur(ur({}, this.options.interpolation.defaultVariables), s), o.usedLng, o.usedNS, o.usedKey, {
          resolved: o
        });
        else if (!s.skipInterpolation) {
          s.interpolation && this.interpolator.init(ur(ur({}, s), {
            interpolation: ur(ur({}, this.options.interpolation), s.interpolation)
          }));
          var u = typeof i == "string" && (s && s.interpolation && s.interpolation.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables),
            f;
          if (u) {
            var d = i.match(this.interpolator.nestingRegexp);
            f = d && d.length
          }
          var h = s.replace && typeof s.replace != "string" ? s.replace : s;
          if (this.options.interpolation.defaultVariables && (h = ur(ur({}, this.options.interpolation.defaultVariables), h)), i = this.interpolator.interpolate(i, h, s.lng || this.language, s), u) {
            var p = i.match(this.interpolator.nestingRegexp),
              v = p && p.length;
            f < v && (s.nest = !1)
          }!s.lng && this.options.compatibilityAPI !== "v1" && o && o.res && (s.lng = o.usedLng), s.nest !== !1 && (i = this.interpolator.nest(i, function () {
            for (var y = arguments.length, x = new Array(y), b = 0; b < y; b++) x[b] = arguments[b];
            return c && c[0] === x[0] && !s.context ? (l.logger.warn("It seems you are nesting recursively key: ".concat(x[0], " in key: ").concat(a[0])), null) : l.translate.apply(l, x.concat([a]))
          }, s)), s.interpolation && this.interpolator.reset()
        }
        var g = s.postProcess || this.options.postProcess,
          m = typeof g == "string" ? [g] : g;
        return i != null && m && m.length && s.applyPostProcessor !== !1 && (i = iZ.handle(m, i, a, this.options && this.options.postProcessPassResolved ? ur({
          i18nResolved: o
        }, s) : s, this)), i
      }
    }, {
      key: "resolve",
      value: function (i) {
        var a = this,
          s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          o, c, l, u, f;
        return typeof i == "string" && (i = [i]), i.forEach(function (d) {
          if (!a.isValidLookup(o)) {
            var h = a.extractFromKey(d, s),
              p = h.key;
            c = p;
            var v = h.namespaces;
            a.options.fallbackNS && (v = v.concat(a.options.fallbackNS));
            var g = s.count !== void 0 && typeof s.count != "string",
              m = g && !s.ordinal && s.count === 0 && a.pluralResolver.shouldUseIntlApi(),
              y = s.context !== void 0 && (typeof s.context == "string" || typeof s.context == "number") && s.context !== "",
              x = s.lngs ? s.lngs : a.languageUtils.toResolveHierarchy(s.lng || a.language, s.fallbackLng);
            v.forEach(function (b) {
              a.isValidLookup(o) || (f = b, !kB["".concat(x[0], "-").concat(b)] && a.utils && a.utils.hasLoadedNamespace && !a.utils.hasLoadedNamespace(f) && (kB["".concat(x[0], "-").concat(b)] = !0, a.logger.warn('key "'.concat(c, '" for languages "').concat(x.join(", "), `" won't get resolved as namespace "`).concat(f, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), x.forEach(function (_) {
                if (!a.isValidLookup(o)) {
                  u = _;
                  var S = [p];
                  if (a.i18nFormat && a.i18nFormat.addLookupKeys) a.i18nFormat.addLookupKeys(S, p, _, b, s);
                  else {
                    var T;
                    g && (T = a.pluralResolver.getSuffix(_, s.count, s));
                    var R = "".concat(a.options.pluralSeparator, "zero");
                    if (g && (S.push(p + T), m && S.push(p + R)), y) {
                      var I = "".concat(p).concat(a.options.contextSeparator).concat(s.context);
                      S.push(I), g && (S.push(I + T), m && S.push(I + R))
                    }
                  }
                  for (var w; w = S.pop();) a.isValidLookup(o) || (l = w, o = a.getResource(_, b, w, s))
                }
              }))
            })
          }
        }), {
          res: o,
          usedKey: c,
          exactUsedKey: l,
          usedLng: u,
          usedNS: f
        }
      }
    }, {
      key: "isValidLookup",
      value: function (i) {
        return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === "")
      }
    }, {
      key: "getResource",
      value: function (i, a, s) {
        var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, a, s, o) : this.resourceStore.getResource(i, a, s, o)
      }
    }], [{
      key: "hasDefaultValue",
      value: function (i) {
        var a = "defaultValue";
        for (var s in i)
          if (Object.prototype.hasOwnProperty.call(i, s) && a === s.substring(0, a.length) && i[s] !== void 0) return !0;
        return !1
      }
    }]), r
  }(Do);

function Sw(t) {
  return t.charAt(0).toUpperCase() + t.slice(1)
}
var LB = function () {
    function t(e) {
      Di(this, t), this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = la.create("languageUtils")
    }
    return Mi(t, [{
      key: "getScriptPartFromCode",
      value: function (r) {
        if (!r || r.indexOf("-") < 0) return null;
        var n = r.split("-");
        return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"))
      }
    }, {
      key: "getLanguagePartFromCode",
      value: function (r) {
        if (!r || r.indexOf("-") < 0) return r;
        var n = r.split("-");
        return this.formatLanguageCode(n[0])
      }
    }, {
      key: "formatLanguageCode",
      value: function (r) {
        if (typeof r == "string" && r.indexOf("-") > -1) {
          var n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"],
            i = r.split("-");
          return this.options.lowerCaseLng ? i = i.map(function (a) {
            return a.toLowerCase()
          }) : i.length === 2 ? (i[0] = i[0].toLowerCase(), i[1] = i[1].toUpperCase(), n.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Sw(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(), i[1].length === 2 && (i[1] = i[1].toUpperCase()), i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()), n.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Sw(i[1].toLowerCase())), n.indexOf(i[2].toLowerCase()) > -1 && (i[2] = Sw(i[2].toLowerCase()))), i.join("-")
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? r.toLowerCase() : r
      }
    }, {
      key: "isSupportedCode",
      value: function (r) {
        return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (r = this.getLanguagePartFromCode(r)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(r) > -1
      }
    }, {
      key: "getBestMatchFromCodes",
      value: function (r) {
        var n = this;
        if (!r) return null;
        var i;
        return r.forEach(function (a) {
          if (!i) {
            var s = n.formatLanguageCode(a);
            (!n.options.supportedLngs || n.isSupportedCode(s)) && (i = s)
          }
        }), !i && this.options.supportedLngs && r.forEach(function (a) {
          if (!i) {
            var s = n.getLanguagePartFromCode(a);
            if (n.isSupportedCode(s)) return i = s;
            i = n.options.supportedLngs.find(function (o) {
              if (o === s) return o;
              if (!(o.indexOf("-") < 0 && s.indexOf("-") < 0) && o.indexOf(s) === 0) return o
            })
          }
        }), i || (i = this.getFallbackCodes(this.options.fallbackLng)[0]), i
      }
    }, {
      key: "getFallbackCodes",
      value: function (r, n) {
        if (!r) return [];
        if (typeof r == "function" && (r = r(n)), typeof r == "string" && (r = [r]), Object.prototype.toString.apply(r) === "[object Array]") return r;
        if (!n) return r.default || [];
        var i = r[n];
        return i || (i = r[this.getScriptPartFromCode(n)]), i || (i = r[this.formatLanguageCode(n)]), i || (i = r[this.getLanguagePartFromCode(n)]), i || (i = r.default), i || []
      }
    }, {
      key: "toResolveHierarchy",
      value: function (r, n) {
        var i = this,
          a = this.getFallbackCodes(n || this.options.fallbackLng || [], r),
          s = [],
          o = function (l) {
            l && (i.isSupportedCode(l) ? s.push(l) : i.logger.warn("rejecting language code not found in supportedLngs: ".concat(l)))
          };
        return typeof r == "string" && r.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(r)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(r)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(r))) : typeof r == "string" && o(this.formatLanguageCode(r)), a.forEach(function (c) {
          s.indexOf(c) < 0 && o(i.formatLanguageCode(c))
        }), s
      }
    }]), t
  }(),
  eWe = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
  }, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
  }],
  tWe = {
    1: function (e) {
      return +(e > 1)
    },
    2: function (e) {
      return +(e != 1)
    },
    3: function (e) {
      return 0
    },
    4: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    5: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
    },
    6: function (e) {
      return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2
    },
    7: function (e) {
      return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    8: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3
    },
    9: function (e) {
      return +(e >= 2)
    },
    10: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4
    },
    11: function (e) {
      return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3
    },
    12: function (e) {
      return +(e % 10 != 1 || e % 100 == 11)
    },
    13: function (e) {
      return +(e !== 0)
    },
    14: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3
    },
    15: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    16: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2
    },
    17: function (e) {
      return e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1
    },
    18: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : 2
    },
    19: function (e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3
    },
    20: function (e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2
    },
    21: function (e) {
      return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0
    },
    22: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
    }
  },
  rWe = ["v1", "v2", "v3"],
  PB = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
  };

function nWe() {
  var t = {};
  return eWe.forEach(function (e) {
    e.lngs.forEach(function (r) {
      t[r] = {
        numbers: e.nr,
        plurals: tWe[e.fc]
      }
    })
  }), t
}
var iWe = function () {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Di(this, t), this.languageUtils = e, this.options = r, this.logger = la.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = nWe()
  }
  return Mi(t, [{
    key: "addRule",
    value: function (r, n) {
      this.rules[r] = n
    }
  }, {
    key: "getRule",
    value: function (r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) try {
        return new Intl.PluralRules(r, {
          type: n.ordinal ? "ordinal" : "cardinal"
        })
      } catch {
        return
      }
      return this.rules[r] || this.rules[this.languageUtils.getLanguagePartFromCode(r)]
    }
  }, {
    key: "needsPlural",
    value: function (r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        i = this.getRule(r, n);
      return this.shouldUseIntlApi() ? i && i.resolvedOptions().pluralCategories.length > 1 : i && i.numbers.length > 1
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function (r, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(r, i).map(function (a) {
        return "".concat(n).concat(a)
      })
    }
  }, {
    key: "getSuffixes",
    value: function (r) {
      var n = this,
        i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        a = this.getRule(r, i);
      return a ? this.shouldUseIntlApi() ? a.resolvedOptions().pluralCategories.sort(function (s, o) {
        return PB[s] - PB[o]
      }).map(function (s) {
        return "".concat(n.options.prepend).concat(s)
      }) : a.numbers.map(function (s) {
        return n.getSuffix(r, s, i)
      }) : []
    }
  }, {
    key: "getSuffix",
    value: function (r, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        a = this.getRule(r, i);
      return a ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(a.select(n)) : this.getSuffixRetroCompatible(a, n) : (this.logger.warn("no plural rule found for: ".concat(r)), "")
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function (r, n) {
      var i = this,
        a = r.noAbs ? r.plurals(n) : r.plurals(Math.abs(n)),
        s = r.numbers[a];
      this.options.simplifyPluralSuffix && r.numbers.length === 2 && r.numbers[0] === 1 && (s === 2 ? s = "plural" : s === 1 && (s = ""));
      var o = function () {
        return i.options.prepend && s.toString() ? i.options.prepend + s.toString() : s.toString()
      };
      return this.options.compatibilityJSON === "v1" ? s === 1 ? "" : typeof s == "number" ? "_plural_".concat(s.toString()) : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && r.numbers.length === 2 && r.numbers[0] === 1 ? o() : this.options.prepend && a.toString() ? this.options.prepend + a.toString() : a.toString()
    }
  }, {
    key: "shouldUseIntlApi",
    value: function () {
      return !rWe.includes(this.options.compatibilityJSON)
    }
  }]), t
}();

function NB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function vi(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? NB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : NB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function DB(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".",
    i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
    a = GVe(t, e, r);
  return !a && i && typeof r == "string" && (a = F1(t, r, n), a === void 0 && (a = F1(e, r, n))), a
}
var aWe = function () {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Di(this, t), this.logger = la.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function (r) {
      return r
    }, this.init(e)
  }
  return Mi(t, [{
    key: "init",
    value: function () {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      r.interpolation || (r.interpolation = {
        escapeValue: !0
      });
      var n = r.interpolation;
      this.escape = n.escape !== void 0 ? n.escape : WVe, this.escapeValue = n.escapeValue !== void 0 ? n.escapeValue : !0, this.useRawValueToEscape = n.useRawValueToEscape !== void 0 ? n.useRawValueToEscape : !1, this.prefix = n.prefix ? qc(n.prefix) : n.prefixEscaped || "{{", this.suffix = n.suffix ? qc(n.suffix) : n.suffixEscaped || "}}", this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",", this.unescapePrefix = n.unescapeSuffix ? "" : n.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : n.unescapeSuffix || "", this.nestingPrefix = n.nestingPrefix ? qc(n.nestingPrefix) : n.nestingPrefixEscaped || qc("$t("), this.nestingSuffix = n.nestingSuffix ? qc(n.nestingSuffix) : n.nestingSuffixEscaped || qc(")"), this.nestingOptionsSeparator = n.nestingOptionsSeparator ? n.nestingOptionsSeparator : n.nestingOptionsSeparator || ",", this.maxReplaces = n.maxReplaces ? n.maxReplaces : 1e3, this.alwaysFormat = n.alwaysFormat !== void 0 ? n.alwaysFormat : !1, this.resetRegExp()
    }
  }, {
    key: "reset",
    value: function () {
      this.options && this.init(this.options)
    }
  }, {
    key: "resetRegExp",
    value: function () {
      var r = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(r, "g");
      var n = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(n, "g");
      var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(i, "g")
    }
  }, {
    key: "interpolate",
    value: function (r, n, i, a) {
      var s = this,
        o, c, l, u = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function f(g) {
        return g.replace(/\$/g, "$$$$")
      }
      var d = function (m) {
        if (m.indexOf(s.formatSeparator) < 0) {
          var y = DB(n, u, m, s.options.keySeparator, s.options.ignoreJSONStructure);
          return s.alwaysFormat ? s.format(y, void 0, i, vi(vi(vi({}, a), n), {}, {
            interpolationkey: m
          })) : y
        }
        var x = m.split(s.formatSeparator),
          b = x.shift().trim(),
          _ = x.join(s.formatSeparator).trim();
        return s.format(DB(n, u, b, s.options.keySeparator, s.options.ignoreJSONStructure), _, i, vi(vi(vi({}, a), n), {}, {
          interpolationkey: b
        }))
      };
      this.resetRegExp();
      var h = a && a.missingInterpolationHandler || this.options.missingInterpolationHandler,
        p = a && a.interpolation && a.interpolation.skipOnVariables !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables,
        v = [{
          regex: this.regexpUnescape,
          safeValue: function (m) {
            return f(m)
          }
        }, {
          regex: this.regexp,
          safeValue: function (m) {
            return s.escapeValue ? f(s.escape(m)) : f(m)
          }
        }];
      return v.forEach(function (g) {
        for (l = 0; o = g.regex.exec(r);) {
          var m = o[1].trim();
          if (c = d(m), c === void 0)
            if (typeof h == "function") {
              var y = h(r, o, a);
              c = typeof y == "string" ? y : ""
            } else if (a && Object.prototype.hasOwnProperty.call(a, m)) c = "";
          else if (p) {
            c = o[0];
            continue
          } else s.logger.warn("missed to pass in variable ".concat(m, " for interpolating ").concat(r)), c = "";
          else typeof c != "string" && !s.useRawValueToEscape && (c = AB(c));
          var x = g.safeValue(c);
          if (r = r.replace(o[0], x), p ? (g.regex.lastIndex += c.length, g.regex.lastIndex -= o[0].length) : g.regex.lastIndex = 0, l++, l >= s.maxReplaces) break
        }
      }), r
    }
  }, {
    key: "nest",
    value: function (r, n) {
      var i = this,
        a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        s, o, c;

      function l(h, p) {
        var v = this.nestingOptionsSeparator;
        if (h.indexOf(v) < 0) return h;
        var g = h.split(new RegExp("".concat(v, "[ ]*{"))),
          m = "{".concat(g[1]);
        h = g[0], m = this.interpolate(m, c);
        var y = m.match(/'/g),
          x = m.match(/"/g);
        (y && y.length % 2 === 0 && !x || x.length % 2 !== 0) && (m = m.replace(/'/g, '"'));
        try {
          c = JSON.parse(m), p && (c = vi(vi({}, p), c))
        } catch (b) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(h), b), "".concat(h).concat(v).concat(m)
        }
        return delete c.defaultValue, h
      }
      for (; s = this.nestingRegexp.exec(r);) {
        var u = [];
        c = vi({}, a), c = c.replace && typeof c.replace != "string" ? c.replace : c, c.applyPostProcessor = !1, delete c.defaultValue;
        var f = !1;
        if (s[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(s[1])) {
          var d = s[1].split(this.formatSeparator).map(function (h) {
            return h.trim()
          });
          s[1] = d.shift(), u = d, f = !0
        }
        if (o = n(l.call(this, s[1].trim(), c), c), o && s[0] === r && typeof o != "string") return o;
        typeof o != "string" && (o = AB(o)), o || (this.logger.warn("missed to resolve ".concat(s[1], " for nesting ").concat(r)), o = ""), f && (o = u.reduce(function (h, p) {
          return i.format(h, p, a.lng, vi(vi({}, a), {}, {
            interpolationkey: s[1].trim()
          }))
        }, o.trim())), r = r.replace(s[0], o), this.regexp.lastIndex = 0
      }
      return r
    }
  }]), t
}();

function MB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function La(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? MB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : MB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function sWe(t) {
  var e = t.toLowerCase().trim(),
    r = {};
  if (t.indexOf("(") > -1) {
    var n = t.split("(");
    e = n[0].toLowerCase().trim();
    var i = n[1].substring(0, n[1].length - 1);
    if (e === "currency" && i.indexOf(":") < 0) r.currency || (r.currency = i.trim());
    else if (e === "relativetime" && i.indexOf(":") < 0) r.range || (r.range = i.trim());
    else {
      var a = i.split(";");
      a.forEach(function (s) {
        if (s) {
          var o = s.split(":"),
            c = BVe(o),
            l = c[0],
            u = c.slice(1),
            f = u.join(":").trim().replace(/^'+|'+$/g, "");
          r[l.trim()] || (r[l.trim()] = f), f === "false" && (r[l.trim()] = !1), f === "true" && (r[l.trim()] = !0), isNaN(f) || (r[l.trim()] = parseInt(f, 10))
        }
      })
    }
  }
  return {
    formatName: e,
    formatOptions: r
  }
}

function Xc(t) {
  var e = {};
  return function (n, i, a) {
    var s = i + JSON.stringify(a),
      o = e[s];
    return o || (o = t(i, a), e[s] = o), o(n)
  }
}
var oWe = function () {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Di(this, t), this.logger = la.create("formatter"), this.options = e, this.formats = {
      number: Xc(function (r, n) {
        var i = new Intl.NumberFormat(r, La({}, n));
        return function (a) {
          return i.format(a)
        }
      }),
      currency: Xc(function (r, n) {
        var i = new Intl.NumberFormat(r, La(La({}, n), {}, {
          style: "currency"
        }));
        return function (a) {
          return i.format(a)
        }
      }),
      datetime: Xc(function (r, n) {
        var i = new Intl.DateTimeFormat(r, La({}, n));
        return function (a) {
          return i.format(a)
        }
      }),
      relativetime: Xc(function (r, n) {
        var i = new Intl.RelativeTimeFormat(r, La({}, n));
        return function (a) {
          return i.format(a, n.range || "day")
        }
      }),
      list: Xc(function (r, n) {
        var i = new Intl.ListFormat(r, La({}, n));
        return function (a) {
          return i.format(a)
        }
      })
    }, this.init(e)
  }
  return Mi(t, [{
    key: "init",
    value: function (r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        },
        i = n.interpolation;
      this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ","
    }
  }, {
    key: "add",
    value: function (r, n) {
      this.formats[r.toLowerCase().trim()] = n
    }
  }, {
    key: "addCached",
    value: function (r, n) {
      this.formats[r.toLowerCase().trim()] = Xc(n)
    }
  }, {
    key: "format",
    value: function (r, n, i) {
      var a = this,
        s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
        o = n.split(this.formatSeparator),
        c = o.reduce(function (l, u) {
          var f = sWe(u),
            d = f.formatName,
            h = f.formatOptions;
          if (a.formats[d]) {
            var p = l;
            try {
              var v = s && s.formatParams && s.formatParams[s.interpolationkey] || {},
                g = v.locale || v.lng || s.locale || s.lng || i;
              p = a.formats[d](l, g, La(La(La({}, h), s), v))
            } catch (m) {
              a.logger.warn(m)
            }
            return p
          } else a.logger.warn("there was no format function for ".concat(d));
          return l
        }, r);
      return c
    }
  }]), t
}();

function FB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function BB(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? FB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : FB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function lWe(t) {
  var e = cWe();
  return function () {
    var n = xa(t),
      i;
    if (e) {
      var a = xa(this).constructor;
      i = Reflect.construct(n, arguments, a)
    } else i = n.apply(this, arguments);
    return yg(this, i)
  }
}

function cWe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
  } catch {
    return !1
  }
}

function uWe(t, e) {
  t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--)
}
var fWe = function (t) {
  SE(r, t);
  var e = lWe(r);

  function r(n, i, a) {
    var s, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Di(this, r), s = e.call(this), _E && Do.call(yo(s)), s.backend = n, s.store = i, s.services = a, s.languageUtils = a.languageUtils, s.options = o, s.logger = la.create("backendConnector"), s.waitingReads = [], s.maxParallelReads = o.maxParallelReads || 10, s.readingCalls = 0, s.maxRetries = o.maxRetries >= 0 ? o.maxRetries : 5, s.retryTimeout = o.retryTimeout >= 1 ? o.retryTimeout : 350, s.state = {}, s.queue = [], s.backend && s.backend.init && s.backend.init(a, o.backend, o), s
  }
  return Mi(r, [{
    key: "queueLoad",
    value: function (i, a, s, o) {
      var c = this,
        l = {},
        u = {},
        f = {},
        d = {};
      return i.forEach(function (h) {
        var p = !0;
        a.forEach(function (v) {
          var g = "".concat(h, "|").concat(v);
          !s.reload && c.store.hasResourceBundle(h, v) ? c.state[g] = 2 : c.state[g] < 0 || (c.state[g] === 1 ? u[g] === void 0 && (u[g] = !0) : (c.state[g] = 1, p = !1, u[g] === void 0 && (u[g] = !0), l[g] === void 0 && (l[g] = !0), d[v] === void 0 && (d[v] = !0)))
        }), p || (f[h] = !0)
      }), (Object.keys(l).length || Object.keys(u).length) && this.queue.push({
        pending: u,
        pendingCount: Object.keys(u).length,
        loaded: {},
        errors: [],
        callback: o
      }), {
        toLoad: Object.keys(l),
        pending: Object.keys(u),
        toLoadLanguages: Object.keys(f),
        toLoadNamespaces: Object.keys(d)
      }
    }
  }, {
    key: "loaded",
    value: function (i, a, s) {
      var o = i.split("|"),
        c = o[0],
        l = o[1];
      a && this.emit("failedLoading", c, l, a), s && this.store.addResourceBundle(c, l, s), this.state[i] = a ? -1 : 2;
      var u = {};
      this.queue.forEach(function (f) {
        zVe(f.loaded, [c], l), uWe(f, i), a && f.errors.push(a), f.pendingCount === 0 && !f.done && (Object.keys(f.loaded).forEach(function (d) {
          u[d] || (u[d] = {});
          var h = f.loaded[d];
          h.length && h.forEach(function (p) {
            u[d][p] === void 0 && (u[d][p] = !0)
          })
        }), f.done = !0, f.errors.length ? f.callback(f.errors) : f.callback())
      }), this.emit("loaded", u), this.queue = this.queue.filter(function (f) {
        return !f.done
      })
    }
  }, {
    key: "read",
    value: function (i, a, s) {
      var o = this,
        c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
        l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout,
        u = arguments.length > 5 ? arguments[5] : void 0;
      if (!i.length) return u(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: i,
          ns: a,
          fcName: s,
          tried: c,
          wait: l,
          callback: u
        });
        return
      }
      this.readingCalls++;
      var f = function (v, g) {
          if (o.readingCalls--, o.waitingReads.length > 0) {
            var m = o.waitingReads.shift();
            o.read(m.lng, m.ns, m.fcName, m.tried, m.wait, m.callback)
          }
          if (v && g && c < o.maxRetries) {
            setTimeout(function () {
              o.read.call(o, i, a, s, c + 1, l * 2, u)
            }, l);
            return
          }
          u(v, g)
        },
        d = this.backend[s].bind(this.backend);
      if (d.length === 2) {
        try {
          var h = d(i, a);
          h && typeof h.then == "function" ? h.then(function (p) {
            return f(null, p)
          }).catch(f) : f(null, h)
        } catch (p) {
          f(p)
        }
        return
      }
      return d(i, a, f)
    }
  }, {
    key: "prepareLoading",
    value: function (i, a) {
      var s = this,
        o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        c = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), c && c();
      typeof i == "string" && (i = this.languageUtils.toResolveHierarchy(i)), typeof a == "string" && (a = [a]);
      var l = this.queueLoad(i, a, o, c);
      if (!l.toLoad.length) return l.pending.length || c(), null;
      l.toLoad.forEach(function (u) {
        s.loadOne(u)
      })
    }
  }, {
    key: "load",
    value: function (i, a, s) {
      this.prepareLoading(i, a, {}, s)
    }
  }, {
    key: "reload",
    value: function (i, a, s) {
      this.prepareLoading(i, a, {
        reload: !0
      }, s)
    }
  }, {
    key: "loadOne",
    value: function (i) {
      var a = this,
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
        o = i.split("|"),
        c = o[0],
        l = o[1];
      this.read(c, l, "read", void 0, void 0, function (u, f) {
        u && a.logger.warn("".concat(s, "loading namespace ").concat(l, " for language ").concat(c, " failed"), u), !u && f && a.logger.log("".concat(s, "loaded namespace ").concat(l, " for language ").concat(c), f), a.loaded(i, u, f)
      })
    }
  }, {
    key: "saveMissing",
    value: function (i, a, s, o, c) {
      var l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {},
        u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function () {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(a)) {
        this.logger.warn('did not save key "'.concat(s, '" as the namespace "').concat(a, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return
      }
      if (!(s == null || s === "")) {
        if (this.backend && this.backend.create) {
          var f = BB(BB({}, l), {}, {
              isUpdate: c
            }),
            d = this.backend.create.bind(this.backend);
          if (d.length < 6) try {
            var h;
            d.length === 5 ? h = d(i, a, s, o, f) : h = d(i, a, s, o), h && typeof h.then == "function" ? h.then(function (p) {
              return u(null, p)
            }).catch(u) : u(null, h)
          } catch (p) {
            u(p)
          } else d(i, a, s, o, u, f)
        }!i || !i[0] || this.store.addResource(i[0], a, s, o)
      }
    }
  }]), r
}(Do);

function UB() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function (e) {
      var r = {};
      if (Vt(e[1]) === "object" && (r = e[1]), typeof e[1] == "string" && (r.defaultValue = e[1]), typeof e[2] == "string" && (r.tDescription = e[2]), Vt(e[2]) === "object" || Vt(e[3]) === "object") {
        var n = e[3] || e[2];
        Object.keys(n).forEach(function (i) {
          r[i] = n[i]
        })
      }
      return r
    },
    interpolation: {
      escapeValue: !0,
      format: function (e, r, n, i) {
        return e
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  }
}

function jB(t) {
  return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t
}

function HB(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function (i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable
    })), r.push.apply(r, n)
  }
  return r
}

function Yi(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? HB(Object(r), !0).forEach(function (n) {
      ci(t, n, r[n])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : HB(Object(r)).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
    })
  }
  return t
}

function dWe(t) {
  var e = hWe();
  return function () {
    var n = xa(t),
      i;
    if (e) {
      var a = xa(this).constructor;
      i = Reflect.construct(n, arguments, a)
    } else i = n.apply(this, arguments);
    return yg(this, i)
  }
}

function hWe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
  } catch {
    return !1
  }
}

function ev() {}

function pWe(t) {
  var e = Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  e.forEach(function (r) {
    typeof t[r] == "function" && (t[r] = t[r].bind(t))
  })
}
var B1 = function (t) {
  SE(r, t);
  var e = dWe(r);

  function r() {
    var n, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      a = arguments.length > 1 ? arguments[1] : void 0;
    if (Di(this, r), n = e.call(this), _E && Do.call(yo(n)), n.options = jB(i), n.services = {}, n.logger = la, n.modules = {
        external: []
      }, pWe(yo(n)), a && !n.isInitialized && !i.isClone) {
      if (!n.options.initImmediate) return n.init(i, a), yg(n, yo(n));
      setTimeout(function () {
        n.init(i, a)
      }, 0)
    }
    return n
  }
  return Mi(r, [{
    key: "init",
    value: function () {
      var i = this,
        a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        s = arguments.length > 1 ? arguments[1] : void 0;
      typeof a == "function" && (s = a, a = {}), !a.defaultNS && a.defaultNS !== !1 && a.ns && (typeof a.ns == "string" ? a.defaultNS = a.ns : a.ns.indexOf("translation") < 0 && (a.defaultNS = a.ns[0]));
      var o = UB();
      this.options = Yi(Yi(Yi({}, o), this.options), jB(a)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = Yi(Yi({}, o.interpolation), this.options.interpolation)), a.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = a.keySeparator), a.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = a.nsSeparator);

      function c(m) {
        return m ? typeof m == "function" ? new m : m : null
      }
      if (!this.options.isClone) {
        this.modules.logger ? la.init(c(this.modules.logger), this.options) : la.init(null, this.options);
        var l;
        this.modules.formatter ? l = this.modules.formatter : typeof Intl < "u" && (l = oWe);
        var u = new LB(this.options);
        this.store = new QVe(this.options.resources, this.options);
        var f = this.services;
        f.logger = la, f.resourceStore = this.store, f.languageUtils = u, f.pluralResolver = new iWe(u, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), l && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (f.formatter = c(l), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new aWe(this.options), f.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, f.backendConnector = new fWe(c(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function (m) {
          for (var y = arguments.length, x = new Array(y > 1 ? y - 1 : 0), b = 1; b < y; b++) x[b - 1] = arguments[b];
          i.emit.apply(i, [m].concat(x))
        }), this.modules.languageDetector && (f.languageDetector = c(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = c(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new OB(this.services, this.options), this.translator.on("*", function (m) {
          for (var y = arguments.length, x = new Array(y > 1 ? y - 1 : 0), b = 1; b < y; b++) x[b - 1] = arguments[b];
          i.emit.apply(i, [m].concat(x))
        }), this.modules.external.forEach(function (m) {
          m.init && m.init(i)
        })
      }
      if (this.format = this.options.interpolation.format, s || (s = ev), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var d = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        d.length > 0 && d[0] !== "dev" && (this.options.lng = d[0])
      }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var h = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      h.forEach(function (m) {
        i[m] = function () {
          var y;
          return (y = i.store)[m].apply(y, arguments)
        }
      });
      var p = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      p.forEach(function (m) {
        i[m] = function () {
          var y;
          return (y = i.store)[m].apply(y, arguments), i
        }
      });
      var v = oh(),
        g = function () {
          var y = function (b, _) {
            i.isInitialized && !i.initializedStoreOnce && i.logger.warn("init: i18next is already initialized. You should call init just once!"), i.isInitialized = !0, i.options.isClone || i.logger.log("initialized", i.options), i.emit("initialized", i.options), v.resolve(_), s(b, _)
          };
          if (i.languages && i.options.compatibilityAPI !== "v1" && !i.isInitialized) return y(null, i.t.bind(i));
          i.changeLanguage(i.options.lng, y)
        };
      return this.options.resources || !this.options.initImmediate ? g() : setTimeout(g, 0), v
    }
  }, {
    key: "loadResources",
    value: function (i) {
      var a = this,
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ev,
        o = s,
        c = typeof i == "string" ? i : this.language;
      if (typeof i == "function" && (o = i), !this.options.resources || this.options.partialBundledLanguages) {
        if (c && c.toLowerCase() === "cimode") return o();
        var l = [],
          u = function (h) {
            if (h) {
              var p = a.services.languageUtils.toResolveHierarchy(h);
              p.forEach(function (v) {
                l.indexOf(v) < 0 && l.push(v)
              })
            }
          };
        if (c) u(c);
        else {
          var f = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          f.forEach(function (d) {
            return u(d)
          })
        }
        this.options.preload && this.options.preload.forEach(function (d) {
          return u(d)
        }), this.services.backendConnector.load(l, this.options.ns, function (d) {
          !d && !a.resolvedLanguage && a.language && a.setResolvedLanguage(a.language), o(d)
        })
      } else o(null)
    }
  }, {
    key: "reloadResources",
    value: function (i, a, s) {
      var o = oh();
      return i || (i = this.languages), a || (a = this.options.ns), s || (s = ev), this.services.backendConnector.reload(i, a, function (c) {
        o.resolve(), s(c)
      }), o
    }
  }, {
    key: "use",
    value: function (i) {
      if (!i) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!i.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return i.type === "backend" && (this.modules.backend = i), (i.type === "logger" || i.log && i.warn && i.error) && (this.modules.logger = i), i.type === "languageDetector" && (this.modules.languageDetector = i), i.type === "i18nFormat" && (this.modules.i18nFormat = i), i.type === "postProcessor" && iZ.addPostProcessor(i), i.type === "formatter" && (this.modules.formatter = i), i.type === "3rdParty" && this.modules.external.push(i), this
    }
  }, {
    key: "setResolvedLanguage",
    value: function (i) {
      if (!(!i || !this.languages) && !(["cimode", "dev"].indexOf(i) > -1))
        for (var a = 0; a < this.languages.length; a++) {
          var s = this.languages[a];
          if (!(["cimode", "dev"].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) {
            this.resolvedLanguage = s;
            break
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function (i, a) {
      var s = this;
      this.isLanguageChangingTo = i;
      var o = oh();
      this.emit("languageChanging", i);
      var c = function (d) {
          s.language = d, s.languages = s.services.languageUtils.toResolveHierarchy(d), s.resolvedLanguage = void 0, s.setResolvedLanguage(d)
        },
        l = function (d, h) {
          h ? (c(h), s.translator.changeLanguage(h), s.isLanguageChangingTo = void 0, s.emit("languageChanged", h), s.logger.log("languageChanged", h)) : s.isLanguageChangingTo = void 0, o.resolve(function () {
            return s.t.apply(s, arguments)
          }), a && a(d, function () {
            return s.t.apply(s, arguments)
          })
        },
        u = function (d) {
          !i && !d && s.services.languageDetector && (d = []);
          var h = typeof d == "string" ? d : s.services.languageUtils.getBestMatchFromCodes(d);
          h && (s.language || c(h), s.translator.language || s.translator.changeLanguage(h), s.services.languageDetector && s.services.languageDetector.cacheUserLanguage && s.services.languageDetector.cacheUserLanguage(h)), s.loadResources(h, function (p) {
            l(p, h)
          })
        };
      return !i && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !i && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(u) : this.services.languageDetector.detect(u) : u(i), o
    }
  }, {
    key: "getFixedT",
    value: function (i, a, s) {
      var o = this,
        c = function l(u, f) {
          var d;
          if (Vt(f) !== "object") {
            for (var h = arguments.length, p = new Array(h > 2 ? h - 2 : 0), v = 2; v < h; v++) p[v - 2] = arguments[v];
            d = o.options.overloadTranslationOptionHandler([u, f].concat(p))
          } else d = Yi({}, f);
          d.lng = d.lng || l.lng, d.lngs = d.lngs || l.lngs, d.ns = d.ns || l.ns, d.keyPrefix = d.keyPrefix || s || l.keyPrefix;
          var g = o.options.keySeparator || ".",
            m;
          return d.keyPrefix && Array.isArray(u) ? m = u.map(function (y) {
            return "".concat(d.keyPrefix).concat(g).concat(y)
          }) : m = d.keyPrefix ? "".concat(d.keyPrefix).concat(g).concat(u) : u, o.t(m, d)
        };
      return typeof i == "string" ? c.lng = i : c.lngs = i, c.ns = a, c.keyPrefix = s, c
    }
  }, {
    key: "t",
    value: function () {
      var i;
      return this.translator && (i = this.translator).translate.apply(i, arguments)
    }
  }, {
    key: "exists",
    value: function () {
      var i;
      return this.translator && (i = this.translator).exists.apply(i, arguments)
    }
  }, {
    key: "setDefaultNamespace",
    value: function (i) {
      this.options.defaultNS = i
    }
  }, {
    key: "hasLoadedNamespace",
    value: function (i) {
      var a = this,
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var o = this.resolvedLanguage || this.languages[0],
        c = this.options ? this.options.fallbackLng : !1,
        l = this.languages[this.languages.length - 1];
      if (o.toLowerCase() === "cimode") return !0;
      var u = function (h, p) {
        var v = a.services.backendConnector.state["".concat(h, "|").concat(p)];
        return v === -1 || v === 2
      };
      if (s.precheck) {
        var f = s.precheck(this, u);
        if (f !== void 0) return f
      }
      return !!(this.hasResourceBundle(o, i) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || u(o, i) && (!c || u(l, i)))
    }
  }, {
    key: "loadNamespaces",
    value: function (i, a) {
      var s = this,
        o = oh();
      return this.options.ns ? (typeof i == "string" && (i = [i]), i.forEach(function (c) {
        s.options.ns.indexOf(c) < 0 && s.options.ns.push(c)
      }), this.loadResources(function (c) {
        o.resolve(), a && a(c)
      }), o) : (a && a(), Promise.resolve())
    }
  }, {
    key: "loadLanguages",
    value: function (i, a) {
      var s = oh();
      typeof i == "string" && (i = [i]);
      var o = this.options.preload || [],
        c = i.filter(function (l) {
          return o.indexOf(l) < 0
        });
      return c.length ? (this.options.preload = o.concat(c), this.loadResources(function (l) {
        s.resolve(), a && a(l)
      }), s) : (a && a(), Promise.resolve())
    }
  }, {
    key: "dir",
    value: function (i) {
      if (i || (i = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !i) return "rtl";
      var a = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
        s = this.services && this.services.languageUtils || new LB(UB());
      return a.indexOf(s.getLanguagePartFromCode(i)) > -1 || i.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
    }
  }, {
    key: "cloneInstance",
    value: function () {
      var i = this,
        a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ev,
        o = Yi(Yi(Yi({}, this.options), a), {
          isClone: !0
        }),
        c = new r(o);
      (a.debug !== void 0 || a.prefix !== void 0) && (c.logger = c.logger.clone(a));
      var l = ["store", "services", "language"];
      return l.forEach(function (u) {
        c[u] = i[u]
      }), c.services = Yi({}, this.services), c.services.utils = {
        hasLoadedNamespace: c.hasLoadedNamespace.bind(c)
      }, c.translator = new OB(c.services, c.options), c.translator.on("*", function (u) {
        for (var f = arguments.length, d = new Array(f > 1 ? f - 1 : 0), h = 1; h < f; h++) d[h - 1] = arguments[h];
        c.emit.apply(c, [u].concat(d))
      }), c.init(o, s), c.translator.options = c.options, c.translator.backendConnector.services.utils = {
        hasLoadedNamespace: c.hasLoadedNamespace.bind(c)
      }, c
    }
  }, {
    key: "toJSON",
    value: function () {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      }
    }
  }]), r
}(Do);
ci(B1, "createInstance", function () {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = arguments.length > 1 ? arguments[1] : void 0;
  return new B1(t, e)
});
var Er = B1.createInstance();
Er.createInstance = B1.createInstance;
Er.createInstance;
Er.dir;
Er.init;
Er.loadResources;
Er.reloadResources;
Er.use;
Er.changeLanguage;
Er.getFixedT;
Er.t;
Er.exists;
Er.setDefaultNamespace;
Er.hasLoadedNamespace;
Er.loadNamespaces;
Er.loadLanguages;
const gWe = {
    name: "movie-web"
  },
  mWe = {
    loading_series: "NaÄÃ­tÃ¡nÃ­ VaÅ¡ich oblÃ­benÃ½ch seriÃ¡lÅ¯...",
    loading_movie: "NaÄÃ­tÃ¡nÃ­ VaÅ¡ich oblÃ­benÃ½ch filmÅ¯...",
    loading: "NaÄÃ­tÃ¡nÃ­...",
    allResults: "To je vÅ¡e co mÃ¡me!",
    noResults: "Nemohli jsme nic najÃ­t!",
    allFailed: "NepodaÅilo se najÃ­t mÃ©dia, zkuste to znovu!",
    headingTitle: "VÃ½sledky vyhledÃ¡vÃ¡nÃ­",
    bookmarks: "ZÃ¡loÅ¾ky",
    continueWatching: "PokraÄujte ve sledovÃ¡nÃ­",
    title: "Co si pÅejete sledovat?",
    placeholder: "Co si pÅejete sledovat?"
  },
  vWe = {
    movie: "Filmy",
    series: "SeriÃ¡ly",
    stopEditing: "Zastavit upravovÃ¡nÃ­",
    errors: {
      genericTitle: "Jejda, rozbilo se to!",
      failedMeta: "Nepovedlo se naÄÃ­st meta",
      mediaFailed: "NepodaÅilo se nÃ¡m poÅ¾Ã¡dat o VaÅ¡e mÃ©dia, zkontrolujte svÃ© internetovÃ© pÅipojenÃ­ a zkuste to znovu.",
      videoFailed: "PÅi pÅehrÃ¡vÃ¡nÃ­ poÅ¾adovanÃ©ho videa doÅ¡lo k chybÄ. Pokud se tohle opakuje prosÃ­m nahlaÅ¡te nÃ¡m to na <0>Discord serveru</0> nebo na <1>GitHubu</1>."
    }
  },
  yWe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  xWe = {
    genericTitle: "Nenalezeno",
    backArrow: "ZpÃ¡tky domÅ¯",
    media: {
      title: "Nemohli jsme najÃ­t VaÅ¡e mÃ©dia.",
      description: "Nemohli jsme najÃ­t mÃ©dia o kterÃ© jste poÅ¾Ã¡dali. BuÄto jsme ho nemohli najÃ­t, nebo jste manipulovali s URL."
    },
    provider: {
      title: "Tento poskytovatel byl zakÃ¡zÃ¡n",
      description: "MÄli jsme s tÃ­mto poskytovatelem problÃ©my, nebo byl moc nestabilnÃ­ na pouÅ¾Ã­vÃ¡nÃ­, a tak jsme ho museli zakÃ¡zat."
    },
    page: {
      title: "Tuto strÃ¡nku se nepodaÅilo najÃ­t",
      description: "DÃ­vali jsme se vÅ¡ude: pod koÅ¡i, ve skÅÃ­ni, za proxy, ale nakonec jsme nemohli najÃ­t strÃ¡nku, kterou hledÃ¡te."
    }
  },
  bWe = {
    movie: "Film",
    series: "SeriÃ¡l",
    Search: "HledÃ¡nÃ­"
  },
  EWe = {
    findingBestVideo: "HledÃ¡me pro VÃ¡s nejlepÅ¡Ã­ video",
    noVideos: "Jejda, nemohli jsme Å¾Ã¡dnÃ© video najÃ­t",
    loading: "NaÄÃ­tÃ¡nÃ­...",
    backToHome: "ZpÃ¡tky domÅ¯",
    backToHomeShort: "ZpÄt",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "ZbÃ½vÃ¡ {{timeLeft}}",
    finishAt: "KonÄÃ­ ve {{timeFinished, datetime}}",
    buttons: {
      episodes: "Epizody",
      source: "Zdroj",
      captions: "Titulky",
      download: "StÃ¡hnout",
      settings: "NastavenÃ­",
      pictureInPicture: "Obraz v obraze",
      playbackSpeed: "Rychlost pÅehrÃ¡vÃ¡nÃ­"
    },
    popouts: {
      back: "ZpÄt",
      sources: "Zdroje",
      seasons: "SezÃ³ny",
      captions: "Titulky",
      playbackSpeed: "Rychlost pÅehrÃ¡vÃ¡nÃ­",
      customPlaybackSpeed: "VlastnÃ­ rychlost pÅehrÃ¡vÃ¡nÃ­",
      captionPreferences: {
        title: "Upravit",
        delay: "ZpoÅ¾denÃ­",
        fontSize: "Velikost",
        opacity: "PrÅ¯hlednost",
        color: "Barva"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "Å½Ã¡dnÃ© titulky",
      linkedCaptions: "PropojenÃ© titulky",
      customCaption: "VlastnÃ­ titulky",
      uploadCustomCaption: "NahrÃ¡t titulky",
      noEmbeds: "Nebyla nalezena Å¾Ã¡dnÃ¡ vloÅ¾enÃ­ pro tento zdroj",
      errors: {
        loadingWentWong: "NÄco se nepovedlo pÅi naÄÃ­tÃ¡nÃ­ epizod pro {{seasonTitle}}",
        embedsError: "NÄco se povedlo pÅi naÄÃ­tÃ¡nÃ­ vloÅ¾enÃ­ pro tuhle vÄc, kterou mÃ¡te tak rÃ¡di"
      },
      descriptions: {
        sources: "JakÃ©ho poskytovatele chcete pouÅ¾Ã­t?",
        embeds: "Vyberte video, kterÃ© chcete sledovat",
        seasons: "Vyberte sÃ©rii, kterou chcete sledovat",
        episode: "Vyberte epizodu",
        captions: "Vyberte jazyk titulkÅ¯",
        captionPreferences: "Upravte titulky tak, jak se VÃ¡m budou lÃ­bit",
        playbackSpeed: "ZmÄÅtÄ rychlost pÅehrÃ¡vÃ¡nÃ­"
      }
    },
    errors: {
      fatalError: "DoÅ¡lo k zÃ¡vaÅ¾nÃ© chybÄ v pÅehrÃ¡vaÄi videa, prosÃ­m nahlaÅ¡te ji na <0>Discord serveru</0> nebo na <1>GitHubu</1>."
    }
  },
  SWe = {
    title: "NastavenÃ­",
    language: "Jazyk",
    captionLanguage: "Jazyk titulkÅ¯"
  },
  _We = {
    newSiteTitle: "Je dostupnÃ¡ novÃ¡ verze!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web se brzy pÅesune na novou domÃ©nu: <0>https://movie-web.app</0>. NezapomeÅte si aktualizovat zÃ¡loÅ¾ky, protoÅ¾e <1>starÃ¡ strÃ¡nka pÅestane fungovat {{date}}.</1>",
    tireless: "Pracovali jsme neÃºnavnÄ na tÃ©to novÃ© aktualizaci, a tak doufÃ¡me, Å¾e se VÃ¡m bude lÃ­bit co jsme v poslednÃ­ch mÄsÃ­cÃ­ch kuchtili.",
    leaveAnnouncement: "VezmÄte mÄ tam!"
  },
  TWe = {
    casting: "PÅehrÃ¡vÃ¡nÃ­ do zaÅÃ­zenÃ­..."
  },
  wWe = {
    offline: "Zkontrolujte svÃ© internetovÃ© pÅipojenÃ­"
  },
  RWe = {
    global: gWe,
    search: mWe,
    media: vWe,
    seasons: yWe,
    notFound: xWe,
    searchBar: bWe,
    videoPlayer: EWe,
    settings: SWe,
    v3: _We,
    casting: TWe,
    errors: wWe
  },
  AWe = {
    name: "movie-web"
  },
  IWe = {
    loading_series: "Auf der Suche nach deiner Lieblingsserie...",
    loading_movie: "Auf der Suche nach deinen Lieblingsfilmen...",
    loading: "Wird geladen...",
    allResults: "Das ist alles, was wir haben!",
    noResults: "Wir haben nichts gefunden!",
    allFailed: "Das Medium wurde nicht gefunden, bitte versuchen Sie es erneut!",
    headingTitle: "Suchergebnisse",
    bookmarks: "Favoriten",
    continueWatching: "Weiter ansehen",
    title: "Was willst du gucken?",
    placeholder: "Was willst du gucken?"
  },
  $We = {
    movie: "Filme",
    series: "Serie",
    stopEditing: "Beenden die Bearbeitung",
    errors: {
      genericTitle: "Hoppla, etwas ist schiefgegangen!",
      failedMeta: "Metadaten konnten nicht geladen werden",
      mediaFailed: "Wir konnten die angeforderten Medien nicht abrufen.",
      videoFailed: "Beim Abspielen des angeforderten Videos ist ein Fehler aufgetreten. <0>Discord</0> Oder weiter <1>GitHub</1>."
    }
  },
  CWe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  kWe = {
    genericTitle: "Nicht gefunden",
    backArrow: "ZurÃ¼ck zur Startseite",
    media: {
      title: "Das Medium konnte nicht gefunden werden",
      description: "Wir konnten die angeforderten Medien nicht finden."
    },
    provider: {
      title: "Dieser Anbieter wurde deaktiviert",
      description: "Wir hatten Probleme mit dem Anbieter oder er war zu instabil, sodass wir ihn deaktivieren mussten."
    },
    page: {
      title: "Diese Seite kann nicht gefunden werden",
      description: "Wir haben Ã¼berall gesucht, aber am Ende konnten wir die gesuchte Seite nicht finden."
    }
  },
  OWe = {
    movie: "Film",
    series: "Serie",
    Search: "Suchen"
  },
  LWe = {
    findingBestVideo: "Auf der Suche nach dem besten Video fÃ¼r Sie",
    noVideos: "Entschuldigung, wir konnten keine Videos finden",
    loading: "Wird geladen...",
    backToHome: "ZurÃ¼ck zur Startseite",
    backToHomeShort: "RÃ¼ckmeldung",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "{{timeLeft}} verbleibend",
    finishAt: "Endet um {{timeFinished, datetime}}",
    buttons: {
      episodes: "Folgen",
      source: "Quelle",
      captions: "Untertitel",
      download: "Herunterladen",
      settings: "Einstellungen",
      pictureInPicture: "Bild-im-Bild",
      playbackSpeed: "Wiedergabegeschwindigkeit"
    },
    popouts: {
      back: "ZurÃ¼ck",
      sources: "Quellen",
      seasons: "Staffel",
      captions: "Untertitel",
      playbackSpeed: "Lesegeschwindigkeit",
      customPlaybackSpeed: "Benutzerdefinierte Wiedergabegeschwindigkeit",
      captionPreferences: {
        title: "Bearbeiten",
        delay: "VerzÃ¶gerung",
        fontSize: "GrÃ¶Ãe",
        opacity: "OpazitÃ¤t",
        color: "Farbe"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "Keine Untertitel",
      linkedCaptions: "Verbundene Untertitel",
      customCaption: "Benutzerdefinierte Untertitel",
      uploadCustomCaption: "Untertitel hochladen",
      noEmbeds: "FÃ¼r diese Quelle wurde kein eingebetteter Inhalt gefunden",
      errors: {
        loadingWentWong: "Beim Laden der Folgen fÃ¼r {{seasonTitle}} ist ein Problem aufgetreten ",
        embedsError: "Beim Laden der eingebetteter Medien ist ein Problem aufgetreten"
      },
      descriptions: {
        sources: "Welchen Anbieter mÃ¶chtest du nutzen?",
        embeds: "WÃ¤hle das Video aus, das du ansehen mÃ¶chten",
        seasons: "WÃ¤hle die Staffel aus, die du sehen mÃ¶chten",
        episode: "WÃ¤hle eine Folge aus",
        captions: "WÃ¤hle eine Untertitelsprache",
        captionPreferences: "Passe das Erscheinungsbild von Untertiteln an",
        playbackSpeed: "Wiedergabegeschwindigkeit Ã¤ndern"
      }
    },
    errors: {
      fatalError: "Der Videoplayer hat einen Fehler festgestellt, bitte melde ihn dem Server <0>Discord</0> Oder weiter <1>GitHub</1>."
    }
  },
  PWe = {
    title: "Einstellungen",
    language: "Sprache",
    captionLanguage: "Untertitelsprache"
  },
  NWe = {
    newSiteTitle: "Neue Version verfÃ¼gbar!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web zieht in KÃ¼rze auf eine neue Domain um: <0>https://movie-web.app</0>. <1>Die alte Website funktioniert nicht mehr {{date}}.</1>",
    tireless: "Wir haben unermÃ¼dlich an diesem neuen Update gearbeitet und hoffen, dass dir gefÃ¤llt, was wir in den letzten Monaten vorbereitet haben.",
    leaveAnnouncement: "Bring mich dahin!"
  },
  DWe = {
    casting: "An GerÃ¤t Ã¼bertragen..."
  },
  MWe = {
    offline: "Internetverbindung ist instabil"
  },
  FWe = {
    global: AWe,
    search: IWe,
    media: $We,
    seasons: CWe,
    notFound: kWe,
    searchBar: OWe,
    videoPlayer: LWe,
    settings: PWe,
    v3: NWe,
    casting: DWe,
    errors: MWe
  },
  BWe = {
    name: "bringe-app"
  },
  UWe = {
    loading_series: "Fetching your favourite series...",
    loading_movie: "Fetching your favourite movies...",
    loading: "Loading...",
    allResults: "That's all we have!",
    noResults: "We couldn't find anything!",
    allFailed: "Failed to find media, try again!",
    headingTitle: "Search results",
    bookmarks: "Bookmarks",
    continueWatching: "Continue Watching",
    title: "Anything in your mind to binge?",
    placeholder: "Anything in your mind to binge?"
  },
  jWe = {
    movie: "Movie",
    series: "Series",
    stopEditing: "Stop editing",
    errors: {
      genericTitle: "Whoops, it broke!",
      failedMeta: "Failed to load meta",
      mediaFailed: "We failed to request the media you asked for, check your internet connection and try again.",
      videoFailed: "We encountered an error while playing the video you requested. If this keeps happening please report the issue to the <0>Discord server</0> or on <1>GitHub</1>."
    }
  },
  HWe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  zWe = {
    genericTitle: "Not found",
    backArrow: "Back to home",
    media: {
      title: "Couldn't find that media",
      description: "We couldn't find the media you requested. Either it's been removed or you tampered with the URL"
    },
    provider: {
      title: "This provider has been disabled",
      description: "We had issues with the provider or it was too unstable to use, so we had to disable it."
    },
    page: {
      title: "Couldn't find that page",
      description: "We looked everywhere: under the bins, in the closet, behind the proxy but ultimately couldn't find the page you are looking for."
    }
  },
  GWe = {
    movie: "Movie",
    series: "Series",
    Search: "Search"
  },
  VWe = {
    findingBestVideo: "Finding the best video for you",
    noVideos: "Whoops, couldn't find any videos for you",
    loading: "Loading...",
    backToHome: "Back to home",
    backToHomeShort: "Back",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "{{timeLeft}} left",
    finishAt: "Finish at {{timeFinished, datetime}}",
    buttons: {
      episodes: "Episodes",
      source: "Source",
      captions: "Captions",
      download: "Download",
      settings: "Settings",
      pictureInPicture: "Picture in Picture",
      playbackSpeed: "Playback speed"
    },
    popouts: {
      back: "Go back",
      sources: "Sources",
      close: "Close",
      seasons: {
        title: "Seasons",
        other: "Other seasons",
        noSeason: "No season"
      },
      episodes: {
        unknown: "Unknown episode",
        noEpisode: "No episode"
      },
      captions: "Captions",
      playbackSpeed: "Playback speed",
      customPlaybackSpeed: "Custom playback speed",
      captionPreferences: {
        title: "Customize",
        delay: "Delay",
        fontSize: "Size",
        opacity: "Opacity",
        color: "Color"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "No captions",
      linkedCaptions: "Linked captions",
      customCaption: "Custom caption",
      uploadCustomCaption: "Upload caption",
      noEmbeds: "No embeds were found for this source",
      errors: {
        loadingWentWong: "Something went wrong loading the episodes for {{seasonTitle}}",
        embedsError: "Something went wrong loading the embeds for this thing that you like"
      },
      descriptions: {
        sources: "What provider do you want to use?",
        embeds: "Choose which video to view",
        seasons: "Choose which season you want to watch",
        episode: "Pick an episode",
        captions: "Choose a subtitle language",
        captionPreferences: "Make subtitles look how you want it",
        playbackSpeed: "Change the playback speed"
      }
    },
    errors: {
      fatalError: "The video player encounted a fatal error, please report it to the <0>Discord server</0> or on <1>GitHub</1>."
    }
  },
  WWe = {
    title: "Settings",
    language: "Language",
    captionLanguage: "Caption Language"
  },
  KWe = {
    newSiteTitle: "New version now released!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web will soon be moving to a new domain: <0>https://movie-web.app</0>. Make sure to update all your bookmarks as <1>the old website will stop working on {{date}}.</1>",
    tireless: "We've worked tirelessly on this new update, we hope you will enjoy what we've been cooking up for the past months.",
    leaveAnnouncement: "Take me there!"
  },
  YWe = {
    casting: "Casting to device..."
  },
  qWe = {
    offline: "Check your internet connection"
  },
  XWe = {
    global: BWe,
    search: UWe,
    media: jWe,
    seasons: HWe,
    notFound: zWe,
    searchBar: GWe,
    videoPlayer: VWe,
    settings: WWe,
    v3: KWe,
    casting: YWe,
    errors: qWe
  },
  QWe = {
    name: "movie-web"
  },
  ZWe = {
    loading_series: "Recherche de votre sÃ©rie prÃ©fÃ©rÃ©e...",
    loading_movie: "Recherche de vos films prÃ©fÃ©rÃ©s...",
    loading: "Chargement...",
    allResults: "C'est tout ce que nous avons!",
    noResults: "Nous n'avons rien trouvÃ©!",
    allFailed: "Le mÃ©dia n'a pas Ã©tÃ© trouvÃ©, veuillez rÃ©essayez!",
    headingTitle: "RÃ©sultats de la recherche",
    bookmarks: "Favoris",
    continueWatching: "Continuer le visionnage",
    title: "Que voulez-vous voir?",
    placeholder: "Que voulez-vous voir?"
  },
  JWe = {
    movie: "Films",
    series: "SÃ©ries",
    stopEditing: "ArrÃªter l'Ã©dition",
    errors: {
      genericTitle: "Oups, c'est coupÃ© !",
      failedMeta: "Impossible de charger les mÃ©tadonnÃ©es",
      mediaFailed: "Nous n'avons pas rÃ©ussi Ã  rÃ©cupÃ©rer le mÃ©dia que vous avez demandÃ©. Veuillez vÃ©rifier votre connexion Internet et rÃ©essayer.",
      videoFailed: "Nous avons rencontrÃ© une erreur lors de la lecture de la vidÃ©o que vous avez demandÃ©e. Si cela se reproduit, veuillez signaler le problÃ¨me au serveur <0>Discord</0> ou sur <1>GitHub</1>."
    }
  },
  eKe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  tKe = {
    genericTitle: "Introuvable",
    backArrow: "Retour Ã  l'accueil",
    media: {
      title: "Impossible de trouver ce mÃ©dia",
      description: "Nous n'avons pas trouvÃ© le mÃ©dia que vous avez demandÃ©. Soit il a Ã©tÃ© supprimÃ©, soit vous avez modifiÃ© l'URL."
    },
    provider: {
      title: "Ce fournisseur a Ã©tÃ© dÃ©sactivÃ©",
      description: "Nous avons eu des problÃ¨mes avec le fournisseur ou il Ã©tait trop instable pour Ãªtre utilisÃ©, nous avons donc dÃ» le dÃ©sactiver."
    },
    page: {
      title: "Impossible de trouver cette page",
      description: "Nous avons cherchÃ© partout : sous les poubelles, dans le placard, derriÃ¨re le proxy, mais nous n'avons finalement pas trouvÃ© la page que vous cherchez."
    }
  },
  rKe = {
    movie: "Film",
    series: "SÃ©rie",
    Search: "Rechercher"
  },
  nKe = {
    findingBestVideo: "Recherche de la meilleure vidÃ©o pour vous",
    noVideos: "DÃ©solÃ©, nous n'avons pas pu trouver de vidÃ©os pour vous",
    loading: "Chargement...",
    backToHome: "Retour Ã  la page d'accueil",
    backToHomeShort: "Retour",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "{{timeLeft}} restant",
    finishAt: "Terminer Ã  {{timeFinished, datetime}}",
    buttons: {
      episodes: "Ãpisodes",
      source: "Source",
      captions: "Sous-titres",
      download: "TÃ©lÃ©charger",
      settings: "ParamÃ¨tres",
      pictureInPicture: "Image dans l'image",
      playbackSpeed: "Vitesse"
    },
    popouts: {
      back: "Retourner",
      sources: "Sources",
      seasons: "Saisons",
      captions: "Sous-titres",
      playbackSpeed: "Vitesse de lecture",
      customPlaybackSpeed: "Vitesse de lecture personnalisÃ©e",
      captionPreferences: {
        title: "Personnaliser",
        delay: "DÃ©lai",
        fontSize: "Taille",
        opacity: "OpacitÃ©",
        color: "Couleur"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "Pas de sous-titres",
      linkedCaptions: "Sous-titres liÃ©s",
      customCaption: "Sous-titres personnalisÃ©s",
      uploadCustomCaption: "TÃ©lÃ©charger des sous-titres",
      noEmbeds: "Aucun contenu intÃ©grÃ© n'a Ã©tÃ© trouvÃ© pour cette source",
      errors: {
        loadingWentWong: "Un problÃ¨me est survenu lors du chargement des Ã©pisodes pour {{seasonTitle}}",
        embedsError: "Un problÃ¨me est survenu lors du chargement des contenus intÃ©grÃ©s pour cet Ã©lÃ©ment que vous aimez"
      },
      descriptions: {
        sources: "Quel fournisseur voulez-vous utiliser ?",
        embeds: "Choisissez quelle vidÃ©o regarder",
        seasons: "Choisissez la saison que vous voulez regarder",
        episode: "SÃ©lectionnez un Ã©pisode",
        captions: "Choisissez une langue de sous-titres",
        captionPreferences: "Personnalisez l'apparence des sous-titres",
        playbackSpeed: "Changer la vitesse de lecture"
      }
    },
    errors: {
      fatalError: "Le lecteur vidÃ©o a rencontrÃ© une erreur fatale, veuillez la signaler au serveur <0>Discord</0> ou sur <1>GitHub</1>."
    }
  },
  iKe = {
    title: "ParamÃ¨tres",
    language: "Language",
    captionLanguage: "Langue des sous-titres"
  },
  aKe = {
    newSiteTitle: "Nouvelle version disponible!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web dÃ©mÃ©nagera bientÃ´t vers un nouveau domaine : <0>https://movie-web.app</0>. Veillez Ã  mettre Ã  jour tous vos favoris car <1>l'ancien site web cessera de fonctionner le {{date}}.</1>",
    tireless: "Nous avons travaillÃ© sans relÃ¢che sur cette nouvelle mise Ã  jour et nous espÃ©rons que vous apprÃ©cierez ce que nous avons prÃ©parÃ© ces derniers mois.",
    leaveAnnouncement: "Emmenez-moi lÃ !"
  },
  sKe = {
    casting: "Transmission Ã  l'appareil..."
  },
  oKe = {
    offline: "VÃ©rifiez votre connexion internet"
  },
  lKe = {
    global: QWe,
    search: ZWe,
    media: JWe,
    seasons: eKe,
    notFound: tKe,
    searchBar: rKe,
    videoPlayer: nKe,
    settings: iKe,
    v3: aKe,
    casting: sKe,
    errors: oKe
  },
  cKe = {
    name: "movie-web"
  },
  uKe = {
    loading_series: "Recupero delle tue serie preferite...",
    loading_movie: "Recupero dei tuoi film preferiti...",
    loading: "Caricamento...",
    allResults: "Ecco tutto ciÃ² che abbiamo!",
    noResults: "Non abbiamo trovato nulla!",
    allFailed: "Impossibile trovare i media, riprova!",
    headingTitle: "Risultati della ricerca",
    bookmarks: "Segnalibri",
    continueWatching: "Continua a guardare",
    title: "Cosa vuoi guardare?",
    placeholder: "Cosa vuoi guardare?"
  },
  fKe = {
    movie: "Film",
    series: "Serie",
    stopEditing: "Interrompi modifica",
    errors: {
      genericTitle: "Ops, qualcosa si Ã¨ rotto!",
      failedMeta: "Caricamento dei metadati non riuscito",
      mediaFailed: "Impossibile richiedere il media che hai richiesto, controlla la tua connessione internet e riprova.",
      videoFailed: "Si Ã¨ verificato un errore durante la riproduzione del video che hai richiesto. Se ciÃ² continua a accadere, segnala il problema sul <0>server Discord</0> o su <1>GitHub</1>."
    }
  },
  dKe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  hKe = {
    genericTitle: "Non trovato",
    backArrow: "Torna alla home",
    media: {
      title: "Impossibile trovare quel media",
      description: "Non siamo riusciti a trovare il media richiesto. Ã stato rimosso o hai manomesso l'URL."
    },
    provider: {
      title: "Questo provider Ã¨ stato disabilitato",
      description: "Abbiamo riscontrato problemi con il provider o era troppo instabile da utilizzare, quindi abbiamo dovuto disabilitarlo."
    },
    page: {
      title: "Impossibile trovare quella pagina",
      description: "Abbiamo cercato ovunque: sotto i bidoni, nell'armadio, dietro il proxy, ma alla fine non siamo riusciti a trovare la pagina che stai cercando."
    }
  },
  pKe = {
    movie: "Film",
    series: "Serie",
    Search: "Cerca"
  },
  gKe = {
    findingBestVideo: "Ricerca del miglior video per te",
    noVideos: "Ops, non Ã¨ stato possibile trovare alcun video per te",
    loading: "Caricamento...",
    backToHome: "Torna alla home",
    backToHomeShort: "Indietro",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "{{timeLeft}} rimanente",
    finishAt: "Fine alle {{timeFinished, datetime}}",
    buttons: {
      episodes: "Episodi",
      source: "Fonte",
      captions: "Sottotitoli",
      download: "Download",
      settings: "Impostazioni",
      pictureInPicture: "Picture in Picture",
      playbackSpeed: "VelocitÃ  di riproduzione"
    },
    popouts: {
      back: "Torna indietro",
      sources: "Fonti",
      seasons: "Stagioni",
      captions: "Sottotitoli",
      playbackSpeed: "VelocitÃ  di riproduzione",
      customPlaybackSpeed: "VelocitÃ  di riproduzione personalizzata",
      captionPreferences: {
        title: "Personalizza",
        delay: "Ritardo",
        fontSize: "Dimensione carattere",
        opacity: "OpacitÃ ",
        color: "Colore"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "Nessun sottotitolo",
      linkedCaptions: "Sottotitoli collegati",
      customCaption: "Sottotitolo personalizzato",
      uploadCustomCaption: "Carica sottotitolo",
      noEmbeds: "Nessun embed Ã¨ stato trovato per questa fonte",
      errors: {
        loadingWentWong: "Si Ã¨ verificato un problema durante il caricamento degli episodi per {{seasonTitle}}",
        embedsError: "Si Ã¨ verificato un problema durante il caricamento degli embed per questa cosa che ti piace"
      },
      descriptions: {
        sources: "Quale provider desideri utilizzare?",
        embeds: "Scegli quale video visualizzare",
        seasons: "Scegli quale stagione vuoi guardare",
        episode: "Scegli un episodio",
        captions: "Scegli una lingua per i sottotitoli",
        captionPreferences: "Personalizza l'aspetto dei sottotitoli",
        playbackSpeed: "Cambia la velocitÃ  di riproduzione"
      }
    },
    errors: {
      fatalError: "Il lettore video ha riscontrato un errore fatale, segnalalo sul <0>server Discord</0> o su <1>GitHub</1>."
    }
  },
  mKe = {
    title: "Impostazioni",
    language: "Lingua",
    captionLanguage: "Lingua dei sottotitoli"
  },
  vKe = {
    newSiteTitle: "Nuova versione ora disponibile!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web si sposterÃ  presto su un nuovo dominio: <0>https://movie-web.app</0>. Assicurati di aggiornare tutti i tuoi segnalibri poichÃ© <1>il vecchio sito smetterÃ  di funzionare il {{date}}.</1>",
    tireless: "Abbiamo lavorato instancabilmente su questo nuovo aggiornamento, speriamo che ti piaccia quello su cui abbiamo lavorato negli ultimi mesi.",
    leaveAnnouncement: "Portami lÃ¬!"
  },
  yKe = {
    casting: "Trasmissione su dispositivo in corso..."
  },
  xKe = {
    offline: "Controlla la tua connessione internet"
  },
  bKe = {
    global: cKe,
    search: uKe,
    media: fKe,
    seasons: dKe,
    notFound: hKe,
    searchBar: pKe,
    videoPlayer: gKe,
    settings: mKe,
    v3: vKe,
    casting: yKe,
    errors: xKe
  },
  EKe = {
    name: "movie-web"
  },
  SKe = {
    loading_series: "We zoeken je favoriete series...",
    loading_movie: "We zoeken je favoriete films...",
    loading: "Aan het zoeken...",
    allResults: "Dat is het!",
    noResults: "We konden helaas niets vinden.",
    allFailed: "Het is niet gelukt de media te laden, probeer het nog eens.",
    headingTitle: "Zoekresultaten",
    bookmarks: "Opgeslagen",
    continueWatching: "Kijk verder",
    title: "Wat wil je graag kijken?",
    placeholder: "Wat wil je graag kijken?"
  },
  _Ke = {
    movie: "Film",
    series: "Serie",
    stopEditing: "Stop met bewerken",
    errors: {
      genericTitle: "Oeps, hier ging iets mis!",
      failedMeta: "Het is niet gelukt de meta-informatie op te halen/",
      mediaFailed: "Het is niet gelukt deze media op te halen. Controleer of je een internetverbinding hebt en probeer het nog een keer.",
      videoFailed: "Er ging iets mis tijdens het spelen van deze video. Als dit blijft gebeuren, deel het dan in de <0>Discord server</0> of maak een <1>GitHub issue</1>."
    }
  },
  TKe = {
    seasonAndEpisode: "S{{season}} A{{episode}}"
  },
  wKe = {
    genericTitle: "Pagina niet gevonden",
    backArrow: "Naar de home-pagina",
    media: {
      title: "We konden deze media niet vinden.",
      description: "We konden dit stukje media niet vinden. Het is mogelijk verwijderd, of jij hebt zelf de URL aangepast."
    },
    provider: {
      title: "Deze bron is niet langer beschikbaar",
      description: "Deze bron was helaas te instabiel, we hebben hem jammer genoeg uit moeten zetten."
    },
    page: {
      title: "Pagina niet gevonden",
      description: "We hebben echt alles geprobeerd, zelfs tijdrijzen; echter hebben we deze pagina helaas niet kunnen vinden."
    }
  },
  RKe = {
    movie: "Films",
    series: "Series",
    Search: "Zoeken"
  },
  AKe = {
    findingBestVideo: "De beste video voor jou aan het zoeken...",
    noVideos: "Helaas konden we dat filmpje niet vinden",
    loading: "Aan het laden...",
    backToHome: "Naar de home-pagina",
    backToHomeShort: "Terug",
    seasonAndEpisode: "S{{season}} A{{episode}}",
    timeLeft: "Nog {{timeLeft}}",
    finishAt: "Afgelopen om {{timeFinished, datetime}}",
    buttons: {
      episodes: "Afleveringen",
      source: "Bron",
      captions: "Ondertiteling",
      download: "Download",
      settings: "Instellingen",
      pictureInPicture: "Beeld-in-beeld",
      playbackSpeed: "Afspeelsnelheid"
    },
    popouts: {
      back: "Terug",
      sources: "Bronnen",
      seasons: "Seizoenen",
      captions: "Ondertiteling",
      playbackSpeed: "Afspeelsnelheid",
      customPlaybackSpeed: "Andere snelheden",
      captionPreferences: {
        title: "Instellingen",
        delay: "Vertraging",
        fontSize: "Lettergrootte",
        opacity: "Doorzichtbaarheid",
        color: "Kleur"
      },
      episode: "A{{index}} - {{title}}",
      noCaptions: "Geen ondertiteling",
      linkedCaptions: "Gelinkte ondertiteling",
      customCaption: "Eigen ondertiteling",
      uploadCustomCaption: "Ondertiteling uploaden",
      noEmbeds: "We hebben geen filmpjes kunnen vinden voor deze bron.",
      errors: {
        loadingWentWong: "Er ging iets mis tijdens het laden van de afleveringen voor {{seasonTitle}}",
        embedsError: "Er ging iets mis tijdens het laden van de embeds voor dit dingetje dat je waarschijnlijk leuk vindt"
      },
      descriptions: {
        sources: "Welke bron wil je graag gebruiken",
        embeds: "Welk filmpje wil je gebruiken?",
        seasons: "Welk seizoen wil je kijken?",
        episode: "Kies een aflevering",
        captions: "Kies een taal voor de ondertiteling",
        captionPreferences: "Pas de ondertiteling aan aan je voorkeuren",
        playbackSpeed: "Pas de afspeelsnelhijd aan"
      }
    },
    errors: {
      fatalError: "De videospeler is helaas ontploft, rapporteer deze fout op de <0>Discord server</0> of op <1>GitHub</1>."
    }
  },
  IKe = {
    title: "Instellingen",
    language: "Taal",
    captionLanguage: "Taal voor de Ondertiteling"
  },
  $Ke = {
    newSiteTitle: "De nieuwe versie is uit!",
    newDomain: "https://movie-web.app",
    newDomainText: "We gaan binnenkort verhuizen naar een nieuw domein: <0>https://movie-web.app</0>. Pas je bladwijzers aan naar het nieuwe domein, want </b>het oude domein gaat stoppen met werken op {{date}}.</b>",
    tireless: "We hebben mega hard gewerkt aan deze nieuwe versie, dus we hopen dat je er van gaat genieten.",
    leaveAnnouncement: "Let's go!"
  },
  CKe = {
    casting: "Aan het casten..."
  },
  kKe = {
    offline: "Controleer je internetverbinding"
  },
  OKe = {
    global: EKe,
    search: SKe,
    media: _Ke,
    seasons: TKe,
    notFound: wKe,
    searchBar: RKe,
    videoPlayer: AKe,
    settings: IKe,
    v3: $Ke,
    casting: CKe,
    errors: kKe
  },
  LKe = {
    name: "movie-web"
  },
  PKe = {
    loading_series: "Fetchin' yer favorite series...",
    loading_movie: "Fetchin' yer favorite movies...",
    "loadin'": "Loadin'...",
    allResults: "That be all we 'ave, me hearty!",
    noResults: "We couldn't find anythin' that matches yer search!",
    allFailed: "Failed t' find media, walk the plank and try again!",
    headingTitle: "Search results",
    bookmarks: "Treasure Maps",
    "continueWatchin'": "Continue Watchin'",
    title: "Wha' be ye wantin' to watch, me matey?",
    placeholder: "Wha' be ye searchin' for?"
  },
  NKe = {
    movie: "Movie",
    series: "Series",
    "stopEditin'": "Stop editin'",
    errors: {
      genericTitle: "Shiver me timbers! It broke!",
      failedMeta: "Ye can't trust the compass, failed to load meta",
      mediaFailed: "We failed t' request the media ye asked fer, check yer internet connection, or Davy Jones's locker awaits ye!",
      videoFailed: "Blimey! We encountered an error while playin' the video ye requested. If this keeps happening please report the issue to the <0>Discord server</0> or on <1>GitHub</1>."
    }
  },
  DKe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  MKe = {
    genericTitle: "Ahoy! I see nothin' on the horizon.",
    backArrow: "Back to the port",
    media: {
      title: "Avast ye! Couldn't find that media",
      description: "We couldn't find the media ye requested. Either it's been scuttled or ye tampered with the URL, ye scallywag!"
    },
    provider: {
      title: "Walk the plank! This provider has been disabled",
      description: "We had issues wit' the provider or 'twas too unstable t' use, so we had t' disable it. Try another one, arrr!"
    },
    page: {
      title: "Avast ye! Couldn't find that page.",
      description: "Arrr! We searched every inch o' the vessel: from the bilge to the crow's nest, from the keel to the topmast, but avast! We couldn't find the page ye be lookin' fer, me heartie."
    }
  },
  FKe = {
    movie: "Movie",
    series: "Series",
    Search: "Search"
  },
  BKe = {
    findingBestVideo: "Finding the best video fer ye, hoist the colors!",
    noVideos: "Blistering barnacles, couldn't find any videos fer ye. Ye need a better map!",
    loading: "Loading...",
    backToHome: "Back to the port, mates!",
    backToHomeShort: "Back",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "{{timeLeft}} left",
    finishAt: "Finish at {{timeFinished}}",
    buttons: {
      episodes: "Episodes",
      source: "Source",
      captions: "Captions",
      download: "Download",
      settings: "Settings",
      pictureInPicture: "Spyglass view",
      playbackSpeed: "Set sail!"
    },
    popouts: {
      back: "Avast ye, go back!",
      sources: "Wha' provider do ye want to use?",
      seasons: "Choose which season you wants to watch!",
      captions: "Select a subtitle language, me hearty!",
      playbackSpeed: "Change the speed of Blackbeard's ship!",
      customPlaybackSpeed: "Set a custom playback speed",
      captionPreferences: {
        title: "Customize yer captions",
        delay: "Delay",
        fontSize: "Size",
        opacity: "Opacity",
        color: "Color"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "No captions, hoist the Jolly Roger!",
      linkedCaptions: "Linked captions, drop anchor!",
      customCaption: "Custom caption, arrr!",
      uploadCustomCaption: "Upload yer own caption!",
      noEmbeds: "No embeds we be found fer this source",
      errors: {
        loadingWentWong: "Shiver me timbers! Somethin' went wrong loadin' the episodes fer {{seasonTitle}}",
        embedsError: "Blimey! Somethin' went wrong loadin' the embeds fer this thin' that ye like"
      },
      descriptions: {
        sources: "Wha' provider do ye wants to use?",
        embeds: "Choose which video to view",
        seasons: "Choose which season ye wants to watch",
        episode: "Pick an episode",
        captions: "Choose a subtitle language",
        captionPreferences: "Make subtitles look how ye wants it",
        playbackSpeed: "Change the playback speed"
      }
    },
    errors: {
      fatalError: "Blow me down! The video player encounted a fatal error, please report it to the <0>Discord server</0> or on <1>GitHub</1>."
    }
  },
  UKe = {
    title: "Settings",
    language: "Language",
    captionLanguage: "Caption Language"
  },
  jKe = {
    newSiteTitle: "New version now released!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web will soon be movin' to a new domain: <0>https://movie-web.app</0>. Make sure to update all yer bookmarks as <1>the ole website will stop workin' on {{date}}.</1>",
    tireless: "We've worked tirelessly on this new update, we hope ye will enjoy wha' we've been cookin' up fer the past months.",
    leaveAnnouncement: "Take me thar!"
  },
  HKe = {
    casting: "Casting to device..."
  },
  zKe = {
    offline: "Avast! Check yer internet connection"
  },
  GKe = {
    global: LKe,
    search: PKe,
    media: NKe,
    seasons: DKe,
    notFound: MKe,
    searchBar: FKe,
    videoPlayer: BKe,
    settings: UKe,
    v3: jKe,
    casting: HKe,
    errors: zKe
  },
  VKe = {
    name: "movie-web"
  },
  WKe = {
    loading_series: "Szukamy twoich ulubionych seriali...",
    loading_movie: "Szukamy twoich ulubionych filmÃ³w...",
    loading: "Wczytywanie...",
    allResults: "To wszystko co mamy!",
    noResults: "Nie mogliÅmy niczego znaleÅºÄ!",
    allFailed: "Nie udaÅo siÄ znaleÅºÄ mediÃ³w, SprÃ³buj ponownie!",
    headingTitle: "Wyniki wyszukiwania",
    bookmarks: "ZakÅadki",
    continueWatching: "Kontynuuj oglÄdanie",
    title: "Co chciaÅbyÅ obejrzeÄ?",
    placeholder: "Co chciaÅbyÅ obejrzeÄ?"
  },
  KKe = {
    movie: "Film",
    series: "Serial",
    stopEditing: "Zatrzymaj edycje",
    errors: {
      genericTitle: "Ups, popsuÅo siÄ!",
      failedMeta: "Nie udaÅo siÄ wczytaÄ metadanych",
      mediaFailed: "Nie udaÅo nam siÄ zarzÄdaÄ mediÃ³w, sprawdÅº poÅÄczenie sieciowe i sprÃ³buj ponownie.",
      videoFailed: "NapotkaliÅmy bÅÄd podczas odtwarzania rzÄdanego video. JeÅli problem bÄdzie siÄ powtarzaÄ prosimy o zgÅoszenie problemu na <0>Serwer Discord</0> lub na <1>GitHub</1>."
    }
  },
  YKe = {
    seasonAndEpisode: "S{{season}} E{{episode}}"
  },
  qKe = {
    genericTitle: "Nie znaleziono",
    backArrow: "WrÃ³Ä na stronÄ gÅÃ³wnÄ",
    media: {
      title: "Nie moÅ¼na znaleÅºÄ multimediÃ³w",
      description: "Nie mogliÅmy znaleÅºÄ rzÄdanych multimediÃ³w. Albo zostaÅy usuniÄte, albo grzebaÅeÅ przy adresie URL."
    },
    provider: {
      title: "Ten dostawca zostaÅ wyÅÄczony",
      description: "MieliÅmy problemy z tym dostawcÄ, albo byÅ zbyt niestabilny, wiÄc musieliÅmy go wyÅÄczyÄ."
    },
    page: {
      title: "Nie moÅ¼na znaleÅºÄ tej strony",
      description: "SzukaliÅmy wszÄdzie: w koszu, w szafie a nawet w piwnicy, ale nie byliÅmy w stanie znaleÅºÄ strony ktÃ³rej szukasz."
    }
  },
  XKe = {
    movie: "Filmy",
    series: "Seriale",
    Search: "Szukaj"
  },
  QKe = {
    findingBestVideo: "Szukamy najlepszego video dla ciebie",
    noVideos: "Oj, Nie mogliÅmy znaleÅºÄ Å¼adnego video",
    loading: "Wczytywanie...",
    backToHome: "WrÃ³Ä na stronÄ gÅÃ³wnÄ",
    backToHomeShort: "WrÃ³Ä",
    seasonAndEpisode: "S{{season}} E{{episode}}",
    timeLeft: "PozostaÅo {{timeLeft}}",
    finishAt: "ZakoÅcz na {{timeFinished, datetime}}",
    buttons: {
      episodes: "Odcinki",
      source: "Å¹rÃ³dÅo",
      captions: "Napisy",
      download: "Pobierz",
      settings: "Ustawienia",
      pictureInPicture: "Obraz w obrazie (PIP)",
      playbackSpeed: "PrÄdkoÅÄ odtwarzania"
    },
    popouts: {
      close: "ZamknÄÄ",
      seasons: {
        title: "Sezony",
        other: "Inne sezony",
        noSeason: "Brak sezonu"
      },
      episodes: {
        unknown: "Nieznany odcinki",
        noEpisode: "Brak odcinki"
      },
      back: "WrÃ³Ä",
      sources: "Å¹rÃ³dÅa",
      captions: "Napisy",
      playbackSpeed: "PrÄdkoÅÄ odtwarzania",
      customPlaybackSpeed: "Niestandardowa prÄdkoÅÄ odtwarzania",
      captionPreferences: {
        title: "Personalizuj",
        delay: "OpÃ³Åºnienie",
        fontSize: "Rozmiar",
        opacity: "PrzeÅºroczystoÅÄ",
        color: "Kolor"
      },
      episode: "E{{index}} - {{title}}",
      noCaptions: "Brak napisÃ³w",
      linkedCaptions: "ZaÅÄczone napisy",
      customCaption: "Napisy niestandardowe",
      uploadCustomCaption: "ZaÅÄcz",
      noEmbeds: "Nie znaleziono osadzonych mediÃ³w dla tego ÅºrÃ³dÅa",
      errors: {
        loadingWentWong: "CoÅ poszÅo nie tak  {{seasonTitle}}",
        embedsError: "CoÅ poszÅo nie tak przy wczytywaniu osadzonych mediÃ³w"
      },
      descriptions: {
        sources: "KtÃ³rego dostawcy chciaÅbyÅ uÅ¼ywaÄ?",
        embeds: "Wybierz, ktÃ³re video chcesz zobaczyÄ",
        seasons: "Wybierz, ktÃ³ry sezon chcesz obejrzeÄ",
        episode: "Wybierz odcinek",
        captions: "ZmieÅ jÄzyk napisÃ³w",
        captionPreferences: "Ustaw napisy, tak jak ci to odpowiada",
        playbackSpeed: "ZmieÅ prÄdkoÅÄ odtwarzania"
      }
    },
    errors: {
      fatalError: "Odtwarzacz napotkaÅ powaÅ¼ny bÅÄd, Prosimy o zÅoszenie tego na <0>Serwer Discord</0> lub na <1>GitHub</1>."
    }
  },
  ZKe = {
    title: "Ustawienia",
    language: "JÄzyk",
    captionLanguage: "JÄzyk napisÃ³w"
  },
  JKe = {
    newSiteTitle: "Nowa wersja zostaÅa wydana!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web przeniesie siÄ wkrÃ³tce na nowy adres: <0>https://movie-web.app</0>. Prosimy zaaktualizowaÄ swoje zakÅadki poniewaÅ¼ <1>stara strona przestanie dziaÅaÄ {{date}}.</1>",
    tireless: "PracowaliÅmy niestrudzenie nad tÄ aktualizacjÄ, Mamy nadziejÄ Å¼e bÄdziecie zadowoleni z tego nad czym pracowaliÅmy przez ostatnie parÄ miesiÄcy.",
    leaveAnnouncement: "Zabierz mnie tam!"
  },
  eYe = {
    casting: "PrzesyÅanie do urzÄdzenia..."
  },
  tYe = {
    offline: "SprawdÅº swoje poÅÄczenie sieciowe"
  },
  rYe = {
    global: VKe,
    search: WKe,
    media: KKe,
    seasons: YKe,
    notFound: qKe,
    searchBar: XKe,
    videoPlayer: QKe,
    settings: ZKe,
    v3: JKe,
    casting: eYe,
    errors: tYe
  },
  nYe = {
    name: "movie-web"
  },
  iYe = {
    loading_series: "Favori dizileriniz aranÄ±yor...",
    loading_movie: "Favori filmleriniz aranÄ±yor...",
    loading: "YÃ¼kleniyor...",
    allResults: "Bu kadarÄ±nÄ± bulabildik!",
    noResults: "HiÃ§bir Åey bulamadÄ±k!",
    allFailed: "Medya bulunamadÄ±, tekrar deneyin!",
    headingTitle: "Arama sonuÃ§larÄ±",
    bookmarks: "Yerimleri",
    continueWatching: "Ä°zlemeye devam edin",
    title: "Ne izlemek istersiniz?",
    placeholder: "Ne izlemek istersiniz?"
  },
  aYe = {
    movie: "Film",
    series: "Dizi",
    stopEditing: "DÃ¼zenlemeyi durdur",
    errors: {
      genericTitle: "Hay aksi, bozuldu!",
      failedMeta: "Ãnbilgi yÃ¼klenemedi",
      mediaFailed: "Ä°stediÄiniz medyaya istek atarken hata oluÅtu, internet baÄlantÄ±nÄ±zÄ± kontrol edin ve tekrar deneyin.",
      videoFailed: "Ä°stediÄiniz videoyu oynatÄ±rken bir sorunla karÅÄ±laÅtÄ±k. Bu durum devam ederse lÃ¼tfen bunu <0>Discord sunucumuza</0> veya <1>GitHub</1> Ã¼zerinden bildiriniz."
    }
  },
  sYe = {
    seasonAndEpisode: "S{{season}} B{{episode}}"
  },
  oYe = {
    genericTitle: "BulunamadÄ±",
    backArrow: "Geri",
    media: {
      title: "Medya bulunamadÄ±",
      description: "Ä°stediÄiniz medyayÄ± bulamadÄ±k. URL'i yanlÄ±Å girdiniz ya da medya kaldÄ±rÄ±ldÄ±."
    },
    provider: {
      title: "Bu saÄlayÄ±cÄ± devre dÄ±ÅÄ± bÄ±rakÄ±ldÄ±",
      description: "SaÄlayÄ±cÄ± ile ilgili bir sorun oluÅtu ya da kullanÄ±lacak kadar stabil deÄildi bu yÃ¼zden devre dÄ±ÅÄ± bÄ±rakmak zorunda kaldÄ±k."
    },
    page: {
      title: "Sayfa bulunamadÄ±",
      description: "Her yere baktÄ±k: bazanÄ±n altÄ±na, dolabÄ±n iÃ§ine hatta ara sunucuya ama maalesef aradÄ±ÄÄ±nÄ±z sayfayÄ± bulamadÄ±k."
    }
  },
  lYe = {
    movie: "Film",
    series: "Dizi",
    Search: "Ara"
  },
  cYe = {
    findingBestVideo: "Sizin iÃ§in en iyi videoyu buluyoruz...",
    noVideos: "Hay aksi, hiÃ§bir video bulamadÄ±k",
    loading: "YÃ¼kleniyor...",
    backToHome: "Ana sayfaya dÃ¶n",
    backToHomeShort: "Geri",
    seasonAndEpisode: "S{{season}} B{{episode}}",
    timeLeft: "{{timeLeft}} kaldÄ±",
    finishAt: "{{timeFinished, datetime}}'de/da bitiyor",
    buttons: {
      episodes: "BÃ¶lÃ¼mler",
      source: "Kaynak",
      captions: "AltyazÄ±lar",
      download: "Ä°ndir",
      settings: "Ayarlar",
      pictureInPicture: "Resim iÃ§inde Resim",
      playbackSpeed: "Oynatma HÄ±zÄ±"
    },
    popouts: {
      back: "Geri git",
      sources: "Kaynaklar",
      close: "Kapat",
      seasons: {
        title: "Sezonlar",
        other: "DiÄer sezonlar",
        noSeason: "Sezon yok"
      },
      episodes: {
        unknown: "Bilinmeyen bÃ¶lÃ¼m",
        noEpisode: "BÃ¶lÃ¼m yok"
      },
      captions: "AltyazÄ±lar",
      playbackSpeed: "Oynatma hÄ±zÄ±",
      customPlaybackSpeed: "Ãzel oynatma hÄ±zÄ±",
      captionPreferences: {
        title: "KiÅiselleÅtirme",
        delay: "Gecikme",
        fontSize: "Boyut",
        opacity: "OpaklÄ±k",
        color: "Renk"
      },
      episode: "B{{index}} - {{title}}",
      noCaptions: "AltyazÄ± yok",
      linkedCaptions: "Kaynak AltyazÄ±larÄ±",
      customCaption: "Ãzel altyazÄ±",
      uploadCustomCaption: "AltyazÄ± yÃ¼kle",
      noEmbeds: "Bu kaynak iÃ§in gÃ¶mÃ¼lÃ¼ video bulunamadÄ±",
      errors: {
        loadingWentWong: "{{seasonTitle}} iÃ§in bÃ¶lÃ¼mler yÃ¼klenirken bir hata oluÅtu",
        embedsError: "Ä°stediÄiniz Åey iÃ§in gÃ¶mÃ¼lÃ¼ video bulunurken bir hata oluÅtu"
      },
      descriptions: {
        sources: "Hangi saÄlayÄ±cÄ±yÄ± kullanmak istersiniz?",
        embeds: "GÃ¶rÃ¼ntÃ¼lemek istediÄiniz videoyu seÃ§iniz",
        seasons: "Ä°zlemek istediÄiniz sezonu seÃ§iniz",
        episode: "Bir bÃ¶lÃ¼m seÃ§iniz",
        captions: "AltyazÄ± dili seÃ§iniz",
        captionPreferences: "AltyazÄ±larÄ± istediÄiniz gibi ayarlayÄ±n",
        playbackSpeed: "Oynatma hÄ±zÄ±nÄ±zÄ± deÄiÅtirin"
      }
    },
    errors: {
      fatalError: "Video oynatÄ±cÄ±da bir hata oluÅtu, lÃ¼tfen bunu <0>Discord sunucumuzda</0> ya da <1>GitHub</1> Ã¼zeriden bildiriniz."
    }
  },
  uYe = {
    title: "Ayarlar",
    language: "Dil",
    captionLanguage: "AltyazÄ± Dili"
  },
  fYe = {
    newSiteTitle: "Yeni sÃ¼rÃ¼m yayÄ±nlandÄ±!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web yakÄ±nda yeni bir alan adÄ±na taÅÄ±nacak: <0>https://movie-web.app</0>. <1>{{date}} tarihinde eski site Ã§alÄ±ÅmayacaÄÄ± iÃ§in</1> yerimlerinizi gÃ¼ncellemeyi unutmayÄ±n.",
    tireless: "Bu yeni gÃ¼ncelleme iÃ§in gece gÃ¼ndÃ¼z Ã§alÄ±ÅtÄ±k, umarÄ±z aylardan beri hazÄ±rladÄ±ÄÄ±mÄ±z bu gÃ¼ncellemeyi beÄenirsiniz.",
    leaveAnnouncement: "GÃ¶tÃ¼r beni!"
  },
  dYe = {
    casting: "Cihaza aktarÄ±lÄ±yor..."
  },
  hYe = {
    offline: "Ä°nternet baÄlantÄ±nÄ±zÄ± kontrol ediniz"
  },
  pYe = {
    global: nYe,
    search: iYe,
    media: aYe,
    seasons: sYe,
    notFound: oYe,
    searchBar: lYe,
    videoPlayer: cYe,
    settings: uYe,
    v3: fYe,
    casting: dYe,
    errors: hYe
  },
  gYe = {
    name: "movie-web"
  },
  mYe = {
    loading_series: "Äang tÃ¬m chÆ°Æ¡ng trÃ¬nh yÃªu thÃ­ch cá»§a báº¡n...",
    loading_movie: "Äang tÃ¬m bá» phim yÃªu thÃ­ch cá»§a báº¡n...",
    loading: "Äang táº£i...",
    allResults: "ÄÃ³ lÃ  táº¥t cáº£ chÃºng tÃ´i cÃ³!",
    noResults: "ChÃºng tÃ´i khÃ´ng thá» tÃ¬m tháº¥y gÃ¬!",
    allFailed: "KhÃ´ng thá» tÃ¬m tháº¥y ná»i dung, hÃ£y thá»­ láº¡i!",
    headingTitle: "Káº¿t quáº£ tÃ¬m kiáº¿m",
    bookmarks: "ÄÃ¡nh dáº¥u",
    continueWatching: "Tiáº¿p tá»¥c xem",
    title: "Báº¡n muá»n xem gÃ¬?",
    placeholder: "Báº¡n muá»n xem gÃ¬?"
  },
  vYe = {
    movie: "Phim",
    series: "ChÆ°Æ¡ng trÃ¬nh truyá»n hÃ¬nh",
    stopEditing: "HÃ£y dá»«ng chá»nh sá»­a",
    errors: {
      genericTitle: "Ráº¥t tiáº¿c, ÄÃ£ há»ng!",
      failedMeta: "KhÃ´ng thá» táº£i meta",
      mediaFailed: "ChÃºng tÃ´i khÃ´ng thá» tÃ¬m tháº¥y ná»i dung mÃ  báº¡n yÃªu cáº§u, hÃ£y kiá»m tra káº¿t ná»i internet cá»§a báº¡n vÃ  thá»­ láº¡i.",
      videoFailed: "ChÃºng tÃ´i ÄÃ£ gáº·p lá»i khi phÃ¡t ná»i dung mÃ  báº¡n yÃªu cáº§u. Náº¿u Äiá»u nÃ y tiáº¿p tá»¥c xáº£y ra, vui lÃ²ng bÃ¡o cÃ¡o sá»± cá» trÃªn <0>mÃ¡y chá»§ Discord</0> hoáº·c trÃªn <1>GitHub</1>."
    }
  },
  yYe = {
    seasonAndEpisode: "M{{season}} T{{episode}}"
  },
  xYe = {
    genericTitle: "KhÃ´ng tÃ¬m tháº¥y",
    backArrow: "Quay láº¡i trang chÃ­nh",
    media: {
      title: "KhÃ´ng thá» tÃ¬m tháº¥y ná»i dung",
      description: "ChÃºng tÃ´i khÃ´ng thá» tÃ¬m tháº¥y ná»i dung mÃ  báº¡n yÃªu cáº§u. Hoáº·c lÃ  nÃ³ ÄÃ£ bá» xÃ³a, hoáº·c báº¡n ÄÃ£ xÃ¡o trá»n URL"
    },
    provider: {
      title: "NhÃ  cung cáº¥p nÃ y ÄÃ£ bá» vÃ´ hiá»u hÃ³a",
      description: "ChÃºng tÃ´i ÄÃ£ gáº·p váº¥n Äá» vá»i nhÃ  cung cáº¥p hoáº·c nÃ³ quÃ¡ báº¥t á»n Äá» sá»­ dá»¥ng, cho nÃªn chÃºng tÃ´i ÄÃ£ pháº£i vÃ´ hiá»u hÃ³a nÃ³."
    },
    page: {
      title: "KhÃ´ng thá» tÃ¬m tháº¥y trang",
      description: "ChÃºng tÃ´i ÄÃ£ tÃ¬m kiáº¿m kháº¯p nÆ¡i: dÆ°á»i thÃ¹ng rÃ¡c, trong tá»§ quáº§n Ã¡o, Äáº±ng sau mÃ¡y chá»§ proxy nhÆ°ng váº«n khÃ´ng thá» tÃ¬m tháº¥y trang báº¡n Äang tÃ¬m kiáº¿m."
    }
  },
  bYe = {
    movie: "Phim",
    series: "ChÆ°Æ¡ng trÃ¬nh truyá»n hÃ¬nh",
    Search: "TÃ¬m kiáº¿m"
  },
  EYe = {
    findingBestVideo: "Äang tÃ¬m ná»i dung tá»t nháº¥t cho báº¡n",
    noVideos: "Ráº¥t tiáº¿c, khÃ´ng tÃ¬m tháº¥y ná»i dung nÃ o cho báº¡n",
    loading: "Äang táº£i...",
    backToHome: "Quay láº¡i trang chÃ­nh",
    backToHomeShort: "Quay láº¡i",
    seasonAndEpisode: "M{{season}} T{{episode}}",
    timeLeft: "CÃ²n {{timeLeft}}",
    finishAt: "Káº¿t thÃºc vÃ o {{timeFinished, datetime}}",
    buttons: {
      episodes: "Táº­p",
      source: "Source",
      captions: "Phá»¥ Äá»",
      download: "Táº£i xuá»ng",
      settings: "CÃ i Äáº·t",
      pictureInPicture: "HÃ¬nh trong hÃ¬nh",
      playbackSpeed: "Tá»c Äá» phÃ¡t"
    },
    popouts: {
      back: "Quay láº¡i",
      sources: "Nguá»n",
      seasons: "MÃ¹a",
      captions: "Phá»¥ Äá»",
      playbackSpeed: "Tá»c Äá» phÃ¡t",
      customPlaybackSpeed: "Tá»§y chá»nh tá»c Äá» phÃ¡t",
      captionPreferences: {
        title: "TÃ¹y chá»nh",
        delay: "TrÃ¬ hoÃ£n",
        fontSize: "KÃ­ch cá»¡",
        opacity: "Äá» má»",
        color: "MÃ u sáº¯c"
      },
      episode: "T{{index}} - {{title}}",
      noCaptions: "KhÃ´ng phá»¥ Äá»",
      linkedCaptions: "Phá»¥ Äá» ÄÆ°á»£c liÃªn káº¿t",
      customCaption: "Phá»¥ Äá» tÃ¹y chá»nh",
      uploadCustomCaption: "Táº£i phá»¥ Äá» lÃªn",
      noEmbeds: "KhÃ´ng tÃ¬m tháº¥y ná»i dung nhÃºng nÃ o cho nguá»n nÃ y",
      errors: {
        loadingWentWong: "ÄÃ£ xáº£y ra lá»i khi táº£i cÃ¡c táº­p phim cho {{seasonTitle}}",
        embedsError: "ÄÃ£ xáº£y ra lá»i khi táº£i ná»i dung nhÃºng cho ná»i dung báº¡n thÃ­ch nÃ y"
      },
      descriptions: {
        sources: "Báº¡n muá»n sá»­ dá»¥ng nhÃ  cung cáº¥p nÃ o?",
        embeds: "Chá»n video Äá» xem",
        seasons: "Chá»n mÃ¹a báº¡n muá»n xem",
        episode: "Chá»n má»t táº­p",
        captions: "Chá»n ngÃ´n ngá»¯ cá»§a phá»¥ Äá»",
        captionPreferences: "LÃ m cho phá»¥ Äá» trÃ´ng nhÆ° tháº¿ nÃ o báº¡n muá»n",
        playbackSpeed: "Thay Äá»i tá»c Äá» phÃ¡t"
      }
    },
    errors: {
      fatalError: "TrÃ¬nh phÃ¡t video ÄÃ£ gáº·p pháº£i lá»i nghiÃªm trá»ng, vui lÃ²ng bÃ¡o cÃ¡o sá»± cá» trÃªn <0>mÃ¡y chá»§ Discord</0> hoáº·c trÃªn <1>GitHub</1>."
    }
  },
  SYe = {
    title: "CÃ i Äáº·t",
    language: "NgÃ´n ngá»¯",
    captionLanguage: "NgÃ´n ngá»¯ phá»¥ Äá»"
  },
  _Ye = {
    newSiteTitle: "PhiÃªn báº£n má»i ÄÃ£ ÄÆ°á»£c phÃ¡t hÃ nh!",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web sáº½ sá»m chuyá»n sang trang má»i: <0>https://movie-web.app</0>. HÃ£y Äáº£m báº£o ráº±ng cÃ¡c ÄÃ¡nh dáº¥u ÄÃ£ ÄÆ°á»£c cáº­p nháº­t vÃ¬ <1>trang web cÅ© sáº½ dá»«ng hoáº¡t Äá»ng vÃ o {{date}}.</1>",
    tireless: "ChÃºng tÃ´i ÄÃ£ lÃ m viá»c váº¥t váº£ Äá» táº¡o phiÃªn báº£n má»i nÃ y, chÃºng tÃ´i hy vá»ng báº¡n sáº½ thÃ­ch nhá»¯ng gÃ¬ chÃºng tÃ´i ÄÃ£ nung náº¥u trong nhá»¯ng thÃ¡ng qua.",
    leaveAnnouncement: "HÃ£y ÄÆ°a tÃ´i Äáº¿n ÄÃ³!"
  },
  TYe = {
    casting: "Äang truyá»n tá»i thiáº¿t bá»..."
  },
  wYe = {
    offline: "HÃ£y kiá»m tra káº¿t ná»i Internet cá»§a báº¡n"
  },
  RYe = {
    global: gYe,
    search: mYe,
    media: vYe,
    seasons: yYe,
    notFound: xYe,
    searchBar: bYe,
    videoPlayer: EYe,
    settings: SYe,
    v3: _Ye,
    casting: TYe,
    errors: wYe
  },
  AYe = {
    name: "movie-web"
  },
  IYe = {
    loading_series: "æ­£å¨è·åæ¨æåæ¬¢çè¿ç»­å§â¦â¦",
    loading_movie: "æ­£å¨è·åæ¨æåæ¬¢çå½±çâ¦â¦",
    loading: "è½½å¥ä¸­â¦â¦",
    allResults: "ä»¥ä¸æ¯æä»¬è½æ¾å°çææç»æï¼",
    noResults: "æä»¬æ¾ä¸å°ä»»ä½ç»æï¼",
    allFailed: "æ¥æ¾åªä½å¤±è´¥ï¼è¯·éè¯ï¼",
    headingTitle: "æç´¢ç»æ",
    bookmarks: "ä¹¦ç­¾",
    continueWatching: "ç»§ç»­è§ç",
    title: "æ¨æ³çäºä»ä¹ï¼",
    placeholder: "æ¨æ³çäºä»ä¹ï¼"
  },
  $Ye = {
    movie: "çµå½±",
    series: "è¿ç»­å§",
    stopEditing: "éåºç¼è¾",
    errors: {
      genericTitle: "ååï¼åºé®é¢äºï¼",
      failedMeta: "å è½½åæ°æ®å¤±è´¥",
      mediaFailed: "æä»¬æªè½è¯·æ±å°æ¨è¦æ±çåªä½ï¼æ£æ¥äºèç½è¿æ¥å¹¶éè¯ã",
      videoFailed: "æä»¬å¨æ­æ¾æ¨è¦æ±çè§é¢æ¶éå°äºéè¯¯ãå¦æéè¯¯æç»­åçï¼è¯·å <0>Discord æå¡å¨</0>æ <1>GitHub</1> æäº¤é®é¢æ¥åã"
    }
  },
  CYe = {
    seasonAndEpisode: "ç¬¬{{season}}å­£ ç¬¬{{episode}}é"
  },
  kYe = {
    genericTitle: "æªæ¾å°",
    backArrow: "è¿åé¦é¡µ",
    media: {
      title: "æ æ³æ¾å°åªä½",
      description: "æä»¬æ æ³æ¾å°æ¨è¯·æ±çåªä½ãå®å¯è½å·²è¢«å é¤ï¼ææ¨ç¯¡æ¹äº URL"
    },
    provider: {
      title: "è¯¥åå®¹æä¾èå·²è¢«åç¨",
      description: "æä»¬çæä¾èåºç°é®é¢ï¼ææ¯å¤ªä¸ç¨³å®ï¼å¯¼è´æ æ³ä½¿ç¨ï¼æä»¥æä»¬ä¸å¾ä¸å°å¶åç¨ã"
    },
    page: {
      title: "æ æ³æ¾å°é¡µé¢",
      description: "æä»¬å·²ç»å°å¤æ¾è¿äºï¼ä¸ç®¡æ¯åå¾æ¡¶ä¸ãæ©±æéææ¯ä»£çä¹åãä½æç»å¹¶æ²¡æåç°æ¨æ¥æ¾çé¡µé¢ã"
    }
  },
  OYe = {
    movie: "çµå½±",
    series: "è¿ç»­å§",
    Search: "æç´¢"
  },
  LYe = {
    findingBestVideo: "æ­£å¨ä¸ºæ¨æ¢æµæä½³è§é¢",
    noVideos: "ååï¼æ æ³ä¸ºæ¨æ¾å°ä»»ä½è§é¢",
    loading: "è½½å¥ä¸­â¦â¦",
    backToHome: "è¿åé¦é¡µ",
    backToHomeShort: "è¿å",
    seasonAndEpisode: "ç¬¬{{season}}å­£ ç¬¬{{episode}}é",
    timeLeft: "è¿å©ä½ {{timeLeft}}",
    finishAt: "å¨ {{timeFinished, datetime}} ç»æ",
    buttons: {
      episodes: "åé",
      source: "è§é¢æº",
      captions: "å­å¹",
      download: "ä¸è½½",
      settings: "è®¾ç½®",
      pictureInPicture: "ç»ä¸­ç»",
      playbackSpeed: "æ­æ¾éåº¦"
    },
    popouts: {
      back: "è¿å",
      sources: "è§é¢æº",
      seasons: "åå­£",
      captions: "å­å¹",
      playbackSpeed: "æ­æ¾éåº¦",
      customPlaybackSpeed: "èªå®ä¹æ­æ¾éåº¦",
      captionPreferences: {
        title: "èªå®ä¹",
        delay: "å»¶è¿",
        fontSize: "å°ºå¯¸",
        opacity: "éæåº¦",
        color: "é¢è²"
      },
      episode: "ç¬¬{{index}}é - {{title}}",
      noCaptions: "æ²¡æå­å¹",
      linkedCaptions: "å·²é¾æ¥å­å¹",
      customCaption: "èªå®ä¹å­å¹",
      uploadCustomCaption: "ä¸ä¼ å­å¹",
      noEmbeds: "æªåç°è¯¥è§é¢æºçåµå¥åå®¹",
      errors: {
        loadingWentWong: "å è½½ {{seasonTitle}} çåéæ¶åºç°äºä¸äºé®é¢",
        embedsError: "ä¸ºæ¨åæ¬¢çè¿ä¸ä¸è¥¿å è½½åµå¥åå®¹æ¶åºç°äºä¸äºé®é¢"
      },
      descriptions: {
        sources: "æ¨æ³ä½¿ç¨åªä¸ªåå®¹æä¾èï¼",
        embeds: "éæ©è¦è§ççè§é¢",
        seasons: "éæ©æ¨è¦è§ççå­£",
        episode: "éæ©ä¸ä¸ªåé",
        captions: "éæ©å­å¹è¯­è¨",
        captionPreferences: "è®©å­å¹çèµ·æ¥å¦æ¨ææ³",
        playbackSpeed: "æ¹åæ­æ¾éåº¦"
      }
    },
    errors: {
      fatalError: "è§é¢æ­æ¾å¨éå°è´å½éè¯¯ï¼è¯·å <0>Discord æå¡å¨</0>æ <1>GitHub</1> æ¥åã"
    }
  },
  PYe = {
    title: "è®¾ç½®",
    language: "è¯­è¨",
    captionLanguage: "å­å¹è¯­è¨"
  },
  NYe = {
    newSiteTitle: "æ°ççæ¬ç°å·²åå¸ï¼",
    newDomain: "https://movie-web.app",
    newDomainText: "movie-web å°å¾å¿«è½¬ç§»å°æ°çååï¼<0>https://movie-web.app</0>ãè¯·ç¡®ä¿å·²ç»æ´æ°å¨é¨ä¹¦ç­¾é¾æ¥ï¼<1>æ§ç½ç«å°äº {{date}} åæ­¢å·¥ä½ã</1>",
    tireless: "ä¸ºäºè¿ä¸æ°çæ¬ï¼æä»¬ä¸æåªåï¼å¸ææ¨ä¼åæ¬¢æä»¬å¨è¿å»å ä¸ªæä¸­æåçä¸åã",
    leaveAnnouncement: "è¯·å¸¦æå»ï¼"
  },
  DYe = {
    casting: "æ­£å¨æå°å°è®¾å¤â¦â¦"
  },
  MYe = {
    offline: "æ£æ¥æ¨çäºèç½è¿æ¥"
  },
  FYe = {
    global: AYe,
    search: IYe,
    media: $Ye,
    seasons: CYe,
    notFound: kYe,
    searchBar: OYe,
    videoPlayer: LYe,
    settings: PYe,
    v3: NYe,
    casting: DYe,
    errors: MYe
  },
  aZ = {
    en: {
      translation: XWe
    },
    it: {
      translation: bKe
    },
    nl: {
      translation: OKe
    },
    tr: {
      translation: pYe
    },
    fr: {
      translation: lKe
    },
    de: {
      translation: FWe
    },
    zh: {
      translation: FYe
    },
    cs: {
      translation: RWe
    },
    pirate: {
      translation: GKe
    },
    vi: {
      translation: RYe
    },
    pl: {
      translation: rYe
    }
  };
Er.use(dMe).init({
  fallbackLng: "en",
  resources: aZ,
  interpolation: {
    escapeValue: !1
  }
});
const zB = S1.filter(t => Object.keys(aZ).includes(t.id));

function BYe(t) {
  const {
    captionSettings: e,
    language: r,
    setLanguage: n,
    setCaptionLanguage: i,
    setCaptionBackgroundColor: a,
    setCaptionFontSize: s
  } = id(), {
    t: o,
    i18n: c
  } = ke(), l = A.useMemo(() => S1.find(d => d.id === e.language), [e.language]), u = A.useMemo(() => zB.find(d => d.id === r), [r]), f = (parseInt(e.style.backgroundColor.substring(7, 9), 16) / 255 * 100).toFixed(0);
  return E(tZ, {
    show: t.show,
    children: Y(rZ, {
      className: "text-white",
      children: [Y("div", {
        className: "flex flex-col gap-4",
        children: [Y("div", {
          className: "flex flex-row justify-between",
          children: [E("span", {
            className: "text-xl font-bold",
            children: o("settings.title")
          }), E("div", {
            onClick: () => t.onClose(),
            className: "hover:cursor-pointer",
            children: E(Ve, {
              icon: ue.X
            })
          })]
        }), Y("div", {
          className: "flex flex-col gap-10 lg:flex-row",
          children: [Y("div", {
            className: "lg:w-1/2",
            children: [Y("div", {
              className: "flex flex-col justify-between",
              children: [E("label", {
                className: "text-md font-semibold",
                children: o("settings.language")
              }), E(TB, {
                selectedItem: u,
                setSelectedItem: d => {
                  c.changeLanguage(d.id), n(d.id)
                },
                options: zB
              })]
            }), Y("div", {
              className: "flex flex-col justify-between",
              children: [E("label", {
                className: "text-md font-semibold",
                children: o("settings.captionLanguage")
              }), E(TB, {
                selectedItem: l,
                setSelectedItem: d => {
                  i(d.id)
                },
                options: S1
              })]
            }), Y("div", {
              className: "flex flex-col justify-between",
              children: [E(Ku, {
                label: o("videoPlayer.popouts.captionPreferences.fontSize"),
                min: 14,
                step: 1,
                max: 60,
                value: e.style.fontSize,
                onChange: d => s(d.target.valueAsNumber)
              }), E(Ku, {
                label: o("videoPlayer.popouts.captionPreferences.opacity"),
                step: 1,
                min: 0,
                max: 255,
                valueDisplay: `${f}%`,
                value: parseInt(e.style.backgroundColor.substring(7, 9), 16),
                onChange: d => a(d.target.valueAsNumber)
              }), Y("div", {
                className: "flex flex-row justify-between",
                children: [E("label", {
                  className: "font-bold",
                  htmlFor: "color",
                  children: o("videoPlayer.popouts.captionPreferences.color")
                }), E("div", {
                  className: "flex flex-row gap-2",
                  children: XX.map(d => E(QX, {
                    color: d
                  }))
                })]
              })]
            }), E("div", {})]
          }), E("div", {
            className: "flex w-full flex-col justify-center",
            children: E("div", {
              className: "flex aspect-video flex-col justify-end rounded bg-zinc-800",
              children: E("div", {
                className: "pointer-events-none flex w-full flex-col items-center transition-[bottom]",
                children: E(eZ, {
                  scale: .5,
                  text: l.nativeName
                })
              })
            })
          })]
        })]
      }), Y("div", {
        className: "float-right mt-1 text-sm",
        children: ["v", kr().APP_VERSION]
      })]
    })
  })
}

function sZ(t) {
  const e = Jb(),
    [r, n] = A.useState(!1);
  return Y("div", {
    className: "fixed left-0 right-0 top-0 z-20 min-h-[150px] bg-gradient-to-b from-denim-300 via-denim-300 to-transparent sm:from-transparent",
    style: {
      top: `${e}px`
    },
    children: [Y("div", {
      className: "fixed left-0 right-0 flex items-center justify-between px-7 py-5",
      children: [E("div", {
        className: `${t.bg?"opacity-100":"opacity-0"} absolute inset-0 block bg-denim-100 transition-opacity duration-300`,
        children: E("div", {
          className: "pointer-events-none absolute -bottom-24 h-24 w-full bg-gradient-to-b from-denim-100 to-transparent"
        })
      }), Y("div", {
        className: "relative flex w-full items-center justify-center sm:w-fit",
        children: [E("div", {
          className: "mr-auto sm:mr-6",
          children: E(sg, {
            to: "/",
            children: E(Lq, {
              clickable: !0
            })
          })
        }), t.children]
      }), Y("div", {
        className: `${t.children?"hidden sm:flex":"flex"} relative flex-row	gap-4`,
        children: [E(rn, {
          className: "text-2xl text-white",
          icon: ue.GEAR,
          clickable: !0,
          onClick: () => {
            n(!0)
          }
        }), E("a", {
          href: kr().DISCORD_LINK,
          target: "_blank",
          rel: "noreferrer",
          className: "text-2xl text-white",
          children: E(rn, {
            icon: ue.DISCORD,
            clickable: !0
          })
        }), E("a", {
          href: kr().GITHUB_LINK,
          target: "_blank",
          rel: "noreferrer",
          className: "text-2xl text-white",
          children: E(rn, {
            icon: ue.GITHUB,
            clickable: !0
          })
        })]
      })]
    }), E(BYe, {
      show: r,
      onClose: () => n(!1)
    })]
  })
}

function oZ(t) {
  const e = t.direction || "right",
    r = !!t.url,
    n = !!t.to,
    i = Y("span", {
      className: "group mt-1 inline-flex cursor-pointer items-center space-x-1 pr-1 font-bold text-bink-600 hover:text-bink-700 active:scale-95",
      children: [e === "left" ? E("span", {
        className: "text-xl transition-transform group-hover:-translate-x-1",
        children: E(Ve, {
          icon: ue.ARROW_LEFT
        })
      }) : null, E("span", {
        className: "flex-1",
        children: t.linkText
      }), e === "right" ? E("span", {
        className: "text-xl transition-transform group-hover:translate-x-1",
        children: E(Ve, {
          icon: ue.ARROW_RIGHT
        })
      }) : null]
    });
  return r ? E("a", {
    href: t.url,
    children: i
  }) : n ? E(sg, {
    to: t.to,
    children: i
  }) : E("span", {
    onClick: () => t.onClick && t.onClick(),
    children: i
  })
}

function lZ(t) {
  const {
    t: e
  } = ke(), r = nE();
  return Y("div", {
    className: "relative flex flex-1 flex-col",
    children: [E(va, {
      children: E("title", {
        children: e("notFound.genericTitle")
      })
    }), t.video ? E("div", {
      className: "absolute inset-x-0 top-0 px-8 py-6",
      children: E(Ec, {
        onClick: r
      })
    }) : E(sZ, {}), E("div", {
      className: "flex h-full flex-1 flex-col items-center justify-center p-5 text-center",
      children: t.children
    })]
  })
}

function UYe() {
  const {
    t
  } = ke();
  return Y("div", {
    className: "flex flex-1 flex-col items-center justify-center p-5 text-center",
    children: [E(rn, {
      icon: ue.EYE_SLASH,
      className: "mb-6 text-xl text-bink-600"
    }), E(og, {
      children: t("notFound.media.title")
    }), E("p", {
      className: "mb-12 mt-5 max-w-sm",
      children: t("notFound.media.description")
    }), E(oZ, {
      to: "/",
      linkText: t("notFound.backArrow")
    })]
  })
}

function jYe() {
  const {
    t
  } = ke();
  return Y(lZ, {
    children: [E(rn, {
      icon: ue.EYE_SLASH,
      className: "mb-6 text-xl text-bink-600"
    }), E(og, {
      children: t("notFound.page.title")
    }), E("p", {
      className: "mb-12 mt-5 max-w-sm",
      children: t("notFound.page.description")
    }), E(oZ, {
      to: "/",
      linkText: t("notFound.backArrow")
    })]
  })
}

function HYe(t) {
  const {
    t: e
  } = ke();
  return Y("div", {
    className: "relative flex flex-1 items-center justify-center",
    children: [E(va, {
      children: E("title", {
        children: e("videoPlayer.loading")
      })
    }), E("div", {
      className: "absolute inset-x-0 top-0 px-8 py-6",
      children: E(Ec, {
        onClick: t.onGoBack
      })
    }), Y("div", {
      className: "flex flex-col items-center",
      children: [E(lg, {
        className: "mb-4"
      }), E("p", {
        className: "mb-8 text-denim-700",
        children: e("videoPlayer.findingBestVideo")
      })]
    })]
  })
}

function zYe(t) {
  const {
    eventLog: e,
    stream: r,
    pending: n
  } = D6e(t.meta, t.selected), {
    t: i
  } = ke();
  return A.useEffect(() => {
    r && t.onStream(r)
  }, [r, t]), Y("div", {
    className: "relative flex flex-1 items-center justify-center",
    children: [E(va, {
      children: E("title", {
        children: t.meta.meta.title
      })
    }), E("div", {
      className: "absolute inset-x-0 top-0 px-8 py-6",
      children: E(Ec, {
        onClick: t.onGoBack,
        media: t.meta.meta
      })
    }), Y("div", {
      className: "flex flex-col items-center transition-opacity duration-200",
      children: [n ? Y(yr, {
        children: [E(lg, {}), E("p", {
          className: "mb-8 text-denim-700",
          children: i("videoPlayer.findingBestVideo")
        })]
      }) : Y(yr, {
        children: [E(rn, {
          icon: ue.EYE_SLASH,
          className: "mb-8 text-bink-700"
        }), E("p", {
          className: "mb-8 text-denim-700",
          children: i("videoPlayer.noVideos")
        })]
      }), E("div", {
        className: `flex flex-col items-center transition-opacity duration-200 ${n?"opacity-100":"opacity-0"}`,
        children: E(NVe, {
          events: e
        })
      })]
    })]
  })
}

function GYe(t) {
  const e = nE(),
    {
      updateProgress: r,
      watchedItem: n
    } = qFe(t.meta, t.selected.episode),
    i = A.useRef(n == null ? void 0 : n.progress);
  A.useEffect(() => {
    i.current = n == null ? void 0 : n.progress
  }, [t.stream]);
  const a = {
    meta: t.meta,
    captions: []
  };
  let s;
  return t.selected.type === ae.SERIES && t.meta.meta.type === ae.SERIES && (a.episode = {
    seasonId: t.selected.season,
    episodeId: t.selected.episode
  }, a.seasons = t.meta.meta.seasons, s = t.meta.meta.seasonData), Y("div", {
    className: "fixed left-0 top-0 h-[100dvh] w-screen",
    children: [E(va, {
      children: E("html", {
        "data-full": "true"
      })
    }), Y(OVe, {
      includeSafeArea: !0,
      autoPlay: !0,
      onGoBack: e,
      children: [E(K6e, {
        data: a,
        seasonData: s,
        linkedCaptions: t.stream.captions
      }), E(OBe, {
        source: t.stream.streamUrl,
        type: t.stream.type,
        quality: t.stream.quality,
        embedId: t.stream.embedId,
        providerId: t.stream.providerId,
        captions: t.stream.captions
      }), E(h5e, {
        startAt: i.current,
        onProgress: r
      }), E(p5e, {
        onSelect: o => {
          var c;
          return o.seasonId && o.episodeId && ((c = t.onChangeStream) == null ? void 0 : c.call(t, o.seasonId, o.episodeId))
        }
      })]
    })]
  })
}

function GB() {
  const t = OY(),
    e = nE(),
    r = nd(),
    [n, i] = A.useState(null),
    [a, s] = A.useState(null),
    [o, c, l] = ad(async (h, p) => {
      const v = tq(h);
      return v ? v1(v.type, v.id, p) : null
    }),
    [u, f] = A.useState(null),
    d = A.useRef(null);
  return A.useEffect(() => {
    const h = [t.media, t.season, t.episode],
      p = d.current,
      v = (p == null ? void 0 : p[0]) === h[0] && ((p == null ? void 0 : p[1]) === h[1] || !(p != null && p[1])) && ((p == null ? void 0 : p[2]) === h[2] || !(p != null && p[2]));
    d.current = h, !(v && p !== null) && (i(null), f(null), s(null), o(t.media, t.season).then(g => {
      if (i(g ? ? null), f(null), g)
        if (g.meta.type !== ae.SERIES) s({
          type: g.meta.type,
          season: void 0,
          episode: void 0
        });
        else {
          const m = t.season ? ? g.meta.seasonData.id,
            y = t.episode ? ? g.meta.seasonData.episodes[0].id;
          s({
            type: ae.SERIES,
            season: m,
            episode: y
          }), (m !== t.season || y !== t.episode) && r.replace(`/media/${encodeURIComponent(t.media)}/${encodeURIComponent(m)}/${encodeURIComponent(y)}`)
        }
      else s(null)
    }))
  }, [o, r, t]), c ? E(HYe, {
    onGoBack: e
  }) : l ? E(LVe, {}) : !n || !a ? E(lZ, {
    video: !0,
    children: E(UYe, {})
  }) : u ? E(GYe, {
    meta: n,
    stream: u,
    selected: a,
    onChangeStream: (h, p) => {
      r.replace(`/media/${encodeURIComponent(t.media)}/${encodeURIComponent(h)}/${encodeURIComponent(p)}`)
    }
  }) : E(zYe, {
    meta: n,
    selected: a,
    onGoBack: e,
    onStream: f
  })
} /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const VYe = 4,
  VB = 0,
  WB = 1,
  WYe = 2;

function ld(t) {
  let e = t.length;
  for (; --e >= 0;) t[e] = 0
}
const KYe = 0,
  cZ = 1,
  YYe = 2,
  qYe = 3,
  XYe = 258,
  zO = 29,
  xg = 256,
  np = xg + 1 + zO,
  qu = 30,
  GO = 19,
  uZ = 2 * np + 1,
  Ol = 15,
  _w = 16,
  QYe = 7,
  VO = 256,
  fZ = 16,
  dZ = 17,
  hZ = 18,
  XA = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
  ny = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
  ZYe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
  pZ = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
  JYe = 512,
  Va = new Array((np + 2) * 2);
ld(Va);
const o0 = new Array(qu * 2);
ld(o0);
const ip = new Array(JYe);
ld(ip);
const ap = new Array(XYe - qYe + 1);
ld(ap);
const WO = new Array(zO);
ld(WO);
const U1 = new Array(qu);
ld(U1);

function Tw(t, e, r, n, i) {
  this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length
}
let gZ, mZ, vZ;

function ww(t, e) {
  this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
}
const yZ = t => t < 256 ? ip[t] : ip[256 + (t >>> 7)],
  sp = (t, e) => {
    t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255
  },
  Jr = (t, e, r) => {
    t.bi_valid > _w - r ? (t.bi_buf |= e << t.bi_valid & 65535, sp(t, t.bi_buf), t.bi_buf = e >> _w - t.bi_valid, t.bi_valid += r - _w) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r)
  },
  ra = (t, e, r) => {
    Jr(t, r[e * 2], r[e * 2 + 1])
  },
  xZ = (t, e) => {
    let r = 0;
    do r |= t & 1, t >>>= 1, r <<= 1; while (--e > 0);
    return r >>> 1
  },
  eqe = t => {
    t.bi_valid === 16 ? (sp(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8)
  },
  tqe = (t, e) => {
    const r = e.dyn_tree,
      n = e.max_code,
      i = e.stat_desc.static_tree,
      a = e.stat_desc.has_stree,
      s = e.stat_desc.extra_bits,
      o = e.stat_desc.extra_base,
      c = e.stat_desc.max_length;
    let l, u, f, d, h, p, v = 0;
    for (d = 0; d <= Ol; d++) t.bl_count[d] = 0;
    for (r[t.heap[t.heap_max] * 2 + 1] = 0, l = t.heap_max + 1; l < uZ; l++) u = t.heap[l], d = r[r[u * 2 + 1] * 2 + 1] + 1, d > c && (d = c, v++), r[u * 2 + 1] = d, !(u > n) && (t.bl_count[d]++, h = 0, u >= o && (h = s[u - o]), p = r[u * 2], t.opt_len += p * (d + h), a && (t.static_len += p * (i[u * 2 + 1] + h)));
    if (v !== 0) {
      do {
        for (d = c - 1; t.bl_count[d] === 0;) d--;
        t.bl_count[d]--, t.bl_count[d + 1] += 2, t.bl_count[c]--, v -= 2
      } while (v > 0);
      for (d = c; d !== 0; d--)
        for (u = t.bl_count[d]; u !== 0;) f = t.heap[--l], !(f > n) && (r[f * 2 + 1] !== d && (t.opt_len += (d - r[f * 2 + 1]) * r[f * 2], r[f * 2 + 1] = d), u--)
    }
  },
  bZ = (t, e, r) => {
    const n = new Array(Ol + 1);
    let i = 0,
      a, s;
    for (a = 1; a <= Ol; a++) i = i + r[a - 1] << 1, n[a] = i;
    for (s = 0; s <= e; s++) {
      let o = t[s * 2 + 1];
      o !== 0 && (t[s * 2] = xZ(n[o]++, o))
    }
  },
  rqe = () => {
    let t, e, r, n, i;
    const a = new Array(Ol + 1);
    for (r = 0, n = 0; n < zO - 1; n++)
      for (WO[n] = r, t = 0; t < 1 << XA[n]; t++) ap[r++] = n;
    for (ap[r - 1] = n, i = 0, n = 0; n < 16; n++)
      for (U1[n] = i, t = 0; t < 1 << ny[n]; t++) ip[i++] = n;
    for (i >>= 7; n < qu; n++)
      for (U1[n] = i << 7, t = 0; t < 1 << ny[n] - 7; t++) ip[256 + i++] = n;
    for (e = 0; e <= Ol; e++) a[e] = 0;
    for (t = 0; t <= 143;) Va[t * 2 + 1] = 8, t++, a[8]++;
    for (; t <= 255;) Va[t * 2 + 1] = 9, t++, a[9]++;
    for (; t <= 279;) Va[t * 2 + 1] = 7, t++, a[7]++;
    for (; t <= 287;) Va[t * 2 + 1] = 8, t++, a[8]++;
    for (bZ(Va, np + 1, a), t = 0; t < qu; t++) o0[t * 2 + 1] = 5, o0[t * 2] = xZ(t, 5);
    gZ = new Tw(Va, XA, xg + 1, np, Ol), mZ = new Tw(o0, ny, 0, qu, Ol), vZ = new Tw(new Array(0), ZYe, 0, GO, QYe)
  },
  EZ = t => {
    let e;
    for (e = 0; e < np; e++) t.dyn_ltree[e * 2] = 0;
    for (e = 0; e < qu; e++) t.dyn_dtree[e * 2] = 0;
    for (e = 0; e < GO; e++) t.bl_tree[e * 2] = 0;
    t.dyn_ltree[VO * 2] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0
  },
  SZ = t => {
    t.bi_valid > 8 ? sp(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
  },
  KB = (t, e, r, n) => {
    const i = e * 2,
      a = r * 2;
    return t[i] < t[a] || t[i] === t[a] && n[e] <= n[r]
  },
  Rw = (t, e, r) => {
    const n = t.heap[r];
    let i = r << 1;
    for (; i <= t.heap_len && (i < t.heap_len && KB(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !KB(e, n, t.heap[i], t.depth));) t.heap[r] = t.heap[i], r = i, i <<= 1;
    t.heap[r] = n
  },
  YB = (t, e, r) => {
    let n, i, a = 0,
      s, o;
    if (t.sym_next !== 0)
      do n = t.pending_buf[t.sym_buf + a++] & 255, n += (t.pending_buf[t.sym_buf + a++] & 255) << 8, i = t.pending_buf[t.sym_buf + a++], n === 0 ? ra(t, i, e) : (s = ap[i], ra(t, s + xg + 1, e), o = XA[s], o !== 0 && (i -= WO[s], Jr(t, i, o)), n--, s = yZ(n), ra(t, s, r), o = ny[s], o !== 0 && (n -= U1[s], Jr(t, n, o))); while (a < t.sym_next);
    ra(t, VO, e)
  },
  QA = (t, e) => {
    const r = e.dyn_tree,
      n = e.stat_desc.static_tree,
      i = e.stat_desc.has_stree,
      a = e.stat_desc.elems;
    let s, o, c = -1,
      l;
    for (t.heap_len = 0, t.heap_max = uZ, s = 0; s < a; s++) r[s * 2] !== 0 ? (t.heap[++t.heap_len] = c = s, t.depth[s] = 0) : r[s * 2 + 1] = 0;
    for (; t.heap_len < 2;) l = t.heap[++t.heap_len] = c < 2 ? ++c : 0, r[l * 2] = 1, t.depth[l] = 0, t.opt_len--, i && (t.static_len -= n[l * 2 + 1]);
    for (e.max_code = c, s = t.heap_len >> 1; s >= 1; s--) Rw(t, r, s);
    l = a;
    do s = t.heap[1], t.heap[1] = t.heap[t.heap_len--], Rw(t, r, 1), o = t.heap[1], t.heap[--t.heap_max] = s, t.heap[--t.heap_max] = o, r[l * 2] = r[s * 2] + r[o * 2], t.depth[l] = (t.depth[s] >= t.depth[o] ? t.depth[s] : t.depth[o]) + 1, r[s * 2 + 1] = r[o * 2 + 1] = l, t.heap[1] = l++, Rw(t, r, 1); while (t.heap_len >= 2);
    t.heap[--t.heap_max] = t.heap[1], tqe(t, e), bZ(r, c, t.bl_count)
  },
  qB = (t, e, r) => {
    let n, i = -1,
      a, s = e[0 * 2 + 1],
      o = 0,
      c = 7,
      l = 4;
    for (s === 0 && (c = 138, l = 3), e[(r + 1) * 2 + 1] = 65535, n = 0; n <= r; n++) a = s, s = e[(n + 1) * 2 + 1], !(++o < c && a === s) && (o < l ? t.bl_tree[a * 2] += o : a !== 0 ? (a !== i && t.bl_tree[a * 2]++, t.bl_tree[fZ * 2]++) : o <= 10 ? t.bl_tree[dZ * 2]++ : t.bl_tree[hZ * 2]++, o = 0, i = a, s === 0 ? (c = 138, l = 3) : a === s ? (c = 6, l = 3) : (c = 7, l = 4))
  },
  XB = (t, e, r) => {
    let n, i = -1,
      a, s = e[0 * 2 + 1],
      o = 0,
      c = 7,
      l = 4;
    for (s === 0 && (c = 138, l = 3), n = 0; n <= r; n++)
      if (a = s, s = e[(n + 1) * 2 + 1], !(++o < c && a === s)) {
        if (o < l)
          do ra(t, a, t.bl_tree); while (--o !== 0);
        else a !== 0 ? (a !== i && (ra(t, a, t.bl_tree), o--), ra(t, fZ, t.bl_tree), Jr(t, o - 3, 2)) : o <= 10 ? (ra(t, dZ, t.bl_tree), Jr(t, o - 3, 3)) : (ra(t, hZ, t.bl_tree), Jr(t, o - 11, 7));
        o = 0, i = a, s === 0 ? (c = 138, l = 3) : a === s ? (c = 6, l = 3) : (c = 7, l = 4)
      }
  },
  nqe = t => {
    let e;
    for (qB(t, t.dyn_ltree, t.l_desc.max_code), qB(t, t.dyn_dtree, t.d_desc.max_code), QA(t, t.bl_desc), e = GO - 1; e >= 3 && t.bl_tree[pZ[e] * 2 + 1] === 0; e--);
    return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
  },
  iqe = (t, e, r, n) => {
    let i;
    for (Jr(t, e - 257, 5), Jr(t, r - 1, 5), Jr(t, n - 4, 4), i = 0; i < n; i++) Jr(t, t.bl_tree[pZ[i] * 2 + 1], 3);
    XB(t, t.dyn_ltree, e - 1), XB(t, t.dyn_dtree, r - 1)
  },
  aqe = t => {
    let e = 4093624447,
      r;
    for (r = 0; r <= 31; r++, e >>>= 1)
      if (e & 1 && t.dyn_ltree[r * 2] !== 0) return VB;
    if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0) return WB;
    for (r = 32; r < xg; r++)
      if (t.dyn_ltree[r * 2] !== 0) return WB;
    return VB
  };
let QB = !1;
const sqe = t => {
    QB || (rqe(), QB = !0), t.l_desc = new ww(t.dyn_ltree, gZ), t.d_desc = new ww(t.dyn_dtree, mZ), t.bl_desc = new ww(t.bl_tree, vZ), t.bi_buf = 0, t.bi_valid = 0, EZ(t)
  },
  _Z = (t, e, r, n) => {
    Jr(t, (KYe << 1) + (n ? 1 : 0), 3), SZ(t), sp(t, r), sp(t, ~r), r && t.pending_buf.set(t.window.subarray(e, e + r), t.pending), t.pending += r
  },
  oqe = t => {
    Jr(t, cZ << 1, 3), ra(t, VO, Va), eqe(t)
  },
  lqe = (t, e, r, n) => {
    let i, a, s = 0;
    t.level > 0 ? (t.strm.data_type === WYe && (t.strm.data_type = aqe(t)), QA(t, t.l_desc), QA(t, t.d_desc), s = nqe(t), i = t.opt_len + 3 + 7 >>> 3, a = t.static_len + 3 + 7 >>> 3, a <= i && (i = a)) : i = a = r + 5, r + 4 <= i && e !== -1 ? _Z(t, e, r, n) : t.strategy === VYe || a === i ? (Jr(t, (cZ << 1) + (n ? 1 : 0), 3), YB(t, Va, o0)) : (Jr(t, (YYe << 1) + (n ? 1 : 0), 3), iqe(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), YB(t, t.dyn_ltree, t.dyn_dtree)), EZ(t), n && SZ(t)
  },
  cqe = (t, e, r) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = r, e === 0 ? t.dyn_ltree[r * 2]++ : (t.matches++, e--, t.dyn_ltree[(ap[r] + xg + 1) * 2]++, t.dyn_dtree[yZ(e) * 2]++), t.sym_next === t.sym_end);
var uqe = sqe,
  fqe = _Z,
  dqe = lqe,
  hqe = cqe,
  pqe = oqe,
  gqe = {
    _tr_init: uqe,
    _tr_stored_block: fqe,
    _tr_flush_block: dqe,
    _tr_tally: hqe,
    _tr_align: pqe
  };
const mqe = (t, e, r, n) => {
  let i = t & 65535 | 0,
    a = t >>> 16 & 65535 | 0,
    s = 0;
  for (; r !== 0;) {
    s = r > 2e3 ? 2e3 : r, r -= s;
    do i = i + e[n++] | 0, a = a + i | 0; while (--s);
    i %= 65521, a %= 65521
  }
  return i | a << 16 | 0
};
var op = mqe;
const vqe = () => {
    let t, e = [];
    for (var r = 0; r < 256; r++) {
      t = r;
      for (var n = 0; n < 8; n++) t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
      e[r] = t
    }
    return e
  },
  yqe = new Uint32Array(vqe()),
  xqe = (t, e, r, n) => {
    const i = yqe,
      a = n + r;
    t ^= -1;
    for (let s = n; s < a; s++) t = t >>> 8 ^ i[(t ^ e[s]) & 255];
    return t ^ -1
  };
var zt = xqe,
  rc = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  },
  _c = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
const {
  _tr_init: bqe,
  _tr_stored_block: ZA,
  _tr_flush_block: Eqe,
  _tr_tally: xo,
  _tr_align: Sqe
} = gqe, {
  Z_NO_FLUSH: bo,
  Z_PARTIAL_FLUSH: _qe,
  Z_FULL_FLUSH: Tqe,
  Z_FINISH: Yn,
  Z_BLOCK: ZB,
  Z_OK: Zt,
  Z_STREAM_END: JB,
  Z_STREAM_ERROR: da,
  Z_DATA_ERROR: wqe,
  Z_BUF_ERROR: Aw,
  Z_DEFAULT_COMPRESSION: Rqe,
  Z_FILTERED: Aqe,
  Z_HUFFMAN_ONLY: tv,
  Z_RLE: Iqe,
  Z_FIXED: $qe,
  Z_DEFAULT_STRATEGY: Cqe,
  Z_UNKNOWN: kqe,
  Z_DEFLATED: TE
} = _c, Oqe = 9, Lqe = 15, Pqe = 8, Nqe = 29, Dqe = 256, JA = Dqe + 1 + Nqe, Mqe = 30, Fqe = 19, Bqe = 2 * JA + 1, Uqe = 15, Pe = 3, ao = 258, ha = ao + Pe + 1, jqe = 32, _f = 42, KO = 57, eI = 69, tI = 73, rI = 91, nI = 103, Ll = 113, Ah = 666, Ir = 1, cd = 2, nc = 3, ud = 4, Hqe = 3, Pl = (t, e) => (t.msg = rc[e], e), eU = t => t * 2 - (t > 4 ? 9 : 0), Ys = t => {
  let e = t.length;
  for (; --e >= 0;) t[e] = 0
}, zqe = t => {
  let e, r, n, i = t.w_size;
  e = t.hash_size, n = e;
  do r = t.head[--n], t.head[n] = r >= i ? r - i : 0; while (--e);
  e = i, n = e;
  do r = t.prev[--n], t.prev[n] = r >= i ? r - i : 0; while (--e)
};
let Gqe = (t, e, r) => (e << t.hash_shift ^ r) & t.hash_mask,
  Eo = Gqe;
const pn = t => {
    const e = t.state;
    let r = e.pending;
    r > t.avail_out && (r = t.avail_out), r !== 0 && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + r), t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, e.pending === 0 && (e.pending_out = 0))
  },
  Sn = (t, e) => {
    Eqe(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, pn(t.strm)
  },
  Ge = (t, e) => {
    t.pending_buf[t.pending++] = e
  },
  lh = (t, e) => {
    t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255
  },
  iI = (t, e, r, n) => {
    let i = t.avail_in;
    return i > n && (i = n), i === 0 ? 0 : (t.avail_in -= i, e.set(t.input.subarray(t.next_in, t.next_in + i), r), t.state.wrap === 1 ? t.adler = op(t.adler, e, i, r) : t.state.wrap === 2 && (t.adler = zt(t.adler, e, i, r)), t.next_in += i, t.total_in += i, i)
  },
  TZ = (t, e) => {
    let r = t.max_chain_length,
      n = t.strstart,
      i, a, s = t.prev_length,
      o = t.nice_match;
    const c = t.strstart > t.w_size - ha ? t.strstart - (t.w_size - ha) : 0,
      l = t.window,
      u = t.w_mask,
      f = t.prev,
      d = t.strstart + ao;
    let h = l[n + s - 1],
      p = l[n + s];
    t.prev_length >= t.good_match && (r >>= 2), o > t.lookahead && (o = t.lookahead);
    do
      if (i = e, !(l[i + s] !== p || l[i + s - 1] !== h || l[i] !== l[n] || l[++i] !== l[n + 1])) {
        n += 2, i++;
        do; while (l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && l[++n] === l[++i] && n < d);
        if (a = ao - (d - n), n = d - ao, a > s) {
          if (t.match_start = e, s = a, a >= o) break;
          h = l[n + s - 1], p = l[n + s]
        }
      } while ((e = f[e & u]) > c && --r !== 0);
    return s <= t.lookahead ? s : t.lookahead
  },
  Tf = t => {
    const e = t.w_size;
    let r, n, i;
    do {
      if (n = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - ha) && (t.window.set(t.window.subarray(e, e + e - n), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), zqe(t), n += e), t.strm.avail_in === 0) break;
      if (r = iI(t.strm, t.window, t.strstart + t.lookahead, n), t.lookahead += r, t.lookahead + t.insert >= Pe)
        for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = Eo(t, t.ins_h, t.window[i + 1]); t.insert && (t.ins_h = Eo(t, t.ins_h, t.window[i + Pe - 1]), t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < Pe)););
    } while (t.lookahead < ha && t.strm.avail_in !== 0)
  },
  wZ = (t, e) => {
    let r = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
      n, i, a, s = 0,
      o = t.strm.avail_in;
    do {
      if (n = 65535, a = t.bi_valid + 42 >> 3, t.strm.avail_out < a || (a = t.strm.avail_out - a, i = t.strstart - t.block_start, n > i + t.strm.avail_in && (n = i + t.strm.avail_in), n > a && (n = a), n < r && (n === 0 && e !== Yn || e === bo || n !== i + t.strm.avail_in))) break;
      s = e === Yn && n === i + t.strm.avail_in ? 1 : 0, ZA(t, 0, 0, s), t.pending_buf[t.pending - 4] = n, t.pending_buf[t.pending - 3] = n >> 8, t.pending_buf[t.pending - 2] = ~n, t.pending_buf[t.pending - 1] = ~n >> 8, pn(t.strm), i && (i > n && (i = n), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, n -= i), n && (iI(t.strm, t.strm.output, t.strm.next_out, n), t.strm.next_out += n, t.strm.avail_out -= n, t.strm.total_out += n)
    } while (s === 0);
    return o -= t.strm.avail_in, o && (o >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= o && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - o, t.strm.next_in), t.strstart), t.strstart += o, t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), s ? ud : e !== bo && e !== Yn && t.strm.avail_in === 0 && t.strstart === t.block_start ? cd : (a = t.window_size - t.strstart, t.strm.avail_in > a && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, a += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), a > t.strm.avail_in && (a = t.strm.avail_in), a && (iI(t.strm, t.window, t.strstart, a), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.high_water < t.strstart && (t.high_water = t.strstart), a = t.bi_valid + 42 >> 3, a = t.pending_buf_size - a > 65535 ? 65535 : t.pending_buf_size - a, r = a > t.w_size ? t.w_size : a, i = t.strstart - t.block_start, (i >= r || (i || e === Yn) && e !== bo && t.strm.avail_in === 0 && i <= a) && (n = i > a ? a : i, s = e === Yn && t.strm.avail_in === 0 && n === i ? 1 : 0, ZA(t, t.block_start, n, s), t.block_start += n, pn(t.strm)), s ? nc : Ir)
  },
  Iw = (t, e) => {
    let r, n;
    for (;;) {
      if (t.lookahead < ha) {
        if (Tf(t), t.lookahead < ha && e === bo) return Ir;
        if (t.lookahead === 0) break
      }
      if (r = 0, t.lookahead >= Pe && (t.ins_h = Eo(t, t.ins_h, t.window[t.strstart + Pe - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), r !== 0 && t.strstart - r <= t.w_size - ha && (t.match_length = TZ(t, r)), t.match_length >= Pe)
        if (n = xo(t, t.strstart - t.match_start, t.match_length - Pe), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= Pe) {
          t.match_length--;
          do t.strstart++, t.ins_h = Eo(t, t.ins_h, t.window[t.strstart + Pe - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart; while (--t.match_length !== 0);
          t.strstart++
        } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Eo(t, t.ins_h, t.window[t.strstart + 1]);
      else n = xo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
      if (n && (Sn(t, !1), t.strm.avail_out === 0)) return Ir
    }
    return t.insert = t.strstart < Pe - 1 ? t.strstart : Pe - 1, e === Yn ? (Sn(t, !0), t.strm.avail_out === 0 ? nc : ud) : t.sym_next && (Sn(t, !1), t.strm.avail_out === 0) ? Ir : cd
  },
  Qc = (t, e) => {
    let r, n, i;
    for (;;) {
      if (t.lookahead < ha) {
        if (Tf(t), t.lookahead < ha && e === bo) return Ir;
        if (t.lookahead === 0) break
      }
      if (r = 0, t.lookahead >= Pe && (t.ins_h = Eo(t, t.ins_h, t.window[t.strstart + Pe - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = Pe - 1, r !== 0 && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - ha && (t.match_length = TZ(t, r), t.match_length <= 5 && (t.strategy === Aqe || t.match_length === Pe && t.strstart - t.match_start > 4096) && (t.match_length = Pe - 1)), t.prev_length >= Pe && t.match_length <= t.prev_length) {
        i = t.strstart + t.lookahead - Pe, n = xo(t, t.strstart - 1 - t.prev_match, t.prev_length - Pe), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
        do ++t.strstart <= i && (t.ins_h = Eo(t, t.ins_h, t.window[t.strstart + Pe - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart); while (--t.prev_length !== 0);
        if (t.match_available = 0, t.match_length = Pe - 1, t.strstart++, n && (Sn(t, !1), t.strm.avail_out === 0)) return Ir
      } else if (t.match_available) {
        if (n = xo(t, 0, t.window[t.strstart - 1]), n && Sn(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return Ir
      } else t.match_available = 1, t.strstart++, t.lookahead--
    }
    return t.match_available && (n = xo(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < Pe - 1 ? t.strstart : Pe - 1, e === Yn ? (Sn(t, !0), t.strm.avail_out === 0 ? nc : ud) : t.sym_next && (Sn(t, !1), t.strm.avail_out === 0) ? Ir : cd
  },
  Vqe = (t, e) => {
    let r, n, i, a;
    const s = t.window;
    for (;;) {
      if (t.lookahead <= ao) {
        if (Tf(t), t.lookahead <= ao && e === bo) return Ir;
        if (t.lookahead === 0) break
      }
      if (t.match_length = 0, t.lookahead >= Pe && t.strstart > 0 && (i = t.strstart - 1, n = s[i], n === s[++i] && n === s[++i] && n === s[++i])) {
        a = t.strstart + ao;
        do; while (n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && n === s[++i] && i < a);
        t.match_length = ao - (a - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
      }
      if (t.match_length >= Pe ? (r = xo(t, 1, t.match_length - Pe), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = xo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (Sn(t, !1), t.strm.avail_out === 0)) return Ir
    }
    return t.insert = 0, e === Yn ? (Sn(t, !0), t.strm.avail_out === 0 ? nc : ud) : t.sym_next && (Sn(t, !1), t.strm.avail_out === 0) ? Ir : cd
  },
  Wqe = (t, e) => {
    let r;
    for (;;) {
      if (t.lookahead === 0 && (Tf(t), t.lookahead === 0)) {
        if (e === bo) return Ir;
        break
      }
      if (t.match_length = 0, r = xo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (Sn(t, !1), t.strm.avail_out === 0)) return Ir
    }
    return t.insert = 0, e === Yn ? (Sn(t, !0), t.strm.avail_out === 0 ? nc : ud) : t.sym_next && (Sn(t, !1), t.strm.avail_out === 0) ? Ir : cd
  };

function qi(t, e, r, n, i) {
  this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i
}
const Ih = [new qi(0, 0, 0, 0, wZ), new qi(4, 4, 8, 4, Iw), new qi(4, 5, 16, 8, Iw), new qi(4, 6, 32, 32, Iw), new qi(4, 4, 16, 16, Qc), new qi(8, 16, 32, 32, Qc), new qi(8, 16, 128, 128, Qc), new qi(8, 32, 128, 256, Qc), new qi(32, 128, 258, 1024, Qc), new qi(32, 258, 258, 4096, Qc)],
  Kqe = t => {
    t.window_size = 2 * t.w_size, Ys(t.head), t.max_lazy_match = Ih[t.level].max_lazy, t.good_match = Ih[t.level].good_length, t.nice_match = Ih[t.level].nice_length, t.max_chain_length = Ih[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = Pe - 1, t.match_available = 0, t.ins_h = 0
  };

function Yqe() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = TE, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Bqe * 2), this.dyn_dtree = new Uint16Array((2 * Mqe + 1) * 2), this.bl_tree = new Uint16Array((2 * Fqe + 1) * 2), Ys(this.dyn_ltree), Ys(this.dyn_dtree), Ys(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Uqe + 1), this.heap = new Uint16Array(2 * JA + 1), Ys(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * JA + 1), Ys(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
}
const bg = t => {
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || e.status !== _f && e.status !== KO && e.status !== eI && e.status !== tI && e.status !== rI && e.status !== nI && e.status !== Ll && e.status !== Ah ? 1 : 0
  },
  RZ = t => {
    if (bg(t)) return Pl(t, da);
    t.total_in = t.total_out = 0, t.data_type = kqe;
    const e = t.state;
    return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap === 2 ? KO : e.wrap ? _f : Ll, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, bqe(e), Zt
  },
  AZ = t => {
    const e = RZ(t);
    return e === Zt && Kqe(t.state), e
  },
  qqe = (t, e) => bg(t) || t.state.wrap !== 2 ? da : (t.state.gzhead = e, Zt),
  IZ = (t, e, r, n, i, a) => {
    if (!t) return da;
    let s = 1;
    if (e === Rqe && (e = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), i < 1 || i > Oqe || r !== TE || n < 8 || n > 15 || e < 0 || e > 9 || a < 0 || a > $qe || n === 8 && s !== 1) return Pl(t, da);
    n === 8 && (n = 9);
    const o = new Yqe;
    return t.state = o, o.strm = t, o.status = _f, o.wrap = s, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + Pe - 1) / Pe), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = e, o.strategy = a, o.method = r, AZ(t)
  },
  Xqe = (t, e) => IZ(t, e, TE, Lqe, Pqe, Cqe),
  Qqe = (t, e) => {
    if (bg(t) || e > ZB || e < 0) return t ? Pl(t, da) : da;
    const r = t.state;
    if (!t.output || t.avail_in !== 0 && !t.input || r.status === Ah && e !== Yn) return Pl(t, t.avail_out === 0 ? Aw : da);
    const n = r.last_flush;
    if (r.last_flush = e, r.pending !== 0) {
      if (pn(t), t.avail_out === 0) return r.last_flush = -1, Zt
    } else if (t.avail_in === 0 && eU(e) <= eU(n) && e !== Yn) return Pl(t, Aw);
    if (r.status === Ah && t.avail_in !== 0) return Pl(t, Aw);
    if (r.status === _f && r.wrap === 0 && (r.status = Ll), r.status === _f) {
      let i = TE + (r.w_bits - 8 << 4) << 8,
        a = -1;
      if (r.strategy >= tv || r.level < 2 ? a = 0 : r.level < 6 ? a = 1 : r.level === 6 ? a = 2 : a = 3, i |= a << 6, r.strstart !== 0 && (i |= jqe), i += 31 - i % 31, lh(r, i), r.strstart !== 0 && (lh(r, t.adler >>> 16), lh(r, t.adler & 65535)), t.adler = 1, r.status = Ll, pn(t), r.pending !== 0) return r.last_flush = -1, Zt
    }
    if (r.status === KO) {
      if (t.adler = 0, Ge(r, 31), Ge(r, 139), Ge(r, 8), r.gzhead) Ge(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), Ge(r, r.gzhead.time & 255), Ge(r, r.gzhead.time >> 8 & 255), Ge(r, r.gzhead.time >> 16 & 255), Ge(r, r.gzhead.time >> 24 & 255), Ge(r, r.level === 9 ? 2 : r.strategy >= tv || r.level < 2 ? 4 : 0), Ge(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (Ge(r, r.gzhead.extra.length & 255), Ge(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (t.adler = zt(t.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = eI;
      else if (Ge(r, 0), Ge(r, 0), Ge(r, 0), Ge(r, 0), Ge(r, 0), Ge(r, r.level === 9 ? 2 : r.strategy >= tv || r.level < 2 ? 4 : 0), Ge(r, Hqe), r.status = Ll, pn(t), r.pending !== 0) return r.last_flush = -1, Zt
    }
    if (r.status === eI) {
      if (r.gzhead.extra) {
        let i = r.pending,
          a = (r.gzhead.extra.length & 65535) - r.gzindex;
        for (; r.pending + a > r.pending_buf_size;) {
          let o = r.pending_buf_size - r.pending;
          if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + o), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i)), r.gzindex += o, pn(t), r.pending !== 0) return r.last_flush = -1, Zt;
          i = 0, a -= o
        }
        let s = new Uint8Array(r.gzhead.extra);
        r.pending_buf.set(s.subarray(r.gzindex, r.gzindex + a), r.pending), r.pending += a, r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0
      }
      r.status = tI
    }
    if (r.status === tI) {
      if (r.gzhead.name) {
        let i = r.pending,
          a;
        do {
          if (r.pending === r.pending_buf_size) {
            if (r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i)), pn(t), r.pending !== 0) return r.last_flush = -1, Zt;
            i = 0
          }
          r.gzindex < r.gzhead.name.length ? a = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : a = 0, Ge(r, a)
        } while (a !== 0);
        r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0
      }
      r.status = rI
    }
    if (r.status === rI) {
      if (r.gzhead.comment) {
        let i = r.pending,
          a;
        do {
          if (r.pending === r.pending_buf_size) {
            if (r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i)), pn(t), r.pending !== 0) return r.last_flush = -1, Zt;
            i = 0
          }
          r.gzindex < r.gzhead.comment.length ? a = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : a = 0, Ge(r, a)
        } while (a !== 0);
        r.gzhead.hcrc && r.pending > i && (t.adler = zt(t.adler, r.pending_buf, r.pending - i, i))
      }
      r.status = nI
    }
    if (r.status === nI) {
      if (r.gzhead.hcrc) {
        if (r.pending + 2 > r.pending_buf_size && (pn(t), r.pending !== 0)) return r.last_flush = -1, Zt;
        Ge(r, t.adler & 255), Ge(r, t.adler >> 8 & 255), t.adler = 0
      }
      if (r.status = Ll, pn(t), r.pending !== 0) return r.last_flush = -1, Zt
    }
    if (t.avail_in !== 0 || r.lookahead !== 0 || e !== bo && r.status !== Ah) {
      let i = r.level === 0 ? wZ(r, e) : r.strategy === tv ? Wqe(r, e) : r.strategy === Iqe ? Vqe(r, e) : Ih[r.level].func(r, e);
      if ((i === nc || i === ud) && (r.status = Ah), i === Ir || i === nc) return t.avail_out === 0 && (r.last_flush = -1), Zt;
      if (i === cd && (e === _qe ? Sqe(r) : e !== ZB && (ZA(r, 0, 0, !1), e === Tqe && (Ys(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), pn(t), t.avail_out === 0)) return r.last_flush = -1, Zt
    }
    return e !== Yn ? Zt : r.wrap <= 0 ? JB : (r.wrap === 2 ? (Ge(r, t.adler & 255), Ge(r, t.adler >> 8 & 255), Ge(r, t.adler >> 16 & 255), Ge(r, t.adler >> 24 & 255), Ge(r, t.total_in & 255), Ge(r, t.total_in >> 8 & 255), Ge(r, t.total_in >> 16 & 255), Ge(r, t.total_in >> 24 & 255)) : (lh(r, t.adler >>> 16), lh(r, t.adler & 65535)), pn(t), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? Zt : JB)
  },
  Zqe = t => {
    if (bg(t)) return da;
    const e = t.state.status;
    return t.state = null, e === Ll ? Pl(t, wqe) : Zt
  },
  Jqe = (t, e) => {
    let r = e.length;
    if (bg(t)) return da;
    const n = t.state,
      i = n.wrap;
    if (i === 2 || i === 1 && n.status !== _f || n.lookahead) return da;
    if (i === 1 && (t.adler = op(t.adler, e, r, 0)), n.wrap = 0, r >= n.w_size) {
      i === 0 && (Ys(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
      let c = new Uint8Array(n.w_size);
      c.set(e.subarray(r - n.w_size, r), 0), e = c, r = n.w_size
    }
    const a = t.avail_in,
      s = t.next_in,
      o = t.input;
    for (t.avail_in = r, t.next_in = 0, t.input = e, Tf(n); n.lookahead >= Pe;) {
      let c = n.strstart,
        l = n.lookahead - (Pe - 1);
      do n.ins_h = Eo(n, n.ins_h, n.window[c + Pe - 1]), n.prev[c & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = c, c++; while (--l);
      n.strstart = c, n.lookahead = Pe - 1, Tf(n)
    }
    return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = Pe - 1, n.match_available = 0, t.next_in = s, t.input = o, t.avail_in = a, n.wrap = i, Zt
  };
var eXe = Xqe,
  tXe = IZ,
  rXe = AZ,
  nXe = RZ,
  iXe = qqe,
  aXe = Qqe,
  sXe = Zqe,
  oXe = Jqe,
  lXe = "pako deflate (from Nodeca project)",
  l0 = {
    deflateInit: eXe,
    deflateInit2: tXe,
    deflateReset: rXe,
    deflateResetKeep: nXe,
    deflateSetHeader: iXe,
    deflate: aXe,
    deflateEnd: sXe,
    deflateSetDictionary: oXe,
    deflateInfo: lXe
  };
const cXe = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var uXe = function (t) {
    const e = Array.prototype.slice.call(arguments, 1);
    for (; e.length;) {
      const r = e.shift();
      if (r) {
        if (typeof r != "object") throw new TypeError(r + "must be non-object");
        for (const n in r) cXe(r, n) && (t[n] = r[n])
      }
    }
    return t
  },
  fXe = t => {
    let e = 0;
    for (let n = 0, i = t.length; n < i; n++) e += t[n].length;
    const r = new Uint8Array(e);
    for (let n = 0, i = 0, a = t.length; n < a; n++) {
      let s = t[n];
      r.set(s, i), i += s.length
    }
    return r
  },
  wE = {
    assign: uXe,
    flattenChunks: fXe
  };
let $Z = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1))
} catch {
  $Z = !1
}
const lp = new Uint8Array(256);
for (let t = 0; t < 256; t++) lp[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
lp[254] = lp[254] = 1;
var dXe = t => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(t);
  let e, r, n, i, a, s = t.length,
    o = 0;
  for (i = 0; i < s; i++) r = t.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (n = t.charCodeAt(i + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++)), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (e = new Uint8Array(o), a = 0, i = 0; a < o; i++) r = t.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (n = t.charCodeAt(i + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++)), r < 128 ? e[a++] = r : r < 2048 ? (e[a++] = 192 | r >>> 6, e[a++] = 128 | r & 63) : r < 65536 ? (e[a++] = 224 | r >>> 12, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | r & 63) : (e[a++] = 240 | r >>> 18, e[a++] = 128 | r >>> 12 & 63, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | r & 63);
  return e
};
const hXe = (t, e) => {
  if (e < 65534 && t.subarray && $Z) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
  let r = "";
  for (let n = 0; n < e; n++) r += String.fromCharCode(t[n]);
  return r
};
var pXe = (t, e) => {
    const r = e || t.length;
    if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(t.subarray(0, e));
    let n, i;
    const a = new Array(r * 2);
    for (i = 0, n = 0; n < r;) {
      let s = t[n++];
      if (s < 128) {
        a[i++] = s;
        continue
      }
      let o = lp[s];
      if (o > 4) {
        a[i++] = 65533, n += o - 1;
        continue
      }
      for (s &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && n < r;) s = s << 6 | t[n++] & 63, o--;
      if (o > 1) {
        a[i++] = 65533;
        continue
      }
      s < 65536 ? a[i++] = s : (s -= 65536, a[i++] = 55296 | s >> 10 & 1023, a[i++] = 56320 | s & 1023)
    }
    return hXe(a, i)
  },
  gXe = (t, e) => {
    e = e || t.length, e > t.length && (e = t.length);
    let r = e - 1;
    for (; r >= 0 && (t[r] & 192) === 128;) r--;
    return r < 0 || r === 0 ? e : r + lp[t[r]] > e ? r : e
  },
  cp = {
    string2buf: dXe,
    buf2string: pXe,
    utf8border: gXe
  };

function mXe() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
}
var CZ = mXe;
const kZ = Object.prototype.toString,
  {
    Z_NO_FLUSH: vXe,
    Z_SYNC_FLUSH: yXe,
    Z_FULL_FLUSH: xXe,
    Z_FINISH: bXe,
    Z_OK: j1,
    Z_STREAM_END: EXe,
    Z_DEFAULT_COMPRESSION: SXe,
    Z_DEFAULT_STRATEGY: _Xe,
    Z_DEFLATED: TXe
  } = _c;

function Eg(t) {
  this.options = wE.assign({
    level: SXe,
    method: TXe,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: _Xe
  }, t || {});
  let e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new CZ, this.strm.avail_out = 0;
  let r = l0.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
  if (r !== j1) throw new Error(rc[r]);
  if (e.header && l0.deflateSetHeader(this.strm, e.header), e.dictionary) {
    let n;
    if (typeof e.dictionary == "string" ? n = cp.string2buf(e.dictionary) : kZ.call(e.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(e.dictionary) : n = e.dictionary, r = l0.deflateSetDictionary(this.strm, n), r !== j1) throw new Error(rc[r]);
    this._dict_set = !0
  }
}
Eg.prototype.push = function (t, e) {
  const r = this.strm,
    n = this.options.chunkSize;
  let i, a;
  if (this.ended) return !1;
  for (e === ~~e ? a = e : a = e === !0 ? bXe : vXe, typeof t == "string" ? r.input = cp.string2buf(t) : kZ.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;;) {
    if (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (a === yXe || a === xXe) && r.avail_out <= 6) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue
    }
    if (i = l0.deflate(r, a), i === EXe) return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), i = l0.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === j1;
    if (r.avail_out === 0) {
      this.onData(r.output);
      continue
    }
    if (a > 0 && r.next_out > 0) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue
    }
    if (r.avail_in === 0) break
  }
  return !0
};
Eg.prototype.onData = function (t) {
  this.chunks.push(t)
};
Eg.prototype.onEnd = function (t) {
  t === j1 && (this.result = wE.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function YO(t, e) {
  const r = new Eg(e);
  if (r.push(t, !0), r.err) throw r.msg || rc[r.err];
  return r.result
}

function wXe(t, e) {
  return e = e || {}, e.raw = !0, YO(t, e)
}

function RXe(t, e) {
  return e = e || {}, e.gzip = !0, YO(t, e)
}
var AXe = Eg,
  IXe = YO,
  $Xe = wXe,
  CXe = RXe,
  kXe = _c,
  OXe = {
    Deflate: AXe,
    deflate: IXe,
    deflateRaw: $Xe,
    gzip: CXe,
    constants: kXe
  };
const rv = 16209,
  LXe = 16191;
var PXe = function (e, r) {
  let n, i, a, s, o, c, l, u, f, d, h, p, v, g, m, y, x, b, _, S, T, R, I, w;
  const C = e.state;
  n = e.next_in, I = e.input, i = n + (e.avail_in - 5), a = e.next_out, w = e.output, s = a - (r - e.avail_out), o = a + (e.avail_out - 257), c = C.dmax, l = C.wsize, u = C.whave, f = C.wnext, d = C.window, h = C.hold, p = C.bits, v = C.lencode, g = C.distcode, m = (1 << C.lenbits) - 1, y = (1 << C.distbits) - 1;
  e: do {
    p < 15 && (h += I[n++] << p, p += 8, h += I[n++] << p, p += 8), x = v[h & m];
    t: for (;;) {
      if (b = x >>> 24, h >>>= b, p -= b, b = x >>> 16 & 255, b === 0) w[a++] = x & 65535;
      else if (b & 16) {
        _ = x & 65535, b &= 15, b && (p < b && (h += I[n++] << p, p += 8), _ += h & (1 << b) - 1, h >>>= b, p -= b), p < 15 && (h += I[n++] << p, p += 8, h += I[n++] << p, p += 8), x = g[h & y];
        r: for (;;) {
          if (b = x >>> 24, h >>>= b, p -= b, b = x >>> 16 & 255, b & 16) {
            if (S = x & 65535, b &= 15, p < b && (h += I[n++] << p, p += 8, p < b && (h += I[n++] << p, p += 8)), S += h & (1 << b) - 1, S > c) {
              e.msg = "invalid distance too far back", C.mode = rv;
              break e
            }
            if (h >>>= b, p -= b, b = a - s, S > b) {
              if (b = S - b, b > u && C.sane) {
                e.msg = "invalid distance too far back", C.mode = rv;
                break e
              }
              if (T = 0, R = d, f === 0) {
                if (T += l - b, b < _) {
                  _ -= b;
                  do w[a++] = d[T++]; while (--b);
                  T = a - S, R = w
                }
              } else if (f < b) {
                if (T += l + f - b, b -= f, b < _) {
                  _ -= b;
                  do w[a++] = d[T++]; while (--b);
                  if (T = 0, f < _) {
                    b = f, _ -= b;
                    do w[a++] = d[T++]; while (--b);
                    T = a - S, R = w
                  }
                }
              } else if (T += f - b, b < _) {
                _ -= b;
                do w[a++] = d[T++]; while (--b);
                T = a - S, R = w
              }
              for (; _ > 2;) w[a++] = R[T++], w[a++] = R[T++], w[a++] = R[T++], _ -= 3;
              _ && (w[a++] = R[T++], _ > 1 && (w[a++] = R[T++]))
            } else {
              T = a - S;
              do w[a++] = w[T++], w[a++] = w[T++], w[a++] = w[T++], _ -= 3; while (_ > 2);
              _ && (w[a++] = w[T++], _ > 1 && (w[a++] = w[T++]))
            }
          } else if (b & 64) {
            e.msg = "invalid distance code", C.mode = rv;
            break e
          } else {
            x = g[(x & 65535) + (h & (1 << b) - 1)];
            continue r
          }
          break
        }
      } else if (b & 64)
        if (b & 32) {
          C.mode = LXe;
          break e
        } else {
          e.msg = "invalid literal/length code", C.mode = rv;
          break e
        }
      else {
        x = v[(x & 65535) + (h & (1 << b) - 1)];
        continue t
      }
      break
    }
  } while (n < i && a < o);
  _ = p >> 3, n -= _, p -= _ << 3, h &= (1 << p) - 1, e.next_in = n, e.next_out = a, e.avail_in = n < i ? 5 + (i - n) : 5 - (n - i), e.avail_out = a < o ? 257 + (o - a) : 257 - (a - o), C.hold = h, C.bits = p
};
const Zc = 15,
  tU = 852,
  rU = 592,
  nU = 0,
  $w = 1,
  iU = 2,
  NXe = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
  DXe = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
  MXe = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
  FXe = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
  BXe = (t, e, r, n, i, a, s, o) => {
    const c = o.bits;
    let l = 0,
      u = 0,
      f = 0,
      d = 0,
      h = 0,
      p = 0,
      v = 0,
      g = 0,
      m = 0,
      y = 0,
      x, b, _, S, T, R = null,
      I;
    const w = new Uint16Array(Zc + 1),
      C = new Uint16Array(Zc + 1);
    let L = null,
      H, N, P;
    for (l = 0; l <= Zc; l++) w[l] = 0;
    for (u = 0; u < n; u++) w[e[r + u]]++;
    for (h = c, d = Zc; d >= 1 && w[d] === 0; d--);
    if (h > d && (h = d), d === 0) return i[a++] = 1 << 24 | 64 << 16 | 0, i[a++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
    for (f = 1; f < d && w[f] === 0; f++);
    for (h < f && (h = f), g = 1, l = 1; l <= Zc; l++)
      if (g <<= 1, g -= w[l], g < 0) return -1;
    if (g > 0 && (t === nU || d !== 1)) return -1;
    for (C[1] = 0, l = 1; l < Zc; l++) C[l + 1] = C[l] + w[l];
    for (u = 0; u < n; u++) e[r + u] !== 0 && (s[C[e[r + u]]++] = u);
    if (t === nU ? (R = L = s, I = 20) : t === $w ? (R = NXe, L = DXe, I = 257) : (R = MXe, L = FXe, I = 0), y = 0, u = 0, l = f, T = a, p = h, v = 0, _ = -1, m = 1 << h, S = m - 1, t === $w && m > tU || t === iU && m > rU) return 1;
    for (;;) {
      H = l - v, s[u] + 1 < I ? (N = 0, P = s[u]) : s[u] >= I ? (N = L[s[u] - I], P = R[s[u] - I]) : (N = 32 + 64, P = 0), x = 1 << l - v, b = 1 << p, f = b;
      do b -= x, i[T + (y >> v) + b] = H << 24 | N << 16 | P | 0; while (b !== 0);
      for (x = 1 << l - 1; y & x;) x >>= 1;
      if (x !== 0 ? (y &= x - 1, y += x) : y = 0, u++, --w[l] === 0) {
        if (l === d) break;
        l = e[r + s[u]]
      }
      if (l > h && (y & S) !== _) {
        for (v === 0 && (v = h), T += f, p = l - v, g = 1 << p; p + v < d && (g -= w[p + v], !(g <= 0));) p++, g <<= 1;
        if (m += 1 << p, t === $w && m > tU || t === iU && m > rU) return 1;
        _ = y & S, i[_] = h << 24 | p << 16 | T - a | 0
      }
    }
    return y !== 0 && (i[T + y] = l - v << 24 | 64 << 16 | 0), o.bits = h, 0
  };
var c0 = BXe;
const UXe = 0,
  OZ = 1,
  LZ = 2,
  {
    Z_FINISH: aU,
    Z_BLOCK: jXe,
    Z_TREES: nv,
    Z_OK: ic,
    Z_STREAM_END: HXe,
    Z_NEED_DICT: zXe,
    Z_STREAM_ERROR: ti,
    Z_DATA_ERROR: PZ,
    Z_MEM_ERROR: NZ,
    Z_BUF_ERROR: GXe,
    Z_DEFLATED: sU
  } = _c,
  RE = 16180,
  oU = 16181,
  lU = 16182,
  cU = 16183,
  uU = 16184,
  fU = 16185,
  dU = 16186,
  hU = 16187,
  pU = 16188,
  gU = 16189,
  H1 = 16190,
  Pa = 16191,
  Cw = 16192,
  mU = 16193,
  kw = 16194,
  vU = 16195,
  yU = 16196,
  xU = 16197,
  bU = 16198,
  iv = 16199,
  av = 16200,
  EU = 16201,
  SU = 16202,
  _U = 16203,
  TU = 16204,
  wU = 16205,
  Ow = 16206,
  RU = 16207,
  AU = 16208,
  ot = 16209,
  DZ = 16210,
  MZ = 16211,
  VXe = 852,
  WXe = 592,
  KXe = 15,
  YXe = KXe,
  IU = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);

function qXe() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
}
const Tc = t => {
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || e.mode < RE || e.mode > MZ ? 1 : 0
  },
  FZ = t => {
    if (Tc(t)) return ti;
    const e = t.state;
    return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = RE, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(VXe), e.distcode = e.distdyn = new Int32Array(WXe), e.sane = 1, e.back = -1, ic
  },
  BZ = t => {
    if (Tc(t)) return ti;
    const e = t.state;
    return e.wsize = 0, e.whave = 0, e.wnext = 0, FZ(t)
  },
  UZ = (t, e) => {
    let r;
    if (Tc(t)) return ti;
    const n = t.state;
    return e < 0 ? (r = 0, e = -e) : (r = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? ti : (n.window !== null && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, BZ(t))
  },
  jZ = (t, e) => {
    if (!t) return ti;
    const r = new qXe;
    t.state = r, r.strm = t, r.window = null, r.mode = RE;
    const n = UZ(t, e);
    return n !== ic && (t.state = null), n
  },
  XXe = t => jZ(t, YXe);
let $U = !0,
  Lw, Pw;
const QXe = t => {
    if ($U) {
      Lw = new Int32Array(512), Pw = new Int32Array(32);
      let e = 0;
      for (; e < 144;) t.lens[e++] = 8;
      for (; e < 256;) t.lens[e++] = 9;
      for (; e < 280;) t.lens[e++] = 7;
      for (; e < 288;) t.lens[e++] = 8;
      for (c0(OZ, t.lens, 0, 288, Lw, 0, t.work, {
          bits: 9
        }), e = 0; e < 32;) t.lens[e++] = 5;
      c0(LZ, t.lens, 0, 32, Pw, 0, t.work, {
        bits: 5
      }), $U = !1
    }
    t.lencode = Lw, t.lenbits = 9, t.distcode = Pw, t.distbits = 5
  },
  HZ = (t, e, r, n) => {
    let i;
    const a = t.state;
    return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), n >= a.wsize ? (a.window.set(e.subarray(r - a.wsize, r), 0), a.wnext = 0, a.whave = a.wsize) : (i = a.wsize - a.wnext, i > n && (i = n), a.window.set(e.subarray(r - n, r - n + i), a.wnext), n -= i, n ? (a.window.set(e.subarray(r - n, r), 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0
  },
  ZXe = (t, e) => {
    let r, n, i, a, s, o, c, l, u, f, d, h, p, v, g = 0,
      m, y, x, b, _, S, T, R;
    const I = new Uint8Array(4);
    let w, C;
    const L = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (Tc(t) || !t.output || !t.input && t.avail_in !== 0) return ti;
    r = t.state, r.mode === Pa && (r.mode = Cw), s = t.next_out, i = t.output, c = t.avail_out, a = t.next_in, n = t.input, o = t.avail_in, l = r.hold, u = r.bits, f = o, d = c, R = ic;
    e: for (;;) switch (r.mode) {
      case RE:
        if (r.wrap === 0) {
          r.mode = Cw;
          break
        }
        for (; u < 16;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if (r.wrap & 2 && l === 35615) {
          r.wbits === 0 && (r.wbits = 15), r.check = 0, I[0] = l & 255, I[1] = l >>> 8 & 255, r.check = zt(r.check, I, 2, 0), l = 0, u = 0, r.mode = oU;
          break
        }
        if (r.head && (r.head.done = !1), !(r.wrap & 1) || (((l & 255) << 8) + (l >> 8)) % 31) {
          t.msg = "incorrect header check", r.mode = ot;
          break
        }
        if ((l & 15) !== sU) {
          t.msg = "unknown compression method", r.mode = ot;
          break
        }
        if (l >>>= 4, u -= 4, T = (l & 15) + 8, r.wbits === 0 && (r.wbits = T), T > 15 || T > r.wbits) {
          t.msg = "invalid window size", r.mode = ot;
          break
        }
        r.dmax = 1 << r.wbits, r.flags = 0, t.adler = r.check = 1, r.mode = l & 512 ? gU : Pa, l = 0, u = 0;
        break;
      case oU:
        for (; u < 16;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if (r.flags = l, (r.flags & 255) !== sU) {
          t.msg = "unknown compression method", r.mode = ot;
          break
        }
        if (r.flags & 57344) {
          t.msg = "unknown header flags set", r.mode = ot;
          break
        }
        r.head && (r.head.text = l >> 8 & 1), r.flags & 512 && r.wrap & 4 && (I[0] = l & 255, I[1] = l >>> 8 & 255, r.check = zt(r.check, I, 2, 0)), l = 0, u = 0, r.mode = lU;
      case lU:
        for (; u < 32;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        r.head && (r.head.time = l), r.flags & 512 && r.wrap & 4 && (I[0] = l & 255, I[1] = l >>> 8 & 255, I[2] = l >>> 16 & 255, I[3] = l >>> 24 & 255, r.check = zt(r.check, I, 4, 0)), l = 0, u = 0, r.mode = cU;
      case cU:
        for (; u < 16;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        r.head && (r.head.xflags = l & 255, r.head.os = l >> 8), r.flags & 512 && r.wrap & 4 && (I[0] = l & 255, I[1] = l >>> 8 & 255, r.check = zt(r.check, I, 2, 0)), l = 0, u = 0, r.mode = uU;
      case uU:
        if (r.flags & 1024) {
          for (; u < 16;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          r.length = l, r.head && (r.head.extra_len = l), r.flags & 512 && r.wrap & 4 && (I[0] = l & 255, I[1] = l >>> 8 & 255, r.check = zt(r.check, I, 2, 0)), l = 0, u = 0
        } else r.head && (r.head.extra = null);
        r.mode = fU;
      case fU:
        if (r.flags & 1024 && (h = r.length, h > o && (h = o), h && (r.head && (T = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(a, a + h), T)), r.flags & 512 && r.wrap & 4 && (r.check = zt(r.check, n, h, a)), o -= h, a += h, r.length -= h), r.length)) break e;
        r.length = 0, r.mode = dU;
      case dU:
        if (r.flags & 2048) {
          if (o === 0) break e;
          h = 0;
          do T = n[a + h++], r.head && T && r.length < 65536 && (r.head.name += String.fromCharCode(T)); while (T && h < o);
          if (r.flags & 512 && r.wrap & 4 && (r.check = zt(r.check, n, h, a)), o -= h, a += h, T) break e
        } else r.head && (r.head.name = null);
        r.length = 0, r.mode = hU;
      case hU:
        if (r.flags & 4096) {
          if (o === 0) break e;
          h = 0;
          do T = n[a + h++], r.head && T && r.length < 65536 && (r.head.comment += String.fromCharCode(T)); while (T && h < o);
          if (r.flags & 512 && r.wrap & 4 && (r.check = zt(r.check, n, h, a)), o -= h, a += h, T) break e
        } else r.head && (r.head.comment = null);
        r.mode = pU;
      case pU:
        if (r.flags & 512) {
          for (; u < 16;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          if (r.wrap & 4 && l !== (r.check & 65535)) {
            t.msg = "header crc mismatch", r.mode = ot;
            break
          }
          l = 0, u = 0
        }
        r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = Pa;
        break;
      case gU:
        for (; u < 32;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        t.adler = r.check = IU(l), l = 0, u = 0, r.mode = H1;
      case H1:
        if (r.havedict === 0) return t.next_out = s, t.avail_out = c, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = u, zXe;
        t.adler = r.check = 1, r.mode = Pa;
      case Pa:
        if (e === jXe || e === nv) break e;
      case Cw:
        if (r.last) {
          l >>>= u & 7, u -= u & 7, r.mode = Ow;
          break
        }
        for (; u < 3;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        switch (r.last = l & 1, l >>>= 1, u -= 1, l & 3) {
          case 0:
            r.mode = mU;
            break;
          case 1:
            if (QXe(r), r.mode = iv, e === nv) {
              l >>>= 2, u -= 2;
              break e
            }
            break;
          case 2:
            r.mode = yU;
            break;
          case 3:
            t.msg = "invalid block type", r.mode = ot
        }
        l >>>= 2, u -= 2;
        break;
      case mU:
        for (l >>>= u & 7, u -= u & 7; u < 32;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if ((l & 65535) !== (l >>> 16 ^ 65535)) {
          t.msg = "invalid stored block lengths", r.mode = ot;
          break
        }
        if (r.length = l & 65535, l = 0, u = 0, r.mode = kw, e === nv) break e;
      case kw:
        r.mode = vU;
      case vU:
        if (h = r.length, h) {
          if (h > o && (h = o), h > c && (h = c), h === 0) break e;
          i.set(n.subarray(a, a + h), s), o -= h, a += h, c -= h, s += h, r.length -= h;
          break
        }
        r.mode = Pa;
        break;
      case yU:
        for (; u < 14;) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if (r.nlen = (l & 31) + 257, l >>>= 5, u -= 5, r.ndist = (l & 31) + 1, l >>>= 5, u -= 5, r.ncode = (l & 15) + 4, l >>>= 4, u -= 4, r.nlen > 286 || r.ndist > 30) {
          t.msg = "too many length or distance symbols", r.mode = ot;
          break
        }
        r.have = 0, r.mode = xU;
      case xU:
        for (; r.have < r.ncode;) {
          for (; u < 3;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          r.lens[L[r.have++]] = l & 7, l >>>= 3, u -= 3
        }
        for (; r.have < 19;) r.lens[L[r.have++]] = 0;
        if (r.lencode = r.lendyn, r.lenbits = 7, w = {
            bits: r.lenbits
          }, R = c0(UXe, r.lens, 0, 19, r.lencode, 0, r.work, w), r.lenbits = w.bits, R) {
          t.msg = "invalid code lengths set", r.mode = ot;
          break
        }
        r.have = 0, r.mode = bU;
      case bU:
        for (; r.have < r.nlen + r.ndist;) {
          for (; g = r.lencode[l & (1 << r.lenbits) - 1], m = g >>> 24, y = g >>> 16 & 255, x = g & 65535, !(m <= u);) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          if (x < 16) l >>>= m, u -= m, r.lens[r.have++] = x;
          else {
            if (x === 16) {
              for (C = m + 2; u < C;) {
                if (o === 0) break e;
                o--, l += n[a++] << u, u += 8
              }
              if (l >>>= m, u -= m, r.have === 0) {
                t.msg = "invalid bit length repeat", r.mode = ot;
                break
              }
              T = r.lens[r.have - 1], h = 3 + (l & 3), l >>>= 2, u -= 2
            } else if (x === 17) {
              for (C = m + 3; u < C;) {
                if (o === 0) break e;
                o--, l += n[a++] << u, u += 8
              }
              l >>>= m, u -= m, T = 0, h = 3 + (l & 7), l >>>= 3, u -= 3
            } else {
              for (C = m + 7; u < C;) {
                if (o === 0) break e;
                o--, l += n[a++] << u, u += 8
              }
              l >>>= m, u -= m, T = 0, h = 11 + (l & 127), l >>>= 7, u -= 7
            }
            if (r.have + h > r.nlen + r.ndist) {
              t.msg = "invalid bit length repeat", r.mode = ot;
              break
            }
            for (; h--;) r.lens[r.have++] = T
          }
        }
        if (r.mode === ot) break;
        if (r.lens[256] === 0) {
          t.msg = "invalid code -- missing end-of-block", r.mode = ot;
          break
        }
        if (r.lenbits = 9, w = {
            bits: r.lenbits
          }, R = c0(OZ, r.lens, 0, r.nlen, r.lencode, 0, r.work, w), r.lenbits = w.bits, R) {
          t.msg = "invalid literal/lengths set", r.mode = ot;
          break
        }
        if (r.distbits = 6, r.distcode = r.distdyn, w = {
            bits: r.distbits
          }, R = c0(LZ, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, w), r.distbits = w.bits, R) {
          t.msg = "invalid distances set", r.mode = ot;
          break
        }
        if (r.mode = iv, e === nv) break e;
      case iv:
        r.mode = av;
      case av:
        if (o >= 6 && c >= 258) {
          t.next_out = s, t.avail_out = c, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = u, PXe(t, d), s = t.next_out, i = t.output, c = t.avail_out, a = t.next_in, n = t.input, o = t.avail_in, l = r.hold, u = r.bits, r.mode === Pa && (r.back = -1);
          break
        }
        for (r.back = 0; g = r.lencode[l & (1 << r.lenbits) - 1], m = g >>> 24, y = g >>> 16 & 255, x = g & 65535, !(m <= u);) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if (y && !(y & 240)) {
          for (b = m, _ = y, S = x; g = r.lencode[S + ((l & (1 << b + _) - 1) >> b)], m = g >>> 24, y = g >>> 16 & 255, x = g & 65535, !(b + m <= u);) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          l >>>= b, u -= b, r.back += b
        }
        if (l >>>= m, u -= m, r.back += m, r.length = x, y === 0) {
          r.mode = wU;
          break
        }
        if (y & 32) {
          r.back = -1, r.mode = Pa;
          break
        }
        if (y & 64) {
          t.msg = "invalid literal/length code", r.mode = ot;
          break
        }
        r.extra = y & 15, r.mode = EU;
      case EU:
        if (r.extra) {
          for (C = r.extra; u < C;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          r.length += l & (1 << r.extra) - 1, l >>>= r.extra, u -= r.extra, r.back += r.extra
        }
        r.was = r.length, r.mode = SU;
      case SU:
        for (; g = r.distcode[l & (1 << r.distbits) - 1], m = g >>> 24, y = g >>> 16 & 255, x = g & 65535, !(m <= u);) {
          if (o === 0) break e;
          o--, l += n[a++] << u, u += 8
        }
        if (!(y & 240)) {
          for (b = m, _ = y, S = x; g = r.distcode[S + ((l & (1 << b + _) - 1) >> b)], m = g >>> 24, y = g >>> 16 & 255, x = g & 65535, !(b + m <= u);) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          l >>>= b, u -= b, r.back += b
        }
        if (l >>>= m, u -= m, r.back += m, y & 64) {
          t.msg = "invalid distance code", r.mode = ot;
          break
        }
        r.offset = x, r.extra = y & 15, r.mode = _U;
      case _U:
        if (r.extra) {
          for (C = r.extra; u < C;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, u -= r.extra, r.back += r.extra
        }
        if (r.offset > r.dmax) {
          t.msg = "invalid distance too far back", r.mode = ot;
          break
        }
        r.mode = TU;
      case TU:
        if (c === 0) break e;
        if (h = d - c, r.offset > h) {
          if (h = r.offset - h, h > r.whave && r.sane) {
            t.msg = "invalid distance too far back", r.mode = ot;
            break
          }
          h > r.wnext ? (h -= r.wnext, p = r.wsize - h) : p = r.wnext - h, h > r.length && (h = r.length), v = r.window
        } else v = i, p = s - r.offset, h = r.length;
        h > c && (h = c), c -= h, r.length -= h;
        do i[s++] = v[p++]; while (--h);
        r.length === 0 && (r.mode = av);
        break;
      case wU:
        if (c === 0) break e;
        i[s++] = r.length, c--, r.mode = av;
        break;
      case Ow:
        if (r.wrap) {
          for (; u < 32;) {
            if (o === 0) break e;
            o--, l |= n[a++] << u, u += 8
          }
          if (d -= c, t.total_out += d, r.total += d, r.wrap & 4 && d && (t.adler = r.check = r.flags ? zt(r.check, i, d, s - d) : op(r.check, i, d, s - d)), d = c, r.wrap & 4 && (r.flags ? l : IU(l)) !== r.check) {
            t.msg = "incorrect data check", r.mode = ot;
            break
          }
          l = 0, u = 0
        }
        r.mode = RU;
      case RU:
        if (r.wrap && r.flags) {
          for (; u < 32;) {
            if (o === 0) break e;
            o--, l += n[a++] << u, u += 8
          }
          if (r.wrap & 4 && l !== (r.total & 4294967295)) {
            t.msg = "incorrect length check", r.mode = ot;
            break
          }
          l = 0, u = 0
        }
        r.mode = AU;
      case AU:
        R = HXe;
        break e;
      case ot:
        R = PZ;
        break e;
      case DZ:
        return NZ;
      case MZ:
      default:
        return ti
    }
    return t.next_out = s, t.avail_out = c, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = u, (r.wsize || d !== t.avail_out && r.mode < ot && (r.mode < Ow || e !== aU)) && HZ(t, t.output, t.next_out, d - t.avail_out), f -= t.avail_in, d -= t.avail_out, t.total_in += f, t.total_out += d, r.total += d, r.wrap & 4 && d && (t.adler = r.check = r.flags ? zt(r.check, i, d, t.next_out - d) : op(r.check, i, d, t.next_out - d)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Pa ? 128 : 0) + (r.mode === iv || r.mode === kw ? 256 : 0), (f === 0 && d === 0 || e === aU) && R === ic && (R = GXe), R
  },
  JXe = t => {
    if (Tc(t)) return ti;
    let e = t.state;
    return e.window && (e.window = null), t.state = null, ic
  },
  eQe = (t, e) => {
    if (Tc(t)) return ti;
    const r = t.state;
    return r.wrap & 2 ? (r.head = e, e.done = !1, ic) : ti
  },
  tQe = (t, e) => {
    const r = e.length;
    let n, i, a;
    return Tc(t) || (n = t.state, n.wrap !== 0 && n.mode !== H1) ? ti : n.mode === H1 && (i = 1, i = op(i, e, r, 0), i !== n.check) ? PZ : (a = HZ(t, e, r, r), a ? (n.mode = DZ, NZ) : (n.havedict = 1, ic))
  };
var rQe = BZ,
  nQe = UZ,
  iQe = FZ,
  aQe = XXe,
  sQe = jZ,
  oQe = ZXe,
  lQe = JXe,
  cQe = eQe,
  uQe = tQe,
  fQe = "pako inflate (from Nodeca project)",
  Wa = {
    inflateReset: rQe,
    inflateReset2: nQe,
    inflateResetKeep: iQe,
    inflateInit: aQe,
    inflateInit2: sQe,
    inflate: oQe,
    inflateEnd: lQe,
    inflateGetHeader: cQe,
    inflateSetDictionary: uQe,
    inflateInfo: fQe
  };

function dQe() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
}
var hQe = dQe;
const zZ = Object.prototype.toString,
  {
    Z_NO_FLUSH: pQe,
    Z_FINISH: gQe,
    Z_OK: up,
    Z_STREAM_END: Nw,
    Z_NEED_DICT: Dw,
    Z_STREAM_ERROR: mQe,
    Z_DATA_ERROR: CU,
    Z_MEM_ERROR: vQe
  } = _c;

function Sg(t) {
  this.options = wE.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, t || {});
  const e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new CZ, this.strm.avail_out = 0;
  let r = Wa.inflateInit2(this.strm, e.windowBits);
  if (r !== up) throw new Error(rc[r]);
  if (this.header = new hQe, Wa.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = cp.string2buf(e.dictionary) : zZ.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = Wa.inflateSetDictionary(this.strm, e.dictionary), r !== up))) throw new Error(rc[r])
}
Sg.prototype.push = function (t, e) {
  const r = this.strm,
    n = this.options.chunkSize,
    i = this.options.dictionary;
  let a, s, o;
  if (this.ended) return !1;
  for (e === ~~e ? s = e : s = e === !0 ? gQe : pQe, zZ.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;;) {
    for (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), a = Wa.inflate(r, s), a === Dw && i && (a = Wa.inflateSetDictionary(r, i), a === up ? a = Wa.inflate(r, s) : a === CU && (a = Dw)); r.avail_in > 0 && a === Nw && r.state.wrap > 0 && t[r.next_in] !== 0;) Wa.inflateReset(r), a = Wa.inflate(r, s);
    switch (a) {
      case mQe:
      case CU:
      case Dw:
      case vQe:
        return this.onEnd(a), this.ended = !0, !1
    }
    if (o = r.avail_out, r.next_out && (r.avail_out === 0 || a === Nw))
      if (this.options.to === "string") {
        let c = cp.utf8border(r.output, r.next_out),
          l = r.next_out - c,
          u = cp.buf2string(r.output, c);
        r.next_out = l, r.avail_out = n - l, l && r.output.set(r.output.subarray(c, c + l), 0), this.onData(u)
      } else this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
    if (!(a === up && o === 0)) {
      if (a === Nw) return a = Wa.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (r.avail_in === 0) break
    }
  }
  return !0
};
Sg.prototype.onData = function (t) {
  this.chunks.push(t)
};
Sg.prototype.onEnd = function (t) {
  t === up && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = wE.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function qO(t, e) {
  const r = new Sg(e);
  if (r.push(t), r.err) throw r.msg || rc[r.err];
  return r.result
}

function yQe(t, e) {
  return e = e || {}, e.raw = !0, qO(t, e)
}
var xQe = Sg,
  bQe = qO,
  EQe = yQe,
  SQe = qO,
  _Qe = _c,
  TQe = {
    Inflate: xQe,
    inflate: bQe,
    inflateRaw: EQe,
    ungzip: SQe,
    constants: _Qe
  };
const {
  Deflate: wQe,
  deflate: RQe,
  deflateRaw: AQe,
  gzip: IQe
} = OXe, {
  Inflate: $Qe,
  inflate: CQe,
  inflateRaw: kQe,
  ungzip: OQe
} = TQe;
var LQe = wQe,
  PQe = RQe,
  NQe = AQe,
  DQe = IQe,
  MQe = $Qe,
  FQe = CQe,
  BQe = kQe,
  UQe = OQe,
  jQe = _c,
  HQe = {
    Deflate: LQe,
    deflate: PQe,
    deflateRaw: NQe,
    gzip: DQe,
    Inflate: MQe,
    inflate: FQe,
    inflateRaw: BQe,
    ungzip: UQe,
    constants: jQe
  };

function zQe(t) {
  const e = new Uint8Array(t.length);
  return [...t].forEach((r, n) => {
    e[n] = r.charCodeAt(0)
  }), e
}

function GZ({
  data: t,
  time: e
}) {
  const r = localStorage.getItem("mw-migration-date");
  return r && new Date(r) >= e ? !1 : (t.bookmarks && localStorage.setItem("mw-bookmarks", JSON.stringify(t.bookmarks)), t.videoProgress && localStorage.setItem("video-progress", JSON.stringify(t.videoProgress)), localStorage.setItem("mw-migration-date", e.toISOString()), !0)
}

function GQe() {
  let t = !1;
  const e = r => {
    const n = r.data;
    n && n.isMigrationData && !t && (t = !0, GZ({
      data: n.data,
      time: n.date
    }) && window.location.reload())
  };
  return A.useEffect(() => (window.addEventListener("message", e), () => {
    window.removeEventListener("message", e)
  })), E("iframe", {
    src: "https://movie.squeezebox.dev",
    hidden: !0
  })
}

function VQe() {
  const [t, e] = A.useState(!1);
  return A.useEffect(() => {
    const r = new URLSearchParams(window.location.search ? ? "");
    if (!r.has("m-time") || !r.has("m-data")) {
      e(!0);
      return
    }
    const n = JSON.parse(HQe.inflate(zQe(atob(r.get("m-data"))), {
        to: "string"
      })),
      i = new Date(r.get("m-time"));
    GZ({
      data: n,
      time: i
    }), e(!0)
  }, []), A.useEffect(() => {
    if (!t) return;
    const r = new URL(window.location.href),
      n = [];
    r.searchParams.forEach((i, a) => n.push(a)), n.forEach(i => r.searchParams.delete(i)), r.searchParams.append("migrated", "1"), r.hash = kr().NORMAL_ROUTER ? "" : `/search/${ae.MOVIE}`, r.pathname = kr().NORMAL_ROUTER ? `/search/${ae.MOVIE}` : "", window.location.href = r.toString()
  }, [t]), null
}
var WQe = typeof me == "object" && me && me.Object === Object && me,
  VZ = WQe,
  KQe = VZ,
  YQe = typeof self == "object" && self && self.Object === Object && self,
  qQe = KQe || YQe || Function("return this")(),
  Ui = qQe,
  XQe = Ui,
  QQe = XQe.Symbol,
  XO = QQe,
  kU = XO,
  WZ = Object.prototype,
  ZQe = WZ.hasOwnProperty,
  JQe = WZ.toString,
  ch = kU ? kU.toStringTag : void 0;

function eZe(t) {
  var e = ZQe.call(t, ch),
    r = t[ch];
  try {
    t[ch] = void 0;
    var n = !0
  } catch {}
  var i = JQe.call(t);
  return n && (e ? t[ch] = r : delete t[ch]), i
}
var tZe = eZe,
  rZe = Object.prototype,
  nZe = rZe.toString;

function iZe(t) {
  return nZe.call(t)
}
var aZe = iZe,
  OU = XO,
  sZe = tZe,
  oZe = aZe,
  lZe = "[object Null]",
  cZe = "[object Undefined]",
  LU = OU ? OU.toStringTag : void 0;

function uZe(t) {
  return t == null ? t === void 0 ? cZe : lZe : LU && LU in Object(t) ? sZe(t) : oZe(t)
}
var _g = uZe;

function fZe(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function")
}
var Rs = fZe,
  dZe = _g,
  hZe = Rs,
  pZe = "[object AsyncFunction]",
  gZe = "[object Function]",
  mZe = "[object GeneratorFunction]",
  vZe = "[object Proxy]";

function yZe(t) {
  if (!hZe(t)) return !1;
  var e = dZe(t);
  return e == gZe || e == mZe || e == pZe || e == vZe
}
var KZ = yZe,
  xZe = Ui,
  bZe = xZe["__core-js_shared__"],
  EZe = bZe,
  Mw = EZe,
  PU = function () {
    var t = /[^.]+$/.exec(Mw && Mw.keys && Mw.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : ""
  }();

function SZe(t) {
  return !!PU && PU in t
}
var _Ze = SZe,
  TZe = Function.prototype,
  wZe = TZe.toString;

function RZe(t) {
  if (t != null) {
    try {
      return wZe.call(t)
    } catch {}
    try {
      return t + ""
    } catch {}
  }
  return ""
}
var YZ = RZe,
  AZe = KZ,
  IZe = _Ze,
  $Ze = Rs,
  CZe = YZ,
  kZe = /[\\^$.*+?()[\]{}|]/g,
  OZe = /^\[object .+?Constructor\]$/,
  LZe = Function.prototype,
  PZe = Object.prototype,
  NZe = LZe.toString,
  DZe = PZe.hasOwnProperty,
  MZe = RegExp("^" + NZe.call(DZe).replace(kZe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function FZe(t) {
  if (!$Ze(t) || IZe(t)) return !1;
  var e = AZe(t) ? MZe : OZe;
  return e.test(CZe(t))
}
var BZe = FZe;

function UZe(t, e) {
  return t == null ? void 0 : t[e]
}
var jZe = UZe,
  HZe = BZe,
  zZe = jZe;

function GZe(t, e) {
  var r = zZe(t, e);
  return HZe(r) ? r : void 0
}
var wc = GZe,
  VZe = wc,
  WZe = function () {
    try {
      var t = VZe(Object, "defineProperty");
      return t({}, "", {}), t
    } catch {}
  }(),
  qZ = WZe,
  NU = qZ;

function KZe(t, e, r) {
  e == "__proto__" && NU ? NU(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r
}
var XZ = KZe;

function YZe(t, e) {
  return t === e || t !== t && e !== e
}
var QO = YZe,
  qZe = XZ,
  XZe = QO,
  QZe = Object.prototype,
  ZZe = QZe.hasOwnProperty;

function JZe(t, e, r) {
  var n = t[e];
  (!(ZZe.call(t, e) && XZe(n, r)) || r === void 0 && !(e in t)) && qZe(t, e, r)
}
var ZO = JZe,
  eJe = ZO,
  tJe = XZ;

function rJe(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s;) {
    var o = e[a],
      c = n ? n(r[o], t[o], o, r, t) : void 0;
    c === void 0 && (c = t[o]), i ? tJe(r, o, c) : eJe(r, o, c)
  }
  return r
}
var Tg = rJe;

function nJe(t) {
  return t
}
var QZ = nJe;

function iJe(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2])
  }
  return t.apply(e, r)
}
var aJe = iJe,
  sJe = aJe,
  DU = Math.max;

function oJe(t, e, r) {
  return e = DU(e === void 0 ? t.length - 1 : e, 0),
    function () {
      for (var n = arguments, i = -1, a = DU(n.length - e, 0), s = Array(a); ++i < a;) s[i] = n[e + i];
      i = -1;
      for (var o = Array(e + 1); ++i < e;) o[i] = n[i];
      return o[e] = r(s), sJe(t, this, o)
    }
}
var lJe = oJe;

function cJe(t) {
  return function () {
    return t
  }
}
var uJe = cJe,
  fJe = uJe,
  MU = qZ,
  dJe = QZ,
  hJe = MU ? function (t, e) {
    return MU(t, "toString", {
      configurable: !0,
      enumerable: !1,
      value: fJe(e),
      writable: !0
    })
  } : dJe,
  pJe = hJe,
  gJe = 800,
  mJe = 16,
  vJe = Date.now;

function yJe(t) {
  var e = 0,
    r = 0;
  return function () {
    var n = vJe(),
      i = mJe - (n - r);
    if (r = n, i > 0) {
      if (++e >= gJe) return arguments[0]
    } else e = 0;
    return t.apply(void 0, arguments)
  }
}
var xJe = yJe,
  bJe = pJe,
  EJe = xJe,
  SJe = EJe(bJe),
  _Je = SJe,
  TJe = QZ,
  wJe = lJe,
  RJe = _Je;

function AJe(t, e) {
  return RJe(wJe(t, e, TJe), t + "")
}
var IJe = AJe,
  $Je = 9007199254740991;

function CJe(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= $Je
}
var ZZ = CJe,
  kJe = KZ,
  OJe = ZZ;

function LJe(t) {
  return t != null && OJe(t.length) && !kJe(t)
}
var AE = LJe,
  PJe = 9007199254740991,
  NJe = /^(?:0|[1-9]\d*)$/;

function DJe(t, e) {
  var r = typeof t;
  return e = e ? ? PJe, !!e && (r == "number" || r != "symbol" && NJe.test(t)) && t > -1 && t % 1 == 0 && t < e
}
var JZ = DJe,
  MJe = QO,
  FJe = AE,
  BJe = JZ,
  UJe = Rs;

function jJe(t, e, r) {
  if (!UJe(r)) return !1;
  var n = typeof e;
  return (n == "number" ? FJe(r) && BJe(e, r.length) : n == "string" && e in r) ? MJe(r[e], t) : !1
}
var HJe = jJe,
  zJe = IJe,
  GJe = HJe;

function VJe(t) {
  return zJe(function (e, r) {
    var n = -1,
      i = r.length,
      a = i > 1 ? r[i - 1] : void 0,
      s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && GJe(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i;) {
      var o = r[n];
      o && t(e, o, n, a)
    }
    return e
  })
}
var WJe = VJe,
  KJe = Object.prototype;

function YJe(t) {
  var e = t && t.constructor,
    r = typeof e == "function" && e.prototype || KJe;
  return t === r
}
var IE = YJe;

function qJe(t, e) {
  for (var r = -1, n = Array(t); ++r < t;) n[r] = e(r);
  return n
}
var XJe = qJe;

function QJe(t) {
  return t != null && typeof t == "object"
}
var fd = QJe,
  ZJe = _g,
  JJe = fd,
  eet = "[object Arguments]";

function tet(t) {
  return JJe(t) && ZJe(t) == eet
}
var ret = tet,
  FU = ret,
  net = fd,
  eJ = Object.prototype,
  iet = eJ.hasOwnProperty,
  aet = eJ.propertyIsEnumerable,
  set = FU(function () {
    return arguments
  }()) ? FU : function (t) {
    return net(t) && iet.call(t, "callee") && !aet.call(t, "callee")
  },
  oet = set,
  cet = Array.isArray,
  JO = cet,
  fp = {},
  uet = {
    get exports() {
      return fp
    },
    set exports(t) {
      fp = t
    }
  };

function fet() {
  return !1
}
var det = fet;
(function (t, e) {
  var r = Ui,
    n = det,
    i = e && !e.nodeType && e,
    a = i && !0 && t && !t.nodeType && t,
    s = a && a.exports === i,
    o = s ? r.Buffer : void 0,
    c = o ? o.isBuffer : void 0,
    l = c || n;
  t.exports = l
})(uet, fp);
var het = _g,
  pet = ZZ,
  get = fd,
  met = "[object Arguments]",
  vet = "[object Array]",
  yet = "[object Boolean]",
  xet = "[object Date]",
  bet = "[object Error]",
  Eet = "[object Function]",
  _et = "[object Map]",
  Tet = "[object Number]",
  wet = "[object Object]",
  Ret = "[object RegExp]",
  Aet = "[object Set]",
  Iet = "[object String]",
  $et = "[object WeakMap]",
  Cet = "[object ArrayBuffer]",
  ket = "[object DataView]",
  Oet = "[object Float32Array]",
  Let = "[object Float64Array]",
  Pet = "[object Int8Array]",
  Net = "[object Int16Array]",
  Det = "[object Int32Array]",
  Met = "[object Uint8Array]",
  Fet = "[object Uint8ClampedArray]",
  Bet = "[object Uint16Array]",
  Uet = "[object Uint32Array]",
  it = {};
it[Oet] = it[Let] = it[Pet] = it[Net] = it[Det] = it[Met] = it[Fet] = it[Bet] = it[Uet] = !0;
it[met] = it[vet] = it[Cet] = it[yet] = it[ket] = it[xet] = it[bet] = it[Eet] = it[_et] = it[Tet] = it[wet] = it[Ret] = it[Aet] = it[Iet] = it[$et] = !1;

function jet(t) {
  return get(t) && pet(t.length) && !!it[het(t)]
}
var Het = jet;

function zet(t) {
  return function (e) {
    return t(e)
  }
}
var eL = zet,
  wf = {},
  Get = {
    get exports() {
      return wf
    },
    set exports(t) {
      wf = t
    }
  };
(function (t, e) {
  var r = VZ,
    n = e && !e.nodeType && e,
    i = n && !0 && t && !t.nodeType && t,
    a = i && i.exports === n,
    s = a && r.process,
    o = function () {
      try {
        var c = i && i.require && i.require("util").types;
        return c || s && s.binding && s.binding("util")
      } catch {}
    }();
  t.exports = o
})(Get, wf);
var Vet = Het,
  Wet = eL,
  BU = wf,
  UU = BU && BU.isTypedArray,
  Ket = UU ? Wet(UU) : Vet,
  Yet = Ket,
  qet = XJe,
  Xet = oet,
  Qet = JO,
  Zet = fp,
  Jet = JZ,
  ett = Yet,
  ttt = Object.prototype,
  rtt = ttt.hasOwnProperty;

function ntt(t, e) {
  var r = Qet(t),
    n = !r && Xet(t),
    i = !r && !n && Zet(t),
    a = !r && !n && !i && ett(t),
    s = r || n || i || a,
    o = s ? qet(t.length, String) : [],
    c = o.length;
  for (var l in t)(e || rtt.call(t, l)) && !(s && (l == "length" || i && (l == "offset" || l == "parent") || a && (l == "buffer" || l == "byteLength" || l == "byteOffset") || Jet(l, c))) && o.push(l);
  return o
}
var tJ = ntt;

function itt(t, e) {
  return function (r) {
    return t(e(r))
  }
}
var rJ = itt,
  att = rJ,
  stt = att(Object.keys, Object),
  ott = stt,
  ltt = IE,
  ctt = ott,
  utt = Object.prototype,
  ftt = utt.hasOwnProperty;

function dtt(t) {
  if (!ltt(t)) return ctt(t);
  var e = [];
  for (var r in Object(t)) ftt.call(t, r) && r != "constructor" && e.push(r);
  return e
}
var htt = dtt,
  ptt = tJ,
  gtt = htt,
  mtt = AE;

function vtt(t) {
  return mtt(t) ? ptt(t) : gtt(t)
}
var $E = vtt,
  ytt = ZO,
  xtt = Tg,
  btt = WJe,
  Ett = AE,
  Stt = IE,
  _tt = $E,
  Ttt = Object.prototype,
  wtt = Ttt.hasOwnProperty,
  Rtt = btt(function (t, e) {
    if (Stt(e) || Ett(e)) {
      xtt(e, _tt(e), t);
      return
    }
    for (var r in e) wtt.call(e, r) && ytt(t, r, e[r])
  }),
  Att = Rtt,
  aI = {},
  Itt = {
    get exports() {
      return aI
    },
    set exports(t) {
      aI = t
    }
  };
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    r = "~";

  function n() {}
  Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1));

  function i(c, l, u) {
    this.fn = c, this.context = l, this.once = u || !1
  }

  function a(c, l, u, f, d) {
    if (typeof u != "function") throw new TypeError("The listener must be a function");
    var h = new i(u, f || c, d),
      p = r ? r + l : l;
    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], h] : c._events[p].push(h) : (c._events[p] = h, c._eventsCount++), c
  }

  function s(c, l) {
    --c._eventsCount === 0 ? c._events = new n : delete c._events[l]
  }

  function o() {
    this._events = new n, this._eventsCount = 0
  }
  o.prototype.eventNames = function () {
    var l = [],
      u, f;
    if (this._eventsCount === 0) return l;
    for (f in u = this._events) e.call(u, f) && l.push(r ? f.slice(1) : f);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
  }, o.prototype.listeners = function (l) {
    var u = r ? r + l : l,
      f = this._events[u];
    if (!f) return [];
    if (f.fn) return [f.fn];
    for (var d = 0, h = f.length, p = new Array(h); d < h; d++) p[d] = f[d].fn;
    return p
  }, o.prototype.listenerCount = function (l) {
    var u = r ? r + l : l,
      f = this._events[u];
    return f ? f.fn ? 1 : f.length : 0
  }, o.prototype.emit = function (l, u, f, d, h, p) {
    var v = r ? r + l : l;
    if (!this._events[v]) return !1;
    var g = this._events[v],
      m = arguments.length,
      y, x;
    if (g.fn) {
      switch (g.once && this.removeListener(l, g.fn, void 0, !0), m) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, u), !0;
        case 3:
          return g.fn.call(g.context, u, f), !0;
        case 4:
          return g.fn.call(g.context, u, f, d), !0;
        case 5:
          return g.fn.call(g.context, u, f, d, h), !0;
        case 6:
          return g.fn.call(g.context, u, f, d, h, p), !0
      }
      for (x = 1, y = new Array(m - 1); x < m; x++) y[x - 1] = arguments[x];
      g.fn.apply(g.context, y)
    } else {
      var b = g.length,
        _;
      for (x = 0; x < b; x++) switch (g[x].once && this.removeListener(l, g[x].fn, void 0, !0), m) {
        case 1:
          g[x].fn.call(g[x].context);
          break;
        case 2:
          g[x].fn.call(g[x].context, u);
          break;
        case 3:
          g[x].fn.call(g[x].context, u, f);
          break;
        case 4:
          g[x].fn.call(g[x].context, u, f, d);
          break;
        default:
          if (!y)
            for (_ = 1, y = new Array(m - 1); _ < m; _++) y[_ - 1] = arguments[_];
          g[x].fn.apply(g[x].context, y)
      }
    }
    return !0
  }, o.prototype.on = function (l, u, f) {
    return a(this, l, u, f, !1)
  }, o.prototype.once = function (l, u, f) {
    return a(this, l, u, f, !0)
  }, o.prototype.removeListener = function (l, u, f, d) {
    var h = r ? r + l : l;
    if (!this._events[h]) return this;
    if (!u) return s(this, h), this;
    var p = this._events[h];
    if (p.fn) p.fn === u && (!d || p.once) && (!f || p.context === f) && s(this, h);
    else {
      for (var v = 0, g = [], m = p.length; v < m; v++)(p[v].fn !== u || d && !p[v].once || f && p[v].context !== f) && g.push(p[v]);
      g.length ? this._events[h] = g.length === 1 ? g[0] : g : s(this, h)
    }
    return this
  }, o.prototype.removeAllListeners = function (l) {
    var u;
    return l ? (u = r ? r + l : l, this._events[u] && s(this, u)) : (this._events = new n, this._eventsCount = 0), this
  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, t.exports = o
})(Itt);
const $tt = aI;
var nJ = !1;
if (typeof window < "u") try {
  var jU = Object.defineProperty({}, "passive", {
    get: function () {
      nJ = !0
    }
  });
  window.addEventListener("test", null, jU), window.removeEventListener("test", null, jU)
} catch {}
const Ctt = nJ,
  Xr = {
    connections: {},
    EE: new $tt,
    enableResizeInfo: !1,
    enableScrollInfo: !1,
    listeners: {},
    removers: [],
    supportPassiveEvent: Ctt
  };
var ktt = Xr.supportPassiveEvent,
  Ott = {
    capture: !1,
    passive: !1
  };

function iJ(t, e, r, n) {
  var i = "addEventListener",
    a = "removeEventListener",
    s = e,
    o = ktt ? Att({}, Ott, n) : !1;
  return !t.addEventListener && t.attachEvent && (i = "attachEvent", a = "detachEvent", s = "on" + e), t[i](s, r, o), {
    remove: function () {
      t[a](e, r)
    }
  }
}
var aJ = !1;
if (typeof navigator < "u") {
  var HU = navigator.userAgent.match(/MSIE (\d+\.\d+)/);
  HU && (aJ = parseFloat(HU[1], 10) < 9)
}
const sJ = aJ;

function Ltt() {
  this.__data__ = [], this.size = 0
}
var Ptt = Ltt,
  Ntt = QO;

function Dtt(t, e) {
  for (var r = t.length; r--;)
    if (Ntt(t[r][0], e)) return r;
  return -1
}
var CE = Dtt,
  Mtt = CE,
  Ftt = Array.prototype,
  Btt = Ftt.splice;

function Utt(t) {
  var e = this.__data__,
    r = Mtt(e, t);
  if (r < 0) return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : Btt.call(e, r, 1), --this.size, !0
}
var jtt = Utt,
  Htt = CE;

function ztt(t) {
  var e = this.__data__,
    r = Htt(e, t);
  return r < 0 ? void 0 : e[r][1]
}
var Gtt = ztt,
  Vtt = CE;

function Wtt(t) {
  return Vtt(this.__data__, t) > -1
}
var Ktt = Wtt,
  Ytt = CE;

function qtt(t, e) {
  var r = this.__data__,
    n = Ytt(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this
}
var Xtt = qtt,
  Qtt = Ptt,
  Ztt = jtt,
  Jtt = Gtt,
  ert = Ktt,
  trt = Xtt;

function dd(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r;) {
    var n = t[e];
    this.set(n[0], n[1])
  }
}
dd.prototype.clear = Qtt;
dd.prototype.delete = Ztt;
dd.prototype.get = Jtt;
dd.prototype.has = ert;
dd.prototype.set = trt;
var kE = dd,
  rrt = kE;

function nrt() {
  this.__data__ = new rrt, this.size = 0
}
var irt = nrt;

function art(t) {
  var e = this.__data__,
    r = e.delete(t);
  return this.size = e.size, r
}
var srt = art;

function ort(t) {
  return this.__data__.get(t)
}
var lrt = ort;

function crt(t) {
  return this.__data__.has(t)
}
var urt = crt,
  frt = wc,
  drt = Ui,
  hrt = frt(drt, "Map"),
  tL = hrt,
  prt = wc,
  grt = prt(Object, "create"),
  OE = grt,
  zU = OE;

function mrt() {
  this.__data__ = zU ? zU(null) : {}, this.size = 0
}
var vrt = mrt;

function yrt(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e
}
var xrt = yrt,
  brt = OE,
  Ert = "__lodash_hash_undefined__",
  Srt = Object.prototype,
  _rt = Srt.hasOwnProperty;

function Trt(t) {
  var e = this.__data__;
  if (brt) {
    var r = e[t];
    return r === Ert ? void 0 : r
  }
  return _rt.call(e, t) ? e[t] : void 0
}
var wrt = Trt,
  Rrt = OE,
  Art = Object.prototype,
  Irt = Art.hasOwnProperty;

function $rt(t) {
  var e = this.__data__;
  return Rrt ? e[t] !== void 0 : Irt.call(e, t)
}
var Crt = $rt,
  krt = OE,
  Ort = "__lodash_hash_undefined__";

function Lrt(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = krt && e === void 0 ? Ort : e, this
}
var Prt = Lrt,
  Nrt = vrt,
  Drt = xrt,
  Mrt = wrt,
  Frt = Crt,
  Brt = Prt;

function hd(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r;) {
    var n = t[e];
    this.set(n[0], n[1])
  }
}
hd.prototype.clear = Nrt;
hd.prototype.delete = Drt;
hd.prototype.get = Mrt;
hd.prototype.has = Frt;
hd.prototype.set = Brt;
var Urt = hd,
  GU = Urt,
  jrt = kE,
  Hrt = tL;

function zrt() {
  this.size = 0, this.__data__ = {
    hash: new GU,
    map: new(Hrt || jrt),
    string: new GU
  }
}
var Grt = zrt;

function Vrt(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}
var Wrt = Vrt,
  Krt = Wrt;

function Yrt(t, e) {
  var r = t.__data__;
  return Krt(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map
}
var LE = Yrt,
  qrt = LE;

function Xrt(t) {
  var e = qrt(this, t).delete(t);
  return this.size -= e ? 1 : 0, e
}
var Qrt = Xrt,
  Zrt = LE;

function Jrt(t) {
  return Zrt(this, t).get(t)
}
var ent = Jrt,
  tnt = LE;

function rnt(t) {
  return tnt(this, t).has(t)
}
var nnt = rnt,
  int = LE;

function ant(t, e) {
  var r = int(this, t),
    n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this
}
var snt = ant,
  ont = Grt,
  lnt = Qrt,
  cnt = ent,
  unt = nnt,
  fnt = snt;

function pd(t) {
  var e = -1,
    r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r;) {
    var n = t[e];
    this.set(n[0], n[1])
  }
}
pd.prototype.clear = ont;
pd.prototype.delete = lnt;
pd.prototype.get = cnt;
pd.prototype.has = unt;
pd.prototype.set = fnt;
var dnt = pd,
  hnt = kE,
  pnt = tL,
  gnt = dnt,
  mnt = 200;

function vnt(t, e) {
  var r = this.__data__;
  if (r instanceof hnt) {
    var n = r.__data__;
    if (!pnt || n.length < mnt - 1) return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new gnt(n)
  }
  return r.set(t, e), this.size = r.size, this
}
var ynt = vnt,
  xnt = kE,
  bnt = irt,
  Ent = srt,
  Snt = lrt,
  _nt = urt,
  Tnt = ynt;

function gd(t) {
  var e = this.__data__ = new xnt(t);
  this.size = e.size
}
gd.prototype.clear = bnt;
gd.prototype.delete = Ent;
gd.prototype.get = Snt;
gd.prototype.has = _nt;
gd.prototype.set = Tnt;
var wnt = gd;

function Rnt(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1;);
  return t
}
var Ant = Rnt,
  Int = Tg,
  $nt = $E;

function Cnt(t, e) {
  return t && Int(e, $nt(e), t)
}
var knt = Cnt;

function Ont(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t)) e.push(r);
  return e
}
var Lnt = Ont,
  Pnt = Rs,
  Nnt = IE,
  Dnt = Lnt,
  Mnt = Object.prototype,
  Fnt = Mnt.hasOwnProperty;

function Bnt(t) {
  if (!Pnt(t)) return Dnt(t);
  var e = Nnt(t),
    r = [];
  for (var n in t) n == "constructor" && (e || !Fnt.call(t, n)) || r.push(n);
  return r
}
var Unt = Bnt,
  jnt = tJ,
  Hnt = Unt,
  znt = AE;

function Gnt(t) {
  return znt(t) ? jnt(t, !0) : Hnt(t)
}
var rL = Gnt,
  Vnt = Tg,
  Wnt = rL;

function Knt(t, e) {
  return t && Vnt(e, Wnt(e), t)
}
var Ynt = Knt,
  z1 = {},
  qnt = {
    get exports() {
      return z1
    },
    set exports(t) {
      z1 = t
    }
  };
(function (t, e) {
  var r = Ui,
    n = e && !e.nodeType && e,
    i = n && !0 && t && !t.nodeType && t,
    a = i && i.exports === n,
    s = a ? r.Buffer : void 0,
    o = s ? s.allocUnsafe : void 0;

  function c(l, u) {
    if (u) return l.slice();
    var f = l.length,
      d = o ? o(f) : new l.constructor(f);
    return l.copy(d), d
  }
  t.exports = c
})(qnt, z1);

function Xnt(t, e) {
  var r = -1,
    n = t.length;
  for (e || (e = Array(n)); ++r < n;) e[r] = t[r];
  return e
}
var Qnt = Xnt;

function Znt(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n;) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s)
  }
  return a
}
var Jnt = Znt;

function eit() {
  return []
}
var oJ = eit,
  tit = Jnt,
  rit = oJ,
  nit = Object.prototype,
  iit = nit.propertyIsEnumerable,
  VU = Object.getOwnPropertySymbols,
  ait = VU ? function (t) {
    return t == null ? [] : (t = Object(t), tit(VU(t), function (e) {
      return iit.call(t, e)
    }))
  } : rit,
  nL = ait,
  sit = Tg,
  oit = nL;

function lit(t, e) {
  return sit(t, oit(t), e)
}
var cit = lit;

function uit(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n;) t[i + r] = e[r];
  return t
}
var lJ = uit,
  fit = rJ,
  dit = fit(Object.getPrototypeOf, Object),
  cJ = dit,
  hit = lJ,
  pit = cJ,
  git = nL,
  mit = oJ,
  vit = Object.getOwnPropertySymbols,
  yit = vit ? function (t) {
    for (var e = []; t;) hit(e, git(t)), t = pit(t);
    return e
  } : mit,
  uJ = yit,
  xit = Tg,
  bit = uJ;

function Eit(t, e) {
  return xit(t, bit(t), e)
}
var Sit = Eit,
  _it = lJ,
  Tit = JO;

function wit(t, e, r) {
  var n = e(t);
  return Tit(t) ? n : _it(n, r(t))
}
var fJ = wit,
  Rit = fJ,
  Ait = nL,
  Iit = $E;

function $it(t) {
  return Rit(t, Iit, Ait)
}
var Cit = $it,
  kit = fJ,
  Oit = uJ,
  Lit = rL;

function Pit(t) {
  return kit(t, Lit, Oit)
}
var Nit = Pit,
  Dit = wc,
  Mit = Ui,
  Fit = Dit(Mit, "DataView"),
  Bit = Fit,
  Uit = wc,
  jit = Ui,
  Hit = Uit(jit, "Promise"),
  zit = Hit,
  Git = wc,
  Vit = Ui,
  Wit = Git(Vit, "Set"),
  Kit = Wit,
  Yit = wc,
  qit = Ui,
  Xit = Yit(qit, "WeakMap"),
  Qit = Xit,
  sI = Bit,
  oI = tL,
  lI = zit,
  cI = Kit,
  uI = Qit,
  dJ = _g,
  md = YZ,
  WU = "[object Map]",
  Zit = "[object Object]",
  KU = "[object Promise]",
  YU = "[object Set]",
  qU = "[object WeakMap]",
  XU = "[object DataView]",
  Jit = md(sI),
  eat = md(oI),
  tat = md(lI),
  rat = md(cI),
  nat = md(uI),
  xl = dJ;
(sI && xl(new sI(new ArrayBuffer(1))) != XU || oI && xl(new oI) != WU || lI && xl(lI.resolve()) != KU || cI && xl(new cI) != YU || uI && xl(new uI) != qU) && (xl = function (t) {
  var e = dJ(t),
    r = e == Zit ? t.constructor : void 0,
    n = r ? md(r) : "";
  if (n) switch (n) {
    case Jit:
      return XU;
    case eat:
      return WU;
    case tat:
      return KU;
    case rat:
      return YU;
    case nat:
      return qU
  }
  return e
});
var iL = xl,
  iat = Object.prototype,
  aat = iat.hasOwnProperty;

function sat(t) {
  var e = t.length,
    r = new t.constructor(e);
  return e && typeof t[0] == "string" && aat.call(t, "index") && (r.index = t.index, r.input = t.input), r
}
var oat = sat,
  lat = Ui,
  cat = lat.Uint8Array,
  uat = cat,
  QU = uat;

function fat(t) {
  var e = new t.constructor(t.byteLength);
  return new QU(e).set(new QU(t)), e
}
var aL = fat,
  dat = aL;

function hat(t, e) {
  var r = e ? dat(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength)
}
var pat = hat,
  gat = /\w*$/;

function mat(t) {
  var e = new t.constructor(t.source, gat.exec(t));
  return e.lastIndex = t.lastIndex, e
}
var vat = mat,
  ZU = XO,
  JU = ZU ? ZU.prototype : void 0,
  e7 = JU ? JU.valueOf : void 0;

function yat(t) {
  return e7 ? Object(e7.call(t)) : {}
}
var xat = yat,
  bat = aL;

function Eat(t, e) {
  var r = e ? bat(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length)
}
var Sat = Eat,
  _at = aL,
  Tat = pat,
  wat = vat,
  Rat = xat,
  Aat = Sat,
  Iat = "[object Boolean]",
  $at = "[object Date]",
  Cat = "[object Map]",
  kat = "[object Number]",
  Oat = "[object RegExp]",
  Lat = "[object Set]",
  Pat = "[object String]",
  Nat = "[object Symbol]",
  Dat = "[object ArrayBuffer]",
  Mat = "[object DataView]",
  Fat = "[object Float32Array]",
  Bat = "[object Float64Array]",
  Uat = "[object Int8Array]",
  jat = "[object Int16Array]",
  Hat = "[object Int32Array]",
  zat = "[object Uint8Array]",
  Gat = "[object Uint8ClampedArray]",
  Vat = "[object Uint16Array]",
  Wat = "[object Uint32Array]";

function Kat(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case Dat:
      return _at(t);
    case Iat:
    case $at:
      return new n(+t);
    case Mat:
      return Tat(t, r);
    case Fat:
    case Bat:
    case Uat:
    case jat:
    case Hat:
    case zat:
    case Gat:
    case Vat:
    case Wat:
      return Aat(t, r);
    case Cat:
      return new n;
    case kat:
    case Pat:
      return new n(t);
    case Oat:
      return wat(t);
    case Lat:
      return new n;
    case Nat:
      return Rat(t)
  }
}
var Yat = Kat,
  qat = Rs,
  t7 = Object.create,
  Xat = function () {
    function t() {}
    return function (e) {
      if (!qat(e)) return {};
      if (t7) return t7(e);
      t.prototype = e;
      var r = new t;
      return t.prototype = void 0, r
    }
  }(),
  Qat = Xat,
  Zat = Qat,
  Jat = cJ,
  est = IE;

function tst(t) {
  return typeof t.constructor == "function" && !est(t) ? Zat(Jat(t)) : {}
}
var rst = tst,
  nst = iL,
  ist = fd,
  ast = "[object Map]";

function sst(t) {
  return ist(t) && nst(t) == ast
}
var ost = sst,
  lst = ost,
  cst = eL,
  r7 = wf,
  n7 = r7 && r7.isMap,
  ust = n7 ? cst(n7) : lst,
  fst = ust,
  dst = iL,
  hst = fd,
  pst = "[object Set]";

function gst(t) {
  return hst(t) && dst(t) == pst
}
var mst = gst,
  vst = mst,
  yst = eL,
  i7 = wf,
  a7 = i7 && i7.isSet,
  xst = a7 ? yst(a7) : vst,
  bst = xst,
  Est = wnt,
  Sst = Ant,
  _st = ZO,
  Tst = knt,
  wst = Ynt,
  Rst = z1,
  Ast = Qnt,
  Ist = cit,
  $st = Sit,
  Cst = Cit,
  kst = Nit,
  Ost = iL,
  Lst = oat,
  Pst = Yat,
  Nst = rst,
  Dst = JO,
  Mst = fp,
  Fst = fst,
  Bst = Rs,
  Ust = bst,
  jst = $E,
  Hst = rL,
  zst = 1,
  Gst = 2,
  Vst = 4,
  hJ = "[object Arguments]",
  Wst = "[object Array]",
  Kst = "[object Boolean]",
  Yst = "[object Date]",
  qst = "[object Error]",
  pJ = "[object Function]",
  Xst = "[object GeneratorFunction]",
  Qst = "[object Map]",
  Zst = "[object Number]",
  gJ = "[object Object]",
  Jst = "[object RegExp]",
  eot = "[object Set]",
  tot = "[object String]",
  rot = "[object Symbol]",
  not = "[object WeakMap]",
  iot = "[object ArrayBuffer]",
  aot = "[object DataView]",
  sot = "[object Float32Array]",
  oot = "[object Float64Array]",
  lot = "[object Int8Array]",
  cot = "[object Int16Array]",
  uot = "[object Int32Array]",
  fot = "[object Uint8Array]",
  dot = "[object Uint8ClampedArray]",
  hot = "[object Uint16Array]",
  pot = "[object Uint32Array]",
  et = {};
et[hJ] = et[Wst] = et[iot] = et[aot] = et[Kst] = et[Yst] = et[sot] = et[oot] = et[lot] = et[cot] = et[uot] = et[Qst] = et[Zst] = et[gJ] = et[Jst] = et[eot] = et[tot] = et[rot] = et[fot] = et[dot] = et[hot] = et[pot] = !0;
et[qst] = et[pJ] = et[not] = !1;

function iy(t, e, r, n, i, a) {
  var s, o = e & zst,
    c = e & Gst,
    l = e & Vst;
  if (r && (s = i ? r(t, n, i, a) : r(t)), s !== void 0) return s;
  if (!Bst(t)) return t;
  var u = Dst(t);
  if (u) {
    if (s = Lst(t), !o) return Ast(t, s)
  } else {
    var f = Ost(t),
      d = f == pJ || f == Xst;
    if (Mst(t)) return Rst(t, o);
    if (f == gJ || f == hJ || d && !i) {
      if (s = c || d ? {} : Nst(t), !o) return c ? $st(t, wst(s, t)) : Ist(t, Tst(s, t))
    } else {
      if (!et[f]) return i ? t : {};
      s = Pst(t, f, o)
    }
  }
  a || (a = new Est);
  var h = a.get(t);
  if (h) return h;
  a.set(t, s), Ust(t) ? t.forEach(function (g) {
    s.add(iy(g, e, r, g, t, a))
  }) : Fst(t) && t.forEach(function (g, m) {
    s.set(m, iy(g, e, r, m, t, a))
  });
  var p = l ? c ? kst : Cst : c ? Hst : jst,
    v = u ? void 0 : p(t);
  return Sst(v || t, function (g, m) {
    v && (m = g, g = t[m]), _st(s, m, iy(g, e, r, m, t, a))
  }), s
}
var got = iy,
  mot = got,
  vot = 4;

function yot(t) {
  return mot(t, vot)
}
var xot = yot,
  bot = Ui,
  Eot = function () {
    return bot.Date.now()
  },
  Sot = Eot,
  _ot = /\s/;

function Tot(t) {
  for (var e = t.length; e-- && _ot.test(t.charAt(e)););
  return e
}
var wot = Tot,
  Rot = wot,
  Aot = /^\s+/;

function Iot(t) {
  return t && t.slice(0, Rot(t) + 1).replace(Aot, "")
}
var $ot = Iot,
  Cot = _g,
  kot = fd,
  Oot = "[object Symbol]";

function Lot(t) {
  return typeof t == "symbol" || kot(t) && Cot(t) == Oot
}
var Pot = Lot,
  Not = $ot,
  s7 = Rs,
  Dot = Pot,
  o7 = 0 / 0,
  Mot = /^[-+]0x[0-9a-f]+$/i,
  Fot = /^0b[01]+$/i,
  Bot = /^0o[0-7]+$/i,
  Uot = parseInt;

function jot(t) {
  if (typeof t == "number") return t;
  if (Dot(t)) return o7;
  if (s7(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = s7(e) ? e + "" : e
  }
  if (typeof t != "string") return t === 0 ? t : +t;
  t = Not(t);
  var r = Fot.test(t);
  return r || Bot.test(t) ? Uot(t.slice(2), r ? 2 : 8) : Mot.test(t) ? o7 : +t
}
var Hot = jot,
  zot = Rs,
  Fw = Sot,
  l7 = Hot,
  Got = "Expected a function",
  Vot = Math.max,
  Wot = Math.min;

function Kot(t, e, r) {
  var n, i, a, s, o, c, l = 0,
    u = !1,
    f = !1,
    d = !0;
  if (typeof t != "function") throw new TypeError(Got);
  e = l7(e) || 0, zot(r) && (u = !!r.leading, f = "maxWait" in r, a = f ? Vot(l7(r.maxWait) || 0, e) : a, d = "trailing" in r ? !!r.trailing : d);

  function h(S) {
    var T = n,
      R = i;
    return n = i = void 0, l = S, s = t.apply(R, T), s
  }

  function p(S) {
    return l = S, o = setTimeout(m, e), u ? h(S) : s
  }

  function v(S) {
    var T = S - c,
      R = S - l,
      I = e - T;
    return f ? Wot(I, a - R) : I
  }

  function g(S) {
    var T = S - c,
      R = S - l;
    return c === void 0 || T >= e || T < 0 || f && R >= a
  }

  function m() {
    var S = Fw();
    if (g(S)) return y(S);
    o = setTimeout(m, v(S))
  }

  function y(S) {
    return o = void 0, d && n ? h(S) : (n = i = void 0, s)
  }

  function x() {
    o !== void 0 && clearTimeout(o), l = 0, n = c = i = o = void 0
  }

  function b() {
    return o === void 0 ? s : y(Fw())
  }

  function _() {
    var S = Fw(),
      T = g(S);
    if (n = arguments, i = this, c = S, T) {
      if (o === void 0) return p(c);
      if (f) return clearTimeout(o), o = setTimeout(m, e), h(c)
    }
    return o === void 0 && (o = setTimeout(m, e)), s
  }
  return _.cancel = x, _.flush = b, _
}
var Yot = Kot,
  qot = Yot,
  Xot = Rs,
  Qot = "Expected a function";

function Zot(t, e, r) {
  var n = !0,
    i = !0;
  if (typeof t != "function") throw new TypeError(Qot);
  return Xot(r) && (n = "leading" in r ? !!r.leading : n, i = "trailing" in r ? !!r.trailing : i), qot(t, e, {
    leading: n,
    maxWait: e,
    trailing: i
  })
}
var Jot = Zot;

function elt() {}
var tlt = elt,
  rlt = function () {
    function t(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
      }
    }
    return function (e, r, n) {
      return r && t(e.prototype, r), n && t(e, n), e
    }
  }();

function nlt(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}
var ilt = {
    width: 0,
    height: 0
  },
  alt = {
    delta: 0,
    top: 0
  },
  slt = {
    axisIntention: "",
    startX: 0,
    startY: 0,
    deltaX: 0,
    deltaY: 0
  },
  c7 = 5,
  u7 = function (e) {
    var r = {
        x: 0,
        y: 0
      },
      n = document.body,
      i = document.documentElement;
    return e.pageX || e.pageY ? (r.x = e.pageX, r.y = e.pageY) : (r.x = e.clientX + n.scrollLeft + i.scrollLeft, r.y = e.clientY + n.scrollTop + i.scrollTop), r
  },
  ay = function () {
    function t() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      nlt(this, t);
      var r = (e.mainType || "").toLowerCase(),
        n = (e.subType || "").toLowerCase();
      this.mainType = r, this.subType = n, this.type = r + n.charAt(0).toUpperCase() + n.slice(1) || "", this.scroll = alt, this.resize = ilt, this.touch = slt
    }
    return rlt(t, [{
      key: "update",
      value: function (r) {
        var n = this.mainType,
          i = this.subType,
          a = document.documentElement;
        if (Xr.enableScrollInfo && (n === "scroll" || n === "touchmove")) {
          var s = a.scrollTop + document.body.scrollTop;
          s !== this.scroll.top && (this.scroll.delta = s - this.scroll.top, this.scroll.top = s)
        }
        if (Xr.enableResizeInfo && n === "resize" && (this.resize.width = window.innerWidth || a.clientWidth, this.resize.height = window.innerHeight || a.clientHeight), Xr.enableTouchInfo && r.touches && (n === "touchstart" || n === "touchmove" || n === "touchend")) {
          var o = void 0,
            c = void 0,
            l = void 0;
          n === "touchstart" || i === "start" ? (o = u7(r.touches[0]), this.touch.axisIntention = "", this.touch.startX = o.x, this.touch.startY = o.y, this.touch.deltaX = 0, this.touch.deltaY = 0) : n === "touchmove" && (o = u7(r.touches[0]), this.touch.deltaX = o.x - this.touch.startX, this.touch.deltaY = o.y - this.touch.startY, this.touch.axisIntention === "" && (c = Math.abs(this.touch.deltaX), l = Math.abs(this.touch.deltaY), c > c7 && c >= l ? this.touch.axisIntention = "x" : l > c7 && l > c && (this.touch.axisIntention = "y")))
        }
      }
    }]), t
  }(),
  Rf = {},
  olt = {
    get exports() {
      return Rf
    },
    set exports(t) {
      Rf = t
    }
  },
  fI = {},
  sv = {
    get exports() {
      return fI
    },
    set exports(t) {
      fI = t
    }
  };
(function () {
  var t, e, r, n, i, a;
  typeof performance < "u" && performance !== null && performance.now ? sv.exports = function () {
    return performance.now()
  } : typeof process < "u" && process !== null && process.hrtime ? (sv.exports = function () {
    return (t() - i) / 1e6
  }, e = process.hrtime, t = function () {
    var s;
    return s = e(), s[0] * 1e9 + s[1]
  }, n = t(), a = process.uptime() * 1e9, i = n - a) : Date.now ? (sv.exports = function () {
    return Date.now() - r
  }, r = Date.now()) : (sv.exports = function () {
    return new Date().getTime() - r
  }, r = new Date().getTime())
}).call(me);
var llt = fI,
  ns = typeof window > "u" ? me : window,
  ov = ["moz", "webkit"],
  Xu = "AnimationFrame",
  Af = ns["request" + Xu],
  dp = ns["cancel" + Xu] || ns["cancelRequest" + Xu];
for (var uh = 0; !Af && uh < ov.length; uh++) Af = ns[ov[uh] + "Request" + Xu], dp = ns[ov[uh] + "Cancel" + Xu] || ns[ov[uh] + "CancelRequest" + Xu];
if (!Af || !dp) {
  var Bw = 0,
    f7 = 0,
    gl = [],
    clt = 1e3 / 60;
  Af = function (t) {
    if (gl.length === 0) {
      var e = llt(),
        r = Math.max(0, clt - (e - Bw));
      Bw = r + e, setTimeout(function () {
        var n = gl.slice(0);
        gl.length = 0;
        for (var i = 0; i < n.length; i++)
          if (!n[i].cancelled) try {
            n[i].callback(Bw)
          } catch (a) {
            setTimeout(function () {
              throw a
            }, 0)
          }
      }, Math.round(r))
    }
    return gl.push({
      handle: ++f7,
      callback: t,
      cancelled: !1
    }), f7
  }, dp = function (t) {
    for (var e = 0; e < gl.length; e++) gl[e].handle === t && (gl[e].cancelled = !0)
  }
}
olt.exports = function (t) {
  return Af.call(ns, t)
};
Rf.cancel = function () {
  dp.apply(ns, arguments)
};
Rf.polyfill = function (t) {
  t || (t = ns), t.requestAnimationFrame = Af, t.cancelAnimationFrame = dp
};
var ult = Date.now || function () {
  return new Date().getTime()
};

function flt(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 15,
    r = void 0,
    n = void 0,
    i = 0,
    a = 0,
    s = function o() {
      var c = ult(),
        l = e - (c - i);
      l <= 0 ? (i = c, a = 0, t.apply(r, n)) : a = Rf(o)
    };
  return function () {
    r = this, n = arguments, a || (a = Rf(s))
  }
}
var d7 = 100,
  dlt = 50,
  lv = Xr.connections,
  Qu = Xr.EE,
  If = Xr.listeners,
  u0 = Xr.removers,
  dI = void 0,
  Gs = void 0,
  lu = void 0,
  hlt = 0;
typeof window < "u" && (Gs = window, dI = Gs.document || document, lu = dI.body);

function mJ(t) {
  return t.id || "target-id-" + hlt++
}

function vJ(t, e, r, n) {
  return Qu.on(t, e || tlt, r), n = n || t, lv[n] = (lv[n] || 0) + 1, {
    _type: t,
    _cb: e,
    _ctx: r,
    unsubscribe: function () {
      if (this._type) {
        Qu.removeListener(t, e, r), lv[n]--, lv[n] === 0 && (If[n].remove(), If[n] = void 0), this._type = void 0, this._cb = void 0, this._ctx = void 0;
        for (var a = u0.length - 1; a >= 0; a--) {
          var s = u0[a];
          if (s === this) {
            u0.splice(a, 1);
            break
          }
        }
      }
    }
  }
}

function Na(t, e, r) {
  return function (i, a, s, o) {
    var c = s.context,
      l = s.target,
      u = l && mJ(l),
      f = u ? ":" + u : "",
      d = e + "Start:" + i + f,
      h = e + "End:" + i + f,
      p = e + ":" + i + f,
      v = r + ":" + i + f,
      g = vJ(v, a, c, p);
    if (u0.push(g), If[p]) return g;
    var m = {
      start: new ay({
        mainType: e,
        subType: "start"
      }),
      main: new ay({
        mainType: e
      }),
      end: new ay({
        mainType: e,
        subType: "end"
      })
    };
    i === "raf" ? (i = 16, b = flt(b)) : i > 0 && (b = Jot(b, i));
    var y = void 0;

    function x(_) {
      m.end.update(_), Qu.emit(h, _, m.end), y = null
    }

    function b(_) {
      y || (m.start.update(_), Qu.emit(d, _, m.start)), clearTimeout(y), m.main.update(_), Qu.emit(p, _, m.main), sJ ? y = setTimeout(function () {
        x(xot(_))
      }, i + d7) : y = setTimeout(x.bind(null, _), i + d7)
    }
    return If[p] = iJ(l || t, e, b, o), g
  }
}

function Uw(t, e) {
  return function (n, i, a, s) {
    var o = a.context,
      c = a.target,
      l = c && mJ(c),
      u = e + ":0" + (l ? ":" + l : ""),
      f = vJ(u, i, o);
    if (u0.push(f), If[u]) return f;
    var d = new ay({
      mainType: e
    });

    function h(p) {
      d.update(p), Qu.emit(u, p, d)
    }
    return If[u] = iJ(c || t, e, h, s), f
  }
}
const plt = {
  scrollStart: Na(Gs, "scroll", "scrollStart"),
  scrollEnd: Na(Gs, "scroll", "scrollEnd"),
  scroll: Na(Gs, "scroll", "scroll"),
  resizeStart: Na(Gs, "resize", "resizeStart"),
  resizeEnd: Na(Gs, "resize", "resizeEnd"),
  resize: Na(Gs, "resize", "resize"),
  visibilitychange: Uw(dI, "visibilitychange"),
  touchmoveStart: Na(lu, "touchmove", "touchmoveStart"),
  touchmoveEnd: Na(lu, "touchmove", "touchmoveEnd"),
  touchmove: Na(lu, "touchmove", "touchmove"),
  touchstart: Uw(lu, "touchstart"),
  touchend: Uw(lu, "touchend")
};

function glt(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    n = r.useRAF || !1,
    i = parseInt(r.throttleRate, 10),
    a = r.eventOptions;
  return isNaN(i) && (i = dlt), n && (i = "raf"), sJ && (i = 0), Xr.enableScrollInfo = Xr.enableScrollInfo || r.enableScrollInfo || !1, Xr.enableResizeInfo = Xr.enableResizeInfo || r.enableResizeInfo || !1, Xr.enableTouchInfo = Xr.enableTouchInfo || r.enableTouchInfo || !1, plt[t](i, e, r, a)
}
var mlt = typeof window < "u";

function vlt() {}
var jw = mlt ? glt : vlt,
  hI = {},
  ylt = {
    get exports() {
      return hI
    },
    set exports(t) {
      hI = t
    }
  };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function (t) {
  (function () {
    var e = {}.hasOwnProperty;

    function r() {
      for (var n = [], i = 0; i < arguments.length; i++) {
        var a = arguments[i];
        if (a) {
          var s = typeof a;
          if (s === "string" || s === "number") n.push(a);
          else if (Array.isArray(a)) {
            if (a.length) {
              var o = r.apply(null, a);
              o && n.push(o)
            }
          } else if (s === "object") {
            if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]")) {
              n.push(a.toString());
              continue
            }
            for (var c in a) e.call(a, c) && a[c] && n.push(c)
          }
        }
      }
      return n.join(" ")
    }
    t.exports ? (r.default = r, t.exports = r) : window.classNames = r
  })()
})(ylt);
const h7 = hI;
var Hw = function (e, r, n, i) {
  var a = n ? n.call(i, e, r) : void 0;
  if (a !== void 0) return !!a;
  if (e === r) return !0;
  if (typeof e != "object" || !e || typeof r != "object" || !r) return !1;
  var s = Object.keys(e),
    o = Object.keys(r);
  if (s.length !== o.length) return !1;
  for (var c = Object.prototype.hasOwnProperty.bind(r), l = 0; l < s.length; l++) {
    var u = s[l];
    if (!c(u)) return !1;
    var f = e[u],
      d = r[u];
    if (a = n ? n.call(i, f, d, u) : void 0, a === !1 || a === void 0 && f !== d) return !1
  }
  return !0
};

function zw(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t
}

function G1(t) {
  return G1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
    return typeof e
  } : function (e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
  }, G1(t)
}

function xlt(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function p7(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
  }
}

function blt(t, e, r) {
  return e && p7(t.prototype, e), r && p7(t, r), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t
}

function Elt(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && pI(t, e)
}

function pI(t, e) {
  return pI = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, i) {
    return n.__proto__ = i, n
  }, pI(t, e)
}

function Slt(t) {
  var e = Tlt();
  return function () {
    var n = V1(t),
      i;
    if (e) {
      var a = V1(this).constructor;
      i = Reflect.construct(n, arguments, a)
    } else i = n.apply(this, arguments);
    return _lt(this, i)
  }
}

function _lt(t, e) {
  if (e && (G1(e) === "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return sy(t)
}

function sy(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t
}

function Tlt() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
  } catch {
    return !1
  }
}

function V1(t) {
  return V1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (r) {
    return r.__proto__ || Object.getPrototypeOf(r)
  }, V1(t)
}
var cu = 0,
  oy = 1,
  bl = 2,
  g7 = "transform",
  fh, m7, Gw, v7 = !0,
  dh, y7 = 0,
  Vw, cv = -1,
  Mo = function (t) {
    Elt(r, t);
    var e = Slt(r);

    function r(n, i) {
      var a;
      return xlt(this, r), a = e.call(this, n, i), a.handleResize = a.handleResize.bind(sy(a)), a.handleScroll = a.handleScroll.bind(sy(a)), a.handleScrollStart = a.handleScrollStart.bind(sy(a)), a.delta = 0, a.stickyTop = 0, a.stickyBottom = 0, a.frozen = !1, a.skipNextScrollEvent = !1, a.scrollTop = -1, a.bottomBoundaryTarget, a.topTarget, a.subscribers, a.state = {
        top: 0,
        bottom: 0,
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        topBoundary: 0,
        bottomBoundary: 1 / 0,
        status: cu,
        pos: 0,
        activated: !1
      }, a
    }
    return blt(r, [{
      key: "getTargetHeight",
      value: function (i) {
        return i && i.offsetHeight || 0
      }
    }, {
      key: "getTopPosition",
      value: function (i) {
        return i = i || this.props.top || 0, typeof i == "string" && (this.topTarget || (this.topTarget = fh.querySelector(i)), i = this.getTargetHeight(this.topTarget)), i
      }
    }, {
      key: "getTargetBottom",
      value: function (i) {
        if (!i) return -1;
        var a = i.getBoundingClientRect();
        return this.scrollTop + a.bottom
      }
    }, {
      key: "getBottomBoundary",
      value: function (i) {
        var a = i || this.props.bottomBoundary;
        return G1(a) === "object" && (a = a.value || a.target || 0), typeof a == "string" && (this.bottomBoundaryTarget || (this.bottomBoundaryTarget = fh.querySelector(a)), a = this.getTargetBottom(this.bottomBoundaryTarget)), a && a > 0 ? a : 1 / 0
      }
    }, {
      key: "reset",
      value: function () {
        this.setState({
          status: cu,
          pos: 0
        })
      }
    }, {
      key: "release",
      value: function (i) {
        this.setState({
          status: oy,
          pos: i - this.state.y
        })
      }
    }, {
      key: "fix",
      value: function (i) {
        this.setState({
          status: bl,
          pos: i
        })
      }
    }, {
      key: "updateInitialDimension",
      value: function (i) {
        if (i = i || {}, !(!this.outerElement || !this.innerElement)) {
          var a = this.outerElement.getBoundingClientRect(),
            s = this.innerElement.getBoundingClientRect(),
            o = a.width || a.right - a.left,
            c = s.height || s.bottom - s.top,
            l = a.top + this.scrollTop;
          this.setState({
            top: this.getTopPosition(i.top),
            bottom: Math.min(this.state.top + c, cv),
            width: o,
            height: c,
            x: a.left,
            y: l,
            bottomBoundary: this.getBottomBoundary(i.bottomBoundary),
            topBoundary: l
          })
        }
      }
    }, {
      key: "handleResize",
      value: function (i, a) {
        this.props.shouldFreeze() || (cv = a.resize.height, this.updateInitialDimension(), this.update())
      }
    }, {
      key: "handleScrollStart",
      value: function (i, a) {
        this.frozen = this.props.shouldFreeze(), !this.frozen && (this.scrollTop === a.scroll.top ? this.skipNextScrollEvent = !0 : (this.scrollTop = a.scroll.top, this.updateInitialDimension()))
      }
    }, {
      key: "handleScroll",
      value: function (i, a) {
        if (this.skipNextScrollEvent) {
          this.skipNextScrollEvent = !1;
          return
        }
        y7 = a.scroll.delta, this.scrollTop = a.scroll.top, this.update()
      }
    }, {
      key: "update",
      value: function () {
        var i = !this.props.enabled || this.state.bottomBoundary - this.state.topBoundary <= this.state.height || this.state.width === 0 && this.state.height === 0;
        if (i) {
          this.state.status !== cu && this.reset();
          return
        }
        var a = y7,
          s = this.scrollTop + this.state.top,
          o = this.scrollTop + this.state.bottom;
        if (s <= this.state.topBoundary) this.reset();
        else if (o >= this.state.bottomBoundary) this.stickyBottom = this.state.bottomBoundary, this.stickyTop = this.stickyBottom - this.state.height, this.release(this.stickyTop);
        else if (this.state.height > cv - this.state.top) switch (this.state.status) {
          case cu:
            this.release(this.state.y), this.stickyTop = this.state.y, this.stickyBottom = this.stickyTop + this.state.height;
          case oy:
            this.stickyBottom = this.stickyTop + this.state.height, a > 0 && o > this.stickyBottom ? this.fix(this.state.bottom - this.state.height) : a < 0 && s < this.stickyTop && this.fix(this.state.top);
            break;
          case bl:
            var c = !0,
              l = this.state.pos,
              u = this.state.height;
            if (a > 0 && l === this.state.top) this.stickyTop = s - a, this.stickyBottom = this.stickyTop + u;
            else if (a < 0 && l === this.state.bottom - u) this.stickyBottom = o - a, this.stickyTop = this.stickyBottom - u;
            else if (l !== this.state.bottom - u && l !== this.state.top) {
              var f = l + u - this.state.bottom;
              this.stickyBottom = o - a + f, this.stickyTop = this.stickyBottom - u
            } else c = !1;
            c && this.release(this.stickyTop);
            break
        } else this.fix(this.state.top);
        this.delta = a
      }
    }, {
      key: "componentDidUpdate",
      value: function (i, a) {
        var s = this;
        a.status !== this.state.status && this.props.onStateChange && this.props.onStateChange({
          status: this.state.status
        }), this.props.top !== a.top && (this.updateInitialDimension(), this.update());
        var o = !Hw(this.props, i);
        o && (i.enabled !== this.props.enabled ? this.props.enabled ? this.setState({
          activated: !0
        }, function () {
          s.updateInitialDimension(), s.update()
        }) : this.setState({
          activated: !1
        }, function () {
          s.reset()
        }) : (i.top !== this.props.top || i.bottomBoundary !== this.props.bottomBoundary) && (this.updateInitialDimension(), this.update()))
      }
    }, {
      key: "componentWillUnmount",
      value: function () {
        for (var i = this.subscribers || [], a = i.length - 1; a >= 0; a--) this.subscribers[a].unsubscribe()
      }
    }, {
      key: "componentDidMount",
      value: function () {
        Vw || (Vw = window, fh = document, Gw = fh.documentElement, m7 = fh.body, cv = Vw.innerHeight || Gw.clientHeight, dh = window.Modernizr, dh && dh.prefixed && (v7 = dh.csstransforms3d, g7 = dh.prefixed("transform"))), this.scrollTop = m7.scrollTop + Gw.scrollTop, this.props.enabled && (this.setState({
          activated: !0
        }), this.updateInitialDimension(), this.update()), this.subscribers = [jw("scrollStart", this.handleScrollStart.bind(this), {
          useRAF: !0
        }), jw("scroll", this.handleScroll.bind(this), {
          useRAF: !0,
          enableScrollInfo: !0
        }), jw("resize", this.handleResize.bind(this), {
          enableResizeInfo: !0
        })]
      }
    }, {
      key: "translate",
      value: function (i, a) {
        var s = v7 && this.props.enableTransforms;
        s && this.state.activated ? i[g7] = "translate3d(0," + Math.round(a) + "px,0)" : i.top = a + "px"
      }
    }, {
      key: "shouldComponentUpdate",
      value: function (i, a) {
        return !this.props.shouldFreeze() && !(Hw(this.props, i) && Hw(this.state, a))
      }
    }, {
      key: "render",
      value: function () {
        var i, a = this,
          s = {
            position: this.state.status === bl ? "fixed" : "relative",
            top: this.state.status === bl ? "0px" : "",
            zIndex: this.props.innerZ
          },
          o = {};
        this.translate(s, this.state.pos), this.state.status !== cu && (s.width = this.state.width + "px", o.height = this.state.height + "px");
        var c = h7("sticky-outer-wrapper", this.props.className, (i = {}, zw(i, this.props.activeClass, this.state.status === bl), zw(i, this.props.releasedClass, this.state.status === oy), i)),
          l = h7("sticky-inner-wrapper", this.props.innerClass, zw({}, this.props.innerActiveClass, this.state.status === bl)),
          u = this.props.children;
        return ce.createElement("div", {
          ref: function (d) {
            a.outerElement = d
          },
          className: c,
          style: o
        }, ce.createElement("div", {
          ref: function (d) {
            a.innerElement = d
          },
          className: l,
          style: s
        }, typeof u == "function" ? u({
          status: this.state.status
        }) : u))
      }
    }]), r
  }(A.Component);
Mo.displayName = "Sticky";
Mo.defaultProps = {
  shouldFreeze: function () {
    return !1
  },
  enabled: !0,
  top: 0,
  bottomBoundary: 0,
  enableTransforms: !0,
  activeClass: "active",
  releasedClass: "released",
  onStateChange: null,
  innerClass: "",
  innerActiveClass: ""
};
Mo.propTypes = {
  enabled: be.bool,
  top: be.oneOfType([be.string, be.number]),
  bottomBoundary: be.oneOfType([be.object, be.string, be.number]),
  enableTransforms: be.bool,
  activeClass: be.string,
  releasedClass: be.string,
  innerClass: be.string,
  innerActiveClass: be.string,
  className: be.string,
  onStateChange: be.func,
  shouldFreeze: be.func,
  innerZ: be.oneOfType([be.string, be.number])
};
Mo.STATUS_ORIGINAL = cu;
Mo.STATUS_RELEASED = oy;
Mo.STATUS_FIXED = bl;

function wlt(t) {
  return E("div", {
    className: `mx-auto w-[600px] max-w-full px-2 sm:px-0 ${t.classNames||""}`,
    children: t.children
  })
}

function Rlt(t) {
  return E("div", {
    className: `mx-auto w-[700px] max-w-full px-8 sm:px-4 ${t.classNames||""}`,
    children: t.children
  })
}
const Alt = (t = !1) => {
  const [e, r] = A.useState(t), [n, i] = A.useState(e);
  return A.useEffect(() => {
    e && i(!0)
  }, [e]), [n, r, {
    style: {
      animation: `${e?"fadeIn":"fadeOut"} .3s`
    },
    onAnimationEnd: () => {
      e || i(!1)
    }
  }]
};

function Ilt() {
  const [t, e] = A.useState(!1), [r, n] = A.useState(!1);
  return [o => {
    e(o), o && n(!0)
  }, {
    active: t,
    onBackdropHide() {
      n(!1)
    }
  }, {
    style: r ? {
      zIndex: "1000",
      position: "relative"
    } : {}
  }]
}

function $lt(t) {
  const e = t.onClick || (() => {}),
    r = t.onBackdropHide || (() => {}),
    [n, i, a] = Alt();
  return A.useEffect(() => {
    i(!!t.active)
  }, [t.active, i]), A.useEffect(() => {
    n || r()
  }, [n]), n ? E("div", {
    className: `pointer-events-auto fixed left-0 right-0 top-0 h-screen w-screen bg-black bg-opacity-50 opacity-100 transition-opacity ${n?"":"opacity-0"}`,
    ...a,
    onClick: s => e(s.nativeEvent)
  }) : null
}

function Clt(t) {
  const e = A.createRef(),
    r = A.createRef();
  return A.useEffect(() => {
    let n = -1;

    function i() {
      if (e.current && r.current) {
        const a = e.current.getBoundingClientRect();
        r.current.style.top = `${a.top}px`, r.current.style.left = `${a.left}px`, r.current.style.width = `${a.width}px`, r.current.style.height = `${a.height}px`
      }
      n = window.requestAnimationFrame(i)
    }
    return i(), () => {
      window.cancelAnimationFrame(n)
    }
  }, [e, r]), Y("div", {
    ref: e,
    children: [ql.createPortal(Y("div", {
      className: "pointer-events-none fixed left-0 top-0 z-[999]",
      children: [E($lt, {
        active: t.active,
        ...t
      }), E("div", {
        ref: r,
        className: "pointer-events-auto absolute",
        children: t.children
      })]
    }), document.body), E("div", {
      className: "invisible",
      children: t.children
    })]
  })
}

function yJ({
  onClick: t,
  children: e,
  className: r
}) {
  return E("button", {
    onClick: t,
    className: r,
    type: "button",
    children: e
  })
}

function klt({
  option: t,
  onClick: e,
  tabIndex: r
}) {
  return Y("div", {
    className: "flex h-10 cursor-pointer items-center space-x-2 px-4 py-2 text-left text-denim-700 transition-colors hover:text-white",
    onClick: e,
    tabIndex: r,
    children: [E(Ve, {
      icon: t.icon
    }), E("input", {
      type: "radio",
      className: "hidden",
      id: t.id
    }), E("label", {
      htmlFor: t.id,
      className: "cursor-pointer ",
      children: E("div", {
        className: "item",
        children: t.name
      })
    })]
  })
}
const Olt = ce.forwardRef((t, e) => {
  const [r, n, i] = Ilt(), [a, s] = A.useState(t.selectedItem);
  A.useEffect(() => {
    let l;
    return t.open ? s(t.selectedItem) : l = setTimeout(() => {
      s(t.selectedItem)
    }, 200), () => {
      l && clearTimeout(l)
    }
  }, [t.open]);
  const o = t.options.find(l => l.id === t.selectedItem) || {
    id: "movie",
    name: "movie",
    icon: ue.ARROW_LEFT
  };
  A.useEffect(() => {
    r(t.open)
  }, [t.open]);
  const c = (l, u) => {
    l.stopPropagation(), t.setSelectedItem(u.id), t.setOpen(!1)
  };
  return E("div", {
    className: "w-full min-w-[140px] sm:w-auto",
    children: E("div", {
      ref: e,
      className: "relative w-full sm:w-auto",
      ...i,
      children: Y(Clt, {
        onClick: () => t.setOpen(!1),
        ...n,
        children: [Y(yJ, {
          ...t,
          className: "sm:justify-left relative z-20 flex h-10 w-full items-center justify-center space-x-2 rounded-[20px] bg-bink-400 px-4 py-2 text-white hover:bg-bink-300",
          children: [E(Ve, {
            icon: o.icon
          }), E("span", {
            className: "flex-1",
            children: o.name
          }), E(Ve, {
            icon: ue.CHEVRON_DOWN,
            className: `transition-transform ${t.open?"rotate-180":""}`
          })]
        }), E("div", {
          className: `absolute top-0 z-10 w-full rounded-[20px] bg-denim-300 pt-[40px] transition-all duration-200 ${t.open?"block max-h-60 opacity-100":"invisible max-h-0 opacity-0"}`,
          children: t.options.filter(l => l.id !== a).map(l => E(klt, {
            option: l,
            onClick: u => c(u, l),
            tabIndex: t.open ? 0 : void 0
          }, l.id))
        })]
      })
    })
  })
});

function Llt({
  onChange: t,
  onUnFocus: e,
  value: r,
  label: n,
  className: i,
  placeholder: a
}) {
  const s = E("input", {
    type: "text",
    className: i,
    placeholder: a,
    onChange: o => t && t(o.target.value),
    value: r,
    onBlur: () => e && e()
  });
  return n ? Y("label", {
    children: [E("span", {
      children: n
    }), s]
  }) : s
}

function Plt(t) {
  const {
    t: e
  } = ke(), [r, n] = A.useState(!1);

  function i(s) {
    t.onChange({
      ...t.value,
      searchQuery: s
    }, !1)
  }

  function a(s) {
    t.onChange({
      ...t.value,
      type: s
    }, !0)
  }
  return Y("div", {
    className: "relative flex flex-col rounded-[28px] bg-denim-400 transition-colors focus-within:bg-denim-400 hover:bg-denim-500 sm:flex-row sm:items-center",
    children: [E("div", {
      className: "pointer-events-none absolute bottom-0 left-5 top-0 flex max-h-14 items-center",
      children: E(Ve, {
        icon: ue.SEARCH
      })
    }), E(Llt, {
      onUnFocus: t.onUnFocus,
      onChange: s => i(s),
      value: t.value.searchQuery,
      className: "w-full flex-1 bg-transparent px-4 py-4 pl-12 text-white  placeholder-denim-700 focus:outline-none sm:py-4 sm:pr-2",
      placeholder: t.placeholder
    }), E("div", {
      className: "px-4 py-4 pt-0 sm:px-2 sm:py-2",
      children: E(Olt, {
        icon: ue.SEARCH,
        open: r,
        setOpen: s => n(s),
        selectedItem: t.value.type,
        setSelectedItem: s => a(s),
        options: [{
          id: ae.MOVIE,
          name: e("searchBar.movie"),
          icon: ue.FILM
        }, {
          id: ae.SERIES,
          name: e("searchBar.series"),
          icon: ue.CLAPPER_BOARD
        }],
        onClick: () => n(s => !s),
        children: t.buttonText || e("searchBar.search")
      })
    })]
  })
}

function Nlt(t) {
  const e = Object.values(ae).find(n => t.type === n) || ae.MOVIE,
    r = decodeURIComponent(t.query || "");
  return {
    type: e,
    searchQuery: r
  }
}

function xJ() {
  const t = nd(),
    {
      path: e,
      params: r
    } = D8e(),
    [n, i] = A.useState(Nlt(r));
  return [n, (o, c) => {
    const l = {
      ...n
    };
    Object.assign(l, o), i(l), c && t.replace(d1(e, {
      query: l.searchQuery.length === 0 ? void 0 : o.searchQuery,
      type: l.type
    }))
  }, () => {
    t.replace(d1(e, {
      query: n.searchQuery.length === 0 ? void 0 : n.searchQuery,
      type: n.type
    }))
  }]
}

function Dlt(t, e) {
  const [r, n] = A.useState(t);
  return A.useEffect(() => {
    const i = setTimeout(() => {
      n(t)
    }, e);
    return () => {
      clearTimeout(i)
    }
  }, [t, e]), r
}
const bJ = new Set,
  nn = new WeakMap,
  Zu = new WeakMap,
  ac = new WeakMap,
  gI = new WeakMap,
  Mlt = new WeakMap,
  $f = new WeakMap,
  W1 = new WeakMap,
  $h = new WeakSet;
let sc;
const Ja = "__aa_tgt",
  mI = "__aa_del",
  Flt = t => {
    const e = zlt(t);
    e && e.forEach(r => Glt(r))
  },
  Blt = t => {
    t.forEach(e => {
      e.target === sc && jlt(), nn.has(e.target) && Rc(e.target)
    })
  };

function Ult(t) {
  const e = gI.get(t);
  e == null || e.disconnect();
  let r = nn.get(t),
    n = 0;
  const i = 5;
  r || (r = Cf(t), nn.set(t, r));
  const {
    offsetWidth: a,
    offsetHeight: s
  } = sc, c = [r.top - i, a - (r.left + i + r.width), s - (r.top + i + r.height), r.left - i].map(u => `${-1*Math.floor(u)}px`).join(" "), l = new IntersectionObserver(() => {
    ++n > 1 && Rc(t)
  }, {
    root: sc,
    threshold: 1,
    rootMargin: c
  });
  l.observe(t), gI.set(t, l)
}

function Rc(t) {
  clearTimeout(W1.get(t));
  const e = PE(t),
    r = typeof e == "function" ? 500 : e.duration;
  W1.set(t, setTimeout(async () => {
    const n = ac.get(t);
    try {
      await (n == null ? void 0 : n.finished), nn.set(t, Cf(t)), Ult(t)
    } catch {}
  }, r))
}

function jlt() {
  clearTimeout(W1.get(sc)), W1.set(sc, setTimeout(() => {
    bJ.forEach(t => TJ(t, e => EJ(() => Rc(e))))
  }, 100))
}

function Hlt(t) {
  setTimeout(() => {
    Mlt.set(t, setInterval(() => EJ(Rc.bind(null, t)), 2e3))
  }, Math.round(2e3 * Math.random()))
}

function EJ(t) {
  typeof requestIdleCallback == "function" ? requestIdleCallback(() => t()) : requestAnimationFrame(() => t())
}
let vI, Tu;
typeof window < "u" && (sc = document.documentElement, vI = new MutationObserver(Flt), Tu = new ResizeObserver(Blt), Tu.observe(sc));

function zlt(t) {
  return t.reduce((n, i) => [...n, ...Array.from(i.addedNodes), ...Array.from(i.removedNodes)], []).every(n => n.nodeName === "#comment") ? !1 : t.reduce((n, i) => {
    if (n === !1) return !1;
    if (i.target instanceof Element) {
      if (Ww(i.target), !n.has(i.target)) {
        n.add(i.target);
        for (let a = 0; a < i.target.children.length; a++) {
          const s = i.target.children.item(a);
          if (s) {
            if (mI in s) return !1;
            Ww(i.target, s), n.add(s)
          }
        }
      }
      if (i.removedNodes.length)
        for (let a = 0; a < i.removedNodes.length; a++) {
          const s = i.removedNodes[a];
          if (mI in s) return !1;
          s instanceof Element && (n.add(s), Ww(i.target, s), Zu.set(s, [i.previousSibling, i.nextSibling]))
        }
    }
    return n
  }, new Set)
}

function Ww(t, e) {
  !e && !(Ja in t) ? Object.defineProperty(t, Ja, {
    value: t
  }) : e && !(Ja in e) && Object.defineProperty(e, Ja, {
    value: t
  })
}

function Glt(t) {
  var e;
  const r = t.isConnected,
    n = nn.has(t);
  r && Zu.has(t) && Zu.delete(t), ac.has(t) && ((e = ac.get(t)) === null || e === void 0 || e.cancel()), n && r ? Vlt(t) : n && !r ? Klt(t) : Wlt(t)
}

function Xi(t) {
  return Number(t.replace(/[^0-9.\-]/g, ""))
}

function Cf(t) {
  const e = t.getBoundingClientRect();
  return {
    top: e.top + window.scrollY,
    left: e.left + window.scrollX,
    width: e.width,
    height: e.height
  }
}

function SJ(t, e, r) {
  let n = e.width,
    i = e.height,
    a = r.width,
    s = r.height;
  const o = getComputedStyle(t);
  if (o.getPropertyValue("box-sizing") === "content-box") {
    const l = Xi(o.paddingTop) + Xi(o.paddingBottom) + Xi(o.borderTopWidth) + Xi(o.borderBottomWidth),
      u = Xi(o.paddingLeft) + Xi(o.paddingRight) + Xi(o.borderRightWidth) + Xi(o.borderLeftWidth);
    n -= u, a -= u, i -= l, s -= l
  }
  return [n, a, i, s].map(Math.round)
}

function PE(t) {
  return Ja in t && $f.has(t[Ja]) ? $f.get(t[Ja]) : {
    duration: 250,
    easing: "ease-in-out"
  }
}

function _J(t) {
  if (Ja in t) return t[Ja]
}

function sL(t) {
  const e = _J(t);
  return e ? $h.has(e) : !1
}

function TJ(t, ...e) {
  e.forEach(r => r(t, $f.has(t)));
  for (let r = 0; r < t.children.length; r++) {
    const n = t.children.item(r);
    n && e.forEach(i => i(n, $f.has(n)))
  }
}

function Vlt(t) {
  const e = nn.get(t),
    r = Cf(t);
  if (!sL(t)) return nn.set(t, r);
  let n;
  if (!e) return;
  const i = PE(t);
  if (typeof i != "function") {
    const a = e.left - r.left,
      s = e.top - r.top,
      [o, c, l, u] = SJ(t, e, r),
      f = {
        transform: `translate(${a}px, ${s}px)`
      },
      d = {
        transform: "translate(0, 0)"
      };
    o !== c && (f.width = `${o}px`, d.width = `${c}px`), l !== u && (f.height = `${l}px`, d.height = `${u}px`), n = t.animate([f, d], {
      duration: i.duration,
      easing: i.easing
    })
  } else n = new Animation(i(t, "remain", e, r)), n.play();
  ac.set(t, n), nn.set(t, r), n.addEventListener("finish", Rc.bind(null, t))
}

function Wlt(t) {
  const e = Cf(t);
  nn.set(t, e);
  const r = PE(t);
  if (!sL(t)) return;
  let n;
  typeof r != "function" ? n = t.animate([{
    transform: "scale(.98)",
    opacity: 0
  }, {
    transform: "scale(0.98)",
    opacity: 0,
    offset: .5
  }, {
    transform: "scale(1)",
    opacity: 1
  }], {
    duration: r.duration * 1.5,
    easing: "ease-in"
  }) : (n = new Animation(r(t, "add", e)), n.play()), ac.set(t, n), n.addEventListener("finish", Rc.bind(null, t))
}

function Klt(t) {
  var e;
  if (!Zu.has(t) || !nn.has(t)) return;
  const [r, n] = Zu.get(t);
  Object.defineProperty(t, mI, {
    value: !0
  }), n && n.parentNode && n.parentNode instanceof Element ? n.parentNode.insertBefore(t, n) : r && r.parentNode ? r.parentNode.appendChild(t) : (e = _J(t)) === null || e === void 0 || e.appendChild(t);

  function i() {
    var d;
    t.remove(), nn.delete(t), Zu.delete(t), ac.delete(t), (d = gI.get(t)) === null || d === void 0 || d.disconnect()
  }
  if (!sL(t)) return i();
  const [a, s, o, c] = Ylt(t), l = PE(t), u = nn.get(t);
  let f;
  Object.assign(t.style, {
    position: "absolute",
    top: `${a}px`,
    left: `${s}px`,
    width: `${o}px`,
    height: `${c}px`,
    margin: 0,
    pointerEvents: "none",
    transformOrigin: "center",
    zIndex: 100
  }), typeof l != "function" ? f = t.animate([{
    transform: "scale(1)",
    opacity: 1
  }, {
    transform: "scale(.98)",
    opacity: 0
  }], {
    duration: l.duration,
    easing: "ease-out"
  }) : (f = new Animation(l(t, "remove", u)), f.play()), ac.set(t, f), f.addEventListener("finish", i)
}

function Ylt(t) {
  const e = nn.get(t),
    [r, , n] = SJ(t, e, Cf(t));
  let i = t.parentElement;
  for (; i && (getComputedStyle(i).position === "static" || i instanceof HTMLBodyElement);) i = i.parentElement;
  i || (i = document.body);
  const a = getComputedStyle(i),
    s = nn.get(i) || Cf(i),
    o = Math.round(e.top - s.top) - Xi(a.borderTopWidth),
    c = Math.round(e.left - s.left) - Xi(a.borderLeftWidth);
  return [o, c, r, n]
}

function qlt(t, e = {}) {
  return vI && Tu && (window.matchMedia("(prefers-reduced-motion: reduce)").matches && typeof e != "function" && !e.disrespectUserMotionPreference || ($h.add(t), getComputedStyle(t).position === "static" && Object.assign(t.style, {
    position: "relative"
  }), TJ(t, Rc, Hlt, i => Tu == null ? void 0 : Tu.observe(i)), typeof e == "function" ? $f.set(t, e) : $f.set(t, {
    duration: 250,
    easing: "ease-in-out",
    ...e
  }), vI.observe(t, {
    childList: !0
  }), bJ.add(t))), Object.freeze({
    parent: t,
    enable: () => {
      $h.add(t)
    },
    disable: () => {
      $h.delete(t)
    },
    isEnabled: () => $h.has(t)
  })
}

function oL(t) {
  const [e, r] = A.useState();
  return [A.useCallback(a => {
    a instanceof HTMLElement ? r(qlt(a, t)) : r(void 0)
  }, []), a => {
    e && (a ? e.enable() : e.disable())
  }]
}

function Xlt(t) {
  return Y("button", {
    type: "button",
    onClick: t.onClick,
    className: "inline-flex items-center justify-center rounded-lg bg-white px-8 py-3 font-bold text-black transition-[transform,background-color] duration-100 hover:bg-gray-200 active:scale-105 md:px-16",
    children: [t.icon ? E("span", {
      className: "mr-3 hidden md:inline-block",
      children: E(Ve, {
        icon: t.icon
      })
    }) : null, t.children]
  })
}

function wJ(t) {
  const {
    t: e
  } = ke(), [r] = oL(), n = A.useCallback(() => {
    var i;
    (i = t.onEdit) == null || i.call(t, !t.editing)
  }, [t]);
  return E(yJ, {
    onClick: n,
    className: "flex h-12 items-center overflow-hidden rounded-full bg-denim-400 px-4 py-2 text-white transition-[background-color,transform] hover:bg-denim-500 active:scale-105",
    children: E("span", {
      ref: r,
      children: t.editing ? E("span", {
        className: "mx-4 whitespace-nowrap",
        children: e("media.stopEditing")
      }) : E(Ve, {
        icon: ue.EDIT
      })
    })
  })
}

function lL(t) {
  return E("div", {
    className: t.className,
    children: Y("div", {
      className: "mb-5 flex items-center",
      children: [Y("p", {
        className: "flex flex-1 items-center font-bold uppercase text-denim-700",
        children: [t.icon ? E("span", {
          className: "mr-2 text-xl",
          children: E(Ve, {
            icon: t.icon
          })
        }) : null, t.title]
      }), t.children]
    })
  })
}
const cL = A.forwardRef((t, e) => E("div", {
  className: "grid grid-cols-2 gap-6 sm:grid-cols-3",
  ref: e,
  children: t.children
}));

function Qlt(t) {
  return E("p", {
    className: `font-semibold text-denim-700 ${t.className||""}`,
    children: t.content.map((e, r) => Y("span", {
      children: [r !== 0 ? E("span", {
        className: "mx-[0.6em] text-[1em]",
        children: "â"
      }) : null, e]
    }, e))
  })
}

function Zlt({
  media: t,
  linkable: e,
  series: r,
  percentage: n,
  closable: i,
  onClose: a
}) {
  const {
    t: s
  } = ke(), o = `${Math.round(n??0).toFixed(0)}%`, c = e && !i, l = [s(`media.${t.type}`)];
  return t.year && l.push(t.year), E("div", {
    className: `group -m-3 mb-2 rounded-xl bg-denim-300 bg-opacity-0 transition-colors duration-100 ${c?"hover:bg-opacity-100":""}`,
    children: Y("article", {
      className: `pointer-events-auto relative mb-2 p-3 transition-transform duration-100 ${c?"group-hover:scale-95":""}`,
      children: [Y("div", {
        className: ["relative mb-4 aspect-[2/3] w-full overflow-hidden rounded-xl bg-denim-500 bg-cover bg-center transition-[border-radius] duration-100", i ? "" : "group-hover:rounded-lg"].join(" "),
        style: {
          backgroundImage: t.poster ? `url(${t.poster})` : void 0
        },
        children: [r ? E("div", {
          className: ["absolute right-2 top-2 rounded-md bg-denim-200 px-2 py-1 transition-colors", i ? "" : "group-hover:bg-denim-500"].join(" "),
          children: E("p", {
            className: ["text-center text-xs font-bold text-slate-400 transition-colors", i ? "" : "group-hover:text-white"].join(" "),
            children: s("seasons.seasonAndEpisode", {
              season: r.season,
              episode: r.episode
            })
          })
        }) : null, n !== void 0 ? Y(yr, {
          children: [E("div", {
            className: `absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-denim-300 to-transparent transition-colors ${c?"group-hover:from-denim-100":""}`
          }), E("div", {
            className: `absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-denim-300 to-transparent transition-colors ${c?"group-hover:from-denim-100":""}`
          }), E("div", {
            className: "absolute inset-x-0 bottom-0 p-3",
            children: E("div", {
              className: "relative h-1 overflow-hidden rounded-full bg-denim-600",
              children: E("div", {
                className: "absolute inset-y-0 left-0 rounded-full bg-bink-700",
                style: {
                  width: o
                }
              })
            })
          })]
        }) : null, E("div", {
          className: `absolute inset-0 flex items-center justify-center bg-denim-200 bg-opacity-80 transition-opacity duration-200 ${i?"opacity-100":"pointer-events-none opacity-0"}`,
          children: E(rn, {
            clickable: !0,
            className: "text-2xl text-slate-400",
            onClick: () => i && (a == null ? void 0 : a()),
            icon: ue.X
          })
        })]
      }), E("h1", {
        className: "mb-1 max-h-[4.5rem] text-ellipsis break-words font-bold text-white line-clamp-3",
        children: E("span", {
          children: t.title
        })
      }), E(Qlt, {
        className: "text-xs",
        content: l
      })]
    })
  })
}

function Jlt(t) {
  const e = E(Zlt, {
      ...t
    }),
    r = t.linkable && !t.closable;
  let n = r ? `/media/${encodeURIComponent(LFe(t.media))}` : "#";
  return r && t.series && (n += `/${encodeURIComponent(t.series.seasonId)}/${encodeURIComponent(t.series.episodeId)}`), t.linkable ? E(sg, {
    to: n,
    className: t.closable ? "hover:cursor-default" : "",
    children: e
  }) : E("span", {
    children: e
  })
}

function ect(t) {
  if (t) return {
    season: t.season,
    episode: t.episode,
    episodeId: t.episodeId,
    seasonId: t.seasonId
  }
}

function uL(t) {
  var n;
  const {
    watched: e
  } = rE(), r = A.useMemo(() => e.items.sort((i, a) => a.watchedAt - i.watchedAt).find(i => i.item.meta.id === t.media.id), [e, t.media]);
  return E(Jlt, {
    media: t.media,
    series: ect((n = r == null ? void 0 : r.item) == null ? void 0 : n.series),
    linkable: !0,
    percentage: r == null ? void 0 : r.percentage,
    onClose: t.onClose,
    closable: t.closable
  })
}

function tct() {
  const {
    t
  } = ke(), {
    getFilteredBookmarks: e,
    setItemBookmark: r
  } = Xk(), n = e(), [i, a] = A.useState(!1), [s] = oL(), {
    watched: o
  } = rE(), c = A.useMemo(() => n.map(l => ({
    ...l,
    watched: o.items.sort((u, f) => f.watchedAt - u.watchedAt).find(u => u.item.meta.id === l.id)
  })).sort((l, u) => {
    var f, d;
    return (((f = u.watched) == null ? void 0 : f.watchedAt) || 0) - (((d = l.watched) == null ? void 0 : d.watchedAt) || 0)
  }), [o.items, n]);
  return n.length === 0 ? null : Y("div", {
    children: [E(lL, {
      title: t("search.bookmarks") || "Bookmarks",
      icon: ue.BOOKMARK,
      children: E(wJ, {
        editing: i,
        onEdit: a
      })
    }), E(cL, {
      ref: s,
      children: c.map(l => E(uL, {
        media: l,
        closable: i,
        onClose: () => r(l, !1)
      }, l.id))
    })]
  })
}

function rct() {
  const {
    t
  } = ke(), {
    getFilteredBookmarks: e
  } = Xk(), {
    getFilteredWatched: r,
    removeProgress: n
  } = rE(), [i, a] = A.useState(!1), [s] = oL(), o = e(), c = r().filter(l => !sq(o, l.item.meta));
  return c.length === 0 ? null : Y("div", {
    children: [E(lL, {
      title: t("search.continueWatching") || "Continue Watching",
      icon: ue.CLOCK,
      children: E(wJ, {
        editing: i,
        onEdit: a
      })
    }), E(cL, {
      ref: s,
      children: c.map(l => E(uL, {
        media: l.item.meta,
        closable: i,
        onClose: () => n(l.item.meta.id)
      }, l.item.meta.id))
    })]
  })
}

function nct() {
  const [t, e] = A.useState(new URLSearchParams(window.location.search).get("migrated") === "1" || localStorage.getItem("mw-show-domain-modal") === "true"), [r, n] = A.useState(!1), i = nd(), {
    t: a
  } = ke(), s = A.useCallback(() => {
    localStorage.setItem("mw-show-domain-modal", "false"), e(!1)
  }, []);
  A.useEffect(() => {
    const d = new URLSearchParams(i.location.search);
    d.delete("migrated"), d.get("migrated") === "1" && localStorage.setItem("mw-show-domain-modal", "true"), i.replace({
      search: d.toString()
    })
  }, [i]), A.useEffect(() => {
    setTimeout(() => {
      n(!0)
    }, 500)
  }, []);
  const o = 1e3 * 60 * 60 * 24,
    c = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    l = new Date(localStorage.getItem("firstVisitToSite") || Date.now());
  localStorage.setItem("firstVisitToSite", l.toISOString());
  const u = new Date(l.getTime() + 14 * o),
    f = `${u.getDate()} ${c[u.getMonth()]} ${u.getFullYear()}`;
  return E(tZ, {
    show: t && r,
    children: Y(rZ, {
      children: [Y("div", {
        className: "mb-12",
        children: [E("div", {
          className: "absolute left-0 top-0 h-[300px] w-full -translate-y-1/2 opacity-50",
          style: {
            backgroundImage: "radial-gradient(ellipse 70% 9rem, #7831C1 0%, transparent 100%)"
          }
        }), E("div", {
          className: "relative flex items-center justify-center",
          children: E("div", {
            className: "rounded-full bg-bink-200 px-12 py-4 text-center text-sm font-bold text-white md:text-xl",
            children: a("v3.newDomain")
          })
        })]
      }), Y("div", {
        className: "space-y-6",
        children: [E("h2", {
          className: "text-2xl font-bold text-white",
          children: a("v3.newSiteTitle")
        }), E("p", {
          className: "leading-7",
          children: Y(zk, {
            i18nKey: "v3.newDomainText",
            values: {
              date: f
            },
            children: [E("span", {
              className: "text-slate-300"
            }), E("span", {
              className: "font-bold text-white"
            })]
          })
        }), E("p", {
          children: a("v3.tireless")
        })]
      }), E("div", {
        className: "mb-6 mt-16 flex items-center justify-center",
        children: E(Xlt, {
          icon: ue.PLAY,
          onClick: () => s(),
          children: a("v3.leaveAnnouncement")
        })
      })]
    })
  })
}

function ict() {
  return Y("div", {
    className: "mb-16",
    children: [E(GQe, {}), E(nct, {}), E(tct, {}), E(rct, {})]
  })
}

function RJ() {
  const {
    t
  } = ke(), [e] = xJ();
  return E(lg, {
    className: "mb-24 mt-40 ",
    text: t(`search.loading_${e.type}`) || t("search.loading") || "Fetching your favourite shows..."
  })
}

function x7(t) {
  const {
    t: e
  } = ke(), r = t.failed ? ue.WARNING : ue.EYE_SLASH;
  return Y("div", {
    className: "mb-24 mt-40  flex flex-col items-center justify-center space-y-3 text-center",
    children: [E(rn, {
      icon: r,
      className: `text-xl ${t.failed?"text-red-400":"text-bink-600"}`
    }), t.failed ? null : E("div", {
      children: (t.results ? ? 0) > 0 ? E("p", {
        children: e("search.allResults")
      }) : E("p", {
        children: e("search.noResults")
      })
    }), t.failed ? E("div", {
      children: E("p", {
        children: e("search.allFailed")
      })
    }) : null]
  })
}

function act({
  searchQuery: t
}) {
  const {
    t: e
  } = ke(), [r, n] = A.useState([]), [i, a, s] = ad(o => nq(o));
  return A.useEffect(() => {
    async function o(c) {
      const l = await i(c);
      l && n(l)
    }
    t.searchQuery !== "" && o(t)
  }, [t, i]), a ? E(RJ, {}) : s ? E(x7, {
    failed: !0
  }) : r ? Y("div", {
    children: [r.length > 0 ? Y("div", {
      children: [E(lL, {
        title: e("search.headingTitle") || "Search results",
        icon: ue.SEARCH
      }), E(cL, {
        children: r.map(o => E(uL, {
          media: o
        }, o.id.toString()))
      })]
    }) : null, E(x7, {
      results: r.length
    })]
  }) : null
}

function sct({
  search: t
}) {
  const [e, r] = A.useState(!1), [n, i] = A.useState(!1), a = Dlt(t, 500);
  return A.useEffect(() => {
    r(t.searchQuery !== ""), i(t.searchQuery !== "")
  }, [t]), A.useEffect(() => {
    i(!1)
  }, [a]), A.useMemo(() => n ? E(RJ, {}) : e ? E(act, {
    searchQuery: a
  }) : E(ict, {}), [n, e, a])
}

function oct() {
  const {
    t
  } = ke(), [e, r, n] = xJ(), [i, a] = A.useState(!1), s = Jb(), o = A.useCallback(({
    status: c
  }) => a(c === Mo.STATUS_FIXED), [a]);
  return Y(yr, {
    children: [Y("div", {
      className: "relative z-10 mb-16 sm:mb-24",
      children: [E(va, {
        children: E("title", {
          children: t("global.name")
        })
      }), E(sZ, {
        bg: i
      }), E(wlt, {
        children: Y("div", {
          className: "mt-44 space-y-16 text-center",
          children: [E("div", {
            className: "absolute bottom-0 left-0 right-0 flex h-0 justify-center",
            children: E("div", {
              className: "absolute bottom-4 h-[100vh] w-[3000px] rounded-[100%] bg-denim-300 md:w-[200vw]"
            })
          }), E("div", {
            className: "relative z-10 mb-16",
            children: E(og, {
              className: "mx-auto max-w-xs",
              children: t("search.title")
            })
          }), E("div", {
            className: "relative z-30",
            children: E(Mo, {
              enabled: !0,
              top: 16 + s,
              onStateChange: o,
              children: E(Plt, {
                onChange: r,
                value: e,
                onUnFocus: n,
                placeholder: t("search.placeholder") || "What do you want to watch?"
              })
            })
          })]
        })
      })]
    }), E(Rlt, {
      children: E(sct, {
        search: e
      })
    })]
  })
}

function lct() {
  return E(HFe, {
    children: E(KFe, {
      children: E(UFe, {
        children: E(MMe, {
          children: E(jMe, {
            children: Y(N8e, {
              children: [E(Ns, {
                exact: !0,
                path: "/v2-migration",
                component: VQe
              }), E(Ns, {
                exact: !0,
                path: "/",
                children: E($8e, {
                  to: `/search/${ae.MOVIE}`
                })
              }), E(Ns, {
                exact: !0,
                path: "/media/:media",
                component: GB
              }), E(Ns, {
                exact: !0,
                path: "/media/:media/:season/:episode",
                component: GB
              }), E(Ns, {
                exact: !0,
                path: "/search/:type/:query?",
                component: oct
              }), E(Ns, {
                exact: !0,
                path: "/dev",
                component: A.lazy(() => lA(() => import("./DeveloperView-5f712547.js"), []))
              }), E(Ns, {
                exact: !0,
                path: "/dev/video",
                component: A.lazy(() => lA(() => import("./VideoTesterView-48ed89a7.js"), []))
              }), null, E(Ns, {
                path: "*",
                component: jYe
              })]
            })
          })
        })
      })
    })
  })
}
var AJ = {},
  IJ = {},
  $J = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = void 0;
  var e = function () {
      for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++) a[s] = arguments[s];
      if (typeof window < "u") {
        var o;
        typeof window.gtag > "u" && (window.dataLayer = window.dataLayer || [], window.gtag = function () {
          window.dataLayer.push(arguments)
        }), (o = window).gtag.apply(o, a)
      }
    },
    r = e;
  t.default = r
})($J);
var CJ = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = s;
  var e = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;

  function r(o) {
    return o.toString().trim().replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function (c, l, u) {
      return l > 0 && l + c.length !== u.length && c.search(e) > -1 && u.charAt(l - 2) !== ":" && (u.charAt(l + c.length) !== "-" || u.charAt(l - 1) === "-") && u.charAt(l - 1).search(/[^\s-]/) < 0 ? c.toLowerCase() : c.substr(1).search(/[A-Z]|\../) > -1 ? c : c.charAt(0).toUpperCase() + c.substr(1)
    })
  }

  function n(o) {
    return typeof o == "string" && o.indexOf("@") !== -1
  }
  var i = "REDACTED (Potential Email Address)";

  function a(o) {
    return n(o) ? (console.warn("This arg looks like an email address, redacting."), i) : o
  }

  function s() {
    var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
      c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
      l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
      u = o || "";
    return c && (u = r(o)), l && (u = a(u)), u
  }
})(CJ);
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = t.GA4 = void 0;
  var e = s($J),
    r = s(CJ),
    n = ["eventCategory", "eventAction", "eventLabel", "eventValue", "hitType"],
    i = ["title", "location"],
    a = ["page", "hitType"];

  function s(N) {
    return N && N.__esModule ? N : {
      default: N
    }
  }

  function o(N, P) {
    if (N == null) return {};
    var B = c(N, P),
      V, M;
    if (Object.getOwnPropertySymbols) {
      var U = Object.getOwnPropertySymbols(N);
      for (M = 0; M < U.length; M++) V = U[M], !(P.indexOf(V) >= 0) && Object.prototype.propertyIsEnumerable.call(N, V) && (B[V] = N[V])
    }
    return B
  }

  function c(N, P) {
    if (N == null) return {};
    var B = {},
      V = Object.keys(N),
      M, U;
    for (U = 0; U < V.length; U++) M = V[U], !(P.indexOf(M) >= 0) && (B[M] = N[M]);
    return B
  }

  function l(N) {
    return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (P) {
      return typeof P
    } : function (P) {
      return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P
    }, l(N)
  }

  function u(N) {
    return h(N) || d(N) || y(N) || f()
  }

  function f() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  }

  function d(N) {
    if (typeof Symbol < "u" && N[Symbol.iterator] != null || N["@@iterator"] != null) return Array.from(N)
  }

  function h(N) {
    if (Array.isArray(N)) return x(N)
  }

  function p(N, P) {
    var B = Object.keys(N);
    if (Object.getOwnPropertySymbols) {
      var V = Object.getOwnPropertySymbols(N);
      P && (V = V.filter(function (M) {
        return Object.getOwnPropertyDescriptor(N, M).enumerable
      })), B.push.apply(B, V)
    }
    return B
  }

  function v(N) {
    for (var P = 1; P < arguments.length; P++) {
      var B = arguments[P] != null ? arguments[P] : {};
      P % 2 ? p(Object(B), !0).forEach(function (V) {
        I(N, V, B[V])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(N, Object.getOwnPropertyDescriptors(B)) : p(Object(B)).forEach(function (V) {
        Object.defineProperty(N, V, Object.getOwnPropertyDescriptor(B, V))
      })
    }
    return N
  }

  function g(N, P) {
    return _(N) || b(N, P) || y(N, P) || m()
  }

  function m() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  }

  function y(N, P) {
    if (N) {
      if (typeof N == "string") return x(N, P);
      var B = Object.prototype.toString.call(N).slice(8, -1);
      if (B === "Object" && N.constructor && (B = N.constructor.name), B === "Map" || B === "Set") return Array.from(N);
      if (B === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B)) return x(N, P)
    }
  }

  function x(N, P) {
    (P == null || P > N.length) && (P = N.length);
    for (var B = 0, V = new Array(P); B < P; B++) V[B] = N[B];
    return V
  }

  function b(N, P) {
    var B = N == null ? null : typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
    if (B != null) {
      var V, M, U, W, k = [],
        O = !0,
        F = !1;
      try {
        if (U = (B = B.call(N)).next, P === 0) {
          if (Object(B) !== B) return;
          O = !1
        } else
          for (; !(O = (V = U.call(B)).done) && (k.push(V.value), k.length !== P); O = !0);
      } catch (D) {
        F = !0, M = D
      } finally {
        try {
          if (!O && B.return != null && (W = B.return(), Object(W) !== W)) return
        } finally {
          if (F) throw M
        }
      }
      return k
    }
  }

  function _(N) {
    if (Array.isArray(N)) return N
  }

  function S(N, P) {
    if (!(N instanceof P)) throw new TypeError("Cannot call a class as a function")
  }

  function T(N, P) {
    for (var B = 0; B < P.length; B++) {
      var V = P[B];
      V.enumerable = V.enumerable || !1, V.configurable = !0, "value" in V && (V.writable = !0), Object.defineProperty(N, w(V.key), V)
    }
  }

  function R(N, P, B) {
    return P && T(N.prototype, P), B && T(N, B), Object.defineProperty(N, "prototype", {
      writable: !1
    }), N
  }

  function I(N, P, B) {
    return P = w(P), P in N ? Object.defineProperty(N, P, {
      value: B,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : N[P] = B, N
  }

  function w(N) {
    var P = C(N, "string");
    return l(P) === "symbol" ? P : String(P)
  }

  function C(N, P) {
    if (l(N) !== "object" || N === null) return N;
    var B = N[Symbol.toPrimitive];
    if (B !== void 0) {
      var V = B.call(N, P || "default");
      if (l(V) !== "object") return V;
      throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (P === "string" ? String : Number)(N)
  }
  var L = function () {
    function N() {
      var P = this;
      S(this, N), I(this, "reset", function () {
        P.isInitialized = !1, P._testMode = !1, P._currentMeasurementId, P._hasLoadedGA = !1, P._isQueuing = !1, P._queueGtag = []
      }), I(this, "_gtag", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        P._testMode || P._isQueuing ? P._queueGtag.push(V) : e.default.apply(void 0, V)
      }), I(this, "_loadGA", function (B, V) {
        var M = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "https://www.googletagmanager.com/gtag/js";
        if (!(typeof window > "u" || typeof document > "u") && !P._hasLoadedGA) {
          var U = document.createElement("script");
          U.async = !0, U.src = "".concat(M, "?id=").concat(B), V && U.setAttribute("nonce", V), document.body.appendChild(U), window.dataLayer = window.dataLayer || [], window.gtag = function () {
            window.dataLayer.push(arguments)
          }, P._hasLoadedGA = !0
        }
      }), I(this, "_toGtagOptions", function (B) {
        if (B) {
          var V = {
              cookieUpdate: "cookie_update",
              cookieExpires: "cookie_expires",
              cookieDomain: "cookie_domain",
              cookieFlags: "cookie_flags",
              userId: "user_id",
              clientId: "client_id",
              anonymizeIp: "anonymize_ip",
              contentGroup1: "content_group1",
              contentGroup2: "content_group2",
              contentGroup3: "content_group3",
              contentGroup4: "content_group4",
              contentGroup5: "content_group5",
              allowAdFeatures: "allow_google_signals",
              allowAdPersonalizationSignals: "allow_ad_personalization_signals",
              nonInteraction: "non_interaction",
              page: "page_path",
              hitCallback: "event_callback"
            },
            M = Object.entries(B).reduce(function (U, W) {
              var k = g(W, 2),
                O = k[0],
                F = k[1];
              return V[O] ? U[V[O]] = F : U[O] = F, U
            }, {});
          return M
        }
      }), I(this, "initialize", function (B) {
        var V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!B) throw new Error("Require GA_MEASUREMENT_ID");
        var M = typeof B == "string" ? [{
          trackingId: B
        }] : B;
        P._currentMeasurementId = M[0].trackingId;
        var U = V.gaOptions,
          W = V.gtagOptions,
          k = V.nonce,
          O = V.testMode,
          F = O === void 0 ? !1 : O,
          D = V.gtagUrl;
        if (P._testMode = F, F || P._loadGA(P._currentMeasurementId, k, D), P.isInitialized || (P._gtag("js", new Date), M.forEach(function (de) {
            var oe = v(v(v({}, P._toGtagOptions(v(v({}, U), de.gaOptions))), W), de.gtagOptions);
            Object.keys(oe).length ? P._gtag("config", de.trackingId, oe) : P._gtag("config", de.trackingId)
          })), P.isInitialized = !0, !F) {
          var Q = u(P._queueGtag);
          for (P._queueGtag = [], P._isQueuing = !1; Q.length;) {
            var ee = Q.shift();
            P._gtag.apply(P, u(ee)), ee[0] === "get" && (P._isQueuing = !0)
          }
        }
      }), I(this, "set", function (B) {
        if (!B) {
          console.warn("`fieldsObject` is required in .set()");
          return
        }
        if (l(B) !== "object") {
          console.warn("Expected `fieldsObject` arg to be an Object");
          return
        }
        Object.keys(B).length === 0 && console.warn("empty `fieldsObject` given to .set()"), P._gaCommand("set", B)
      }), I(this, "_gaCommandSendEvent", function (B, V, M, U, W) {
        P._gtag("event", V, v(v({
          event_category: B,
          event_label: M,
          value: U
        }, W && {
          non_interaction: W.nonInteraction
        }), P._toGtagOptions(W)))
      }), I(this, "_gaCommandSendEventParameters", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        if (typeof V[0] == "string") P._gaCommandSendEvent.apply(P, u(V.slice(1)));
        else {
          var U = V[0],
            W = U.eventCategory,
            k = U.eventAction,
            O = U.eventLabel,
            F = U.eventValue;
          U.hitType;
          var D = o(U, n);
          P._gaCommandSendEvent(W, k, O, F, D)
        }
      }), I(this, "_gaCommandSendTiming", function (B, V, M, U) {
        P._gtag("event", "timing_complete", {
          name: V,
          value: M,
          event_category: B,
          event_label: U
        })
      }), I(this, "_gaCommandSendPageview", function (B, V) {
        if (V && Object.keys(V).length) {
          var M = P._toGtagOptions(V),
            U = M.title,
            W = M.location,
            k = o(M, i);
          P._gtag("event", "page_view", v(v(v(v({}, B && {
            page_path: B
          }), U && {
            page_title: U
          }), W && {
            page_location: W
          }), k))
        } else B ? P._gtag("event", "page_view", {
          page_path: B
        }) : P._gtag("event", "page_view")
      }), I(this, "_gaCommandSendPageviewParameters", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        if (typeof V[0] == "string") P._gaCommandSendPageview.apply(P, u(V.slice(1)));
        else {
          var U = V[0],
            W = U.page;
          U.hitType;
          var k = o(U, a);
          P._gaCommandSendPageview(W, k)
        }
      }), I(this, "_gaCommandSend", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        var U = typeof V[0] == "string" ? V[0] : V[0].hitType;
        switch (U) {
          case "event":
            P._gaCommandSendEventParameters.apply(P, V);
            break;
          case "pageview":
            P._gaCommandSendPageviewParameters.apply(P, V);
            break;
          case "timing":
            P._gaCommandSendTiming.apply(P, u(V.slice(1)));
            break;
          case "screenview":
          case "transaction":
          case "item":
          case "social":
          case "exception":
            console.warn("Unsupported send command: ".concat(U));
            break;
          default:
            console.warn("Send command doesn't exist: ".concat(U))
        }
      }), I(this, "_gaCommandSet", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        typeof V[0] == "string" && (V[0] = I({}, V[0], V[1])), P._gtag("set", P._toGtagOptions(V[0]))
      }), I(this, "_gaCommand", function (B) {
        for (var V = arguments.length, M = new Array(V > 1 ? V - 1 : 0), U = 1; U < V; U++) M[U - 1] = arguments[U];
        switch (B) {
          case "send":
            P._gaCommandSend.apply(P, M);
            break;
          case "set":
            P._gaCommandSet.apply(P, M);
            break;
          default:
            console.warn("Command doesn't exist: ".concat(B))
        }
      }), I(this, "ga", function () {
        for (var B = arguments.length, V = new Array(B), M = 0; M < B; M++) V[M] = arguments[M];
        if (typeof V[0] == "string") P._gaCommand.apply(P, V);
        else {
          var U = V[0];
          P._gtag("get", P._currentMeasurementId, "client_id", function (W) {
            P._isQueuing = !1;
            var k = P._queueGtag;
            for (U({
                get: function (D) {
                  return D === "clientId" ? W : D === "trackingId" ? P._currentMeasurementId : D === "apiVersion" ? "1" : void 0
                }
              }); k.length;) {
              var O = k.shift();
              P._gtag.apply(P, u(O))
            }
          }), P._isQueuing = !0
        }
        return P.ga
      }), I(this, "event", function (B, V) {
        if (typeof B == "string") P._gtag("event", B, P._toGtagOptions(V));
        else {
          var M = B.action,
            U = B.category,
            W = B.label,
            k = B.value,
            O = B.nonInteraction,
            F = B.transport;
          if (!U || !M) {
            console.warn("args.category AND args.action are required in event()");
            return
          }
          var D = {
            hitType: "event",
            eventCategory: (0, r.default)(U),
            eventAction: (0, r.default)(M)
          };
          W && (D.eventLabel = (0, r.default)(W)), typeof k < "u" && (typeof k != "number" ? console.warn("Expected `args.value` arg to be a Number.") : D.eventValue = k), typeof O < "u" && (typeof O != "boolean" ? console.warn("`args.nonInteraction` must be a boolean.") : D.nonInteraction = O), typeof F < "u" && (typeof F != "string" ? console.warn("`args.transport` must be a string.") : (["beacon", "xhr", "image"].indexOf(F) === -1 && console.warn("`args.transport` must be either one of these values: `beacon`, `xhr` or `image`"), D.transport = F)), P._gaCommand("send", D)
        }
      }), I(this, "send", function (B) {
        P._gaCommand("send", B)
      }), this.reset()
    }
    return R(N, [{
      key: "gtag",
      value: function () {
        this._gtag.apply(this, arguments)
      }
    }]), N
  }();
  t.GA4 = L;
  var H = new L;
  t.default = H
})(IJ);
(function (t) {
  function e(o) {
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (c) {
      return typeof c
    } : function (c) {
      return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
    }, e(o)
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = t.ReactGAImplementation = void 0;
  var r = i(IJ);

  function n(o) {
    if (typeof WeakMap != "function") return null;
    var c = new WeakMap,
      l = new WeakMap;
    return (n = function (f) {
      return f ? l : c
    })(o)
  }

  function i(o, c) {
    if (!c && o && o.__esModule) return o;
    if (o === null || e(o) !== "object" && typeof o != "function") return {
      default: o
    };
    var l = n(c);
    if (l && l.has(o)) return l.get(o);
    var u = {},
      f = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var d in o)
      if (d !== "default" && Object.prototype.hasOwnProperty.call(o, d)) {
        var h = f ? Object.getOwnPropertyDescriptor(o, d) : null;
        h && (h.get || h.set) ? Object.defineProperty(u, d, h) : u[d] = o[d]
      } return u.default = o, l && l.set(o, u), u
  }
  var a = r.GA4;
  t.ReactGAImplementation = a;
  var s = r.default;
  t.default = s
})(AJ);
const cct = PI(AJ);
cct.initialize([{
  trackingId: TMe
}]);
const kJ = Object.prototype.toString;

function OJ(t) {
  switch (kJ.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Bo(t, Error)
  }
}

function vd(t, e) {
  return kJ.call(t) === `[object ${e}]`
}

function LJ(t) {
  return vd(t, "ErrorEvent")
}

function b7(t) {
  return vd(t, "DOMError")
}

function uct(t) {
  return vd(t, "DOMException")
}

function Fo(t) {
  return vd(t, "String")
}

function PJ(t) {
  return t === null || typeof t != "object" && typeof t != "function"
}

function kf(t) {
  return vd(t, "Object")
}

function fL(t) {
  return typeof Event < "u" && Bo(t, Event)
}

function fct(t) {
  return typeof Element < "u" && Bo(t, Element)
}

function dct(t) {
  return vd(t, "RegExp")
}

function dL(t) {
  return !!(t && t.then && typeof t.then == "function")
}

function hct(t) {
  return kf(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}

function NJ(t) {
  return typeof t == "number" && t !== t
}

function Bo(t, e) {
  try {
    return t instanceof e
  } catch {
    return !1
  }
}

function uv(t) {
  return t && t.Math == Math ? t : void 0
}
const Wt = typeof globalThis == "object" && uv(globalThis) || typeof window == "object" && uv(window) || typeof self == "object" && uv(self) || typeof global == "object" && uv(global) || function () {
  return this
}() || {};

function wg() {
  return Wt
}

function hL(t, e, r) {
  const n = r || Wt,
    i = n.__SENTRY__ = n.__SENTRY__ || {};
  return i[t] || (i[t] = e())
}
const ly = wg(),
  pct = 80;

function Of(t, e = {}) {
  try {
    let r = t;
    const n = 5,
      i = [];
    let a = 0,
      s = 0;
    const o = " > ",
      c = o.length;
    let l;
    const u = Array.isArray(e) ? e : e.keyAttrs,
      f = !Array.isArray(e) && e.maxStringLength || pct;
    for (; r && a++ < n && (l = gct(r, u), !(l === "html" || a > 1 && s + i.length * c + l.length >= f));) i.push(l), s += l.length, r = r.parentNode;
    return i.reverse().join(o)
  } catch {
    return "<unknown>"
  }
}

function gct(t, e) {
  const r = t,
    n = [];
  let i, a, s, o, c;
  if (!r || !r.tagName) return "";
  n.push(r.tagName.toLowerCase());
  const l = e && e.length ? e.filter(f => r.getAttribute(f)).map(f => [f, r.getAttribute(f)]) : null;
  if (l && l.length) l.forEach(f => {
    n.push(`[${f[0]}="${f[1]}"]`)
  });
  else if (r.id && n.push(`#${r.id}`), i = r.className, i && Fo(i))
    for (a = i.split(/\s+/), c = 0; c < a.length; c++) n.push(`.${a[c]}`);
  const u = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < u.length; c++) s = u[c], o = r.getAttribute(s), o && n.push(`[${s}="${o}"]`);
  return n.join("")
}

function mct() {
  try {
    return ly.document.location.href
  } catch {
    return ""
  }
}

function vct(t) {
  return ly.document && ly.document.querySelector ? ly.document.querySelector(t) : null
}
class pr extends Error {
  constructor(e, r = "warn") {
    super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = r
  }
}
const yct = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function xct(t) {
  return t === "http" || t === "https"
}

function NE(t, e = !1) {
  const {
    host: r,
    path: n,
    pass: i,
    port: a,
    projectId: s,
    protocol: o,
    publicKey: c
  } = t;
  return `${o}://${c}${e&&i?`:${i}`:""}@${r}${a?`:${a}`:""}/${n&&`${n}/`}${s}`
}

function bct(t) {
  const e = yct.exec(t);
  if (!e) throw new pr(`Invalid Sentry Dsn: ${t}`);
  const [r, n, i = "", a, s = "", o] = e.slice(1);
  let c = "",
    l = o;
  const u = l.split("/");
  if (u.length > 1 && (c = u.slice(0, -1).join("/"), l = u.pop()), l) {
    const f = l.match(/^\d+/);
    f && (l = f[0])
  }
  return DJ({
    host: a,
    pass: i,
    path: c,
    projectId: l,
    port: s,
    protocol: r,
    publicKey: n
  })
}

function DJ(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId
  }
}

function Ect(t) {
  if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
  const {
    port: e,
    projectId: r,
    protocol: n
  } = t;
  if (["protocol", "publicKey", "host", "projectId"].forEach(a => {
      if (!t[a]) throw new pr(`Invalid Sentry Dsn: ${a} missing`)
    }), !r.match(/^\d+$/)) throw new pr(`Invalid Sentry Dsn: Invalid projectId ${r}`);
  if (!xct(n)) throw new pr(`Invalid Sentry Dsn: Invalid protocol ${n}`);
  if (e && isNaN(parseInt(e, 10))) throw new pr(`Invalid Sentry Dsn: Invalid port ${e}`);
  return !0
}

function Sct(t) {
  const e = typeof t == "string" ? bct(t) : DJ(t);
  return Ect(e), e
}
const _ct = "Sentry Logger ",
  hp = ["debug", "info", "warn", "error", "log", "assert", "trace"];

function MJ(t) {
  if (!("console" in Wt)) return t();
  const e = Wt.console,
    r = {};
  hp.forEach(n => {
    const i = e[n] && e[n].__sentry_original__;
    n in e && i && (r[n] = e[n], e[n] = i)
  });
  try {
    return t()
  } finally {
    Object.keys(r).forEach(n => {
      e[n] = r[n]
    })
  }
}

function E7() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0
    },
    disable: () => {
      t = !1
    }
  };
  return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? hp.forEach(r => {
    e[r] = (...n) => {
      t && MJ(() => {
        Wt.console[r](`${_ct}[${r}]:`, ...n)
      })
    }
  }) : hp.forEach(r => {
    e[r] = () => {}
  }), e
}
let J;
typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? J = hL("logger", E7) : J = E7();

function f0(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
}

function K1(t, e) {
  if (!Array.isArray(t)) return "";
  const r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    try {
      r.push(String(i))
    } catch {
      r.push("[value cannot be serialized]")
    }
  }
  return r.join(e)
}

function Tct(t, e, r = !1) {
  return Fo(t) ? dct(e) ? e.test(t) : Fo(e) ? r ? t === e : t.includes(e) : !1 : !1
}

function Rg(t, e = [], r = !1) {
  return e.some(n => Tct(t, n, r))
}

function Kt(t, e, r) {
  if (!(e in t)) return;
  const n = t[e],
    i = r(n);
  if (typeof i == "function") try {
    FJ(i, n)
  } catch {}
  t[e] = i
}

function pL(t, e, r) {
  Object.defineProperty(t, e, {
    value: r,
    writable: !0,
    configurable: !0
  })
}

function FJ(t, e) {
  const r = e.prototype || {};
  t.prototype = e.prototype = r, pL(t, "__sentry_original__", e)
}

function gL(t) {
  return t.__sentry_original__
}

function wct(t) {
  return Object.keys(t).map(e => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&")
}

function BJ(t) {
  if (OJ(t)) return {
    message: t.message,
    name: t.name,
    stack: t.stack,
    ..._7(t)
  };
  if (fL(t)) {
    const e = {
      type: t.type,
      target: S7(t.target),
      currentTarget: S7(t.currentTarget),
      ..._7(t)
    };
    return typeof CustomEvent < "u" && Bo(t, CustomEvent) && (e.detail = t.detail), e
  } else return t
}

function S7(t) {
  try {
    return fct(t) ? Of(t) : Object.prototype.toString.call(t)
  } catch {
    return "<unknown>"
  }
}

function _7(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    return e
  } else return {}
}

function Rct(t, e = 40) {
  const r = Object.keys(BJ(t));
  if (r.sort(), !r.length) return "[object has no keys]";
  if (r[0].length >= e) return f0(r[0], e);
  for (let n = r.length; n > 0; n--) {
    const i = r.slice(0, n).join(", ");
    if (!(i.length > e)) return n === r.length ? i : f0(i, e)
  }
  return ""
}

function So(t) {
  return yI(t, new Map)
}

function yI(t, e) {
  if (kf(t)) {
    const r = e.get(t);
    if (r !== void 0) return r;
    const n = {};
    e.set(t, n);
    for (const i of Object.keys(t)) typeof t[i] < "u" && (n[i] = yI(t[i], e));
    return n
  }
  if (Array.isArray(t)) {
    const r = e.get(t);
    if (r !== void 0) return r;
    const n = [];
    return e.set(t, n), t.forEach(i => {
      n.push(yI(i, e))
    }), n
  }
  return t
}
const UJ = 50,
  T7 = /\(error: (.*)\)/;

function jJ(...t) {
  const e = t.sort((r, n) => r[0] - n[0]).map(r => r[1]);
  return (r, n = 0) => {
    const i = [],
      a = r.split(`
`);
    for (let s = n; s < a.length; s++) {
      const o = a[s];
      if (o.length > 1024) continue;
      const c = T7.test(o) ? o.replace(T7, "$1") : o;
      if (!c.match(/\S*Error: /)) {
        for (const l of e) {
          const u = l(c);
          if (u) {
            i.push(u);
            break
          }
        }
        if (i.length >= UJ) break
      }
    }
    return Ict(i)
  }
}

function Act(t) {
  return Array.isArray(t) ? jJ(...t) : t
}

function Ict(t) {
  if (!t.length) return [];
  const e = t.slice(0, UJ),
    r = e[e.length - 1].function;
  r && /sentryWrapped/.test(r) && e.pop(), e.reverse();
  const n = e[e.length - 1].function;
  return n && /captureMessage|captureException/.test(n) && e.pop(), e.map(i => ({
    ...i,
    filename: i.filename || e[e.length - 1].filename,
    function: i.function || "?"
  }))
}
const Kw = "<anonymous>";

function Uo(t) {
  try {
    return !t || typeof t != "function" ? Kw : t.name || Kw
  } catch {
    return Kw
  }
}
const xI = wg();

function HJ() {
  if (!("fetch" in xI)) return !1;
  try {
    return new Headers, new Request("http://www.example.com"), new Response, !0
  } catch {
    return !1
  }
}

function bI(t) {
  return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function zJ() {
  if (!HJ()) return !1;
  if (bI(xI.fetch)) return !0;
  let t = !1;
  const e = xI.document;
  if (e && typeof e.createElement == "function") try {
    const r = e.createElement("iframe");
    r.hidden = !0, e.head.appendChild(r), r.contentWindow && r.contentWindow.fetch && (t = bI(r.contentWindow.fetch)), e.head.removeChild(r)
  } catch (r) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r)
  }
  return t
}
const fv = wg();

function $ct() {
  const t = fv.chrome,
    e = t && t.app && t.app.runtime,
    r = "history" in fv && !!fv.history.pushState && !!fv.history.replaceState;
  return !e && r
}
const ut = wg(),
  Nl = "__sentry_xhr_v2__",
  d0 = {},
  w7 = {};

function Cct(t) {
  if (!w7[t]) switch (w7[t] = !0, t) {
    case "console":
      kct();
      break;
    case "dom":
      Bct();
      break;
    case "xhr":
      Pct();
      break;
    case "fetch":
      Oct();
      break;
    case "history":
      Nct();
      break;
    case "error":
      Uct();
      break;
    case "unhandledrejection":
      jct();
      break;
    default:
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("unknown instrumentation type:", t);
      return
  }
}

function wr(t, e) {
  d0[t] = d0[t] || [], d0[t].push(e), Cct(t)
}

function Ci(t, e) {
  if (!(!t || !d0[t]))
    for (const r of d0[t] || []) try {
      r(e)
    } catch (n) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${Uo(r)}
Error:`, n)
    }
}

function kct() {
  "console" in ut && hp.forEach(function (t) {
    t in ut.console && Kt(ut.console, t, function (e) {
      return function (...r) {
        Ci("console", {
          args: r,
          level: t
        }), e && e.apply(ut.console, r)
      }
    })
  })
}

function Oct() {
  zJ() && Kt(ut, "fetch", function (t) {
    return function (...e) {
      const {
        method: r,
        url: n
      } = Lct(e), i = {
        args: e,
        fetchData: {
          method: r,
          url: n
        },
        startTimestamp: Date.now()
      };
      return Ci("fetch", {
        ...i
      }), t.apply(ut, e).then(a => (Ci("fetch", {
        ...i,
        endTimestamp: Date.now(),
        response: a
      }), a), a => {
        throw Ci("fetch", {
          ...i,
          endTimestamp: Date.now(),
          error: a
        }), a
      })
    }
  })
}

function EI(t, e) {
  return !!t && typeof t == "object" && !!t[e]
}

function R7(t) {
  return typeof t == "string" ? t : t ? EI(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}

function Lct(t) {
  if (t.length === 0) return {
    method: "GET",
    url: ""
  };
  if (t.length === 2) {
    const [r, n] = t;
    return {
      url: R7(r),
      method: EI(n, "method") ? String(n.method).toUpperCase() : "GET"
    }
  }
  const e = t[0];
  return {
    url: R7(e),
    method: EI(e, "method") ? String(e.method).toUpperCase() : "GET"
  }
}

function Pct() {
  if (!("XMLHttpRequest" in ut)) return;
  const t = XMLHttpRequest.prototype;
  Kt(t, "open", function (e) {
    return function (...r) {
      const n = r[1],
        i = this[Nl] = {
          method: Fo(r[0]) ? r[0].toUpperCase() : r[0],
          url: r[1],
          request_headers: {}
        };
      Fo(n) && i.method === "POST" && n.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const a = () => {
        const s = this[Nl];
        if (s && this.readyState === 4) {
          try {
            s.status_code = this.status
          } catch {}
          Ci("xhr", {
            args: r,
            endTimestamp: Date.now(),
            startTimestamp: Date.now(),
            xhr: this
          })
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Kt(this, "onreadystatechange", function (s) {
        return function (...o) {
          return a(), s.apply(this, o)
        }
      }) : this.addEventListener("readystatechange", a), Kt(this, "setRequestHeader", function (s) {
        return function (...o) {
          const [c, l] = o, u = this[Nl];
          return u && (u.request_headers[c.toLowerCase()] = l), s.apply(this, o)
        }
      }), e.apply(this, r)
    }
  }), Kt(t, "send", function (e) {
    return function (...r) {
      const n = this[Nl];
      return n && r[0] !== void 0 && (n.body = r[0]), Ci("xhr", {
        args: r,
        startTimestamp: Date.now(),
        xhr: this
      }), e.apply(this, r)
    }
  })
}
let dv;

function Nct() {
  if (!$ct()) return;
  const t = ut.onpopstate;
  ut.onpopstate = function (...r) {
    const n = ut.location.href,
      i = dv;
    if (dv = n, Ci("history", {
        from: i,
        to: n
      }), t) try {
      return t.apply(this, r)
    } catch {}
  };

  function e(r) {
    return function (...n) {
      const i = n.length > 2 ? n[2] : void 0;
      if (i) {
        const a = dv,
          s = String(i);
        dv = s, Ci("history", {
          from: a,
          to: s
        })
      }
      return r.apply(this, n)
    }
  }
  Kt(ut.history, "pushState", e), Kt(ut.history, "replaceState", e)
}
const Dct = 1e3;
let hv, pv;

function Mct(t, e) {
  if (!t || t.type !== e.type) return !0;
  try {
    if (t.target !== e.target) return !0
  } catch {}
  return !1
}

function Fct(t) {
  if (t.type !== "keypress") return !1;
  try {
    const e = t.target;
    if (!e || !e.tagName) return !0;
    if (e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) return !1
  } catch {}
  return !0
}

function A7(t, e = !1) {
  return r => {
    if (!r || pv === r || Fct(r)) return;
    const n = r.type === "keypress" ? "input" : r.type;
    hv === void 0 ? (t({
      event: r,
      name: n,
      global: e
    }), pv = r) : Mct(pv, r) && (t({
      event: r,
      name: n,
      global: e
    }), pv = r), clearTimeout(hv), hv = ut.setTimeout(() => {
      hv = void 0
    }, Dct)
  }
}

function Bct() {
  if (!("document" in ut)) return;
  const t = Ci.bind(null, "dom"),
    e = A7(t, !0);
  ut.document.addEventListener("click", e, !1), ut.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(r => {
    const n = ut[r] && ut[r].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Kt(n, "addEventListener", function (i) {
      return function (a, s, o) {
        if (a === "click" || a == "keypress") try {
          const c = this,
            l = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {},
            u = l[a] = l[a] || {
              refCount: 0
            };
          if (!u.handler) {
            const f = A7(t);
            u.handler = f, i.call(this, a, f, o)
          }
          u.refCount++
        } catch {}
        return i.call(this, a, s, o)
      }
    }), Kt(n, "removeEventListener", function (i) {
      return function (a, s, o) {
        if (a === "click" || a == "keypress") try {
          const c = this,
            l = c.__sentry_instrumentation_handlers__ || {},
            u = l[a];
          u && (u.refCount--, u.refCount <= 0 && (i.call(this, a, u.handler, o), u.handler = void 0, delete l[a]), Object.keys(l).length === 0 && delete c.__sentry_instrumentation_handlers__)
        } catch {}
        return i.call(this, a, s, o)
      }
    }))
  })
}
let gv = null;

function Uct() {
  gv = ut.onerror, ut.onerror = function (t, e, r, n, i) {
    return Ci("error", {
      column: n,
      error: i,
      line: r,
      msg: t,
      url: e
    }), gv && !gv.__SENTRY_LOADER__ ? gv.apply(this, arguments) : !1
  }, ut.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let mv = null;

function jct() {
  mv = ut.onunhandledrejection, ut.onunhandledrejection = function (t) {
    return Ci("unhandledrejection", t), mv && !mv.__SENTRY_LOADER__ ? mv.apply(this, arguments) : !0
  }, ut.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}

function Hct() {
  const t = typeof WeakSet == "function",
    e = t ? new WeakSet : [];

  function r(i) {
    if (t) return e.has(i) ? !0 : (e.add(i), !1);
    for (let a = 0; a < e.length; a++)
      if (e[a] === i) return !0;
    return e.push(i), !1
  }

  function n(i) {
    if (t) e.delete(i);
    else
      for (let a = 0; a < e.length; a++)
        if (e[a] === i) {
          e.splice(a, 1);
          break
        }
  }
  return [r, n]
}

function _o() {
  const t = Wt,
    e = t.crypto || t.msCrypto;
  if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
  const r = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, n => (n ^ (r() & 15) >> n / 4).toString(16))
}

function GJ(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0
}

function qs(t) {
  const {
    message: e,
    event_id: r
  } = t;
  if (e) return e;
  const n = GJ(t);
  return n ? n.type && n.value ? `${n.type}: ${n.value}` : n.type || n.value || r || "<unknown>" : r || "<unknown>"
}

function SI(t, e, r) {
  const n = t.exception = t.exception || {},
    i = n.values = n.values || [],
    a = i[0] = i[0] || {};
  a.value || (a.value = e || ""), a.type || (a.type = r || "Error")
}

function Lf(t, e) {
  const r = GJ(t);
  if (!r) return;
  const n = {
      type: "generic",
      handled: !0
    },
    i = r.mechanism;
  if (r.mechanism = {
      ...n,
      ...i,
      ...e
    }, e && "data" in e) {
    const a = {
      ...i && i.data,
      ...e.data
    };
    r.mechanism.data = a
  }
}

function I7(t) {
  if (t && t.__sentry_captured__) return !0;
  try {
    pL(t, "__sentry_captured__", !0)
  } catch {}
  return !1
}

function VJ(t) {
  return Array.isArray(t) ? t : [t]
}

function zct() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function Gct() {
  return "npm"
}

function Vct() {
  return !zct() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}

function Wct(t, e) {
  return t.require(e)
}

function Vs(t, e = 1 / 0, r = 1 / 0) {
  try {
    return _I("", t, e, r)
  } catch (n) {
    return {
      ERROR: `**non-serializable** (${n})`
    }
  }
}

function WJ(t, e = 3, r = 100 * 1024) {
  const n = Vs(t, e);
  return Xct(n) > r ? WJ(t, e - 1, r) : n
}

function _I(t, e, r = 1 / 0, n = 1 / 0, i = Hct()) {
  const [a, s] = i;
  if (e === null || ["number", "boolean", "string"].includes(typeof e) && !NJ(e)) return e;
  const o = Kct(t, e);
  if (!o.startsWith("[object ")) return o;
  if (e.__sentry_skip_normalization__) return e;
  let c = r;
  if (typeof e.__sentry_override_normalization_depth__ == "number" && (c = e.__sentry_override_normalization_depth__), c === 0) return o.replace("object ", "");
  if (a(e)) return "[Circular ~]";
  const l = e;
  if (l && typeof l.toJSON == "function") try {
    const h = l.toJSON();
    return _I("", h, c - 1, n, i)
  } catch {}
  const u = Array.isArray(e) ? [] : {};
  let f = 0;
  const d = BJ(e);
  for (const h in d) {
    if (!Object.prototype.hasOwnProperty.call(d, h)) continue;
    if (f >= n) {
      u[h] = "[MaxProperties ~]";
      break
    }
    const p = d[h];
    u[h] = _I(h, p, c - 1, n, i), f++
  }
  return s(e), u
}

function Kct(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events) return "[Domain]";
    if (t === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && e === global) return "[Global]";
    if (typeof window < "u" && e === window) return "[Window]";
    if (typeof document < "u" && e === document) return "[Document]";
    if (hct(e)) return "[SyntheticEvent]";
    if (typeof e == "number" && e !== e) return "[NaN]";
    if (e === void 0) return "[undefined]";
    if (typeof e == "function") return `[Function: ${Uo(e)}]`;
    if (typeof e == "symbol") return `[${String(e)}]`;
    if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
    const r = Yct(e);
    return /^HTML(\w*)Element$/.test(r) ? `[HTMLElement: ${r}]` : `[object ${r}]`
  } catch (r) {
    return `**non-serializable** (${r})`
  }
}

function Yct(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype"
}

function qct(t) {
  return ~-encodeURI(t).split(/%..|./).length
}

function Xct(t) {
  return qct(JSON.stringify(t))
}
var Ha;
(function (t) {
  t[t.PENDING = 0] = "PENDING";
  const r = 1;
  t[t.RESOLVED = r] = "RESOLVED";
  const n = 2;
  t[t.REJECTED = n] = "REJECTED"
})(Ha || (Ha = {}));

function oc(t) {
  return new _r(e => {
    e(t)
  })
}

function Y1(t) {
  return new _r((e, r) => {
    r(t)
  })
}
class _r {
  __init() {
    this._state = Ha.PENDING
  }
  __init2() {
    this._handlers = []
  }
  constructor(e) {
    _r.prototype.__init.call(this), _r.prototype.__init2.call(this), _r.prototype.__init3.call(this), _r.prototype.__init4.call(this), _r.prototype.__init5.call(this), _r.prototype.__init6.call(this);
    try {
      e(this._resolve, this._reject)
    } catch (r) {
      this._reject(r)
    }
  }
  then(e, r) {
    return new _r((n, i) => {
      this._handlers.push([!1, a => {
        if (!e) n(a);
        else try {
          n(e(a))
        } catch (s) {
          i(s)
        }
      }, a => {
        if (!r) i(a);
        else try {
          n(r(a))
        } catch (s) {
          i(s)
        }
      }]), this._executeHandlers()
    })
  } catch (e) {
    return this.then(r => r, e)
  } finally(e) {
    return new _r((r, n) => {
      let i, a;
      return this.then(s => {
        a = !1, i = s, e && e()
      }, s => {
        a = !0, i = s, e && e()
      }).then(() => {
        if (a) {
          n(i);
          return
        }
        r(i)
      })
    })
  }
  __init3() {
    this._resolve = e => {
      this._setResult(Ha.RESOLVED, e)
    }
  }
  __init4() {
    this._reject = e => {
      this._setResult(Ha.REJECTED, e)
    }
  }
  __init5() {
    this._setResult = (e, r) => {
      if (this._state === Ha.PENDING) {
        if (dL(r)) {
          r.then(this._resolve, this._reject);
          return
        }
        this._state = e, this._value = r, this._executeHandlers()
      }
    }
  }
  __init6() {
    this._executeHandlers = () => {
      if (this._state === Ha.PENDING) return;
      const e = this._handlers.slice();
      this._handlers = [], e.forEach(r => {
        r[0] || (this._state === Ha.RESOLVED && r[1](this._value), this._state === Ha.REJECTED && r[2](this._value), r[0] = !0)
      })
    }
  }
}

function Qct(t) {
  const e = [];

  function r() {
    return t === void 0 || e.length < t
  }

  function n(s) {
    return e.splice(e.indexOf(s), 1)[0]
  }

  function i(s) {
    if (!r()) return Y1(new pr("Not adding Promise because buffer limit was reached."));
    const o = s();
    return e.indexOf(o) === -1 && e.push(o), o.then(() => n(o)).then(null, () => n(o).then(null, () => {})), o
  }

  function a(s) {
    return new _r((o, c) => {
      let l = e.length;
      if (!l) return o(!0);
      const u = setTimeout(() => {
        s && s > 0 && o(!1)
      }, s);
      e.forEach(f => {
        oc(f).then(() => {
          --l || (clearTimeout(u), o(!0))
        }, c)
      })
    })
  }
  return {
    $: e,
    add: i,
    drain: a
  }
}

function Yw(t) {
  if (!t) return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e) return {};
  const r = e[6] || "",
    n = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: r,
    hash: n,
    relative: e[5] + r + n
  }
}
const Zct = ["fatal", "error", "warning", "log", "info", "debug"];

function KJ(t) {
  return t === "warn" ? "warning" : Zct.includes(t) ? t : "log"
}
const YJ = wg(),
  TI = {
    nowSeconds: () => Date.now() / 1e3
  };

function Jct() {
  const {
    performance: t
  } = YJ;
  if (!t || !t.now) return;
  const e = Date.now() - t.now();
  return {
    now: () => t.now(),
    timeOrigin: e
  }
}

function eut() {
  try {
    return Wct(module, "perf_hooks").performance
  } catch {
    return
  }
}
const qw = Vct() ? eut() : Jct(),
  $7 = qw === void 0 ? TI : {
    nowSeconds: () => (qw.timeOrigin + qw.now()) / 1e3
  },
  DE = TI.nowSeconds.bind(TI),
  lc = $7.nowSeconds.bind($7),
  jo = (() => {
    const {
      performance: t
    } = YJ;
    if (!t || !t.now) return;
    const e = 3600 * 1e3,
      r = t.now(),
      n = Date.now(),
      i = t.timeOrigin ? Math.abs(t.timeOrigin + r - n) : e,
      a = i < e,
      s = t.timing && t.timing.navigationStart,
      c = typeof s == "number" ? Math.abs(s + r - n) : e,
      l = c < e;
    return a || l ? i <= c ? t.timeOrigin : s : n
  })(),
  tut = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

function rut(t) {
  const e = t.match(tut);
  if (!t || !e) return;
  let r;
  return e[3] === "1" ? r = !0 : e[3] === "0" && (r = !1), {
    traceId: e[1],
    parentSampled: r,
    parentSpanId: e[2]
  }
}

function Ag(t, e = []) {
  return [t, e]
}

function nut(t, e) {
  const [r, n] = t;
  return [r, [...n, e]]
}

function C7(t, e) {
  const r = t[1];
  for (const n of r) {
    const i = n[0].type;
    if (e(n, i)) return !0
  }
  return !1
}

function wI(t, e) {
  return (e || new TextEncoder).encode(t)
}

function iut(t, e) {
  const [r, n] = t;
  let i = JSON.stringify(r);

  function a(s) {
    typeof i == "string" ? i = typeof s == "string" ? i + s : [wI(i, e), s] : i.push(typeof s == "string" ? wI(s, e) : s)
  }
  for (const s of n) {
    const [o, c] = s;
    if (a(`
${JSON.stringify(o)}
`), typeof c == "string" || c instanceof Uint8Array) a(c);
    else {
      let l;
      try {
        l = JSON.stringify(c)
      } catch {
        l = JSON.stringify(Vs(c))
      }
      a(l)
    }
  }
  return typeof i == "string" ? i : aut(i)
}

function aut(t) {
  const e = t.reduce((i, a) => i + a.length, 0),
    r = new Uint8Array(e);
  let n = 0;
  for (const i of t) r.set(i, n), n += i.length;
  return r
}

function sut(t, e) {
  const r = typeof t.data == "string" ? wI(t.data, e) : t.data;
  return [So({
    type: "attachment",
    length: r.length,
    filename: t.filename,
    content_type: t.contentType,
    attachment_type: t.attachmentType
  }), r]
}
const out = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor"
};

function k7(t) {
  return out[t]
}

function qJ(t) {
  if (!t || !t.sdk) return;
  const {
    name: e,
    version: r
  } = t.sdk;
  return {
    name: e,
    version: r
  }
}

function lut(t, e, r, n) {
  const i = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...e && {
      sdk: e
    },
    ...!!r && {
      dsn: NE(n)
    },
    ...i && {
      trace: So({
        ...i
      })
    }
  }
}

function cut(t, e, r) {
  const n = [{
    type: "client_report"
  }, {
    timestamp: r || DE(),
    discarded_events: t
  }];
  return Ag(e ? {
    dsn: e
  } : {}, [n])
}
const uut = 60 * 1e3;

function fut(t, e = Date.now()) {
  const r = parseInt(`${t}`, 10);
  if (!isNaN(r)) return r * 1e3;
  const n = Date.parse(`${t}`);
  return isNaN(n) ? uut : n - e
}

function dut(t, e) {
  return t[e] || t.all || 0
}

function hut(t, e, r = Date.now()) {
  return dut(t, e) > r
}

function put(t, {
  statusCode: e,
  headers: r
}, n = Date.now()) {
  const i = {
      ...t
    },
    a = r && r["x-sentry-rate-limits"],
    s = r && r["retry-after"];
  if (a)
    for (const o of a.trim().split(",")) {
      const [c, l] = o.split(":", 2), u = parseInt(c, 10), f = (isNaN(u) ? 60 : u) * 1e3;
      if (!l) i.all = n + f;
      else
        for (const d of l.split(";")) i[d] = n + f
    } else s ? i.all = n + fut(s, n) : e === 429 && (i.all = n + 60 * 1e3);
  return i
}
const RI = "baggage",
  XJ = "sentry-",
  gut = /^sentry-/,
  mut = 8192;

function vut(t) {
  if (!Fo(t) && !Array.isArray(t)) return;
  let e = {};
  if (Array.isArray(t)) e = t.reduce((n, i) => {
    const a = O7(i);
    return {
      ...n,
      ...a
    }
  }, {});
  else {
    if (!t) return;
    e = O7(t)
  }
  const r = Object.entries(e).reduce((n, [i, a]) => {
    if (i.match(gut)) {
      const s = i.slice(XJ.length);
      n[s] = a
    }
    return n
  }, {});
  if (Object.keys(r).length > 0) return r
}

function QJ(t) {
  const e = Object.entries(t).reduce((r, [n, i]) => (i && (r[`${XJ}${n}`] = i), r), {});
  return yut(e)
}

function O7(t) {
  return t.split(",").map(e => e.split("=").map(r => decodeURIComponent(r.trim()))).reduce((e, [r, n]) => (e[r] = n, e), {})
}

function yut(t) {
  if (Object.keys(t).length !== 0) return Object.entries(t).reduce((e, [r, n], i) => {
    const a = `${encodeURIComponent(r)}=${encodeURIComponent(n)}`,
      s = i === 0 ? a : `${e},${a}`;
    return s.length > mut ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Not adding key: ${r} with val: ${n} to baggage header due to exceeding baggage size limits.`), e) : s
  }, "")
}
class Dl {
  static __initStatic() {
    this.id = "CaptureConsole"
  }
  __init() {
    this.name = Dl.id
  }
  __init2() {
    this._levels = hp
  }
  constructor(e = {}) {
    Dl.prototype.__init.call(this), Dl.prototype.__init2.call(this), e.levels && (this._levels = e.levels)
  }
  setupOnce(e, r) {
    "console" in Wt && this._levels.forEach(n => {
      n in Wt.console && Kt(Wt.console, n, i => (...a) => {
        const s = r();
        s.getIntegration(Dl) && s.withScope(o => {
          o.setLevel(KJ(n)), o.setExtra("arguments", a), o.addEventProcessor(l => (l.logger = "console", l));
          let c = K1(a, " ");
          n === "assert" ? a[0] === !1 && (c = `Assertion failed: ${K1(a.slice(1)," ")||"console.assert"}`, o.setExtra("arguments", a.slice(1)), s.captureMessage(c)) : n === "error" && a[0] instanceof Error ? s.captureException(a[0]) : s.captureMessage(c)
        }), i && i.apply(Wt.console, a)
      })
    })
  }
}
Dl.__initStatic();

function xut(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
class pp {
  static __initStatic() {
    this.id = "HttpClient"
  }
  __init() {
    this.name = pp.id
  }
  constructor(e) {
    pp.prototype.__init.call(this), this._options = {
      failedRequestStatusCodes: [
        [500, 599]
      ],
      failedRequestTargets: [/.*/],
      ...e
    }
  }
  setupOnce(e, r) {
    this._getCurrentHub = r, this._wrapFetch(), this._wrapXHR()
  }
  _fetchResponseHandler(e, r, n) {
    if (this._getCurrentHub && this._shouldCaptureResponse(r.status, r.url)) {
      const i = but(e, n),
        a = this._getCurrentHub();
      let s, o, c, l;
      a.shouldSendDefaultPii() && ([{
        headers: s,
        cookies: c
      }, {
        headers: o,
        cookies: l
      }] = [{
        cookieHeader: "Cookie",
        obj: i
      }, {
        cookieHeader: "Set-Cookie",
        obj: r
      }].map(({
        cookieHeader: f,
        obj: d
      }) => {
        const h = this._extractFetchHeaders(d.headers);
        let p;
        try {
          const v = h[f] || h[f.toLowerCase()] || void 0;
          v && (p = this._parseCookieString(v))
        } catch {
          (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`Could not extract cookies from header ${f}`)
        }
        return {
          headers: h,
          cookies: p
        }
      }));
      const u = this._createEvent({
        url: i.url,
        method: i.method,
        status: r.status,
        requestHeaders: s,
        responseHeaders: o,
        requestCookies: c,
        responseCookies: l
      });
      a.captureEvent(u)
    }
  }
  _xhrResponseHandler(e, r, n) {
    if (this._getCurrentHub && this._shouldCaptureResponse(e.status, e.responseURL)) {
      let i, a, s;
      const o = this._getCurrentHub();
      if (o.shouldSendDefaultPii()) {
        try {
          const l = e.getResponseHeader("Set-Cookie") || e.getResponseHeader("set-cookie") || void 0;
          l && (a = this._parseCookieString(l))
        } catch {
          (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("Could not extract cookies from response headers")
        }
        try {
          s = this._getXHRResponseHeaders(e)
        } catch {
          (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("Could not extract headers from response")
        }
        i = n
      }
      const c = this._createEvent({
        url: e.responseURL,
        method: r,
        status: e.status,
        requestHeaders: i,
        responseHeaders: s,
        responseCookies: a
      });
      o.captureEvent(c)
    }
  }
  _getResponseSizeFromHeaders(e) {
    if (e) {
      const r = e["Content-Length"] || e["content-length"];
      if (r) return parseInt(r, 10)
    }
  }
  _parseCookieString(e) {
    return e.split("; ").reduce((r, n) => {
      const [i, a] = n.split("=");
      return r[i] = a, r
    }, {})
  }
  _extractFetchHeaders(e) {
    const r = {};
    return e.forEach((n, i) => {
      r[i] = n
    }), r
  }
  _getXHRResponseHeaders(e) {
    const r = e.getAllResponseHeaders();
    return r ? r.split(`\r
`).reduce((n, i) => {
      const [a, s] = i.split(": ");
      return n[a] = s, n
    }, {}) : {}
  }
  _isInGivenRequestTargets(e) {
    return this._options.failedRequestTargets ? this._options.failedRequestTargets.some(r => typeof r == "string" ? e.includes(r) : r.test(e)) : !1
  }
  _isInGivenStatusRanges(e) {
    return this._options.failedRequestStatusCodes ? this._options.failedRequestStatusCodes.some(r => typeof r == "number" ? r === e : e >= r[0] && e <= r[1]) : !1
  }
  _wrapFetch() {
    zJ() && wr("fetch", e => {
      const {
        response: r,
        args: n
      } = e, [i, a] = n;
      r && this._fetchResponseHandler(i, r, a)
    })
  }
  _wrapXHR() {
    "XMLHttpRequest" in Wt && wr("xhr", e => {
      const {
        xhr: r
      } = e, n = r[Nl];
      if (!n) return;
      const {
        method: i,
        request_headers: a
      } = n;
      if (i) try {
        this._xhrResponseHandler(r, i, a)
      } catch (s) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Error while extracting response event form XHR response", s)
      }
    })
  }
  _isSentryRequest(e) {
    const r = this._getCurrentHub && this._getCurrentHub().getClient();
    if (!r) return !1;
    const n = r.getDsn();
    return n ? e.includes(n.host) : !1
  }
  _shouldCaptureResponse(e, r) {
    return this._isInGivenStatusRanges(e) && this._isInGivenRequestTargets(r) && !this._isSentryRequest(r)
  }
  _createEvent(e) {
    const r = `HTTP Client Error with status code: ${e.status}`,
      n = {
        message: r,
        exception: {
          values: [{
            type: "Error",
            value: r
          }]
        },
        request: {
          url: e.url,
          method: e.method,
          headers: e.requestHeaders,
          cookies: e.requestCookies
        },
        contexts: {
          response: {
            status_code: e.status,
            headers: e.responseHeaders,
            cookies: e.responseCookies,
            body_size: this._getResponseSizeFromHeaders(e.responseHeaders)
          }
        }
      };
    return Lf(n, {
      type: "http.client"
    }), n
  }
}
pp.__initStatic();

function but(t, e) {
  return !e && t instanceof Request || t instanceof Request && t.bodyUsed ? t : new Request(t, e)
}
const mL = "production";

function Eut(t) {
  const e = lc(),
    r = {
      sid: _o(),
      init: !0,
      timestamp: e,
      started: e,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => _ut(r)
    };
  return t && Pf(r, t), r
}

function Pf(t, e = {}) {
  if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || lc(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : _o()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
  else if (typeof e.duration == "number") t.duration = e.duration;
  else {
    const r = t.timestamp - t.started;
    t.duration = r >= 0 ? r : 0
  }
  e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
}

function Sut(t, e) {
  let r = {};
  e ? r = {
    status: e
  } : t.status === "ok" && (r = {
    status: "exited"
  }), Pf(t, r)
}

function _ut(t) {
  return So({
    sid: `${t.sid}`,
    init: t.init,
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
    duration: t.duration,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent
    }
  })
}
const Tut = 100;
class zl {
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
  }
  static clone(e) {
    const r = new zl;
    return e && (r._breadcrumbs = [...e._breadcrumbs], r._tags = {
      ...e._tags
    }, r._extra = {
      ...e._extra
    }, r._contexts = {
      ...e._contexts
    }, r._user = e._user, r._level = e._level, r._span = e._span, r._session = e._session, r._transactionName = e._transactionName, r._fingerprint = e._fingerprint, r._eventProcessors = [...e._eventProcessors], r._requestSession = e._requestSession, r._attachments = [...e._attachments], r._sdkProcessingMetadata = {
      ...e._sdkProcessingMetadata
    }), r
  }
  addScopeListener(e) {
    this._scopeListeners.push(e)
  }
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this
  }
  setUser(e) {
    return this._user = e || {}, this._session && Pf(this._session, {
      user: e
    }), this._notifyScopeListeners(), this
  }
  getUser() {
    return this._user
  }
  getRequestSession() {
    return this._requestSession
  }
  setRequestSession(e) {
    return this._requestSession = e, this
  }
  setTags(e) {
    return this._tags = {
      ...this._tags,
      ...e
    }, this._notifyScopeListeners(), this
  }
  setTag(e, r) {
    return this._tags = {
      ...this._tags,
      [e]: r
    }, this._notifyScopeListeners(), this
  }
  setExtras(e) {
    return this._extra = {
      ...this._extra,
      ...e
    }, this._notifyScopeListeners(), this
  }
  setExtra(e, r) {
    return this._extra = {
      ...this._extra,
      [e]: r
    }, this._notifyScopeListeners(), this
  }
  setFingerprint(e) {
    return this._fingerprint = e, this._notifyScopeListeners(), this
  }
  setLevel(e) {
    return this._level = e, this._notifyScopeListeners(), this
  }
  setTransactionName(e) {
    return this._transactionName = e, this._notifyScopeListeners(), this
  }
  setContext(e, r) {
    return r === null ? delete this._contexts[e] : this._contexts[e] = r, this._notifyScopeListeners(), this
  }
  setSpan(e) {
    return this._span = e, this._notifyScopeListeners(), this
  }
  getSpan() {
    return this._span
  }
  getTransaction() {
    const e = this.getSpan();
    return e && e.transaction
  }
  setSession(e) {
    return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
  }
  getSession() {
    return this._session
  }
  update(e) {
    if (!e) return this;
    if (typeof e == "function") {
      const r = e(this);
      return r instanceof zl ? r : this
    }
    return e instanceof zl ? (this._tags = {
      ...this._tags,
      ...e._tags
    }, this._extra = {
      ...this._extra,
      ...e._extra
    }, this._contexts = {
      ...this._contexts,
      ...e._contexts
    }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : kf(e) && (e = e, this._tags = {
      ...this._tags,
      ...e.tags
    }, this._extra = {
      ...this._extra,
      ...e.extra
    }, this._contexts = {
      ...this._contexts,
      ...e.contexts
    }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
  }
  addBreadcrumb(e, r) {
    const n = typeof r == "number" ? r : Tut;
    if (n <= 0) return this;
    const i = {
      timestamp: DE(),
      ...e
    };
    return this._breadcrumbs = [...this._breadcrumbs, i].slice(-n), this._notifyScopeListeners(), this
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1]
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this
  }
  addAttachment(e) {
    return this._attachments.push(e), this
  }
  getAttachments() {
    return this._attachments
  }
  clearAttachments() {
    return this._attachments = [], this
  }
  applyToEvent(e, r = {}) {
    if (this._extra && Object.keys(this._extra).length && (e.extra = {
        ...this._extra,
        ...e.extra
      }), this._tags && Object.keys(this._tags).length && (e.tags = {
        ...this._tags,
        ...e.tags
      }), this._user && Object.keys(this._user).length && (e.user = {
        ...this._user,
        ...e.user
      }), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
        ...this._contexts,
        ...e.contexts
      }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
      e.contexts = {
        trace: this._span.getTraceContext(),
        ...e.contexts
      };
      const n = this._span.transaction;
      if (n) {
        e.sdkProcessingMetadata = {
          dynamicSamplingContext: n.getDynamicSamplingContext(),
          ...e.sdkProcessingMetadata
        };
        const i = n.name;
        i && (e.tags = {
          transaction: i,
          ...e.tags
        })
      }
    }
    return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = {
      ...e.sdkProcessingMetadata,
      ...this._sdkProcessingMetadata
    }, this._notifyEventProcessors([...ZJ(), ...this._eventProcessors], e, r)
  }
  setSDKProcessingMetadata(e) {
    return this._sdkProcessingMetadata = {
      ...this._sdkProcessingMetadata,
      ...e
    }, this
  }
  _notifyEventProcessors(e, r, n, i = 0) {
    return new _r((a, s) => {
      const o = e[i];
      if (r === null || typeof o != "function") a(r);
      else {
        const c = o({
          ...r
        }, n);
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && o.id && c === null && J.log(`Event processor "${o.id}" dropped event`), dL(c) ? c.then(l => this._notifyEventProcessors(e, l, n, i + 1).then(a)).then(null, s) : this._notifyEventProcessors(e, c, n, i + 1).then(a).then(null, s)
      }
    })
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
      e(this)
    }), this._notifyingListeners = !1)
  }
  _applyFingerprint(e) {
    e.fingerprint = e.fingerprint ? VJ(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
  }
}

function ZJ() {
  return hL("globalEventProcessors", () => [])
}

function vL(t) {
  ZJ().push(t)
}
const JJ = 4,
  wut = 100;
class eee {
  constructor(e, r = new zl, n = JJ) {
    this._version = n, this._stack = [{
      scope: r
    }], e && this.bindClient(e)
  }
  isOlderThan(e) {
    return this._version < e
  }
  bindClient(e) {
    const r = this.getStackTop();
    r.client = e, e && e.setupIntegrations && e.setupIntegrations()
  }
  pushScope() {
    const e = zl.clone(this.getScope());
    return this.getStack().push({
      client: this.getClient(),
      scope: e
    }), e
  }
  popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
  }
  withScope(e) {
    const r = this.pushScope();
    try {
      e(r)
    } finally {
      this.popScope()
    }
  }
  getClient() {
    return this.getStackTop().client
  }
  getScope() {
    return this.getStackTop().scope
  }
  getStack() {
    return this._stack
  }
  getStackTop() {
    return this._stack[this._stack.length - 1]
  }
  captureException(e, r) {
    const n = this._lastEventId = r && r.event_id ? r.event_id : _o(),
      i = new Error("Sentry syntheticException");
    return this._withClient((a, s) => {
      a.captureException(e, {
        originalException: e,
        syntheticException: i,
        ...r,
        event_id: n
      }, s)
    }), n
  }
  captureMessage(e, r, n) {
    const i = this._lastEventId = n && n.event_id ? n.event_id : _o(),
      a = new Error(e);
    return this._withClient((s, o) => {
      s.captureMessage(e, r, {
        originalException: e,
        syntheticException: a,
        ...n,
        event_id: i
      }, o)
    }), i
  }
  captureEvent(e, r) {
    const n = r && r.event_id ? r.event_id : _o();
    return e.type || (this._lastEventId = n), this._withClient((i, a) => {
      i.captureEvent(e, {
        ...r,
        event_id: n
      }, a)
    }), n
  }
  lastEventId() {
    return this._lastEventId
  }
  addBreadcrumb(e, r) {
    const {
      scope: n,
      client: i
    } = this.getStackTop();
    if (!i) return;
    const {
      beforeBreadcrumb: a = null,
      maxBreadcrumbs: s = wut
    } = i.getOptions && i.getOptions() || {};
    if (s <= 0) return;
    const c = {
        timestamp: DE(),
        ...e
      },
      l = a ? MJ(() => a(c, r)) : c;
    l !== null && (i.emit && i.emit("beforeAddBreadcrumb", l, r), n.addBreadcrumb(l, s))
  }
  setUser(e) {
    this.getScope().setUser(e)
  }
  setTags(e) {
    this.getScope().setTags(e)
  }
  setExtras(e) {
    this.getScope().setExtras(e)
  }
  setTag(e, r) {
    this.getScope().setTag(e, r)
  }
  setExtra(e, r) {
    this.getScope().setExtra(e, r)
  }
  setContext(e, r) {
    this.getScope().setContext(e, r)
  }
  configureScope(e) {
    const {
      scope: r,
      client: n
    } = this.getStackTop();
    n && e(r)
  }
  run(e) {
    const r = L7(this);
    try {
      e(this)
    } finally {
      L7(r)
    }
  }
  getIntegration(e) {
    const r = this.getClient();
    if (!r) return null;
    try {
      return r.getIntegration(e)
    } catch {
      return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
    }
  }
  startTransaction(e, r) {
    const n = this._callExtensionMethod("startTransaction", e, r);
    return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !n && console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`), n
  }
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders")
  }
  captureSession(e = !1) {
    if (e) return this.endSession();
    this._sendSessionUpdate()
  }
  endSession() {
    const r = this.getStackTop().scope,
      n = r.getSession();
    n && Sut(n), this._sendSessionUpdate(), r.setSession()
  }
  startSession(e) {
    const {
      scope: r,
      client: n
    } = this.getStackTop(), {
      release: i,
      environment: a = mL
    } = n && n.getOptions() || {}, {
      userAgent: s
    } = Wt.navigator || {}, o = Eut({
      release: i,
      environment: a,
      user: r.getUser(),
      ...s && {
        userAgent: s
      },
      ...e
    }), c = r.getSession && r.getSession();
    return c && c.status === "ok" && Pf(c, {
      status: "exited"
    }), this.endSession(), r.setSession(o), o
  }
  shouldSendDefaultPii() {
    const e = this.getClient(),
      r = e && e.getOptions();
    return !!(r && r.sendDefaultPii)
  }
  _sendSessionUpdate() {
    const {
      scope: e,
      client: r
    } = this.getStackTop(), n = e.getSession();
    n && r && r.captureSession && r.captureSession(n)
  }
  _withClient(e) {
    const {
      scope: r,
      client: n
    } = this.getStackTop();
    n && e(n, r)
  }
  _callExtensionMethod(e, ...r) {
    const i = Ig().__SENTRY__;
    if (i && i.extensions && typeof i.extensions[e] == "function") return i.extensions[e].apply(this, r);
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Extension method ${e} couldn't be found, doing nothing.`)
  }
}

function Ig() {
  return Wt.__SENTRY__ = Wt.__SENTRY__ || {
    extensions: {},
    hub: void 0
  }, Wt
}

function L7(t) {
  const e = Ig(),
    r = AI(e);
  return tee(e, t), r
}

function dt() {
  const t = Ig();
  if (t.__SENTRY__ && t.__SENTRY__.acs) {
    const e = t.__SENTRY__.acs.getCurrentHub();
    if (e) return e
  }
  return Rut(t)
}

function Rut(t = Ig()) {
  return (!Aut(t) || AI(t).isOlderThan(JJ)) && tee(t, new eee), AI(t)
}

function Aut(t) {
  return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
}

function AI(t) {
  return hL("hub", () => new eee, t)
}

function tee(t, e) {
  if (!t) return !1;
  const r = t.__SENTRY__ = t.__SENTRY__ || {};
  return r.hub = e, !0
}

function yL(t) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
  const e = dt().getClient(),
    r = t || e && e.getOptions();
  return !!r && (r.enableTracing || "tracesSampleRate" in r || "tracesSampler" in r)
}

function $g(t) {
  return (t || dt()).getScope().getTransaction()
}
let P7 = !1;

function Iut() {
  P7 || (P7 = !0, wr("error", II), wr("unhandledrejection", II))
}

function II() {
  const t = $g();
  if (t) {
    const e = "internal_error";
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Transaction: ${e} -> Global error occured`), t.setStatus(e)
  }
}
II.tag = "sentry_tracingErrorCallback";
class ME {
  __init() {
    this.spans = []
  }
  constructor(e = 1e3) {
    ME.prototype.__init.call(this), this._maxlen = e
  }
  add(e) {
    this.spans.length > this._maxlen ? e.spanRecorder = void 0 : this.spans.push(e)
  }
}
class za {
  __init2() {
    this.traceId = _o()
  }
  __init3() {
    this.spanId = _o().substring(16)
  }
  __init4() {
    this.startTimestamp = lc()
  }
  __init5() {
    this.tags = {}
  }
  __init6() {
    this.data = {}
  }
  __init7() {
    this.instrumenter = "sentry"
  }
  constructor(e) {
    if (za.prototype.__init2.call(this), za.prototype.__init3.call(this), za.prototype.__init4.call(this), za.prototype.__init5.call(this), za.prototype.__init6.call(this), za.prototype.__init7.call(this), !e) return this;
    e.traceId && (this.traceId = e.traceId), e.spanId && (this.spanId = e.spanId), e.parentSpanId && (this.parentSpanId = e.parentSpanId), "sampled" in e && (this.sampled = e.sampled), e.op && (this.op = e.op), e.description && (this.description = e.description), e.data && (this.data = e.data), e.tags && (this.tags = e.tags), e.status && (this.status = e.status), e.startTimestamp && (this.startTimestamp = e.startTimestamp), e.endTimestamp && (this.endTimestamp = e.endTimestamp), e.instrumenter && (this.instrumenter = e.instrumenter)
  }
  startChild(e) {
    const r = new za({
      ...e,
      parentSpanId: this.spanId,
      sampled: this.sampled,
      traceId: this.traceId
    });
    if (r.spanRecorder = this.spanRecorder, r.spanRecorder && r.spanRecorder.add(r), r.transaction = this.transaction, (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && r.transaction) {
      const n = e && e.op || "< unknown op >",
        i = r.transaction.name || "< unknown name >",
        a = r.transaction.spanId,
        s = `[Tracing] Starting '${n}' span on transaction '${i}' (${a}).`;
      r.transaction.metadata.spanMetadata[r.spanId] = {
        logMessage: s
      }, J.log(s)
    }
    return r
  }
  setTag(e, r) {
    return this.tags = {
      ...this.tags,
      [e]: r
    }, this
  }
  setData(e, r) {
    return this.data = {
      ...this.data,
      [e]: r
    }, this
  }
  setStatus(e) {
    return this.status = e, this
  }
  setHttpStatus(e) {
    this.setTag("http.status_code", String(e));
    const r = $ut(e);
    return r !== "unknown_error" && this.setStatus(r), this
  }
  isSuccess() {
    return this.status === "ok"
  }
  finish(e) {
    if ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && this.transaction && this.transaction.spanId !== this.spanId) {
      const {
        logMessage: r
      } = this.transaction.metadata.spanMetadata[this.spanId];
      r && J.log(r.replace("Starting", "Finishing"))
    }
    this.endTimestamp = typeof e == "number" ? e : lc()
  }
  toTraceparent() {
    let e = "";
    return this.sampled !== void 0 && (e = this.sampled ? "-1" : "-0"), `${this.traceId}-${this.spanId}${e}`
  }
  toContext() {
    return So({
      data: this.data,
      description: this.description,
      endTimestamp: this.endTimestamp,
      op: this.op,
      parentSpanId: this.parentSpanId,
      sampled: this.sampled,
      spanId: this.spanId,
      startTimestamp: this.startTimestamp,
      status: this.status,
      tags: this.tags,
      traceId: this.traceId
    })
  }
  updateWithContext(e) {
    return this.data = e.data || {}, this.description = e.description, this.endTimestamp = e.endTimestamp, this.op = e.op, this.parentSpanId = e.parentSpanId, this.sampled = e.sampled, this.spanId = e.spanId || this.spanId, this.startTimestamp = e.startTimestamp || this.startTimestamp, this.status = e.status, this.tags = e.tags || {}, this.traceId = e.traceId || this.traceId, this
  }
  getTraceContext() {
    return So({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      trace_id: this.traceId
    })
  }
  toJSON() {
    return So({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      start_timestamp: this.startTimestamp,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      timestamp: this.endTimestamp,
      trace_id: this.traceId
    })
  }
}

function $ut(t) {
  if (t < 400 && t >= 100) return "ok";
  if (t >= 400 && t < 500) switch (t) {
    case 401:
      return "unauthenticated";
    case 403:
      return "permission_denied";
    case 404:
      return "not_found";
    case 409:
      return "already_exists";
    case 413:
      return "failed_precondition";
    case 429:
      return "resource_exhausted";
    default:
      return "invalid_argument"
  }
  if (t >= 500 && t < 600) switch (t) {
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline_exceeded";
    default:
      return "internal_error"
  }
  return "unknown_error"
}
class Ju extends za {
  __init() {
    this._measurements = {}
  }
  __init2() {
    this._contexts = {}
  }
  __init3() {
    this._frozenDynamicSamplingContext = void 0
  }
  constructor(e, r) {
    super(e), Ju.prototype.__init.call(this), Ju.prototype.__init2.call(this), Ju.prototype.__init3.call(this), this._hub = r || dt(), this._name = e.name || "", this.metadata = {
      source: "custom",
      ...e.metadata,
      spanMetadata: {}
    }, this._trimEnd = e.trimEnd, this.transaction = this;
    const n = this.metadata.dynamicSamplingContext;
    n && (this._frozenDynamicSamplingContext = {
      ...n
    })
  }
  get name() {
    return this._name
  }
  set name(e) {
    this.setName(e)
  }
  setName(e, r = "custom") {
    this._name = e, this.metadata.source = r
  }
  initSpanRecorder(e = 1e3) {
    this.spanRecorder || (this.spanRecorder = new ME(e)), this.spanRecorder.add(this)
  }
  setContext(e, r) {
    r === null ? delete this._contexts[e] : this._contexts[e] = r
  }
  setMeasurement(e, r, n = "") {
    this._measurements[e] = {
      value: r,
      unit: n
    }
  }
  setMetadata(e) {
    this.metadata = {
      ...this.metadata,
      ...e
    }
  }
  finish(e) {
    if (this.endTimestamp !== void 0) return;
    this.name || ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this.name = "<unlabeled transaction>"), super.finish(e);
    const r = this._hub.getClient();
    if (r && r.emit && r.emit("finishTransaction", this), this.sampled !== !0) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), r && r.recordDroppedEvent("sample_rate", "transaction");
      return
    }
    const n = this.spanRecorder ? this.spanRecorder.spans.filter(o => o !== this && o.endTimestamp) : [];
    this._trimEnd && n.length > 0 && (this.endTimestamp = n.reduce((o, c) => o.endTimestamp && c.endTimestamp ? o.endTimestamp > c.endTimestamp ? o : c : o).endTimestamp);
    const i = this.metadata,
      a = {
        contexts: {
          ...this._contexts,
          trace: this.getTraceContext()
        },
        spans: n,
        start_timestamp: this.startTimestamp,
        tags: this.tags,
        timestamp: this.endTimestamp,
        transaction: this.name,
        type: "transaction",
        sdkProcessingMetadata: {
          ...i,
          dynamicSamplingContext: this.getDynamicSamplingContext()
        },
        ...i.source && {
          transaction_info: {
            source: i.source
          }
        }
      };
    return Object.keys(this._measurements).length > 0 && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), a.measurements = this._measurements), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`), this._hub.captureEvent(a)
  }
  toContext() {
    const e = super.toContext();
    return So({
      ...e,
      name: this.name,
      trimEnd: this._trimEnd
    })
  }
  updateWithContext(e) {
    return super.updateWithContext(e), this.name = e.name || "", this._trimEnd = e.trimEnd, this
  }
  getDynamicSamplingContext() {
    if (this._frozenDynamicSamplingContext) return this._frozenDynamicSamplingContext;
    const e = this._hub || dt(),
      r = e && e.getClient();
    if (!r) return {};
    const {
      environment: n,
      release: i
    } = r.getOptions() || {}, {
      publicKey: a
    } = r.getDsn() || {}, s = this.metadata.sampleRate, o = s !== void 0 ? s.toString() : void 0, {
      segment: c
    } = e.getScope().getUser() || {}, l = this.metadata.source, u = l && l !== "url" ? this.name : void 0, f = So({
      environment: n || mL,
      release: i,
      transaction: u,
      user_segment: c,
      public_key: a,
      trace_id: this.traceId,
      sample_rate: o
    });
    return r.emit && r.emit("createDsc", f), f
  }
  setHub(e) {
    this._hub = e
  }
}
const cy = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    heartbeatInterval: 5e3
  },
  Cut = "finishReason",
  Jc = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"];
class kut extends ME {
  constructor(e, r, n, i) {
    super(i), this._pushActivity = e, this._popActivity = r, this.transactionSpanId = n
  }
  add(e) {
    e.spanId !== this.transactionSpanId && (e.finish = r => {
      e.endTimestamp = typeof r == "number" ? r : lc(), this._popActivity(e.spanId)
    }, e.endTimestamp === void 0 && this._pushActivity(e.spanId)), super.add(e)
  }
}
class Ws extends Ju {
  __init() {
    this.activities = {}
  }
  __init2() {
    this._heartbeatCounter = 0
  }
  __init3() {
    this._finished = !1
  }
  __init4() {
    this._idleTimeoutCanceledPermanently = !1
  }
  __init5() {
    this._beforeFinishCallbacks = []
  }
  __init6() {
    this._finishReason = Jc[4]
  }
  constructor(e, r, n = cy.idleTimeout, i = cy.finalTimeout, a = cy.heartbeatInterval, s = !1) {
    super(e, r), this._idleHub = r, this._idleTimeout = n, this._finalTimeout = i, this._heartbeatInterval = a, this._onScope = s, Ws.prototype.__init.call(this), Ws.prototype.__init2.call(this), Ws.prototype.__init3.call(this), Ws.prototype.__init4.call(this), Ws.prototype.__init5.call(this), Ws.prototype.__init6.call(this), s && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`), r.configureScope(o => o.setSpan(this))), this._restartIdleTimeout(), setTimeout(() => {
      this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = Jc[3], this.finish())
    }, this._finalTimeout)
  }
  finish(e = lc()) {
    if (this._finished = !0, this.activities = {}, this.op === "ui.action.click" && this.setTag(Cut, this._finishReason), this.spanRecorder) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] finishing IdleTransaction", new Date(e * 1e3).toISOString(), this.op);
      for (const r of this._beforeFinishCallbacks) r(this, e);
      this.spanRecorder.spans = this.spanRecorder.spans.filter(r => {
        if (r.spanId === this.spanId) return !0;
        r.endTimestamp || (r.endTimestamp = e, r.setStatus("cancelled"), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(r, void 0, 2)));
        const n = r.startTimestamp < e;
        return n || (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(r, void 0, 2)), n
      }), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] flushing IdleTransaction")
    } else(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] No active IdleTransaction");
    if (this._onScope) {
      const r = this._idleHub.getScope();
      r.getTransaction() === this && r.setSpan(void 0)
    }
    return super.finish(e)
  }
  registerBeforeFinishCallback(e) {
    this._beforeFinishCallbacks.push(e)
  }
  initSpanRecorder(e) {
    if (!this.spanRecorder) {
      const r = i => {
          this._finished || this._pushActivity(i)
        },
        n = i => {
          this._finished || this._popActivity(i)
        };
      this.spanRecorder = new kut(r, n, this.spanId, e), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("Starting heartbeat"), this._pingHeartbeat()
    }
    this.spanRecorder.add(this)
  }
  cancelIdleTimeout(e, {
    restartOnChildSpanChange: r
  } = {
    restartOnChildSpanChange: !0
  }) {
    this._idleTimeoutCanceledPermanently = r === !1, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently && (this._finishReason = Jc[5], this.finish(e)))
  }
  setFinishReason(e) {
    this._finishReason = e
  }
  _restartIdleTimeout(e) {
    this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout(() => {
      !this._finished && Object.keys(this.activities).length === 0 && (this._finishReason = Jc[1], this.finish(e))
    }, this._idleTimeout)
  }
  _pushActivity(e) {
    this.cancelIdleTimeout(void 0, {
      restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently
    }), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] pushActivity: ${e}`), this.activities[e] = !0, (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] new activities count", Object.keys(this.activities).length)
  }
  _popActivity(e) {
    if (this.activities[e] && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] popActivity ${e}`), delete this.activities[e], (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] new activities count", Object.keys(this.activities).length)), Object.keys(this.activities).length === 0) {
      const r = lc();
      this._idleTimeoutCanceledPermanently ? (this._finishReason = Jc[5], this.finish(r)) : this._restartIdleTimeout(r + this._idleTimeout / 1e3)
    }
  }
  _beat() {
    if (this._finished) return;
    const e = Object.keys(this.activities).join("");
    e === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = e, this._heartbeatCounter >= 3 ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = Jc[0], this.finish()) : this._pingHeartbeat()
  }
  _pingHeartbeat() {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout(() => {
      this._beat()
    }, this._heartbeatInterval)
  }
}

function Out() {
  const e = this.getScope().getSpan();
  return e ? {
    "sentry-trace": e.toTraceparent()
  } : {}
}

function ree(t, e, r) {
  if (!yL(e)) return t.sampled = !1, t;
  if (t.sampled !== void 0) return t.setMetadata({
    sampleRate: Number(t.sampled)
  }), t;
  let n;
  return typeof e.tracesSampler == "function" ? (n = e.tracesSampler(r), t.setMetadata({
    sampleRate: Number(n)
  })) : r.parentSampled !== void 0 ? n = r.parentSampled : typeof e.tracesSampleRate < "u" ? (n = e.tracesSampleRate, t.setMetadata({
    sampleRate: Number(n)
  })) : (n = 1, t.setMetadata({
    sampleRate: n
  })), Lut(n) ? n ? (t.sampled = Math.random() < n, t.sampled ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] starting ${t.op} transaction - ${t.name}`), t) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(n)})`), t)) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Discarding transaction because ${typeof e.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), t.sampled = !1, t) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("[Tracing] Discarding transaction because of invalid sample rate."), t.sampled = !1, t)
}

function Lut(t) {
  return NJ(t) || !(typeof t == "number" || typeof t == "boolean") ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(t)} of type ${JSON.stringify(typeof t)}.`), !1) : t < 0 || t > 1 ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${t}.`), !1) : !0
}

function Put(t, e) {
  const r = this.getClient(),
    n = r && r.getOptions() || {},
    i = n.instrumenter || "sentry",
    a = t.instrumenter || "sentry";
  i !== a && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error(`A transaction was started with instrumenter=\`${a}\`, but the SDK is configured with the \`${i}\` instrumenter.
The transaction will not be sampled. Please use the ${i} instrumentation to start transactions.`), t.sampled = !1);
  let s = new Ju(t, this);
  return s = ree(s, n, {
    parentSampled: t.parentSampled,
    transactionContext: t,
    ...e
  }), s.sampled && s.initSpanRecorder(n._experiments && n._experiments.maxSpans), r && r.emit && r.emit("startTransaction", s), s
}

function N7(t, e, r, n, i, a, s) {
  const o = t.getClient(),
    c = o && o.getOptions() || {};
  let l = new Ws(e, t, r, n, s, i);
  return l = ree(l, c, {
    parentSampled: e.parentSampled,
    transactionContext: e,
    ...a
  }), l.sampled && l.initSpanRecorder(c._experiments && c._experiments.maxSpans), o && o.emit && o.emit("startTransaction", l), l
}

function Nut() {
  const t = Ig();
  t.__SENTRY__ && (t.__SENTRY__.extensions = t.__SENTRY__.extensions || {}, t.__SENTRY__.extensions.startTransaction || (t.__SENTRY__.extensions.startTransaction = Put), t.__SENTRY__.extensions.traceHeaders || (t.__SENTRY__.extensions.traceHeaders = Out), Iut())
}

function Dut(t, e) {
  return dt().captureException(t, {
    captureContext: e
  })
}

function Mut(t) {
  dt().withScope(t)
}
const Fut = "7";

function But(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    r = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${r}${t.path?`/${t.path}`:""}/api/`
}

function Uut(t) {
  return `${But(t)}${t.projectId}/envelope/`
}

function jut(t, e) {
  return wct({
    sentry_key: t.publicKey,
    sentry_version: Fut,
    ...e && {
      sentry_client: `${e.name}/${e.version}`
    }
  })
}

function Hut(t, e = {}) {
  const r = typeof e == "string" ? e : e.tunnel,
    n = typeof e == "string" || !e._metadata ? void 0 : e._metadata.sdk;
  return r || `${Uut(t)}?${jut(t,n)}`
}

function zut(t, e) {
  return e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]), t
}

function Gut(t, e, r, n) {
  const i = qJ(r),
    a = {
      sent_at: new Date().toISOString(),
      ...i && {
        sdk: i
      },
      ...!!n && {
        dsn: NE(e)
      }
    },
    s = "aggregates" in t ? [{
      type: "sessions"
    }, t] : [{
      type: "session"
    }, t];
  return Ag(a, [s])
}

function Vut(t, e, r, n) {
  const i = qJ(r),
    a = t.type && t.type !== "replay_event" ? t.type : "event";
  zut(t, r && r.sdk);
  const s = lut(t, i, n, e);
  return delete t.sdkProcessingMetadata, Ag(s, [
    [{
      type: a
    }, t]
  ])
}
const D7 = [];

function Wut(t) {
  const e = {};
  return t.forEach(r => {
    const {
      name: n
    } = r, i = e[n];
    i && !i.isDefaultInstance && r.isDefaultInstance || (e[n] = r)
  }), Object.keys(e).map(r => e[r])
}

function Kut(t) {
  const e = t.defaultIntegrations || [],
    r = t.integrations;
  e.forEach(s => {
    s.isDefaultInstance = !0
  });
  let n;
  Array.isArray(r) ? n = [...e, ...r] : typeof r == "function" ? n = VJ(r(e)) : n = e;
  const i = Wut(n),
    a = qut(i, s => s.name === "Debug");
  if (a !== -1) {
    const [s] = i.splice(a, 1);
    i.push(s)
  }
  return i
}

function Yut(t) {
  const e = {};
  return t.forEach(r => {
    r && nee(r, e)
  }), e
}

function nee(t, e) {
  e[t.name] = t, D7.indexOf(t.name) === -1 && (t.setupOnce(vL, dt), D7.push(t.name), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`Integration installed: ${t.name}`))
}

function qut(t, e) {
  for (let r = 0; r < t.length; r++)
    if (e(t[r]) === !0) return r;
  return -1
}

function Xut(t, e, r, n) {
  const {
    normalizeDepth: i = 3,
    normalizeMaxBreadth: a = 1e3
  } = t, s = {
    ...e,
    event_id: e.event_id || r.event_id || _o(),
    timestamp: e.timestamp || DE()
  }, o = r.integrations || t.integrations.map(u => u.name);
  Qut(s, t), Jut(s, o), e.type === void 0 && Zut(s, t.stackParser);
  let c = n;
  r.captureContext && (c = zl.clone(c).update(r.captureContext));
  let l = oc(s);
  if (c) {
    if (c.getAttachments) {
      const u = [...r.attachments || [], ...c.getAttachments()];
      u.length && (r.attachments = u)
    }
    l = c.applyToEvent(s, r)
  }
  return l.then(u => typeof i == "number" && i > 0 ? eft(u, i, a) : u)
}

function Qut(t, e) {
  const {
    environment: r,
    release: n,
    dist: i,
    maxValueLength: a = 250
  } = e;
  "environment" in t || (t.environment = "environment" in e ? r : mL), t.release === void 0 && n !== void 0 && (t.release = n), t.dist === void 0 && i !== void 0 && (t.dist = i), t.message && (t.message = f0(t.message, a));
  const s = t.exception && t.exception.values && t.exception.values[0];
  s && s.value && (s.value = f0(s.value, a));
  const o = t.request;
  o && o.url && (o.url = f0(o.url, a))
}
const M7 = new WeakMap;

function Zut(t, e) {
  const r = Wt._sentryDebugIds;
  if (!r) return;
  let n;
  const i = M7.get(e);
  i ? n = i : (n = new Map, M7.set(e, n));
  const a = Object.keys(r).reduce((c, l) => {
      let u;
      const f = n.get(l);
      f ? u = f : (u = e(l), n.set(l, u));
      for (let d = u.length - 1; d >= 0; d--) {
        const h = u[d];
        if (h.filename) {
          c[h.filename] = r[l];
          break
        }
      }
      return c
    }, {}),
    s = new Set;
  try {
    t.exception.values.forEach(c => {
      c.stacktrace.frames.forEach(l => {
        l.filename && s.add(l.filename)
      })
    })
  } catch {}
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const o = t.debug_meta.images;
  s.forEach(c => {
    a[c] && o.push({
      type: "sourcemap",
      code_file: c,
      debug_id: a[c]
    })
  })
}

function Jut(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e])
}

function eft(t, e, r) {
  if (!t) return null;
  const n = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map(i => ({
        ...i,
        ...i.data && {
          data: Vs(i.data, e, r)
        }
      }))
    },
    ...t.user && {
      user: Vs(t.user, e, r)
    },
    ...t.contexts && {
      contexts: Vs(t.contexts, e, r)
    },
    ...t.extra && {
      extra: Vs(t.extra, e, r)
    }
  };
  return t.contexts && t.contexts.trace && n.contexts && (n.contexts.trace = t.contexts.trace, t.contexts.trace.data && (n.contexts.trace.data = Vs(t.contexts.trace.data, e, r))), t.spans && (n.spans = t.spans.map(i => (i.data && (i.data = Vs(i.data, e, r)), i))), n
}
const F7 = "Not capturing exception because it's already been captured.";
class wl {
  __init() {
    this._integrations = {}
  }
  __init2() {
    this._integrationsInitialized = !1
  }
  __init3() {
    this._numProcessing = 0
  }
  __init4() {
    this._outcomes = {}
  }
  __init5() {
    this._hooks = {}
  }
  constructor(e) {
    if (wl.prototype.__init.call(this), wl.prototype.__init2.call(this), wl.prototype.__init3.call(this), wl.prototype.__init4.call(this), wl.prototype.__init5.call(this), this._options = e, e.dsn) {
      this._dsn = Sct(e.dsn);
      const r = Hut(this._dsn, e);
      this._transport = e.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: r
      })
    } else(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("No DSN provided, client will not do anything.")
  }
  captureException(e, r, n) {
    if (I7(e)) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(F7);
      return
    }
    let i = r && r.event_id;
    return this._process(this.eventFromException(e, r).then(a => this._captureEvent(a, r, n)).then(a => {
      i = a
    })), i
  }
  captureMessage(e, r, n, i) {
    let a = n && n.event_id;
    const s = PJ(e) ? this.eventFromMessage(String(e), r, n) : this.eventFromException(e, n);
    return this._process(s.then(o => this._captureEvent(o, n, i)).then(o => {
      a = o
    })), a
  }
  captureEvent(e, r, n) {
    if (r && r.originalException && I7(r.originalException)) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(F7);
      return
    }
    let i = r && r.event_id;
    return this._process(this._captureEvent(e, r, n).then(a => {
      i = a
    })), i
  }
  captureSession(e) {
    if (!this._isEnabled()) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("SDK not enabled, will not capture session.");
      return
    }
    typeof e.release != "string" ? (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), Pf(e, {
      init: !1
    }))
  }
  getDsn() {
    return this._dsn
  }
  getOptions() {
    return this._options
  }
  getSdkMetadata() {
    return this._options._metadata
  }
  getTransport() {
    return this._transport
  }
  flush(e) {
    const r = this._transport;
    return r ? this._isClientDoneProcessing(e).then(n => r.flush(e).then(i => n && i)) : oc(!0)
  }
  close(e) {
    return this.flush(e).then(r => (this.getOptions().enabled = !1, r))
  }
  setupIntegrations() {
    this._isEnabled() && !this._integrationsInitialized && (this._integrations = Yut(this._options.integrations), this._integrationsInitialized = !0)
  }
  getIntegrationById(e) {
    return this._integrations[e]
  }
  getIntegration(e) {
    try {
      return this._integrations[e.id] || null
    } catch {
      return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Cannot retrieve integration ${e.id} from the current Client`), null
    }
  }
  addIntegration(e) {
    nee(e, this._integrations)
  }
  sendEvent(e, r = {}) {
    if (this._dsn) {
      let n = Vut(e, this._dsn, this._options._metadata, this._options.tunnel);
      for (const a of r.attachments || []) n = nut(n, sut(a, this._options.transportOptions && this._options.transportOptions.textEncoder));
      const i = this._sendEnvelope(n);
      i && i.then(a => this.emit("afterSendEvent", e, a), null)
    }
  }
  sendSession(e) {
    if (this._dsn) {
      const r = Gut(e, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(r)
    }
  }
  recordDroppedEvent(e, r, n) {
    if (this._options.sendClientReports) {
      const i = `${e}:${r}`;
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`Adding outcome: "${i}"`), this._outcomes[i] = this._outcomes[i] + 1 || 1
    }
  }
  on(e, r) {
    this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(r)
  }
  emit(e, ...r) {
    this._hooks[e] && this._hooks[e].forEach(n => n(...r))
  }
  _updateSessionFromEvent(e, r) {
    let n = !1,
      i = !1;
    const a = r.exception && r.exception.values;
    if (a) {
      i = !0;
      for (const c of a) {
        const l = c.mechanism;
        if (l && l.handled === !1) {
          n = !0;
          break
        }
      }
    }
    const s = e.status === "ok";
    (s && e.errors === 0 || s && n) && (Pf(e, {
      ...n && {
        status: "crashed"
      },
      errors: e.errors || Number(i || n)
    }), this.captureSession(e))
  }
  _isClientDoneProcessing(e) {
    return new _r(r => {
      let n = 0;
      const i = 1,
        a = setInterval(() => {
          this._numProcessing == 0 ? (clearInterval(a), r(!0)) : (n += i, e && n >= e && (clearInterval(a), r(!1)))
        }, i)
    })
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._dsn !== void 0
  }
  _prepareEvent(e, r, n) {
    const i = this.getOptions(),
      a = Object.keys(this._integrations);
    return !r.integrations && a.length > 0 && (r.integrations = a), Xut(i, e, r, n)
  }
  _captureEvent(e, r = {}, n) {
    return this._processEvent(e, r, n).then(i => i.event_id, i => {
      if (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) {
        const a = i;
        a.logLevel === "log" ? J.log(a.message) : J.warn(a)
      }
    })
  }
  _processEvent(e, r, n) {
    const i = this.getOptions(),
      {
        sampleRate: a
      } = i;
    if (!this._isEnabled()) return Y1(new pr("SDK not enabled, will not capture event.", "log"));
    const s = aee(e),
      o = iee(e),
      c = e.type || "error",
      l = `before send for type \`${c}\``;
    if (o && typeof a == "number" && Math.random() > a) return this.recordDroppedEvent("sample_rate", "error", e), Y1(new pr(`Discarding event because it's not included in the random sample (sampling rate = ${a})`, "log"));
    const u = c === "replay_event" ? "replay" : c;
    return this._prepareEvent(e, r, n).then(f => {
      if (f === null) throw this.recordDroppedEvent("event_processor", u, e), new pr("An event processor returned `null`, will not send event.", "log");
      if (r.data && r.data.__sentry__ === !0) return f;
      const h = rft(i, f, r);
      return tft(h, l)
    }).then(f => {
      if (f === null) throw this.recordDroppedEvent("before_send", u, e), new pr(`${l} returned \`null\`, will not send event.`, "log");
      const d = n && n.getSession();
      !s && d && this._updateSessionFromEvent(d, f);
      const h = f.transaction_info;
      if (s && h && f.transaction !== e.transaction) {
        const p = "custom";
        f.transaction_info = {
          ...h,
          source: p
        }
      }
      return this.sendEvent(f, r), f
    }).then(null, f => {
      throw f instanceof pr ? f : (this.captureException(f, {
        data: {
          __sentry__: !0
        },
        originalException: f
      }), new pr(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${f}`))
    })
  }
  _process(e) {
    this._numProcessing++, e.then(r => (this._numProcessing--, r), r => (this._numProcessing--, r))
  }
  _sendEnvelope(e) {
    if (this._transport && this._dsn) return this.emit("beforeEnvelope", e), this._transport.send(e).then(null, r => {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error("Error while sending event:", r)
    });
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error("Transport disabled")
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.keys(e).map(r => {
      const [n, i] = r.split(":");
      return {
        reason: n,
        category: i,
        quantity: e[r]
      }
    })
  }
}

function tft(t, e) {
  const r = `${e} must return \`null\` or a valid event.`;
  if (dL(t)) return t.then(n => {
    if (!kf(n) && n !== null) throw new pr(r);
    return n
  }, n => {
    throw new pr(`${e} rejected with ${n}`)
  });
  if (!kf(t) && t !== null) throw new pr(r);
  return t
}

function rft(t, e, r) {
  const {
    beforeSend: n,
    beforeSendTransaction: i
  } = t;
  return iee(e) && n ? n(e, r) : aee(e) && i ? i(e, r) : e
}

function iee(t) {
  return t.type === void 0
}

function aee(t) {
  return t.type === "transaction"
}

function nft(t, e) {
  e.debug === !0 && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? J.enable() : console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."));
  const r = dt();
  r.getScope().update(e.initialScope);
  const i = new t(e);
  r.bindClient(i)
}
const ift = 30;

function see(t, e, r = Qct(t.bufferSize || ift)) {
  let n = {};
  const i = s => r.drain(s);

  function a(s) {
    const o = [];
    if (C7(s, (f, d) => {
        const h = k7(d);
        if (hut(n, h)) {
          const p = B7(f, d);
          t.recordDroppedEvent("ratelimit_backoff", h, p)
        } else o.push(f)
      }), o.length === 0) return oc();
    const c = Ag(s[0], o),
      l = f => {
        C7(c, (d, h) => {
          const p = B7(d, h);
          t.recordDroppedEvent(f, k7(h), p)
        })
      },
      u = () => e({
        body: iut(c, t.textEncoder)
      }).then(f => (f.statusCode !== void 0 && (f.statusCode < 200 || f.statusCode >= 300) && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Sentry responded with status code ${f.statusCode} to sent event.`), n = put(n, f), f), f => {
        throw l("network_error"), f
      });
    return r.add(u).then(f => f, f => {
      if (f instanceof pr) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error("Skipped sending event because buffer is full."), l("queue_overflow"), oc();
      throw f
    })
  }
  return a.__sentry__baseTransport__ = !0, {
    send: a,
    flush: i
  }
}

function B7(t, e) {
  if (!(e !== "event" && e !== "transaction")) return Array.isArray(t) ? t[1] : void 0
}
const q1 = "7.49.0";
let U7;
class gp {
  constructor() {
    gp.prototype.__init.call(this)
  }
  static __initStatic() {
    this.id = "FunctionToString"
  }
  __init() {
    this.name = gp.id
  }
  setupOnce() {
    U7 = Function.prototype.toString, Function.prototype.toString = function (...e) {
      const r = gL(this) || this;
      return U7.apply(r, e)
    }
  }
}
gp.__initStatic();
const aft = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
class ef {
  static __initStatic() {
    this.id = "InboundFilters"
  }
  __init() {
    this.name = ef.id
  }
  constructor(e = {}) {
    this._options = e, ef.prototype.__init.call(this)
  }
  setupOnce(e, r) {
    const n = i => {
      const a = r();
      if (a) {
        const s = a.getIntegration(ef);
        if (s) {
          const o = a.getClient(),
            c = o ? o.getOptions() : {},
            l = sft(s._options, c);
          return oft(i, l) ? null : i
        }
      }
      return i
    };
    n.id = this.name, e(n)
  }
}
ef.__initStatic();

function sft(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...aft],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
  }
}

function oft(t, e) {
  return e.ignoreInternal && hft(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Event dropped due to being internal Sentry Error.
Event: ${qs(t)}`), !0) : lft(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${qs(t)}`), !0) : cft(t, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${qs(t)}`), !0) : uft(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${qs(t)}.
Url: ${X1(t)}`), !0) : fft(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${qs(t)}.
Url: ${X1(t)}`), !0)
}

function lft(t, e) {
  return t.type || !e || !e.length ? !1 : dft(t).some(r => Rg(r, e))
}

function cft(t, e) {
  if (t.type !== "transaction" || !e || !e.length) return !1;
  const r = t.transaction;
  return r ? Rg(r, e) : !1
}

function uft(t, e) {
  if (!e || !e.length) return !1;
  const r = X1(t);
  return r ? Rg(r, e) : !1
}

function fft(t, e) {
  if (!e || !e.length) return !0;
  const r = X1(t);
  return r ? Rg(r, e) : !0
}

function dft(t) {
  if (t.message) return [t.message];
  if (t.exception) try {
    const {
      type: e = "",
      value: r = ""
    } = t.exception.values && t.exception.values[0] || {};
    return [`${r}`, `${e}: ${r}`]
  } catch {
    return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error(`Cannot extract message for event ${qs(t)}`), []
  }
  return []
}

function hft(t) {
  try {
    return t.exception.values[0].type === "SentryError"
  } catch {}
  return !1
}

function pft(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const r = t[e];
    if (r && r.filename !== "<anonymous>" && r.filename !== "[native code]") return r.filename || null
  }
  return null
}

function X1(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames
    } catch {}
    return e ? pft(e) : null
  } catch {
    return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.error(`Cannot extract url for event ${qs(t)}`), null
  }
}
const Ze = Wt;
let $I = 0;

function oee() {
  return $I > 0
}

function gft() {
  $I++, setTimeout(() => {
    $I--
  })
}

function Nf(t, e = {}, r) {
  if (typeof t != "function") return t;
  try {
    const i = t.__sentry_wrapped__;
    if (i) return i;
    if (gL(t)) return t
  } catch {
    return t
  }
  const n = function () {
    const i = Array.prototype.slice.call(arguments);
    try {
      r && typeof r == "function" && r.apply(this, arguments);
      const a = i.map(s => Nf(s, e));
      return t.apply(this, a)
    } catch (a) {
      throw gft(), Mut(s => {
        s.addEventProcessor(o => (e.mechanism && (SI(o, void 0, void 0), Lf(o, e.mechanism)), o.extra = {
          ...o.extra,
          arguments: i
        }, o)), Dut(a)
      }), a
    }
  };
  try {
    for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
  } catch {}
  FJ(n, t), pL(t, "__sentry_wrapped__", n);
  try {
    Object.getOwnPropertyDescriptor(n, "name").configurable && Object.defineProperty(n, "name", {
      get() {
        return t.name
      }
    })
  } catch {}
  return n
}

function lee(t, e) {
  const r = xL(t, e),
    n = {
      type: e && e.name,
      value: xft(e)
    };
  return r.length && (n.stacktrace = {
    frames: r
  }), n.type === void 0 && n.value === "" && (n.value = "Unrecoverable error caught"), n
}

function mft(t, e, r, n) {
  const a = dt().getClient(),
    s = a && a.getOptions().normalizeDepth,
    o = {
      exception: {
        values: [{
          type: fL(e) ? e.constructor.name : n ? "UnhandledRejection" : "Error",
          value: `Non-Error ${n?"promise rejection":"exception"} captured with keys: ${Rct(e)}`
        }]
      },
      extra: {
        __serialized__: WJ(e, s)
      }
    };
  if (r) {
    const c = xL(t, r);
    c.length && (o.exception.values[0].stacktrace = {
      frames: c
    })
  }
  return o
}

function Xw(t, e) {
  return {
    exception: {
      values: [lee(t, e)]
    }
  }
}

function xL(t, e) {
  const r = e.stacktrace || e.stack || "",
    n = yft(e);
  try {
    return t(r, n)
  } catch {}
  return []
}
const vft = /Minified React error #\d+;/i;

function yft(t) {
  if (t) {
    if (typeof t.framesToPop == "number") return t.framesToPop;
    if (vft.test(t.message)) return 1
  }
  return 0
}

function xft(t) {
  const e = t && t.message;
  return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function bft(t, e, r, n) {
  const i = r && r.syntheticException || void 0,
    a = bL(t, e, i, n);
  return Lf(a), a.level = "error", r && r.event_id && (a.event_id = r.event_id), oc(a)
}

function Eft(t, e, r = "info", n, i) {
  const a = n && n.syntheticException || void 0,
    s = CI(t, e, a, i);
  return s.level = r, n && n.event_id && (s.event_id = n.event_id), oc(s)
}

function bL(t, e, r, n, i) {
  let a;
  if (LJ(e) && e.error) return Xw(t, e.error);
  if (b7(e) || uct(e)) {
    const s = e;
    if ("stack" in e) a = Xw(t, e);
    else {
      const o = s.name || (b7(s) ? "DOMError" : "DOMException"),
        c = s.message ? `${o}: ${s.message}` : o;
      a = CI(t, c, r, n), SI(a, c)
    }
    return "code" in s && (a.tags = {
      ...a.tags,
      "DOMException.code": `${s.code}`
    }), a
  }
  return OJ(e) ? Xw(t, e) : kf(e) || fL(e) ? (a = mft(t, e, r, i), Lf(a, {
    synthetic: !0
  }), a) : (a = CI(t, e, r, n), SI(a, `${e}`, void 0), Lf(a, {
    synthetic: !0
  }), a)
}

function CI(t, e, r, n) {
  const i = {
    message: e
  };
  if (n && r) {
    const a = xL(t, r);
    a.length && (i.exception = {
      values: [{
        value: e,
        stacktrace: {
          frames: a
        }
      }]
    })
  }
  return i
}
const vv = 1024,
  cee = "Breadcrumbs";
class mp {
  static __initStatic() {
    this.id = cee
  }
  __init() {
    this.name = mp.id
  }
  constructor(e) {
    mp.prototype.__init.call(this), this.options = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...e
    }
  }
  setupOnce() {
    this.options.console && wr("console", _ft), this.options.dom && wr("dom", Sft(this.options.dom)), this.options.xhr && wr("xhr", Tft), this.options.fetch && wr("fetch", wft), this.options.history && wr("history", Rft)
  }
  addSentryBreadcrumb(e) {
    this.options.sentry && dt().addBreadcrumb({
      category: `sentry.${e.type==="transaction"?"transaction":"event"}`,
      event_id: e.event_id,
      level: e.level,
      message: qs(e)
    }, {
      event: e
    })
  }
}
mp.__initStatic();

function Sft(t) {
  function e(r) {
    let n, i = typeof t == "object" ? t.serializeAttribute : void 0,
      a = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    a && a > vv && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`\`dom.maxStringLength\` cannot exceed ${vv}, but a value of ${a} was configured. Sentry will use ${vv} instead.`), a = vv), typeof i == "string" && (i = [i]);
    try {
      const s = r.event;
      n = Aft(s) ? Of(s.target, {
        keyAttrs: i,
        maxStringLength: a
      }) : Of(s, {
        keyAttrs: i,
        maxStringLength: a
      })
    } catch {
      n = "<unknown>"
    }
    n.length !== 0 && dt().addBreadcrumb({
      category: `ui.${r.name}`,
      message: n
    }, {
      event: r.event,
      name: r.name,
      global: r.global
    })
  }
  return e
}

function _ft(t) {
  for (let r = 0; r < t.args.length; r++)
    if (t.args[r] === "ref=Ref<") {
      t.args[r + 1] = "viewRef";
      break
    } const e = {
    category: "console",
    data: {
      arguments: t.args,
      logger: "console"
    },
    level: KJ(t.level),
    message: K1(t.args, " ")
  };
  if (t.level === "assert")
    if (t.args[0] === !1) e.message = `Assertion failed: ${K1(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
    else return;
  dt().addBreadcrumb(e, {
    input: t.args,
    level: t.level
  })
}

function Tft(t) {
  const {
    startTimestamp: e,
    endTimestamp: r
  } = t, n = t.xhr[Nl];
  if (!e || !r || !n) return;
  const {
    method: i,
    url: a,
    status_code: s,
    body: o
  } = n, c = {
    method: i,
    url: a,
    status_code: s
  }, l = {
    xhr: t.xhr,
    input: o,
    startTimestamp: e,
    endTimestamp: r
  };
  dt().addBreadcrumb({
    category: "xhr",
    data: c,
    type: "http"
  }, l)
}

function wft(t) {
  const {
    startTimestamp: e,
    endTimestamp: r
  } = t;
  if (r && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
    if (t.error) {
      const n = t.fetchData,
        i = {
          data: t.error,
          input: t.args,
          startTimestamp: e,
          endTimestamp: r
        };
      dt().addBreadcrumb({
        category: "fetch",
        data: n,
        level: "error",
        type: "http"
      }, i)
    } else {
      const n = {
          ...t.fetchData,
          status_code: t.response && t.response.status
        },
        i = {
          input: t.args,
          response: t.response,
          startTimestamp: e,
          endTimestamp: r
        };
      dt().addBreadcrumb({
        category: "fetch",
        data: n,
        type: "http"
      }, i)
    }
}

function Rft(t) {
  let e = t.from,
    r = t.to;
  const n = Yw(Ze.location.href);
  let i = Yw(e);
  const a = Yw(r);
  i.path || (i = n), n.protocol === a.protocol && n.host === a.host && (r = a.relative), n.protocol === i.protocol && n.host === i.host && (e = i.relative), dt().addBreadcrumb({
    category: "navigation",
    data: {
      from: e,
      to: r
    }
  })
}

function Aft(t) {
  return t && !!t.target
}

function Ift(t, {
  metadata: e,
  tunnel: r,
  dsn: n
}) {
  const i = {
      event_id: t.event_id,
      sent_at: new Date().toISOString(),
      ...e && e.sdk && {
        sdk: {
          name: e.sdk.name,
          version: e.sdk.version
        }
      },
      ...!!r && !!n && {
        dsn: NE(n)
      }
    },
    a = $ft(t);
  return Ag(i, [a])
}

function $ft(t) {
  return [{
    type: "user_report"
  }, t]
}
class Cft extends wl {
  constructor(e) {
    const r = Ze.SENTRY_SDK_SOURCE || Gct();
    e._metadata = e._metadata || {}, e._metadata.sdk = e._metadata.sdk || {
      name: "sentry.javascript.browser",
      packages: [{
        name: `${r}:@sentry/browser`,
        version: q1
      }],
      version: q1
    }, super(e), e.sendClientReports && Ze.document && Ze.document.addEventListener("visibilitychange", () => {
      Ze.document.visibilityState === "hidden" && this._flushOutcomes()
    })
  }
  eventFromException(e, r) {
    return bft(this._options.stackParser, e, r, this._options.attachStacktrace)
  }
  eventFromMessage(e, r = "info", n) {
    return Eft(this._options.stackParser, e, r, n, this._options.attachStacktrace)
  }
  sendEvent(e, r) {
    const n = this.getIntegrationById(cee);
    n && n.addSentryBreadcrumb && n.addSentryBreadcrumb(e), super.sendEvent(e, r)
  }
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("SDK not enabled, will not capture user feedback.");
      return
    }
    const r = Ift(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this._sendEnvelope(r)
  }
  _prepareEvent(e, r, n) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, r, n)
  }
  _flushOutcomes() {
    const e = this._clearOutcomes();
    if (e.length === 0) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("No outcomes to send");
      return
    }
    if (!this._dsn) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("No dsn provided, will not send outcomes");
      return
    }(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("Sending outcomes:", e);
    const r = cut(e, this._options.tunnel && NE(this._dsn));
    this._sendEnvelope(r)
  }
}
let Ch;

function kft() {
  if (Ch) return Ch;
  if (bI(Ze.fetch)) return Ch = Ze.fetch.bind(Ze);
  const t = Ze.document;
  let e = Ze.fetch;
  if (t && typeof t.createElement == "function") try {
    const r = t.createElement("iframe");
    r.hidden = !0, t.head.appendChild(r);
    const n = r.contentWindow;
    n && n.fetch && (e = n.fetch), t.head.removeChild(r)
  } catch (r) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r)
  }
  return Ch = e.bind(Ze)
}

function Oft() {
  Ch = void 0
}

function Lft(t, e = kft()) {
  let r = 0,
    n = 0;

  function i(a) {
    const s = a.body.length;
    r += s, n++;
    const o = {
      body: a.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      keepalive: r <= 6e4 && n < 15,
      ...t.fetchOptions
    };
    try {
      return e(t.url, o).then(c => (r -= s, n--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }))
    } catch (c) {
      return Oft(), r -= s, n--, Y1(c)
    }
  }
  return see(t, i)
}
const Pft = 4;

function Nft(t) {
  function e(r) {
    return new _r((n, i) => {
      const a = new XMLHttpRequest;
      a.onerror = i, a.onreadystatechange = () => {
        a.readyState === Pft && n({
          statusCode: a.status,
          headers: {
            "x-sentry-rate-limits": a.getResponseHeader("X-Sentry-Rate-Limits"),
            "retry-after": a.getResponseHeader("Retry-After")
          }
        })
      }, a.open("POST", t.url);
      for (const s in t.headers) Object.prototype.hasOwnProperty.call(t.headers, s) && a.setRequestHeader(s, t.headers[s]);
      a.send(r.body)
    })
  }
  return see(t, e)
}
const FE = "?",
  Dft = 30,
  Mft = 40,
  Fft = 50;

function EL(t, e, r, n) {
  const i = {
    filename: t,
    function: e,
    in_app: !0
  };
  return r !== void 0 && (i.lineno = r), n !== void 0 && (i.colno = n), i
}
const Bft = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  Uft = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  jft = t => {
    const e = Bft.exec(t);
    if (e) {
      if (e[2] && e[2].indexOf("eval") === 0) {
        const a = Uft.exec(e[2]);
        a && (e[2] = a[1], e[3] = a[2], e[4] = a[3])
      }
      const [n, i] = uee(e[1] || FE, e[2]);
      return EL(i, n, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0)
    }
  },
  Hft = [Dft, jft],
  zft = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  Gft = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  Vft = t => {
    const e = zft.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const a = Gft.exec(e[3]);
        a && (e[1] = e[1] || "eval", e[3] = a[1], e[4] = a[2], e[5] = "")
      }
      let n = e[3],
        i = e[1] || FE;
      return [i, n] = uee(i, n), EL(n, i, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
    }
  },
  Wft = [Fft, Vft],
  Kft = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
  Yft = t => {
    const e = Kft.exec(t);
    return e ? EL(e[2], e[1] || FE, +e[3], e[4] ? +e[4] : void 0) : void 0
  },
  qft = [Mft, Yft],
  Xft = [Hft, Wft, qft],
  Qft = jJ(...Xft),
  uee = (t, e) => {
    const r = t.indexOf("safari-extension") !== -1,
      n = t.indexOf("safari-web-extension") !== -1;
    return r || n ? [t.indexOf("@") !== -1 ? t.split("@")[0] : FE, r ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
  };
class To {
  static __initStatic() {
    this.id = "GlobalHandlers"
  }
  __init() {
    this.name = To.id
  }
  __init2() {
    this._installFunc = {
      onerror: Zft,
      onunhandledrejection: Jft
    }
  }
  constructor(e) {
    To.prototype.__init.call(this), To.prototype.__init2.call(this), this._options = {
      onerror: !0,
      onunhandledrejection: !0,
      ...e
    }
  }
  setupOnce() {
    Error.stackTraceLimit = 50;
    const e = this._options;
    for (const r in e) {
      const n = this._installFunc[r];
      n && e[r] && (rdt(r), n(), this._installFunc[r] = void 0)
    }
  }
}
To.__initStatic();

function Zft() {
  wr("error", t => {
    const [e, r, n] = hee();
    if (!e.getIntegration(To)) return;
    const {
      msg: i,
      url: a,
      line: s,
      column: o,
      error: c
    } = t;
    if (oee() || c && c.__sentry_own_request__) return;
    const l = c === void 0 && Fo(i) ? tdt(i, a, s, o) : fee(bL(r, c || i, void 0, n, !1), a, s, o);
    l.level = "error", dee(e, c, l, "onerror")
  })
}

function Jft() {
  wr("unhandledrejection", t => {
    const [e, r, n] = hee();
    if (!e.getIntegration(To)) return;
    let i = t;
    try {
      "reason" in t ? i = t.reason : "detail" in t && "reason" in t.detail && (i = t.detail.reason)
    } catch {}
    if (oee() || i && i.__sentry_own_request__) return !0;
    const a = PJ(i) ? edt(i) : bL(r, i, void 0, n, !0);
    a.level = "error", dee(e, i, a, "onunhandledrejection")
  })
}

function edt(t) {
  return {
    exception: {
      values: [{
        type: "UnhandledRejection",
        value: `Non-Error promise rejection captured with value: ${String(t)}`
      }]
    }
  }
}

function tdt(t, e, r, n) {
  const i = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let a = LJ(t) ? t.message : t,
    s = "Error";
  const o = a.match(i);
  return o && (s = o[1], a = o[2]), fee({
    exception: {
      values: [{
        type: s,
        value: a
      }]
    }
  }, e, r, n)
}

function fee(t, e, r, n) {
  const i = t.exception = t.exception || {},
    a = i.values = i.values || [],
    s = a[0] = a[0] || {},
    o = s.stacktrace = s.stacktrace || {},
    c = o.frames = o.frames || [],
    l = isNaN(parseInt(n, 10)) ? void 0 : n,
    u = isNaN(parseInt(r, 10)) ? void 0 : r,
    f = Fo(e) && e.length > 0 ? e : mct();
  return c.length === 0 && c.push({
    colno: l,
    filename: f,
    function: "?",
    in_app: !0,
    lineno: u
  }), t
}

function rdt(t) {
  (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`Global Handler attached: ${t}`)
}

function dee(t, e, r, n) {
  Lf(r, {
    handled: !1,
    type: n
  }), t.captureEvent(r, {
    originalException: e
  })
}

function hee() {
  const t = dt(),
    e = t.getClient(),
    r = e && e.getOptions() || {
      stackParser: () => [],
      attachStacktrace: !1
    };
  return [t, r.stackParser, r.attachStacktrace]
}
const ndt = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
class vp {
  static __initStatic() {
    this.id = "TryCatch"
  }
  __init() {
    this.name = vp.id
  }
  constructor(e) {
    vp.prototype.__init.call(this), this._options = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      ...e
    }
  }
  setupOnce() {
    this._options.setTimeout && Kt(Ze, "setTimeout", j7), this._options.setInterval && Kt(Ze, "setInterval", j7), this._options.requestAnimationFrame && Kt(Ze, "requestAnimationFrame", idt), this._options.XMLHttpRequest && "XMLHttpRequest" in Ze && Kt(XMLHttpRequest.prototype, "send", adt);
    const e = this._options.eventTarget;
    e && (Array.isArray(e) ? e : ndt).forEach(sdt)
  }
}
vp.__initStatic();

function j7(t) {
  return function (...e) {
    const r = e[0];
    return e[0] = Nf(r, {
      mechanism: {
        data: {
          function: Uo(t)
        },
        handled: !0,
        type: "instrument"
      }
    }), t.apply(this, e)
  }
}

function idt(t) {
  return function (e) {
    return t.apply(this, [Nf(e, {
      mechanism: {
        data: {
          function: "requestAnimationFrame",
          handler: Uo(t)
        },
        handled: !0,
        type: "instrument"
      }
    })])
  }
}

function adt(t) {
  return function (...e) {
    const r = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(i => {
      i in r && typeof r[i] == "function" && Kt(r, i, function (a) {
        const s = {
            mechanism: {
              data: {
                function: i,
                handler: Uo(a)
              },
              handled: !0,
              type: "instrument"
            }
          },
          o = gL(a);
        return o && (s.mechanism.data.handler = Uo(o)), Nf(a, s)
      })
    }), t.apply(this, e)
  }
}

function sdt(t) {
  const e = Ze,
    r = e[t] && e[t].prototype;
  !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Kt(r, "addEventListener", function (n) {
    return function (i, a, s) {
      try {
        typeof a.handleEvent == "function" && (a.handleEvent = Nf(a.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Uo(a),
              target: t
            },
            handled: !0,
            type: "instrument"
          }
        }))
      } catch {}
      return n.apply(this, [i, Nf(a, {
        mechanism: {
          data: {
            function: "addEventListener",
            handler: Uo(a),
            target: t
          },
          handled: !0,
          type: "instrument"
        }
      }), s])
    }
  }), Kt(r, "removeEventListener", function (n) {
    return function (i, a, s) {
      const o = a;
      try {
        const c = o && o.__sentry_wrapped__;
        c && n.call(this, i, c, s)
      } catch {}
      return n.call(this, i, o, s)
    }
  }))
}
const odt = "cause",
  ldt = 5;
class tf {
  static __initStatic() {
    this.id = "LinkedErrors"
  }
  __init() {
    this.name = tf.id
  }
  constructor(e = {}) {
    tf.prototype.__init.call(this), this._key = e.key || odt, this._limit = e.limit || ldt
  }
  setupOnce() {
    const e = dt().getClient();
    e && vL((r, n) => {
      const i = dt().getIntegration(tf);
      return i ? cdt(e.getOptions().stackParser, i._key, i._limit, r, n) : r
    })
  }
}
tf.__initStatic();

function cdt(t, e, r, n, i) {
  if (!n.exception || !n.exception.values || !i || !Bo(i.originalException, Error)) return n;
  const a = pee(t, r, i.originalException, e);
  return n.exception.values = [...a, ...n.exception.values], n
}

function pee(t, e, r, n, i = []) {
  if (!Bo(r[n], Error) || i.length + 1 >= e) return i;
  const a = lee(t, r[n]);
  return pee(t, e, r[n], n, [a, ...i])
}
class rf {
  constructor() {
    rf.prototype.__init.call(this)
  }
  static __initStatic() {
    this.id = "HttpContext"
  }
  __init() {
    this.name = rf.id
  }
  setupOnce() {
    vL(e => {
      if (dt().getIntegration(rf)) {
        if (!Ze.navigator && !Ze.location && !Ze.document) return e;
        const r = e.request && e.request.url || Ze.location && Ze.location.href,
          {
            referrer: n
          } = Ze.document || {},
          {
            userAgent: i
          } = Ze.navigator || {},
          a = {
            ...e.request && e.request.headers,
            ...n && {
              Referer: n
            },
            ...i && {
              "User-Agent": i
            }
          },
          s = {
            ...e.request,
            ...r && {
              url: r
            },
            headers: a
          };
        return {
          ...e,
          request: s
        }
      }
      return e
    })
  }
}
rf.__initStatic();
class nf {
  constructor() {
    nf.prototype.__init.call(this)
  }
  static __initStatic() {
    this.id = "Dedupe"
  }
  __init() {
    this.name = nf.id
  }
  setupOnce(e, r) {
    const n = i => {
      if (i.type) return i;
      const a = r().getIntegration(nf);
      if (a) {
        try {
          if (udt(i, a._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Event dropped due to being a duplicate of previously captured event."), null
        } catch {
          return a._previousEvent = i
        }
        return a._previousEvent = i
      }
      return i
    };
    n.id = this.name, e(n)
  }
}
nf.__initStatic();

function udt(t, e) {
  return e ? !!(fdt(t, e) || ddt(t, e)) : !1
}

function fdt(t, e) {
  const r = t.message,
    n = e.message;
  return !(!r && !n || r && !n || !r && n || r !== n || !mee(t, e) || !gee(t, e))
}

function ddt(t, e) {
  const r = H7(e),
    n = H7(t);
  return !(!r || !n || r.type !== n.type || r.value !== n.value || !mee(t, e) || !gee(t, e))
}

function gee(t, e) {
  let r = z7(t),
    n = z7(e);
  if (!r && !n) return !0;
  if (r && !n || !r && n || (r = r, n = n, n.length !== r.length)) return !1;
  for (let i = 0; i < n.length; i++) {
    const a = n[i],
      s = r[i];
    if (a.filename !== s.filename || a.lineno !== s.lineno || a.colno !== s.colno || a.function !== s.function) return !1
  }
  return !0
}

function mee(t, e) {
  let r = t.fingerprint,
    n = e.fingerprint;
  if (!r && !n) return !0;
  if (r && !n || !r && n) return !1;
  r = r, n = n;
  try {
    return r.join("") === n.join("")
  } catch {
    return !1
  }
}

function H7(t) {
  return t.exception && t.exception.values && t.exception.values[0]
}

function z7(t) {
  const e = t.exception;
  if (e) try {
    return e.values[0].stacktrace.frames
  } catch {
    return
  }
}
const hdt = [new ef, new gp, new vp, new mp, new To, new tf, new nf, new rf];

function pdt(t = {}) {
  t.defaultIntegrations === void 0 && (t.defaultIntegrations = hdt), t.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (t.release = __SENTRY_RELEASE__), Ze.SENTRY_RELEASE && Ze.SENTRY_RELEASE.id && (t.release = Ze.SENTRY_RELEASE.id)), t.autoSessionTracking === void 0 && (t.autoSessionTracking = !0), t.sendClientReports === void 0 && (t.sendClientReports = !0);
  const e = {
    ...t,
    stackParser: Act(t.stackParser || Qft),
    integrations: Kut(t),
    transport: t.transport || (HJ() ? Lft : Nft)
  };
  nft(Cft, e), t.autoSessionTracking && gdt()
}

function G7(t) {
  t.startSession({
    ignoreDuration: !0
  }), t.captureSession()
}

function gdt() {
  if (typeof Ze.document > "u") {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return
  }
  const t = dt();
  t.captureSession && (G7(t), wr("history", ({
    from: e,
    to: r
  }) => {
    e === void 0 || e === r || G7(dt())
  }))
}
const Je = Wt;

function mdt() {
  Je && Je.document ? Je.document.addEventListener("visibilitychange", () => {
    const t = $g();
    if (Je.document.hidden && t) {
      const e = "cancelled";
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Transaction: ${e} -> since tab moved to the background, op: ${t.op}`), t.status || t.setStatus(e), t.setTag("visibilitychange", "document.hidden"), t.finish()
    }
  }) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const SL = (t, e, r) => {
    let n, i;
    return a => {
      e.value >= 0 && (a || r) && (i = e.value - (n || 0), (i || n === void 0) && (n = e.value, e.delta = i, t(e)))
    }
  },
  vdt = () => `v3-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
  ydt = () => {
    const t = Je.performance.timing,
      e = Je.performance.navigation.type,
      r = {
        entryType: "navigation",
        startTime: 0,
        type: e == 2 ? "back_forward" : e === 1 ? "reload" : "navigate"
      };
    for (const n in t) n !== "navigationStart" && n !== "toJSON" && (r[n] = Math.max(t[n] - t.navigationStart, 0));
    return r
  },
  vee = () => Je.__WEB_VITALS_POLYFILL__ ? Je.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || ydt()) : Je.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0],
  yee = () => {
    const t = vee();
    return t && t.activationStart || 0
  },
  _L = (t, e) => {
    const r = vee();
    let n = "navigate";
    return r && (Je.document.prerendering || yee() > 0 ? n = "prerender" : n = r.type.replace(/_/g, "-")), {
      name: t,
      value: typeof e > "u" ? -1 : e,
      rating: "good",
      delta: 0,
      entries: [],
      id: vdt(),
      navigationType: n
    }
  },
  Cg = (t, e, r) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        const n = new PerformanceObserver(i => {
          e(i.getEntries())
        });
        return n.observe(Object.assign({
          type: t,
          buffered: !0
        }, r || {})), n
      }
    } catch {}
  },
  BE = (t, e) => {
    const r = n => {
      (n.type === "pagehide" || Je.document.visibilityState === "hidden") && (t(n), e && (removeEventListener("visibilitychange", r, !0), removeEventListener("pagehide", r, !0)))
    };
    addEventListener("visibilitychange", r, !0), addEventListener("pagehide", r, !0)
  },
  xdt = t => {
    const e = _L("CLS", 0);
    let r, n = 0,
      i = [];
    const a = o => {
        o.forEach(c => {
          if (!c.hadRecentInput) {
            const l = i[0],
              u = i[i.length - 1];
            n && i.length !== 0 && c.startTime - u.startTime < 1e3 && c.startTime - l.startTime < 5e3 ? (n += c.value, i.push(c)) : (n = c.value, i = [c]), n > e.value && (e.value = n, e.entries = i, r && r())
          }
        })
      },
      s = Cg("layout-shift", a);
    if (s) {
      r = SL(t, e);
      const o = () => {
        a(s.takeRecords()), r(!0)
      };
      return BE(o), o
    }
  };
let uy = -1;
const bdt = () => Je.document.visibilityState === "hidden" && !Je.document.prerendering ? 0 : 1 / 0,
  Edt = () => {
    BE(({
      timeStamp: t
    }) => {
      uy = t
    }, !0)
  },
  TL = () => (uy < 0 && (uy = bdt(), Edt()), {
    get firstHiddenTime() {
      return uy
    }
  }),
  Sdt = t => {
    const e = TL(),
      r = _L("FID");
    let n;
    const i = o => {
        o.startTime < e.firstHiddenTime && (r.value = o.processingStart - o.startTime, r.entries.push(o), n(!0))
      },
      a = o => {
        o.forEach(i)
      },
      s = Cg("first-input", a);
    n = SL(t, r), s && BE(() => {
      a(s.takeRecords()), s.disconnect()
    }, !0)
  },
  V7 = {},
  _dt = t => {
    const e = TL(),
      r = _L("LCP");
    let n;
    const i = s => {
        const o = s[s.length - 1];
        if (o) {
          const c = Math.max(o.startTime - yee(), 0);
          c < e.firstHiddenTime && (r.value = c, r.entries = [o], n())
        }
      },
      a = Cg("largest-contentful-paint", i);
    if (a) {
      n = SL(t, r);
      const s = () => {
        V7[r.id] || (i(a.takeRecords()), a.disconnect(), V7[r.id] = !0, n(!0))
      };
      return ["keydown", "click"].forEach(o => {
        addEventListener(o, s, {
          once: !0,
          capture: !0
        })
      }), BE(s, !0), s
    }
  };

function Qw(t) {
  return typeof t == "number" && isFinite(t)
}

function Df(t, {
  startTimestamp: e,
  ...r
}) {
  return e && t.startTimestamp > e && (t.startTimestamp = e), t.startChild({
    startTimestamp: e,
    ...r
  })
}

function Lt(t) {
  return t / 1e3
}

function xee() {
  return Je && Je.addEventListener && Je.performance
}
let W7 = 0,
  bt = {},
  Qi, h0;

function Tdt() {
  const t = xee();
  if (t && jo) {
    t.mark && Je.performance.mark("sentry-tracing-init"), $dt();
    const e = Adt(),
      r = Idt();
    return () => {
      e && e(), r && r()
    }
  }
  return () => {}
}

function wdt() {
  Cg("longtask", e => {
    for (const r of e) {
      const n = $g();
      if (!n) return;
      const i = Lt(jo + r.startTime),
        a = Lt(r.duration);
      n.startChild({
        description: "Main UI thread blocked",
        op: "ui.long-task",
        startTimestamp: i,
        endTimestamp: i + a
      })
    }
  })
}

function Rdt() {
  Cg("event", e => {
    for (const r of e) {
      const n = $g();
      if (!n) return;
      if (r.name === "click") {
        const i = Lt(jo + r.startTime),
          a = Lt(r.duration);
        n.startChild({
          description: Of(r.target),
          op: `ui.interaction.${r.name}`,
          startTimestamp: i,
          endTimestamp: i + a
        })
      }
    }
  }, {
    durationThreshold: 0
  })
}

function Adt() {
  return xdt(t => {
    const e = t.entries.pop();
    e && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding CLS"), bt.cls = {
      value: t.value,
      unit: ""
    }, h0 = e)
  })
}

function Idt() {
  return _dt(t => {
    const e = t.entries.pop();
    e && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding LCP"), bt.lcp = {
      value: t.value,
      unit: "millisecond"
    }, Qi = e)
  })
}

function $dt() {
  Sdt(t => {
    const e = t.entries.pop();
    if (!e) return;
    const r = Lt(jo),
      n = Lt(e.startTime);
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding FID"), bt.fid = {
      value: t.value,
      unit: "millisecond"
    }, bt["mark.fid"] = {
      value: r + n,
      unit: "second"
    }
  })
}

function Cdt(t) {
  const e = xee();
  if (!e || !Je.performance.getEntries || !jo) return;
  (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Tracing] Adding & adjusting spans using Performance API");
  const r = Lt(jo),
    n = e.getEntries();
  let i, a;
  if (n.slice(W7).forEach(s => {
      const o = Lt(s.startTime),
        c = Lt(s.duration);
      if (!(t.op === "navigation" && r + o < t.startTimestamp)) switch (s.entryType) {
        case "navigation": {
          Odt(t, s, r), i = r + Lt(s.responseStart), a = r + Lt(s.requestStart);
          break
        }
        case "mark":
        case "paint":
        case "measure": {
          kdt(t, s, o, c, r);
          const l = TL(),
            u = s.startTime < l.firstHiddenTime;
          s.name === "first-paint" && u && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding FP"), bt.fp = {
            value: s.startTime,
            unit: "millisecond"
          }), s.name === "first-contentful-paint" && u && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding FCP"), bt.fcp = {
            value: s.startTime,
            unit: "millisecond"
          });
          break
        }
        case "resource": {
          const l = s.name.replace(Je.location.origin, "");
          Pdt(t, s, l, o, c, r);
          break
        }
      }
    }), W7 = Math.max(n.length - 1, 0), Ndt(t), t.op === "pageload") {
    typeof i == "number" && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding TTFB"), bt.ttfb = {
      value: (i - t.startTimestamp) * 1e3,
      unit: "millisecond"
    }, typeof a == "number" && a <= i && (bt["ttfb.requestTime"] = {
      value: (i - a) * 1e3,
      unit: "millisecond"
    })), ["fcp", "fp", "lcp"].forEach(o => {
      if (!bt[o] || r >= t.startTimestamp) return;
      const c = bt[o].value,
        l = r + Lt(c),
        u = Math.abs((l - t.startTimestamp) * 1e3),
        f = u - c;
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Measurements] Normalized ${o} from ${c} to ${u} (${f})`), bt[o].value = u
    });
    const s = bt["mark.fid"];
    s && bt.fid && (Df(t, {
      description: "first input delay",
      endTimestamp: s.value + Lt(bt.fid.value),
      op: "ui.action",
      startTimestamp: s.value
    }), delete bt["mark.fid"]), "fcp" in bt || delete bt.cls, Object.keys(bt).forEach(o => {
      t.setMeasurement(o, bt[o].value, bt[o].unit)
    }), Ddt(t)
  }
  Qi = void 0, h0 = void 0, bt = {}
}

function kdt(t, e, r, n, i) {
  const a = i + r,
    s = a + n;
  return Df(t, {
    description: e.name,
    endTimestamp: s,
    op: e.entryType,
    startTimestamp: a
  }), a
}

function Odt(t, e, r) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(n => {
    yv(t, e, n, r)
  }), yv(t, e, "secureConnection", r, "TLS/SSL", "connectEnd"), yv(t, e, "fetch", r, "cache", "domainLookupStart"), yv(t, e, "domainLookup", r, "DNS"), Ldt(t, e, r)
}

function yv(t, e, r, n, i, a) {
  const s = a ? e[a] : e[`${r}End`],
    o = e[`${r}Start`];
  !o || !s || Df(t, {
    op: "browser",
    description: i || r,
    startTimestamp: n + Lt(o),
    endTimestamp: n + Lt(s)
  })
}

function Ldt(t, e, r) {
  Df(t, {
    op: "browser",
    description: "request",
    startTimestamp: r + Lt(e.requestStart),
    endTimestamp: r + Lt(e.responseEnd)
  }), Df(t, {
    op: "browser",
    description: "response",
    startTimestamp: r + Lt(e.responseStart),
    endTimestamp: r + Lt(e.responseEnd)
  })
}

function Pdt(t, e, r, n, i, a) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch") return;
  const s = {};
  "transferSize" in e && (s["Transfer Size"] = e.transferSize), "encodedBodySize" in e && (s["Encoded Body Size"] = e.encodedBodySize), "decodedBodySize" in e && (s["Decoded Body Size"] = e.decodedBodySize), "renderBlockingStatus" in e && (s["resource.render_blocking_status"] = e.renderBlockingStatus);
  const o = a + n,
    c = o + i;
  Df(t, {
    description: r,
    endTimestamp: c,
    op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
    startTimestamp: o,
    data: s
  })
}

function Ndt(t) {
  const e = Je.navigator;
  if (!e) return;
  const r = e.connection;
  r && (r.effectiveType && t.setTag("effectiveConnectionType", r.effectiveType), r.type && t.setTag("connectionType", r.type), Qw(r.rtt) && (bt["connection.rtt"] = {
    value: r.rtt,
    unit: "millisecond"
  })), Qw(e.deviceMemory) && t.setTag("deviceMemory", `${e.deviceMemory} GB`), Qw(e.hardwareConcurrency) && t.setTag("hardwareConcurrency", String(e.hardwareConcurrency))
}

function Ddt(t) {
  Qi && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding LCP Data"), Qi.element && t.setTag("lcp.element", Of(Qi.element)), Qi.id && t.setTag("lcp.id", Qi.id), Qi.url && t.setTag("lcp.url", Qi.url.trim().slice(0, 200)), t.setTag("lcp.size", Qi.size)), h0 && h0.sources && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log("[Measurements] Adding CLS Data"), h0.sources.forEach((e, r) => t.setTag(`cls.source.${r+1}`, Of(e.node))))
}
const kI = ["localhost", /^\//],
  OI = {
    traceFetch: !0,
    traceXHR: !0,
    tracingOrigins: kI,
    tracePropagationTargets: kI
  };

function Mdt(t) {
  const {
    traceFetch: e,
    traceXHR: r,
    tracePropagationTargets: n,
    tracingOrigins: i,
    shouldCreateSpanForRequest: a
  } = {
    traceFetch: OI.traceFetch,
    traceXHR: OI.traceXHR,
    ...t
  }, s = typeof a == "function" ? a : l => !0, o = l => Fdt(l, n || i), c = {};
  e && wr("fetch", l => {
    Bdt(l, s, o, c)
  }), r && wr("xhr", l => {
    jdt(l, s, o, c)
  })
}

function Fdt(t, e) {
  return Rg(t, e || kI)
}

function Bdt(t, e, r, n) {
  if (!yL() || !(t.fetchData && e(t.fetchData.url))) return;
  if (t.endTimestamp) {
    const o = t.fetchData.__span;
    if (!o) return;
    const c = n[o];
    c && (t.response ? c.setHttpStatus(t.response.status) : t.error && c.setStatus("internal_error"), c.finish(), delete n[o]);
    return
  }
  const i = dt().getScope(),
    a = i && i.getSpan(),
    s = a && a.transaction;
  if (a && s) {
    const o = a.startChild({
      data: {
        ...t.fetchData,
        type: "fetch"
      },
      description: `${t.fetchData.method} ${t.fetchData.url}`,
      op: "http.client"
    });
    t.fetchData.__span = o.spanId, n[o.spanId] = o;
    const c = t.args[0];
    t.args[1] = t.args[1] || {};
    const l = t.args[1];
    r(t.fetchData.url) && (l.headers = Udt(c, s.getDynamicSamplingContext(), o, l))
  }
}

function Udt(t, e, r, n) {
  const i = QJ(e),
    a = r.toTraceparent(),
    s = typeof Request < "u" && Bo(t, Request) ? t.headers : n.headers;
  if (s)
    if (typeof Headers < "u" && Bo(s, Headers)) {
      const o = new Headers(s);
      return o.append("sentry-trace", a), i && o.append(RI, i), o
    } else if (Array.isArray(s)) {
    const o = [...s, ["sentry-trace", a]];
    return i && o.push([RI, i]), o
  } else {
    const o = "baggage" in s ? s.baggage : void 0,
      c = [];
    return Array.isArray(o) ? c.push(...o) : o && c.push(o), i && c.push(i), {
      ...s,
      "sentry-trace": a,
      baggage: c.length > 0 ? c.join(",") : void 0
    }
  } else return {
    "sentry-trace": a,
    baggage: i
  }
}

function jdt(t, e, r, n) {
  const i = t.xhr,
    a = i && i[Nl];
  if (!yL() || i && i.__sentry_own_request__ || !(i && a && e(a.url))) return;
  if (t.endTimestamp) {
    const l = i.__sentry_xhr_span_id__;
    if (!l) return;
    const u = n[l];
    u && (u.setHttpStatus(a.status_code), u.finish(), delete n[l]);
    return
  }
  const s = dt().getScope(),
    o = s && s.getSpan(),
    c = o && o.transaction;
  if (o && c) {
    const l = o.startChild({
      data: {
        ...a.data,
        type: "xhr",
        method: a.method,
        url: a.url
      },
      description: `${a.method} ${a.url}`,
      op: "http.client"
    });
    if (i.__sentry_xhr_span_id__ = l.spanId, n[i.__sentry_xhr_span_id__] = l, i.setRequestHeader && r(a.url)) try {
      i.setRequestHeader("sentry-trace", l.toTraceparent());
      const u = c.getDynamicSamplingContext(),
        f = QJ(u);
      f && i.setRequestHeader(RI, f)
    } catch {}
  }
}

function Hdt(t, e = !0, r = !0) {
  if (!Je || !Je.location) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn("Could not initialize routing instrumentation due to invalid location");
    return
  }
  let n = Je.location.href,
    i;
  e && (i = t({
    name: Je.location.pathname,
    startTimestamp: jo ? jo / 1e3 : void 0,
    op: "pageload",
    metadata: {
      source: "url"
    }
  })), r && wr("history", ({
    to: a,
    from: s
  }) => {
    if (s === void 0 && n && n.indexOf(a) !== -1) {
      n = void 0;
      return
    }
    s !== a && (n = void 0, i && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Finishing current transaction with op: ${i.op}`), i.finish()), i = t({
      name: Je.location.pathname,
      op: "navigation",
      metadata: {
        source: "url"
      }
    }))
  })
}
const zdt = "BrowserTracing",
  Gdt = {
    ...cy,
    markBackgroundTransactions: !0,
    routingInstrumentation: Hdt,
    startTransactionOnLocationChange: !0,
    startTransactionOnPageLoad: !0,
    enableLongTask: !0,
    _experiments: {},
    ...OI
  };
class wL {
  __init() {
    this.name = zdt
  }
  constructor(e) {
    wL.prototype.__init.call(this), Nut(), this.options = {
      ...Gdt,
      ...e
    }, this.options._experiments.enableLongTask !== void 0 && (this.options.enableLongTask = this.options._experiments.enableLongTask), e && !e.tracePropagationTargets && e.tracingOrigins && (this.options.tracePropagationTargets = e.tracingOrigins), this._collectWebVitals = Tdt(), this.options.enableLongTask && wdt(), this.options._experiments.enableInteractions && Rdt()
  }
  setupOnce(e, r) {
    this._getCurrentHub = r;
    const {
      routingInstrumentation: n,
      startTransactionOnLocationChange: i,
      startTransactionOnPageLoad: a,
      markBackgroundTransactions: s,
      traceFetch: o,
      traceXHR: c,
      tracePropagationTargets: l,
      shouldCreateSpanForRequest: u,
      _experiments: f
    } = this.options;
    n(d => {
      const h = this._createRouteTransaction(d);
      return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(h, d, r), h
    }, a, i), s && mdt(), f.enableInteractions && this._registerInteractionListener(), Mdt({
      traceFetch: o,
      traceXHR: c,
      tracePropagationTargets: l,
      shouldCreateSpanForRequest: u
    })
  }
  _createRouteTransaction(e) {
    if (!this._getCurrentHub) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Did not create ${e.op} transaction because _getCurrentHub is invalid.`);
      return
    }
    const {
      beforeNavigate: r,
      idleTimeout: n,
      finalTimeout: i,
      heartbeatInterval: a
    } = this.options, s = e.op === "pageload", o = s ? K7("sentry-trace") : null, c = s ? K7("baggage") : null, l = o ? rut(o) : void 0, u = c ? vut(c) : void 0, f = {
      ...e,
      ...l,
      metadata: {
        ...e.metadata,
        dynamicSamplingContext: l && !u ? {} : u
      },
      trimEnd: !0
    }, d = typeof r == "function" ? r(f) : f, h = d === void 0 ? {
      ...f,
      sampled: !1
    } : d;
    h.metadata = h.name !== f.name ? {
      ...h.metadata,
      source: "custom"
    } : h.metadata, this._latestRouteName = h.name, this._latestRouteSource = h.metadata && h.metadata.source, h.sampled === !1 && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Will not send ${h.op} transaction because of beforeNavigate.`), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.log(`[Tracing] Starting ${h.op} transaction on scope`);
    const p = this._getCurrentHub(),
      {
        location: v
      } = Je,
      g = N7(p, h, n, i, !0, {
        location: v
      }, a);
    return g.registerBeforeFinishCallback(m => {
      this._collectWebVitals(), Cdt(m)
    }), g
  }
  _registerInteractionListener() {
    let e;
    const r = () => {
      const {
        idleTimeout: n,
        finalTimeout: i,
        heartbeatInterval: a
      } = this.options, s = "ui.action.click", o = $g();
      if (o && o.op && ["navigation", "pageload"].includes(o.op)) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Did not create ${s} transaction because a pageload or navigation transaction is in progress.`);
        return
      }
      if (e && (e.setFinishReason("interactionInterrupted"), e.finish(), e = void 0), !this._getCurrentHub) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Did not create ${s} transaction because _getCurrentHub is invalid.`);
        return
      }
      if (!this._latestRouteName) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && J.warn(`[Tracing] Did not create ${s} transaction because _latestRouteName is missing.`);
        return
      }
      const c = this._getCurrentHub(),
        {
          location: l
        } = Je,
        u = {
          name: this._latestRouteName,
          op: s,
          trimEnd: !0,
          metadata: {
            source: this._latestRouteSource || "url"
          }
        };
      e = N7(c, u, n, i, !0, {
        location: l
      }, a)
    };
    ["click"].forEach(n => {
      addEventListener(n, r, {
        once: !1,
        capture: !0
      })
    })
  }
}

function K7(t) {
  const e = vct(`meta[name=${t}]`);
  return e ? e.getAttribute("content") : null
}

function Vdt(t) {
  t._metadata = t._metadata || {}, t._metadata.sdk = t._metadata.sdk || {
    name: "sentry.javascript.react",
    packages: [{
      name: "npm:@sentry/react",
      version: q1
    }],
    version: q1
  }, pdt(t)
}
Vdt({
  dsn: wMe,
  release: `movie-web@${kr().APP_VERSION}`,
  sampleRate: .5,
  integrations: [new wL, new Dl, new pp]
});
const Zw = "https://consumet-api-clone.vercel.app/meta/tmdb";

function Wdt({
  url: t,
  lang: e
}) {
  if (e.includes("(maybe)") || !rO(t)) return null;
  const n = Cq(t);
  return {
    url: t,
    langIso: e,
    type: n
  }
}
const Kdt = {
  360: Oe.Q360P,
  540: Oe.Q540P,
  480: Oe.Q480P,
  720: Oe.Q720P,
  1080: Oe.Q1080P
};

function Y7(t) {
  return t === "Movie" ? ae.MOVIE : ae.SERIES
}
Fi({
  id: "flixhq",
  displayName: "FlixHQ",
  rank: 100,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var l;
    if (!this.type.includes(t.meta.type)) throw new Error("Unsupported type");
    const i = (await Zh(`/${encodeURIComponent(t.meta.title)}`, {
      baseURL: Zw
    })).results.find(u => u.type !== "Movie" && u.type !== "TV Series" ? !1 : qk(u.title, t.meta.title) && Y7(u.type) === t.meta.type && u.releaseDate === t.meta.year);
    if (!i) throw new Error("No watchable item found");
    r(25);
    const a = await Zh(`/info/${i.id}`, {
      baseURL: Zw,
      params: {
        type: Y7(i.type)
      }
    });
    if (!a.id) throw new Error("No watchable item found");
    r(50);
    let s;
    if (t.meta.type === ae.MOVIE) s = a.episodeId;
    else if (t.meta.type === ae.SERIES) {
      const u = t.meta.seasonData.number,
        f = (l = t.meta.seasonData.episodes.find(h => h.id === e)) == null ? void 0 : l.number;
      s = a.seasons.find(h => h.season === u).episodes.find(h => h.episode === f).id
    }
    if (!s) throw new Error("No watchable item found");
    r(75);
    const o = await Zh(`/watch/${s}`, {
      baseURL: Zw,
      params: {
        id: a.id
      }
    });
    if (!o.sources) throw new Error("No watchable item found");
    const c = o.sources[0];
    return {
      embeds: [],
      stream: {
        streamUrl: c.url,
        quality: Kdt[c.quality],
        type: c.isM3U8 ? Ct.HLS : Ct.MP4,
        captions: o.subtitles.map(Wdt).filter(Boolean)
      }
    }
  }
});
var yp = {},
  Ydt = {
    get exports() {
      return yp
    },
    set exports(t) {
      yp = t
    }
  },
  Q1 = {},
  qdt = {
    get exports() {
      return Q1
    },
    set exports(t) {
      Q1 = t
    }
  };
const Xdt = {},
  Qdt = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Xdt
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  Zdt = Cee(Qdt);
var q7;

function Be() {
  return q7 || (q7 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n()
    })(me, function () {
      var r = r || function (n, i) {
        var a;
        if (typeof window < "u" && window.crypto && (a = window.crypto), typeof self < "u" && self.crypto && (a = self.crypto), typeof globalThis < "u" && globalThis.crypto && (a = globalThis.crypto), !a && typeof window < "u" && window.msCrypto && (a = window.msCrypto), !a && typeof me < "u" && me.crypto && (a = me.crypto), !a && typeof xut == "function") try {
          a = Zdt
        } catch {}
        var s = function () {
            if (a) {
              if (typeof a.getRandomValues == "function") try {
                return a.getRandomValues(new Uint32Array(1))[0]
              } catch {}
              if (typeof a.randomBytes == "function") try {
                return a.randomBytes(4).readInt32LE()
              } catch {}
            }
            throw new Error("Native crypto module could not be used to get secure random number.")
          },
          o = Object.create || function () {
            function y() {}
            return function (x) {
              var b;
              return y.prototype = x, b = new y, y.prototype = null, b
            }
          }(),
          c = {},
          l = c.lib = {},
          u = l.Base = function () {
            return {
              extend: function (y) {
                var x = o(this);
                return y && x.mixIn(y), (!x.hasOwnProperty("init") || this.init === x.init) && (x.init = function () {
                  x.$super.init.apply(this, arguments)
                }), x.init.prototype = x, x.$super = this, x
              },
              create: function () {
                var y = this.extend();
                return y.init.apply(y, arguments), y
              },
              init: function () {},
              mixIn: function (y) {
                for (var x in y) y.hasOwnProperty(x) && (this[x] = y[x]);
                y.hasOwnProperty("toString") && (this.toString = y.toString)
              },
              clone: function () {
                return this.init.prototype.extend(this)
              }
            }
          }(),
          f = l.WordArray = u.extend({
            init: function (y, x) {
              y = this.words = y || [], x != i ? this.sigBytes = x : this.sigBytes = y.length * 4
            },
            toString: function (y) {
              return (y || h).stringify(this)
            },
            concat: function (y) {
              var x = this.words,
                b = y.words,
                _ = this.sigBytes,
                S = y.sigBytes;
              if (this.clamp(), _ % 4)
                for (var T = 0; T < S; T++) {
                  var R = b[T >>> 2] >>> 24 - T % 4 * 8 & 255;
                  x[_ + T >>> 2] |= R << 24 - (_ + T) % 4 * 8
                } else
                  for (var I = 0; I < S; I += 4) x[_ + I >>> 2] = b[I >>> 2];
              return this.sigBytes += S, this
            },
            clamp: function () {
              var y = this.words,
                x = this.sigBytes;
              y[x >>> 2] &= 4294967295 << 32 - x % 4 * 8, y.length = n.ceil(x / 4)
            },
            clone: function () {
              var y = u.clone.call(this);
              return y.words = this.words.slice(0), y
            },
            random: function (y) {
              for (var x = [], b = 0; b < y; b += 4) x.push(s());
              return new f.init(x, y)
            }
          }),
          d = c.enc = {},
          h = d.Hex = {
            stringify: function (y) {
              for (var x = y.words, b = y.sigBytes, _ = [], S = 0; S < b; S++) {
                var T = x[S >>> 2] >>> 24 - S % 4 * 8 & 255;
                _.push((T >>> 4).toString(16)), _.push((T & 15).toString(16))
              }
              return _.join("")
            },
            parse: function (y) {
              for (var x = y.length, b = [], _ = 0; _ < x; _ += 2) b[_ >>> 3] |= parseInt(y.substr(_, 2), 16) << 24 - _ % 8 * 4;
              return new f.init(b, x / 2)
            }
          },
          p = d.Latin1 = {
            stringify: function (y) {
              for (var x = y.words, b = y.sigBytes, _ = [], S = 0; S < b; S++) {
                var T = x[S >>> 2] >>> 24 - S % 4 * 8 & 255;
                _.push(String.fromCharCode(T))
              }
              return _.join("")
            },
            parse: function (y) {
              for (var x = y.length, b = [], _ = 0; _ < x; _++) b[_ >>> 2] |= (y.charCodeAt(_) & 255) << 24 - _ % 4 * 8;
              return new f.init(b, x)
            }
          },
          v = d.Utf8 = {
            stringify: function (y) {
              try {
                return decodeURIComponent(escape(p.stringify(y)))
              } catch {
                throw new Error("Malformed UTF-8 data")
              }
            },
            parse: function (y) {
              return p.parse(unescape(encodeURIComponent(y)))
            }
          },
          g = l.BufferedBlockAlgorithm = u.extend({
            reset: function () {
              this._data = new f.init, this._nDataBytes = 0
            },
            _append: function (y) {
              typeof y == "string" && (y = v.parse(y)), this._data.concat(y), this._nDataBytes += y.sigBytes
            },
            _process: function (y) {
              var x, b = this._data,
                _ = b.words,
                S = b.sigBytes,
                T = this.blockSize,
                R = T * 4,
                I = S / R;
              y ? I = n.ceil(I) : I = n.max((I | 0) - this._minBufferSize, 0);
              var w = I * T,
                C = n.min(w * 4, S);
              if (w) {
                for (var L = 0; L < w; L += T) this._doProcessBlock(_, L);
                x = _.splice(0, w), b.sigBytes -= C
              }
              return new f.init(x, C)
            },
            clone: function () {
              var y = u.clone.call(this);
              return y._data = this._data.clone(), y
            },
            _minBufferSize: 0
          });
        l.Hasher = g.extend({
          cfg: u.extend(),
          init: function (y) {
            this.cfg = this.cfg.extend(y), this.reset()
          },
          reset: function () {
            g.reset.call(this), this._doReset()
          },
          update: function (y) {
            return this._append(y), this._process(), this
          },
          finalize: function (y) {
            y && this._append(y);
            var x = this._doFinalize();
            return x
          },
          blockSize: 16,
          _createHelper: function (y) {
            return function (x, b) {
              return new y.init(b).finalize(x)
            }
          },
          _createHmacHelper: function (y) {
            return function (x, b) {
              return new m.HMAC.init(y, b).finalize(x)
            }
          }
        });
        var m = c.algo = {};
        return c
      }(Math);
      return r
    })
  }(qdt)), Q1
}
var Z1 = {},
  Jdt = {
    get exports() {
      return Z1
    },
    set exports(t) {
      Z1 = t
    }
  },
  X7;

function UE() {
  return X7 || (X7 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.Base,
          o = a.WordArray,
          c = i.x64 = {};
        c.Word = s.extend({
          init: function (l, u) {
            this.high = l, this.low = u
          }
        }), c.WordArray = s.extend({
          init: function (l, u) {
            l = this.words = l || [], u != n ? this.sigBytes = u : this.sigBytes = l.length * 8
          },
          toX32: function () {
            for (var l = this.words, u = l.length, f = [], d = 0; d < u; d++) {
              var h = l[d];
              f.push(h.high), f.push(h.low)
            }
            return o.create(f, this.sigBytes)
          },
          clone: function () {
            for (var l = s.clone.call(this), u = l.words = this.words.slice(0), f = u.length, d = 0; d < f; d++) u[d] = u[d].clone();
            return l
          }
        })
      }(), r
    })
  }(Jdt)), Z1
}
var J1 = {},
  eht = {
    get exports() {
      return J1
    },
    set exports(t) {
      J1 = t
    }
  },
  Q7;

function tht() {
  return Q7 || (Q7 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function () {
        if (typeof ArrayBuffer == "function") {
          var n = r,
            i = n.lib,
            a = i.WordArray,
            s = a.init,
            o = a.init = function (c) {
              if (c instanceof ArrayBuffer && (c = new Uint8Array(c)), (c instanceof Int8Array || typeof Uint8ClampedArray < "u" && c instanceof Uint8ClampedArray || c instanceof Int16Array || c instanceof Uint16Array || c instanceof Int32Array || c instanceof Uint32Array || c instanceof Float32Array || c instanceof Float64Array) && (c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength)), c instanceof Uint8Array) {
                for (var l = c.byteLength, u = [], f = 0; f < l; f++) u[f >>> 2] |= c[f] << 24 - f % 4 * 8;
                s.call(this, u, l)
              } else s.apply(this, arguments)
            };
          o.prototype = a
        }
      }(), r.lib.WordArray
    })
  }(eht)), J1
}
var ex = {},
  rht = {
    get exports() {
      return ex
    },
    set exports(t) {
      ex = t
    }
  },
  Z7;

function nht() {
  return Z7 || (Z7 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.WordArray,
          s = n.enc;
        s.Utf16 = s.Utf16BE = {
          stringify: function (c) {
            for (var l = c.words, u = c.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = l[d >>> 2] >>> 16 - d % 4 * 8 & 65535;
              f.push(String.fromCharCode(h))
            }
            return f.join("")
          },
          parse: function (c) {
            for (var l = c.length, u = [], f = 0; f < l; f++) u[f >>> 1] |= c.charCodeAt(f) << 16 - f % 2 * 16;
            return a.create(u, l * 2)
          }
        }, s.Utf16LE = {
          stringify: function (c) {
            for (var l = c.words, u = c.sigBytes, f = [], d = 0; d < u; d += 2) {
              var h = o(l[d >>> 2] >>> 16 - d % 4 * 8 & 65535);
              f.push(String.fromCharCode(h))
            }
            return f.join("")
          },
          parse: function (c) {
            for (var l = c.length, u = [], f = 0; f < l; f++) u[f >>> 1] |= o(c.charCodeAt(f) << 16 - f % 2 * 16);
            return a.create(u, l * 2)
          }
        };

        function o(c) {
          return c << 8 & 4278255360 | c >>> 8 & 16711935
        }
      }(), r.enc.Utf16
    })
  }(rht)), ex
}
var fs = {},
  iht = {
    get exports() {
      return fs
    },
    set exports(t) {
      fs = t
    }
  };
(function (t, e) {
  (function (r, n) {
    t.exports = n(Be())
  })(me, function (r) {
    return function () {
      var n = r,
        i = n.lib,
        a = i.WordArray,
        s = n.enc;
      s.Base64 = {
        stringify: function (c) {
          var l = c.words,
            u = c.sigBytes,
            f = this._map;
          c.clamp();
          for (var d = [], h = 0; h < u; h += 3)
            for (var p = l[h >>> 2] >>> 24 - h % 4 * 8 & 255, v = l[h + 1 >>> 2] >>> 24 - (h + 1) % 4 * 8 & 255, g = l[h + 2 >>> 2] >>> 24 - (h + 2) % 4 * 8 & 255, m = p << 16 | v << 8 | g, y = 0; y < 4 && h + y * .75 < u; y++) d.push(f.charAt(m >>> 6 * (3 - y) & 63));
          var x = f.charAt(64);
          if (x)
            for (; d.length % 4;) d.push(x);
          return d.join("")
        },
        parse: function (c) {
          var l = c.length,
            u = this._map,
            f = this._reverseMap;
          if (!f) {
            f = this._reverseMap = [];
            for (var d = 0; d < u.length; d++) f[u.charCodeAt(d)] = d
          }
          var h = u.charAt(64);
          if (h) {
            var p = c.indexOf(h);
            p !== -1 && (l = p)
          }
          return o(c, l, f)
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };

      function o(c, l, u) {
        for (var f = [], d = 0, h = 0; h < l; h++)
          if (h % 4) {
            var p = u[c.charCodeAt(h - 1)] << h % 4 * 2,
              v = u[c.charCodeAt(h)] >>> 6 - h % 4 * 2,
              g = p | v;
            f[d >>> 2] |= g << 24 - d % 4 * 8, d++
          } return a.create(f, d)
      }
    }(), r.enc.Base64
  })
})(iht);
const bee = fs;
var tx = {},
  aht = {
    get exports() {
      return tx
    },
    set exports(t) {
      tx = t
    }
  },
  J7;

function sht() {
  return J7 || (J7 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.WordArray,
          s = n.enc;
        s.Base64url = {
          stringify: function (c, l = !0) {
            var u = c.words,
              f = c.sigBytes,
              d = l ? this._safe_map : this._map;
            c.clamp();
            for (var h = [], p = 0; p < f; p += 3)
              for (var v = u[p >>> 2] >>> 24 - p % 4 * 8 & 255, g = u[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, m = u[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, y = v << 16 | g << 8 | m, x = 0; x < 4 && p + x * .75 < f; x++) h.push(d.charAt(y >>> 6 * (3 - x) & 63));
            var b = d.charAt(64);
            if (b)
              for (; h.length % 4;) h.push(b);
            return h.join("")
          },
          parse: function (c, l = !0) {
            var u = c.length,
              f = l ? this._safe_map : this._map,
              d = this._reverseMap;
            if (!d) {
              d = this._reverseMap = [];
              for (var h = 0; h < f.length; h++) d[f.charCodeAt(h)] = h
            }
            var p = f.charAt(64);
            if (p) {
              var v = c.indexOf(p);
              v !== -1 && (u = v)
            }
            return o(c, u, d)
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };

        function o(c, l, u) {
          for (var f = [], d = 0, h = 0; h < l; h++)
            if (h % 4) {
              var p = u[c.charCodeAt(h - 1)] << h % 4 * 2,
                v = u[c.charCodeAt(h)] >>> 6 - h % 4 * 2,
                g = p | v;
              f[d >>> 2] |= g << 24 - d % 4 * 8, d++
            } return a.create(f, d)
        }
      }(), r.enc.Base64url
    })
  }(aht)), tx
}
var rx = {},
  oht = {
    get exports() {
      return rx
    },
    set exports(t) {
      rx = t
    }
  },
  e9;

function yd() {
  return e9 || (e9 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.WordArray,
          o = a.Hasher,
          c = i.algo,
          l = [];
        (function () {
          for (var v = 0; v < 64; v++) l[v] = n.abs(n.sin(v + 1)) * 4294967296 | 0
        })();
        var u = c.MD5 = o.extend({
          _doReset: function () {
            this._hash = new s.init([1732584193, 4023233417, 2562383102, 271733878])
          },
          _doProcessBlock: function (v, g) {
            for (var m = 0; m < 16; m++) {
              var y = g + m,
                x = v[y];
              v[y] = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360
            }
            var b = this._hash.words,
              _ = v[g + 0],
              S = v[g + 1],
              T = v[g + 2],
              R = v[g + 3],
              I = v[g + 4],
              w = v[g + 5],
              C = v[g + 6],
              L = v[g + 7],
              H = v[g + 8],
              N = v[g + 9],
              P = v[g + 10],
              B = v[g + 11],
              V = v[g + 12],
              M = v[g + 13],
              U = v[g + 14],
              W = v[g + 15],
              k = b[0],
              O = b[1],
              F = b[2],
              D = b[3];
            k = f(k, O, F, D, _, 7, l[0]), D = f(D, k, O, F, S, 12, l[1]), F = f(F, D, k, O, T, 17, l[2]), O = f(O, F, D, k, R, 22, l[3]), k = f(k, O, F, D, I, 7, l[4]), D = f(D, k, O, F, w, 12, l[5]), F = f(F, D, k, O, C, 17, l[6]), O = f(O, F, D, k, L, 22, l[7]), k = f(k, O, F, D, H, 7, l[8]), D = f(D, k, O, F, N, 12, l[9]), F = f(F, D, k, O, P, 17, l[10]), O = f(O, F, D, k, B, 22, l[11]), k = f(k, O, F, D, V, 7, l[12]), D = f(D, k, O, F, M, 12, l[13]), F = f(F, D, k, O, U, 17, l[14]), O = f(O, F, D, k, W, 22, l[15]), k = d(k, O, F, D, S, 5, l[16]), D = d(D, k, O, F, C, 9, l[17]), F = d(F, D, k, O, B, 14, l[18]), O = d(O, F, D, k, _, 20, l[19]), k = d(k, O, F, D, w, 5, l[20]), D = d(D, k, O, F, P, 9, l[21]), F = d(F, D, k, O, W, 14, l[22]), O = d(O, F, D, k, I, 20, l[23]), k = d(k, O, F, D, N, 5, l[24]), D = d(D, k, O, F, U, 9, l[25]), F = d(F, D, k, O, R, 14, l[26]), O = d(O, F, D, k, H, 20, l[27]), k = d(k, O, F, D, M, 5, l[28]), D = d(D, k, O, F, T, 9, l[29]), F = d(F, D, k, O, L, 14, l[30]), O = d(O, F, D, k, V, 20, l[31]), k = h(k, O, F, D, w, 4, l[32]), D = h(D, k, O, F, H, 11, l[33]), F = h(F, D, k, O, B, 16, l[34]), O = h(O, F, D, k, U, 23, l[35]), k = h(k, O, F, D, S, 4, l[36]), D = h(D, k, O, F, I, 11, l[37]), F = h(F, D, k, O, L, 16, l[38]), O = h(O, F, D, k, P, 23, l[39]), k = h(k, O, F, D, M, 4, l[40]), D = h(D, k, O, F, _, 11, l[41]), F = h(F, D, k, O, R, 16, l[42]), O = h(O, F, D, k, C, 23, l[43]), k = h(k, O, F, D, N, 4, l[44]), D = h(D, k, O, F, V, 11, l[45]), F = h(F, D, k, O, W, 16, l[46]), O = h(O, F, D, k, T, 23, l[47]), k = p(k, O, F, D, _, 6, l[48]), D = p(D, k, O, F, L, 10, l[49]), F = p(F, D, k, O, U, 15, l[50]), O = p(O, F, D, k, w, 21, l[51]), k = p(k, O, F, D, V, 6, l[52]), D = p(D, k, O, F, R, 10, l[53]), F = p(F, D, k, O, P, 15, l[54]), O = p(O, F, D, k, S, 21, l[55]), k = p(k, O, F, D, H, 6, l[56]), D = p(D, k, O, F, W, 10, l[57]), F = p(F, D, k, O, C, 15, l[58]), O = p(O, F, D, k, M, 21, l[59]), k = p(k, O, F, D, I, 6, l[60]), D = p(D, k, O, F, B, 10, l[61]), F = p(F, D, k, O, T, 15, l[62]), O = p(O, F, D, k, N, 21, l[63]), b[0] = b[0] + k | 0, b[1] = b[1] + O | 0, b[2] = b[2] + F | 0, b[3] = b[3] + D | 0
          },
          _doFinalize: function () {
            var v = this._data,
              g = v.words,
              m = this._nDataBytes * 8,
              y = v.sigBytes * 8;
            g[y >>> 5] |= 128 << 24 - y % 32;
            var x = n.floor(m / 4294967296),
              b = m;
            g[(y + 64 >>> 9 << 4) + 15] = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360, g[(y + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360, v.sigBytes = (g.length + 1) * 4, this._process();
            for (var _ = this._hash, S = _.words, T = 0; T < 4; T++) {
              var R = S[T];
              S[T] = (R << 8 | R >>> 24) & 16711935 | (R << 24 | R >>> 8) & 4278255360
            }
            return _
          },
          clone: function () {
            var v = o.clone.call(this);
            return v._hash = this._hash.clone(), v
          }
        });

        function f(v, g, m, y, x, b, _) {
          var S = v + (g & m | ~g & y) + x + _;
          return (S << b | S >>> 32 - b) + g
        }

        function d(v, g, m, y, x, b, _) {
          var S = v + (g & y | m & ~y) + x + _;
          return (S << b | S >>> 32 - b) + g
        }

        function h(v, g, m, y, x, b, _) {
          var S = v + (g ^ m ^ y) + x + _;
          return (S << b | S >>> 32 - b) + g
        }

        function p(v, g, m, y, x, b, _) {
          var S = v + (m ^ (g | ~y)) + x + _;
          return (S << b | S >>> 32 - b) + g
        }
        i.MD5 = o._createHelper(u), i.HmacMD5 = o._createHmacHelper(u)
      }(Math), r.MD5
    })
  }(oht)), rx
}
var nx = {},
  lht = {
    get exports() {
      return nx
    },
    set exports(t) {
      nx = t
    }
  },
  t9;

function RL() {
  return t9 || (t9 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.WordArray,
          s = i.Hasher,
          o = n.algo,
          c = [],
          l = o.SHA1 = s.extend({
            _doReset: function () {
              this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
            },
            _doProcessBlock: function (u, f) {
              for (var d = this._hash.words, h = d[0], p = d[1], v = d[2], g = d[3], m = d[4], y = 0; y < 80; y++) {
                if (y < 16) c[y] = u[f + y] | 0;
                else {
                  var x = c[y - 3] ^ c[y - 8] ^ c[y - 14] ^ c[y - 16];
                  c[y] = x << 1 | x >>> 31
                }
                var b = (h << 5 | h >>> 27) + m + c[y];
                y < 20 ? b += (p & v | ~p & g) + 1518500249 : y < 40 ? b += (p ^ v ^ g) + 1859775393 : y < 60 ? b += (p & v | p & g | v & g) - 1894007588 : b += (p ^ v ^ g) - 899497514, m = g, g = v, v = p << 30 | p >>> 2, p = h, h = b
              }
              d[0] = d[0] + h | 0, d[1] = d[1] + p | 0, d[2] = d[2] + v | 0, d[3] = d[3] + g | 0, d[4] = d[4] + m | 0
            },
            _doFinalize: function () {
              var u = this._data,
                f = u.words,
                d = this._nDataBytes * 8,
                h = u.sigBytes * 8;
              return f[h >>> 5] |= 128 << 24 - h % 32, f[(h + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296), f[(h + 64 >>> 9 << 4) + 15] = d, u.sigBytes = f.length * 4, this._process(), this._hash
            },
            clone: function () {
              var u = s.clone.call(this);
              return u._hash = this._hash.clone(), u
            }
          });
        n.SHA1 = s._createHelper(l), n.HmacSHA1 = s._createHmacHelper(l)
      }(), r.SHA1
    })
  }(lht)), nx
}
var ix = {},
  cht = {
    get exports() {
      return ix
    },
    set exports(t) {
      ix = t
    }
  },
  r9;

function Eee() {
  return r9 || (r9 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.WordArray,
          o = a.Hasher,
          c = i.algo,
          l = [],
          u = [];
        (function () {
          function h(m) {
            for (var y = n.sqrt(m), x = 2; x <= y; x++)
              if (!(m % x)) return !1;
            return !0
          }

          function p(m) {
            return (m - (m | 0)) * 4294967296 | 0
          }
          for (var v = 2, g = 0; g < 64;) h(v) && (g < 8 && (l[g] = p(n.pow(v, 1 / 2))), u[g] = p(n.pow(v, 1 / 3)), g++), v++
        })();
        var f = [],
          d = c.SHA256 = o.extend({
            _doReset: function () {
              this._hash = new s.init(l.slice(0))
            },
            _doProcessBlock: function (h, p) {
              for (var v = this._hash.words, g = v[0], m = v[1], y = v[2], x = v[3], b = v[4], _ = v[5], S = v[6], T = v[7], R = 0; R < 64; R++) {
                if (R < 16) f[R] = h[p + R] | 0;
                else {
                  var I = f[R - 15],
                    w = (I << 25 | I >>> 7) ^ (I << 14 | I >>> 18) ^ I >>> 3,
                    C = f[R - 2],
                    L = (C << 15 | C >>> 17) ^ (C << 13 | C >>> 19) ^ C >>> 10;
                  f[R] = w + f[R - 7] + L + f[R - 16]
                }
                var H = b & _ ^ ~b & S,
                  N = g & m ^ g & y ^ m & y,
                  P = (g << 30 | g >>> 2) ^ (g << 19 | g >>> 13) ^ (g << 10 | g >>> 22),
                  B = (b << 26 | b >>> 6) ^ (b << 21 | b >>> 11) ^ (b << 7 | b >>> 25),
                  V = T + B + H + u[R] + f[R],
                  M = P + N;
                T = S, S = _, _ = b, b = x + V | 0, x = y, y = m, m = g, g = V + M | 0
              }
              v[0] = v[0] + g | 0, v[1] = v[1] + m | 0, v[2] = v[2] + y | 0, v[3] = v[3] + x | 0, v[4] = v[4] + b | 0, v[5] = v[5] + _ | 0, v[6] = v[6] + S | 0, v[7] = v[7] + T | 0
            },
            _doFinalize: function () {
              var h = this._data,
                p = h.words,
                v = this._nDataBytes * 8,
                g = h.sigBytes * 8;
              return p[g >>> 5] |= 128 << 24 - g % 32, p[(g + 64 >>> 9 << 4) + 14] = n.floor(v / 4294967296), p[(g + 64 >>> 9 << 4) + 15] = v, h.sigBytes = p.length * 4, this._process(), this._hash
            },
            clone: function () {
              var h = o.clone.call(this);
              return h._hash = this._hash.clone(), h
            }
          });
        i.SHA256 = o._createHelper(d), i.HmacSHA256 = o._createHmacHelper(d)
      }(Math), r.SHA256
    })
  }(cht)), ix
}
var ax = {},
  uht = {
    get exports() {
      return ax
    },
    set exports(t) {
      ax = t
    }
  },
  n9;

function fht() {
  return n9 || (n9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), Eee())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.WordArray,
          s = n.algo,
          o = s.SHA256,
          c = s.SHA224 = o.extend({
            _doReset: function () {
              this._hash = new a.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
            },
            _doFinalize: function () {
              var l = o._doFinalize.call(this);
              return l.sigBytes -= 4, l
            }
          });
        n.SHA224 = o._createHelper(c), n.HmacSHA224 = o._createHmacHelper(c)
      }(), r.SHA224
    })
  }(uht)), ax
}
var sx = {},
  dht = {
    get exports() {
      return sx
    },
    set exports(t) {
      sx = t
    }
  },
  i9;

function See() {
  return i9 || (i9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), UE())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.Hasher,
          s = n.x64,
          o = s.Word,
          c = s.WordArray,
          l = n.algo;

        function u() {
          return o.create.apply(o, arguments)
        }
        var f = [u(1116352408, 3609767458), u(1899447441, 602891725), u(3049323471, 3964484399), u(3921009573, 2173295548), u(961987163, 4081628472), u(1508970993, 3053834265), u(2453635748, 2937671579), u(2870763221, 3664609560), u(3624381080, 2734883394), u(310598401, 1164996542), u(607225278, 1323610764), u(1426881987, 3590304994), u(1925078388, 4068182383), u(2162078206, 991336113), u(2614888103, 633803317), u(3248222580, 3479774868), u(3835390401, 2666613458), u(4022224774, 944711139), u(264347078, 2341262773), u(604807628, 2007800933), u(770255983, 1495990901), u(1249150122, 1856431235), u(1555081692, 3175218132), u(1996064986, 2198950837), u(2554220882, 3999719339), u(2821834349, 766784016), u(2952996808, 2566594879), u(3210313671, 3203337956), u(3336571891, 1034457026), u(3584528711, 2466948901), u(113926993, 3758326383), u(338241895, 168717936), u(666307205, 1188179964), u(773529912, 1546045734), u(1294757372, 1522805485), u(1396182291, 2643833823), u(1695183700, 2343527390), u(1986661051, 1014477480), u(2177026350, 1206759142), u(2456956037, 344077627), u(2730485921, 1290863460), u(2820302411, 3158454273), u(3259730800, 3505952657), u(3345764771, 106217008), u(3516065817, 3606008344), u(3600352804, 1432725776), u(4094571909, 1467031594), u(275423344, 851169720), u(430227734, 3100823752), u(506948616, 1363258195), u(659060556, 3750685593), u(883997877, 3785050280), u(958139571, 3318307427), u(1322822218, 3812723403), u(1537002063, 2003034995), u(1747873779, 3602036899), u(1955562222, 1575990012), u(2024104815, 1125592928), u(2227730452, 2716904306), u(2361852424, 442776044), u(2428436474, 593698344), u(2756734187, 3733110249), u(3204031479, 2999351573), u(3329325298, 3815920427), u(3391569614, 3928383900), u(3515267271, 566280711), u(3940187606, 3454069534), u(4118630271, 4000239992), u(116418474, 1914138554), u(174292421, 2731055270), u(289380356, 3203993006), u(460393269, 320620315), u(685471733, 587496836), u(852142971, 1086792851), u(1017036298, 365543100), u(1126000580, 2618297676), u(1288033470, 3409855158), u(1501505948, 4234509866), u(1607167915, 987167468), u(1816402316, 1246189591)],
          d = [];
        (function () {
          for (var p = 0; p < 80; p++) d[p] = u()
        })();
        var h = l.SHA512 = a.extend({
          _doReset: function () {
            this._hash = new c.init([new o.init(1779033703, 4089235720), new o.init(3144134277, 2227873595), new o.init(1013904242, 4271175723), new o.init(2773480762, 1595750129), new o.init(1359893119, 2917565137), new o.init(2600822924, 725511199), new o.init(528734635, 4215389547), new o.init(1541459225, 327033209)])
          },
          _doProcessBlock: function (p, v) {
            for (var g = this._hash.words, m = g[0], y = g[1], x = g[2], b = g[3], _ = g[4], S = g[5], T = g[6], R = g[7], I = m.high, w = m.low, C = y.high, L = y.low, H = x.high, N = x.low, P = b.high, B = b.low, V = _.high, M = _.low, U = S.high, W = S.low, k = T.high, O = T.low, F = R.high, D = R.low, Q = I, ee = w, de = C, oe = L, rt = H, Ft = N, Dr = P, un = B, Tt = V, wt = M, Ia = U, As = W, Zo = k, Jo = O, el = F, fi = D, Bt = 0; Bt < 80; Bt++) {
              var kt, di, tl = d[Bt];
              if (Bt < 16) di = tl.high = p[v + Bt * 2] | 0, kt = tl.low = p[v + Bt * 2 + 1] | 0;
              else {
                var xd = d[Bt - 15],
                  ji = xd.high,
                  Is = xd.low,
                  Ic = (ji >>> 1 | Is << 31) ^ (ji >>> 8 | Is << 24) ^ ji >>> 7,
                  rl = (Is >>> 1 | ji << 31) ^ (Is >>> 8 | ji << 24) ^ (Is >>> 7 | ji << 25),
                  kn = d[Bt - 2],
                  fn = kn.high,
                  $a = kn.low,
                  bd = (fn >>> 19 | $a << 13) ^ (fn << 3 | $a >>> 29) ^ fn >>> 6,
                  kg = ($a >>> 19 | fn << 13) ^ ($a << 3 | fn >>> 29) ^ ($a >>> 6 | fn << 26),
                  Hi = d[Bt - 7],
                  jE = Hi.high,
                  HE = Hi.low,
                  Rt = d[Bt - 16],
                  $s = Rt.high,
                  Og = Rt.low;
                kt = rl + HE, di = Ic + jE + (kt >>> 0 < rl >>> 0 ? 1 : 0), kt = kt + kg, di = di + bd + (kt >>> 0 < kg >>> 0 ? 1 : 0), kt = kt + Og, di = di + $s + (kt >>> 0 < Og >>> 0 ? 1 : 0), tl.high = di, tl.low = kt
              }
              var Lg = Tt & Ia ^ ~Tt & Zo,
                $c = wt & As ^ ~wt & Jo,
                Pg = Q & de ^ Q & rt ^ de & rt,
                Ng = ee & oe ^ ee & Ft ^ oe & Ft,
                zE = (Q >>> 28 | ee << 4) ^ (Q << 30 | ee >>> 2) ^ (Q << 25 | ee >>> 7),
                nl = (ee >>> 28 | Q << 4) ^ (ee << 30 | Q >>> 2) ^ (ee << 25 | Q >>> 7),
                Ed = (Tt >>> 14 | wt << 18) ^ (Tt >>> 18 | wt << 14) ^ (Tt << 23 | wt >>> 9),
                GE = (wt >>> 14 | Tt << 18) ^ (wt >>> 18 | Tt << 14) ^ (wt << 23 | Tt >>> 9),
                zi = f[Bt],
                Sd = zi.high,
                _d = zi.low,
                cr = fi + GE,
                Gi = el + Ed + (cr >>> 0 < fi >>> 0 ? 1 : 0),
                cr = cr + $c,
                Gi = Gi + Lg + (cr >>> 0 < $c >>> 0 ? 1 : 0),
                cr = cr + _d,
                Gi = Gi + Sd + (cr >>> 0 < _d >>> 0 ? 1 : 0),
                cr = cr + kt,
                Gi = Gi + di + (cr >>> 0 < kt >>> 0 ? 1 : 0),
                il = nl + Ng,
                hi = zE + Pg + (il >>> 0 < nl >>> 0 ? 1 : 0);
              el = Zo, fi = Jo, Zo = Ia, Jo = As, Ia = Tt, As = wt, wt = un + cr | 0, Tt = Dr + Gi + (wt >>> 0 < un >>> 0 ? 1 : 0) | 0, Dr = rt, un = Ft, rt = de, Ft = oe, de = Q, oe = ee, ee = cr + il | 0, Q = Gi + hi + (ee >>> 0 < cr >>> 0 ? 1 : 0) | 0
            }
            w = m.low = w + ee, m.high = I + Q + (w >>> 0 < ee >>> 0 ? 1 : 0), L = y.low = L + oe, y.high = C + de + (L >>> 0 < oe >>> 0 ? 1 : 0), N = x.low = N + Ft, x.high = H + rt + (N >>> 0 < Ft >>> 0 ? 1 : 0), B = b.low = B + un, b.high = P + Dr + (B >>> 0 < un >>> 0 ? 1 : 0), M = _.low = M + wt, _.high = V + Tt + (M >>> 0 < wt >>> 0 ? 1 : 0), W = S.low = W + As, S.high = U + Ia + (W >>> 0 < As >>> 0 ? 1 : 0), O = T.low = O + Jo, T.high = k + Zo + (O >>> 0 < Jo >>> 0 ? 1 : 0), D = R.low = D + fi, R.high = F + el + (D >>> 0 < fi >>> 0 ? 1 : 0)
          },
          _doFinalize: function () {
            var p = this._data,
              v = p.words,
              g = this._nDataBytes * 8,
              m = p.sigBytes * 8;
            v[m >>> 5] |= 128 << 24 - m % 32, v[(m + 128 >>> 10 << 5) + 30] = Math.floor(g / 4294967296), v[(m + 128 >>> 10 << 5) + 31] = g, p.sigBytes = v.length * 4, this._process();
            var y = this._hash.toX32();
            return y
          },
          clone: function () {
            var p = a.clone.call(this);
            return p._hash = this._hash.clone(), p
          },
          blockSize: 1024 / 32
        });
        n.SHA512 = a._createHelper(h), n.HmacSHA512 = a._createHmacHelper(h)
      }(), r.SHA512
    })
  }(dht)), sx
}
var ox = {},
  hht = {
    get exports() {
      return ox
    },
    set exports(t) {
      ox = t
    }
  },
  a9;

function pht() {
  return a9 || (a9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), UE(), See())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.x64,
          a = i.Word,
          s = i.WordArray,
          o = n.algo,
          c = o.SHA512,
          l = o.SHA384 = c.extend({
            _doReset: function () {
              this._hash = new s.init([new a.init(3418070365, 3238371032), new a.init(1654270250, 914150663), new a.init(2438529370, 812702999), new a.init(355462360, 4144912697), new a.init(1731405415, 4290775857), new a.init(2394180231, 1750603025), new a.init(3675008525, 1694076839), new a.init(1203062813, 3204075428)])
            },
            _doFinalize: function () {
              var u = c._doFinalize.call(this);
              return u.sigBytes -= 16, u
            }
          });
        n.SHA384 = c._createHelper(l), n.HmacSHA384 = c._createHmacHelper(l)
      }(), r.SHA384
    })
  }(hht)), ox
}
var lx = {},
  ght = {
    get exports() {
      return lx
    },
    set exports(t) {
      lx = t
    }
  },
  s9;

function mht() {
  return s9 || (s9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), UE())
    })(me, function (r) {
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.WordArray,
          o = a.Hasher,
          c = i.x64,
          l = c.Word,
          u = i.algo,
          f = [],
          d = [],
          h = [];
        (function () {
          for (var g = 1, m = 0, y = 0; y < 24; y++) {
            f[g + 5 * m] = (y + 1) * (y + 2) / 2 % 64;
            var x = m % 5,
              b = (2 * g + 3 * m) % 5;
            g = x, m = b
          }
          for (var g = 0; g < 5; g++)
            for (var m = 0; m < 5; m++) d[g + 5 * m] = m + (2 * g + 3 * m) % 5 * 5;
          for (var _ = 1, S = 0; S < 24; S++) {
            for (var T = 0, R = 0, I = 0; I < 7; I++) {
              if (_ & 1) {
                var w = (1 << I) - 1;
                w < 32 ? R ^= 1 << w : T ^= 1 << w - 32
              }
              _ & 128 ? _ = _ << 1 ^ 113 : _ <<= 1
            }
            h[S] = l.create(T, R)
          }
        })();
        var p = [];
        (function () {
          for (var g = 0; g < 25; g++) p[g] = l.create()
        })();
        var v = u.SHA3 = o.extend({
          cfg: o.cfg.extend({
            outputLength: 512
          }),
          _doReset: function () {
            for (var g = this._state = [], m = 0; m < 25; m++) g[m] = new l.init;
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
          },
          _doProcessBlock: function (g, m) {
            for (var y = this._state, x = this.blockSize / 2, b = 0; b < x; b++) {
              var _ = g[m + 2 * b],
                S = g[m + 2 * b + 1];
              _ = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360, S = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360;
              var T = y[b];
              T.high ^= S, T.low ^= _
            }
            for (var R = 0; R < 24; R++) {
              for (var I = 0; I < 5; I++) {
                for (var w = 0, C = 0, L = 0; L < 5; L++) {
                  var T = y[I + 5 * L];
                  w ^= T.high, C ^= T.low
                }
                var H = p[I];
                H.high = w, H.low = C
              }
              for (var I = 0; I < 5; I++)
                for (var N = p[(I + 4) % 5], P = p[(I + 1) % 5], B = P.high, V = P.low, w = N.high ^ (B << 1 | V >>> 31), C = N.low ^ (V << 1 | B >>> 31), L = 0; L < 5; L++) {
                  var T = y[I + 5 * L];
                  T.high ^= w, T.low ^= C
                }
              for (var M = 1; M < 25; M++) {
                var w, C, T = y[M],
                  U = T.high,
                  W = T.low,
                  k = f[M];
                k < 32 ? (w = U << k | W >>> 32 - k, C = W << k | U >>> 32 - k) : (w = W << k - 32 | U >>> 64 - k, C = U << k - 32 | W >>> 64 - k);
                var O = p[d[M]];
                O.high = w, O.low = C
              }
              var F = p[0],
                D = y[0];
              F.high = D.high, F.low = D.low;
              for (var I = 0; I < 5; I++)
                for (var L = 0; L < 5; L++) {
                  var M = I + 5 * L,
                    T = y[M],
                    Q = p[M],
                    ee = p[(I + 1) % 5 + 5 * L],
                    de = p[(I + 2) % 5 + 5 * L];
                  T.high = Q.high ^ ~ee.high & de.high, T.low = Q.low ^ ~ee.low & de.low
                }
              var T = y[0],
                oe = h[R];
              T.high ^= oe.high, T.low ^= oe.low
            }
          },
          _doFinalize: function () {
            var g = this._data,
              m = g.words;
            this._nDataBytes * 8;
            var y = g.sigBytes * 8,
              x = this.blockSize * 32;
            m[y >>> 5] |= 1 << 24 - y % 32, m[(n.ceil((y + 1) / x) * x >>> 5) - 1] |= 128, g.sigBytes = m.length * 4, this._process();
            for (var b = this._state, _ = this.cfg.outputLength / 8, S = _ / 8, T = [], R = 0; R < S; R++) {
              var I = b[R],
                w = I.high,
                C = I.low;
              w = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360, C = (C << 8 | C >>> 24) & 16711935 | (C << 24 | C >>> 8) & 4278255360, T.push(C), T.push(w)
            }
            return new s.init(T, _)
          },
          clone: function () {
            for (var g = o.clone.call(this), m = g._state = this._state.slice(0), y = 0; y < 25; y++) m[y] = m[y].clone();
            return g
          }
        });
        i.SHA3 = o._createHelper(v), i.HmacSHA3 = o._createHmacHelper(v)
      }(Math), r.SHA3
    })
  }(ght)), lx
}
var cx = {},
  vht = {
    get exports() {
      return cx
    },
    set exports(t) {
      cx = t
    }
  },
  o9;

function yht() {
  return o9 || (o9 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      /** @preserve
      			(c) 2012 by CÃ©dric Mesnil. All rights reserved.

      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.WordArray,
          o = a.Hasher,
          c = i.algo,
          l = s.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
          u = s.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
          f = s.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
          d = s.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
          h = s.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
          p = s.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
          v = c.RIPEMD160 = o.extend({
            _doReset: function () {
              this._hash = s.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
            },
            _doProcessBlock: function (S, T) {
              for (var R = 0; R < 16; R++) {
                var I = T + R,
                  w = S[I];
                S[I] = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360
              }
              var C = this._hash.words,
                L = h.words,
                H = p.words,
                N = l.words,
                P = u.words,
                B = f.words,
                V = d.words,
                M, U, W, k, O, F, D, Q, ee, de;
              F = M = C[0], D = U = C[1], Q = W = C[2], ee = k = C[3], de = O = C[4];
              for (var oe, R = 0; R < 80; R += 1) oe = M + S[T + N[R]] | 0, R < 16 ? oe += g(U, W, k) + L[0] : R < 32 ? oe += m(U, W, k) + L[1] : R < 48 ? oe += y(U, W, k) + L[2] : R < 64 ? oe += x(U, W, k) + L[3] : oe += b(U, W, k) + L[4], oe = oe | 0, oe = _(oe, B[R]), oe = oe + O | 0, M = O, O = k, k = _(W, 10), W = U, U = oe, oe = F + S[T + P[R]] | 0, R < 16 ? oe += b(D, Q, ee) + H[0] : R < 32 ? oe += x(D, Q, ee) + H[1] : R < 48 ? oe += y(D, Q, ee) + H[2] : R < 64 ? oe += m(D, Q, ee) + H[3] : oe += g(D, Q, ee) + H[4], oe = oe | 0, oe = _(oe, V[R]), oe = oe + de | 0, F = de, de = ee, ee = _(Q, 10), Q = D, D = oe;
              oe = C[1] + W + ee | 0, C[1] = C[2] + k + de | 0, C[2] = C[3] + O + F | 0, C[3] = C[4] + M + D | 0, C[4] = C[0] + U + Q | 0, C[0] = oe
            },
            _doFinalize: function () {
              var S = this._data,
                T = S.words,
                R = this._nDataBytes * 8,
                I = S.sigBytes * 8;
              T[I >>> 5] |= 128 << 24 - I % 32, T[(I + 64 >>> 9 << 4) + 14] = (R << 8 | R >>> 24) & 16711935 | (R << 24 | R >>> 8) & 4278255360, S.sigBytes = (T.length + 1) * 4, this._process();
              for (var w = this._hash, C = w.words, L = 0; L < 5; L++) {
                var H = C[L];
                C[L] = (H << 8 | H >>> 24) & 16711935 | (H << 24 | H >>> 8) & 4278255360
              }
              return w
            },
            clone: function () {
              var S = o.clone.call(this);
              return S._hash = this._hash.clone(), S
            }
          });

        function g(S, T, R) {
          return S ^ T ^ R
        }

        function m(S, T, R) {
          return S & T | ~S & R
        }

        function y(S, T, R) {
          return (S | ~T) ^ R
        }

        function x(S, T, R) {
          return S & R | T & ~R
        }

        function b(S, T, R) {
          return S ^ (T | ~R)
        }

        function _(S, T) {
          return S << T | S >>> 32 - T
        }
        i.RIPEMD160 = o._createHelper(v), i.HmacRIPEMD160 = o._createHmacHelper(v)
      }(), r.RIPEMD160
    })
  }(vht)), cx
}
var ux = {},
  xht = {
    get exports() {
      return ux
    },
    set exports(t) {
      ux = t
    }
  },
  l9;

function AL() {
  return l9 || (l9 = 1, function (t, e) {
    (function (r, n) {
      t.exports = n(Be())
    })(me, function (r) {
      (function () {
        var n = r,
          i = n.lib,
          a = i.Base,
          s = n.enc,
          o = s.Utf8,
          c = n.algo;
        c.HMAC = a.extend({
          init: function (l, u) {
            l = this._hasher = new l.init, typeof u == "string" && (u = o.parse(u));
            var f = l.blockSize,
              d = f * 4;
            u.sigBytes > d && (u = l.finalize(u)), u.clamp();
            for (var h = this._oKey = u.clone(), p = this._iKey = u.clone(), v = h.words, g = p.words, m = 0; m < f; m++) v[m] ^= 1549556828, g[m] ^= 909522486;
            h.sigBytes = p.sigBytes = d, this.reset()
          },
          reset: function () {
            var l = this._hasher;
            l.reset(), l.update(this._iKey)
          },
          update: function (l) {
            return this._hasher.update(l), this
          },
          finalize: function (l) {
            var u = this._hasher,
              f = u.finalize(l);
            u.reset();
            var d = u.finalize(this._oKey.clone().concat(f));
            return d
          }
        })
      })()
    })
  }(xht)), ux
}
var fx = {},
  bht = {
    get exports() {
      return fx
    },
    set exports(t) {
      fx = t
    }
  },
  c9;

function Eht() {
  return c9 || (c9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), RL(), AL())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.Base,
          s = i.WordArray,
          o = n.algo,
          c = o.SHA1,
          l = o.HMAC,
          u = o.PBKDF2 = a.extend({
            cfg: a.extend({
              keySize: 128 / 32,
              hasher: c,
              iterations: 1
            }),
            init: function (f) {
              this.cfg = this.cfg.extend(f)
            },
            compute: function (f, d) {
              for (var h = this.cfg, p = l.create(h.hasher, f), v = s.create(), g = s.create([1]), m = v.words, y = g.words, x = h.keySize, b = h.iterations; m.length < x;) {
                var _ = p.update(d).finalize(g);
                p.reset();
                for (var S = _.words, T = S.length, R = _, I = 1; I < b; I++) {
                  R = p.finalize(R), p.reset();
                  for (var w = R.words, C = 0; C < T; C++) S[C] ^= w[C]
                }
                v.concat(_), y[0]++
              }
              return v.sigBytes = x * 4, v
            }
          });
        n.PBKDF2 = function (f, d, h) {
          return u.create(h).compute(f, d)
        }
      }(), r.PBKDF2
    })
  }(bht)), fx
}
var dx = {},
  Sht = {
    get exports() {
      return dx
    },
    set exports(t) {
      dx = t
    }
  },
  u9;

function Ac() {
  return u9 || (u9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), RL(), AL())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.Base,
          s = i.WordArray,
          o = n.algo,
          c = o.MD5,
          l = o.EvpKDF = a.extend({
            cfg: a.extend({
              keySize: 128 / 32,
              hasher: c,
              iterations: 1
            }),
            init: function (u) {
              this.cfg = this.cfg.extend(u)
            },
            compute: function (u, f) {
              for (var d, h = this.cfg, p = h.hasher.create(), v = s.create(), g = v.words, m = h.keySize, y = h.iterations; g.length < m;) {
                d && p.update(d), d = p.update(u).finalize(f), p.reset();
                for (var x = 1; x < y; x++) d = p.finalize(d), p.reset();
                v.concat(d)
              }
              return v.sigBytes = m * 4, v
            }
          });
        n.EvpKDF = function (u, f, d) {
          return l.create(d).compute(u, f)
        }
      }(), r.EvpKDF
    })
  }(Sht)), dx
}
var hx = {},
  _ht = {
    get exports() {
      return hx
    },
    set exports(t) {
      hx = t
    }
  },
  f9;

function lr() {
  return f9 || (f9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), Ac())
    })(me, function (r) {
      r.lib.Cipher || function (n) {
        var i = r,
          a = i.lib,
          s = a.Base,
          o = a.WordArray,
          c = a.BufferedBlockAlgorithm,
          l = i.enc;
        l.Utf8;
        var u = l.Base64,
          f = i.algo,
          d = f.EvpKDF,
          h = a.Cipher = c.extend({
            cfg: s.extend(),
            createEncryptor: function (w, C) {
              return this.create(this._ENC_XFORM_MODE, w, C)
            },
            createDecryptor: function (w, C) {
              return this.create(this._DEC_XFORM_MODE, w, C)
            },
            init: function (w, C, L) {
              this.cfg = this.cfg.extend(L), this._xformMode = w, this._key = C, this.reset()
            },
            reset: function () {
              c.reset.call(this), this._doReset()
            },
            process: function (w) {
              return this._append(w), this._process()
            },
            finalize: function (w) {
              w && this._append(w);
              var C = this._doFinalize();
              return C
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            _createHelper: function () {
              function w(C) {
                return typeof C == "string" ? I : S
              }
              return function (C) {
                return {
                  encrypt: function (L, H, N) {
                    return w(H).encrypt(C, L, H, N)
                  },
                  decrypt: function (L, H, N) {
                    return w(H).decrypt(C, L, H, N)
                  }
                }
              }
            }()
          });
        a.StreamCipher = h.extend({
          _doFinalize: function () {
            var w = this._process(!0);
            return w
          },
          blockSize: 1
        });
        var p = i.mode = {},
          v = a.BlockCipherMode = s.extend({
            createEncryptor: function (w, C) {
              return this.Encryptor.create(w, C)
            },
            createDecryptor: function (w, C) {
              return this.Decryptor.create(w, C)
            },
            init: function (w, C) {
              this._cipher = w, this._iv = C
            }
          }),
          g = p.CBC = function () {
            var w = v.extend();
            w.Encryptor = w.extend({
              processBlock: function (L, H) {
                var N = this._cipher,
                  P = N.blockSize;
                C.call(this, L, H, P), N.encryptBlock(L, H), this._prevBlock = L.slice(H, H + P)
              }
            }), w.Decryptor = w.extend({
              processBlock: function (L, H) {
                var N = this._cipher,
                  P = N.blockSize,
                  B = L.slice(H, H + P);
                N.decryptBlock(L, H), C.call(this, L, H, P), this._prevBlock = B
              }
            });

            function C(L, H, N) {
              var P, B = this._iv;
              B ? (P = B, this._iv = n) : P = this._prevBlock;
              for (var V = 0; V < N; V++) L[H + V] ^= P[V]
            }
            return w
          }(),
          m = i.pad = {},
          y = m.Pkcs7 = {
            pad: function (w, C) {
              for (var L = C * 4, H = L - w.sigBytes % L, N = H << 24 | H << 16 | H << 8 | H, P = [], B = 0; B < H; B += 4) P.push(N);
              var V = o.create(P, H);
              w.concat(V)
            },
            unpad: function (w) {
              var C = w.words[w.sigBytes - 1 >>> 2] & 255;
              w.sigBytes -= C
            }
          };
        a.BlockCipher = h.extend({
          cfg: h.cfg.extend({
            mode: g,
            padding: y
          }),
          reset: function () {
            var w;
            h.reset.call(this);
            var C = this.cfg,
              L = C.iv,
              H = C.mode;
            this._xformMode == this._ENC_XFORM_MODE ? w = H.createEncryptor : (w = H.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == w ? this._mode.init(this, L && L.words) : (this._mode = w.call(H, this, L && L.words), this._mode.__creator = w)
          },
          _doProcessBlock: function (w, C) {
            this._mode.processBlock(w, C)
          },
          _doFinalize: function () {
            var w, C = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (C.pad(this._data, this.blockSize), w = this._process(!0)) : (w = this._process(!0), C.unpad(w)), w
          },
          blockSize: 128 / 32
        });
        var x = a.CipherParams = s.extend({
            init: function (w) {
              this.mixIn(w)
            },
            toString: function (w) {
              return (w || this.formatter).stringify(this)
            }
          }),
          b = i.format = {},
          _ = b.OpenSSL = {
            stringify: function (w) {
              var C, L = w.ciphertext,
                H = w.salt;
              return H ? C = o.create([1398893684, 1701076831]).concat(H).concat(L) : C = L, C.toString(u)
            },
            parse: function (w) {
              var C, L = u.parse(w),
                H = L.words;
              return H[0] == 1398893684 && H[1] == 1701076831 && (C = o.create(H.slice(2, 4)), H.splice(0, 4), L.sigBytes -= 16), x.create({
                ciphertext: L,
                salt: C
              })
            }
          },
          S = a.SerializableCipher = s.extend({
            cfg: s.extend({
              format: _
            }),
            encrypt: function (w, C, L, H) {
              H = this.cfg.extend(H);
              var N = w.createEncryptor(L, H),
                P = N.finalize(C),
                B = N.cfg;
              return x.create({
                ciphertext: P,
                key: L,
                iv: B.iv,
                algorithm: w,
                mode: B.mode,
                padding: B.padding,
                blockSize: w.blockSize,
                formatter: H.format
              })
            },
            decrypt: function (w, C, L, H) {
              H = this.cfg.extend(H), C = this._parse(C, H.format);
              var N = w.createDecryptor(L, H).finalize(C.ciphertext);
              return N
            },
            _parse: function (w, C) {
              return typeof w == "string" ? C.parse(w, this) : w
            }
          }),
          T = i.kdf = {},
          R = T.OpenSSL = {
            execute: function (w, C, L, H) {
              H || (H = o.random(64 / 8));
              var N = d.create({
                  keySize: C + L
                }).compute(w, H),
                P = o.create(N.words.slice(C), L * 4);
              return N.sigBytes = C * 4, x.create({
                key: N,
                iv: P,
                salt: H
              })
            }
          },
          I = a.PasswordBasedCipher = S.extend({
            cfg: S.cfg.extend({
              kdf: R
            }),
            encrypt: function (w, C, L, H) {
              H = this.cfg.extend(H);
              var N = H.kdf.execute(L, w.keySize, w.ivSize);
              H.iv = N.iv;
              var P = S.encrypt.call(this, w, C, N.key, H);
              return P.mixIn(N), P
            },
            decrypt: function (w, C, L, H) {
              H = this.cfg.extend(H), C = this._parse(C, H.format);
              var N = H.kdf.execute(L, w.keySize, w.ivSize, C.salt);
              H.iv = N.iv;
              var P = S.decrypt.call(this, w, C, N.key, H);
              return P
            }
          })
      }()
    })
  }(_ht)), hx
}
var px = {},
  Tht = {
    get exports() {
      return px
    },
    set exports(t) {
      px = t
    }
  },
  d9;

function wht() {
  return d9 || (d9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.mode.CFB = function () {
        var n = r.lib.BlockCipherMode.extend();
        n.Encryptor = n.extend({
          processBlock: function (a, s) {
            var o = this._cipher,
              c = o.blockSize;
            i.call(this, a, s, c, o), this._prevBlock = a.slice(s, s + c)
          }
        }), n.Decryptor = n.extend({
          processBlock: function (a, s) {
            var o = this._cipher,
              c = o.blockSize,
              l = a.slice(s, s + c);
            i.call(this, a, s, c, o), this._prevBlock = l
          }
        });

        function i(a, s, o, c) {
          var l, u = this._iv;
          u ? (l = u.slice(0), this._iv = void 0) : l = this._prevBlock, c.encryptBlock(l, 0);
          for (var f = 0; f < o; f++) a[s + f] ^= l[f]
        }
        return n
      }(), r.mode.CFB
    })
  }(Tht)), px
}
var gx = {},
  Rht = {
    get exports() {
      return gx
    },
    set exports(t) {
      gx = t
    }
  },
  h9;

function Aht() {
  return h9 || (h9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.mode.CTR = function () {
        var n = r.lib.BlockCipherMode.extend(),
          i = n.Encryptor = n.extend({
            processBlock: function (a, s) {
              var o = this._cipher,
                c = o.blockSize,
                l = this._iv,
                u = this._counter;
              l && (u = this._counter = l.slice(0), this._iv = void 0);
              var f = u.slice(0);
              o.encryptBlock(f, 0), u[c - 1] = u[c - 1] + 1 | 0;
              for (var d = 0; d < c; d++) a[s + d] ^= f[d]
            }
          });
        return n.Decryptor = i, n
      }(), r.mode.CTR
    })
  }(Rht)), gx
}
var mx = {},
  Iht = {
    get exports() {
      return mx
    },
    set exports(t) {
      mx = t
    }
  },
  p9;

function $ht() {
  return p9 || (p9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      return r.mode.CTRGladman = function () {
        var n = r.lib.BlockCipherMode.extend();

        function i(o) {
          if ((o >> 24 & 255) === 255) {
            var c = o >> 16 & 255,
              l = o >> 8 & 255,
              u = o & 255;
            c === 255 ? (c = 0, l === 255 ? (l = 0, u === 255 ? u = 0 : ++u) : ++l) : ++c, o = 0, o += c << 16, o += l << 8, o += u
          } else o += 1 << 24;
          return o
        }

        function a(o) {
          return (o[0] = i(o[0])) === 0 && (o[1] = i(o[1])), o
        }
        var s = n.Encryptor = n.extend({
          processBlock: function (o, c) {
            var l = this._cipher,
              u = l.blockSize,
              f = this._iv,
              d = this._counter;
            f && (d = this._counter = f.slice(0), this._iv = void 0), a(d);
            var h = d.slice(0);
            l.encryptBlock(h, 0);
            for (var p = 0; p < u; p++) o[c + p] ^= h[p]
          }
        });
        return n.Decryptor = s, n
      }(), r.mode.CTRGladman
    })
  }(Iht)), mx
}
var vx = {},
  Cht = {
    get exports() {
      return vx
    },
    set exports(t) {
      vx = t
    }
  },
  g9;

function kht() {
  return g9 || (g9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.mode.OFB = function () {
        var n = r.lib.BlockCipherMode.extend(),
          i = n.Encryptor = n.extend({
            processBlock: function (a, s) {
              var o = this._cipher,
                c = o.blockSize,
                l = this._iv,
                u = this._keystream;
              l && (u = this._keystream = l.slice(0), this._iv = void 0), o.encryptBlock(u, 0);
              for (var f = 0; f < c; f++) a[s + f] ^= u[f]
            }
          });
        return n.Decryptor = i, n
      }(), r.mode.OFB
    })
  }(Cht)), vx
}
var yx = {},
  Oht = {
    get exports() {
      return yx
    },
    set exports(t) {
      yx = t
    }
  },
  m9;

function Lht() {
  return m9 || (m9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.mode.ECB = function () {
        var n = r.lib.BlockCipherMode.extend();
        return n.Encryptor = n.extend({
          processBlock: function (i, a) {
            this._cipher.encryptBlock(i, a)
          }
        }), n.Decryptor = n.extend({
          processBlock: function (i, a) {
            this._cipher.decryptBlock(i, a)
          }
        }), n
      }(), r.mode.ECB
    })
  }(Oht)), yx
}
var xx = {},
  Pht = {
    get exports() {
      return xx
    },
    set exports(t) {
      xx = t
    }
  },
  v9;

function Nht() {
  return v9 || (v9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.pad.AnsiX923 = {
        pad: function (n, i) {
          var a = n.sigBytes,
            s = i * 4,
            o = s - a % s,
            c = a + o - 1;
          n.clamp(), n.words[c >>> 2] |= o << 24 - c % 4 * 8, n.sigBytes += o
        },
        unpad: function (n) {
          var i = n.words[n.sigBytes - 1 >>> 2] & 255;
          n.sigBytes -= i
        }
      }, r.pad.Ansix923
    })
  }(Pht)), xx
}
var bx = {},
  Dht = {
    get exports() {
      return bx
    },
    set exports(t) {
      bx = t
    }
  },
  y9;

function Mht() {
  return y9 || (y9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.pad.Iso10126 = {
        pad: function (n, i) {
          var a = i * 4,
            s = a - n.sigBytes % a;
          n.concat(r.lib.WordArray.random(s - 1)).concat(r.lib.WordArray.create([s << 24], 1))
        },
        unpad: function (n) {
          var i = n.words[n.sigBytes - 1 >>> 2] & 255;
          n.sigBytes -= i
        }
      }, r.pad.Iso10126
    })
  }(Dht)), bx
}
var Ex = {},
  Fht = {
    get exports() {
      return Ex
    },
    set exports(t) {
      Ex = t
    }
  },
  x9;

function Bht() {
  return x9 || (x9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.pad.Iso97971 = {
        pad: function (n, i) {
          n.concat(r.lib.WordArray.create([2147483648], 1)), r.pad.ZeroPadding.pad(n, i)
        },
        unpad: function (n) {
          r.pad.ZeroPadding.unpad(n), n.sigBytes--
        }
      }, r.pad.Iso97971
    })
  }(Fht)), Ex
}
var Sx = {},
  Uht = {
    get exports() {
      return Sx
    },
    set exports(t) {
      Sx = t
    }
  },
  b9;

function jht() {
  return b9 || (b9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.pad.ZeroPadding = {
        pad: function (n, i) {
          var a = i * 4;
          n.clamp(), n.sigBytes += a - (n.sigBytes % a || a)
        },
        unpad: function (n) {
          for (var i = n.words, a = n.sigBytes - 1, a = n.sigBytes - 1; a >= 0; a--)
            if (i[a >>> 2] >>> 24 - a % 4 * 8 & 255) {
              n.sigBytes = a + 1;
              break
            }
        }
      }, r.pad.ZeroPadding
    })
  }(Uht)), Sx
}
var _x = {},
  Hht = {
    get exports() {
      return _x
    },
    set exports(t) {
      _x = t
    }
  },
  E9;

function zht() {
  return E9 || (E9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return r.pad.NoPadding = {
        pad: function () {},
        unpad: function () {}
      }, r.pad.NoPadding
    })
  }(Hht)), _x
}
var Tx = {},
  Ght = {
    get exports() {
      return Tx
    },
    set exports(t) {
      Tx = t
    }
  },
  S9;

function Vht() {
  return S9 || (S9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), lr())
    })(me, function (r) {
      return function (n) {
        var i = r,
          a = i.lib,
          s = a.CipherParams,
          o = i.enc,
          c = o.Hex,
          l = i.format;
        l.Hex = {
          stringify: function (u) {
            return u.ciphertext.toString(c)
          },
          parse: function (u) {
            var f = c.parse(u);
            return s.create({
              ciphertext: f
            })
          }
        }
      }(), r.format.Hex
    })
  }(Ght)), Tx
}
var wx = {},
  Wht = {
    get exports() {
      return wx
    },
    set exports(t) {
      wx = t
    }
  },
  _9;

function Kht() {
  return _9 || (_9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), fs, yd(), Ac(), lr())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.BlockCipher,
          s = n.algo,
          o = [],
          c = [],
          l = [],
          u = [],
          f = [],
          d = [],
          h = [],
          p = [],
          v = [],
          g = [];
        (function () {
          for (var x = [], b = 0; b < 256; b++) b < 128 ? x[b] = b << 1 : x[b] = b << 1 ^ 283;
          for (var _ = 0, S = 0, b = 0; b < 256; b++) {
            var T = S ^ S << 1 ^ S << 2 ^ S << 3 ^ S << 4;
            T = T >>> 8 ^ T & 255 ^ 99, o[_] = T, c[T] = _;
            var R = x[_],
              I = x[R],
              w = x[I],
              C = x[T] * 257 ^ T * 16843008;
            l[_] = C << 24 | C >>> 8, u[_] = C << 16 | C >>> 16, f[_] = C << 8 | C >>> 24, d[_] = C;
            var C = w * 16843009 ^ I * 65537 ^ R * 257 ^ _ * 16843008;
            h[T] = C << 24 | C >>> 8, p[T] = C << 16 | C >>> 16, v[T] = C << 8 | C >>> 24, g[T] = C, _ ? (_ = R ^ x[x[x[w ^ R]]], S ^= x[x[S]]) : _ = S = 1
          }
        })();
        var m = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
          y = s.AES = a.extend({
            _doReset: function () {
              var x;
              if (!(this._nRounds && this._keyPriorReset === this._key)) {
                for (var b = this._keyPriorReset = this._key, _ = b.words, S = b.sigBytes / 4, T = this._nRounds = S + 6, R = (T + 1) * 4, I = this._keySchedule = [], w = 0; w < R; w++) w < S ? I[w] = _[w] : (x = I[w - 1], w % S ? S > 6 && w % S == 4 && (x = o[x >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[x & 255]) : (x = x << 8 | x >>> 24, x = o[x >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[x & 255], x ^= m[w / S | 0] << 24), I[w] = I[w - S] ^ x);
                for (var C = this._invKeySchedule = [], L = 0; L < R; L++) {
                  var w = R - L;
                  if (L % 4) var x = I[w];
                  else var x = I[w - 4];
                  L < 4 || w <= 4 ? C[L] = x : C[L] = h[o[x >>> 24]] ^ p[o[x >>> 16 & 255]] ^ v[o[x >>> 8 & 255]] ^ g[o[x & 255]]
                }
              }
            },
            encryptBlock: function (x, b) {
              this._doCryptBlock(x, b, this._keySchedule, l, u, f, d, o)
            },
            decryptBlock: function (x, b) {
              var _ = x[b + 1];
              x[b + 1] = x[b + 3], x[b + 3] = _, this._doCryptBlock(x, b, this._invKeySchedule, h, p, v, g, c);
              var _ = x[b + 1];
              x[b + 1] = x[b + 3], x[b + 3] = _
            },
            _doCryptBlock: function (x, b, _, S, T, R, I, w) {
              for (var C = this._nRounds, L = x[b] ^ _[0], H = x[b + 1] ^ _[1], N = x[b + 2] ^ _[2], P = x[b + 3] ^ _[3], B = 4, V = 1; V < C; V++) {
                var M = S[L >>> 24] ^ T[H >>> 16 & 255] ^ R[N >>> 8 & 255] ^ I[P & 255] ^ _[B++],
                  U = S[H >>> 24] ^ T[N >>> 16 & 255] ^ R[P >>> 8 & 255] ^ I[L & 255] ^ _[B++],
                  W = S[N >>> 24] ^ T[P >>> 16 & 255] ^ R[L >>> 8 & 255] ^ I[H & 255] ^ _[B++],
                  k = S[P >>> 24] ^ T[L >>> 16 & 255] ^ R[H >>> 8 & 255] ^ I[N & 255] ^ _[B++];
                L = M, H = U, N = W, P = k
              }
              var M = (w[L >>> 24] << 24 | w[H >>> 16 & 255] << 16 | w[N >>> 8 & 255] << 8 | w[P & 255]) ^ _[B++],
                U = (w[H >>> 24] << 24 | w[N >>> 16 & 255] << 16 | w[P >>> 8 & 255] << 8 | w[L & 255]) ^ _[B++],
                W = (w[N >>> 24] << 24 | w[P >>> 16 & 255] << 16 | w[L >>> 8 & 255] << 8 | w[H & 255]) ^ _[B++],
                k = (w[P >>> 24] << 24 | w[L >>> 16 & 255] << 16 | w[H >>> 8 & 255] << 8 | w[N & 255]) ^ _[B++];
              x[b] = M, x[b + 1] = U, x[b + 2] = W, x[b + 3] = k
            },
            keySize: 256 / 32
          });
        n.AES = a._createHelper(y)
      }(), r.AES
    })
  }(Wht)), wx
}
var Rx = {},
  Yht = {
    get exports() {
      return Rx
    },
    set exports(t) {
      Rx = t
    }
  },
  T9;

function qht() {
  return T9 || (T9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), fs, yd(), Ac(), lr())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.WordArray,
          s = i.BlockCipher,
          o = n.algo,
          c = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
          l = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
          u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
          f = [{
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          }, {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          }, {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          }, {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          }, {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          }, {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          }, {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          }, {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }],
          d = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
          h = o.DES = s.extend({
            _doReset: function () {
              for (var m = this._key, y = m.words, x = [], b = 0; b < 56; b++) {
                var _ = c[b] - 1;
                x[b] = y[_ >>> 5] >>> 31 - _ % 32 & 1
              }
              for (var S = this._subKeys = [], T = 0; T < 16; T++) {
                for (var R = S[T] = [], I = u[T], b = 0; b < 24; b++) R[b / 6 | 0] |= x[(l[b] - 1 + I) % 28] << 31 - b % 6, R[4 + (b / 6 | 0)] |= x[28 + (l[b + 24] - 1 + I) % 28] << 31 - b % 6;
                R[0] = R[0] << 1 | R[0] >>> 31;
                for (var b = 1; b < 7; b++) R[b] = R[b] >>> (b - 1) * 4 + 3;
                R[7] = R[7] << 5 | R[7] >>> 27
              }
              for (var w = this._invSubKeys = [], b = 0; b < 16; b++) w[b] = S[15 - b]
            },
            encryptBlock: function (m, y) {
              this._doCryptBlock(m, y, this._subKeys)
            },
            decryptBlock: function (m, y) {
              this._doCryptBlock(m, y, this._invSubKeys)
            },
            _doCryptBlock: function (m, y, x) {
              this._lBlock = m[y], this._rBlock = m[y + 1], p.call(this, 4, 252645135), p.call(this, 16, 65535), v.call(this, 2, 858993459), v.call(this, 8, 16711935), p.call(this, 1, 1431655765);
              for (var b = 0; b < 16; b++) {
                for (var _ = x[b], S = this._lBlock, T = this._rBlock, R = 0, I = 0; I < 8; I++) R |= f[I][((T ^ _[I]) & d[I]) >>> 0];
                this._lBlock = T, this._rBlock = S ^ R
              }
              var w = this._lBlock;
              this._lBlock = this._rBlock, this._rBlock = w, p.call(this, 1, 1431655765), v.call(this, 8, 16711935), v.call(this, 2, 858993459), p.call(this, 16, 65535), p.call(this, 4, 252645135), m[y] = this._lBlock, m[y + 1] = this._rBlock
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });

        function p(m, y) {
          var x = (this._lBlock >>> m ^ this._rBlock) & y;
          this._rBlock ^= x, this._lBlock ^= x << m
        }

        function v(m, y) {
          var x = (this._rBlock >>> m ^ this._lBlock) & y;
          this._lBlock ^= x, this._rBlock ^= x << m
        }
        n.DES = s._createHelper(h);
        var g = o.TripleDES = s.extend({
          _doReset: function () {
            var m = this._key,
              y = m.words;
            if (y.length !== 2 && y.length !== 4 && y.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var x = y.slice(0, 2),
              b = y.length < 4 ? y.slice(0, 2) : y.slice(2, 4),
              _ = y.length < 6 ? y.slice(0, 2) : y.slice(4, 6);
            this._des1 = h.createEncryptor(a.create(x)), this._des2 = h.createEncryptor(a.create(b)), this._des3 = h.createEncryptor(a.create(_))
          },
          encryptBlock: function (m, y) {
            this._des1.encryptBlock(m, y), this._des2.decryptBlock(m, y), this._des3.encryptBlock(m, y)
          },
          decryptBlock: function (m, y) {
            this._des3.decryptBlock(m, y), this._des2.encryptBlock(m, y), this._des1.decryptBlock(m, y)
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        n.TripleDES = s._createHelper(g)
      }(), r.TripleDES
    })
  }(Yht)), Rx
}
var Ax = {},
  Xht = {
    get exports() {
      return Ax
    },
    set exports(t) {
      Ax = t
    }
  },
  w9;

function Qht() {
  return w9 || (w9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), fs, yd(), Ac(), lr())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.StreamCipher,
          s = n.algo,
          o = s.RC4 = a.extend({
            _doReset: function () {
              for (var u = this._key, f = u.words, d = u.sigBytes, h = this._S = [], p = 0; p < 256; p++) h[p] = p;
              for (var p = 0, v = 0; p < 256; p++) {
                var g = p % d,
                  m = f[g >>> 2] >>> 24 - g % 4 * 8 & 255;
                v = (v + h[p] + m) % 256;
                var y = h[p];
                h[p] = h[v], h[v] = y
              }
              this._i = this._j = 0
            },
            _doProcessBlock: function (u, f) {
              u[f] ^= c.call(this)
            },
            keySize: 256 / 32,
            ivSize: 0
          });

        function c() {
          for (var u = this._S, f = this._i, d = this._j, h = 0, p = 0; p < 4; p++) {
            f = (f + 1) % 256, d = (d + u[f]) % 256;
            var v = u[f];
            u[f] = u[d], u[d] = v, h |= u[(u[f] + u[d]) % 256] << 24 - p * 8
          }
          return this._i = f, this._j = d, h
        }
        n.RC4 = a._createHelper(o);
        var l = s.RC4Drop = o.extend({
          cfg: o.cfg.extend({
            drop: 192
          }),
          _doReset: function () {
            o._doReset.call(this);
            for (var u = this.cfg.drop; u > 0; u--) c.call(this)
          }
        });
        n.RC4Drop = a._createHelper(l)
      }(), r.RC4
    })
  }(Xht)), Ax
}
var Ix = {},
  Zht = {
    get exports() {
      return Ix
    },
    set exports(t) {
      Ix = t
    }
  },
  R9;

function Jht() {
  return R9 || (R9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), fs, yd(), Ac(), lr())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.StreamCipher,
          s = n.algo,
          o = [],
          c = [],
          l = [],
          u = s.Rabbit = a.extend({
            _doReset: function () {
              for (var d = this._key.words, h = this.cfg.iv, p = 0; p < 4; p++) d[p] = (d[p] << 8 | d[p] >>> 24) & 16711935 | (d[p] << 24 | d[p] >>> 8) & 4278255360;
              var v = this._X = [d[0], d[3] << 16 | d[2] >>> 16, d[1], d[0] << 16 | d[3] >>> 16, d[2], d[1] << 16 | d[0] >>> 16, d[3], d[2] << 16 | d[1] >>> 16],
                g = this._C = [d[2] << 16 | d[2] >>> 16, d[0] & 4294901760 | d[1] & 65535, d[3] << 16 | d[3] >>> 16, d[1] & 4294901760 | d[2] & 65535, d[0] << 16 | d[0] >>> 16, d[2] & 4294901760 | d[3] & 65535, d[1] << 16 | d[1] >>> 16, d[3] & 4294901760 | d[0] & 65535];
              this._b = 0;
              for (var p = 0; p < 4; p++) f.call(this);
              for (var p = 0; p < 8; p++) g[p] ^= v[p + 4 & 7];
              if (h) {
                var m = h.words,
                  y = m[0],
                  x = m[1],
                  b = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360,
                  _ = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360,
                  S = b >>> 16 | _ & 4294901760,
                  T = _ << 16 | b & 65535;
                g[0] ^= b, g[1] ^= S, g[2] ^= _, g[3] ^= T, g[4] ^= b, g[5] ^= S, g[6] ^= _, g[7] ^= T;
                for (var p = 0; p < 4; p++) f.call(this)
              }
            },
            _doProcessBlock: function (d, h) {
              var p = this._X;
              f.call(this), o[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, o[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, o[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, o[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
              for (var v = 0; v < 4; v++) o[v] = (o[v] << 8 | o[v] >>> 24) & 16711935 | (o[v] << 24 | o[v] >>> 8) & 4278255360, d[h + v] ^= o[v]
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });

        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++) c[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < c[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < c[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < c[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < c[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < c[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < c[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < c[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < c[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var v = d[p] + h[p],
              g = v & 65535,
              m = v >>> 16,
              y = ((g * g >>> 17) + g * m >>> 15) + m * m,
              x = ((v & 4294901760) * v | 0) + ((v & 65535) * v | 0);
            l[p] = y ^ x
          }
          d[0] = l[0] + (l[7] << 16 | l[7] >>> 16) + (l[6] << 16 | l[6] >>> 16) | 0, d[1] = l[1] + (l[0] << 8 | l[0] >>> 24) + l[7] | 0, d[2] = l[2] + (l[1] << 16 | l[1] >>> 16) + (l[0] << 16 | l[0] >>> 16) | 0, d[3] = l[3] + (l[2] << 8 | l[2] >>> 24) + l[1] | 0, d[4] = l[4] + (l[3] << 16 | l[3] >>> 16) + (l[2] << 16 | l[2] >>> 16) | 0, d[5] = l[5] + (l[4] << 8 | l[4] >>> 24) + l[3] | 0, d[6] = l[6] + (l[5] << 16 | l[5] >>> 16) + (l[4] << 16 | l[4] >>> 16) | 0, d[7] = l[7] + (l[6] << 8 | l[6] >>> 24) + l[5] | 0
        }
        n.Rabbit = a._createHelper(u)
      }(), r.Rabbit
    })
  }(Zht)), Ix
}
var $x = {},
  e0t = {
    get exports() {
      return $x
    },
    set exports(t) {
      $x = t
    }
  },
  A9;

function t0t() {
  return A9 || (A9 = 1, function (t, e) {
    (function (r, n, i) {
      t.exports = n(Be(), fs, yd(), Ac(), lr())
    })(me, function (r) {
      return function () {
        var n = r,
          i = n.lib,
          a = i.StreamCipher,
          s = n.algo,
          o = [],
          c = [],
          l = [],
          u = s.RabbitLegacy = a.extend({
            _doReset: function () {
              var d = this._key.words,
                h = this.cfg.iv,
                p = this._X = [d[0], d[3] << 16 | d[2] >>> 16, d[1], d[0] << 16 | d[3] >>> 16, d[2], d[1] << 16 | d[0] >>> 16, d[3], d[2] << 16 | d[1] >>> 16],
                v = this._C = [d[2] << 16 | d[2] >>> 16, d[0] & 4294901760 | d[1] & 65535, d[3] << 16 | d[3] >>> 16, d[1] & 4294901760 | d[2] & 65535, d[0] << 16 | d[0] >>> 16, d[2] & 4294901760 | d[3] & 65535, d[1] << 16 | d[1] >>> 16, d[3] & 4294901760 | d[0] & 65535];
              this._b = 0;
              for (var g = 0; g < 4; g++) f.call(this);
              for (var g = 0; g < 8; g++) v[g] ^= p[g + 4 & 7];
              if (h) {
                var m = h.words,
                  y = m[0],
                  x = m[1],
                  b = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360,
                  _ = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360,
                  S = b >>> 16 | _ & 4294901760,
                  T = _ << 16 | b & 65535;
                v[0] ^= b, v[1] ^= S, v[2] ^= _, v[3] ^= T, v[4] ^= b, v[5] ^= S, v[6] ^= _, v[7] ^= T;
                for (var g = 0; g < 4; g++) f.call(this)
              }
            },
            _doProcessBlock: function (d, h) {
              var p = this._X;
              f.call(this), o[0] = p[0] ^ p[5] >>> 16 ^ p[3] << 16, o[1] = p[2] ^ p[7] >>> 16 ^ p[5] << 16, o[2] = p[4] ^ p[1] >>> 16 ^ p[7] << 16, o[3] = p[6] ^ p[3] >>> 16 ^ p[1] << 16;
              for (var v = 0; v < 4; v++) o[v] = (o[v] << 8 | o[v] >>> 24) & 16711935 | (o[v] << 24 | o[v] >>> 8) & 4278255360, d[h + v] ^= o[v]
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });

        function f() {
          for (var d = this._X, h = this._C, p = 0; p < 8; p++) c[p] = h[p];
          h[0] = h[0] + 1295307597 + this._b | 0, h[1] = h[1] + 3545052371 + (h[0] >>> 0 < c[0] >>> 0 ? 1 : 0) | 0, h[2] = h[2] + 886263092 + (h[1] >>> 0 < c[1] >>> 0 ? 1 : 0) | 0, h[3] = h[3] + 1295307597 + (h[2] >>> 0 < c[2] >>> 0 ? 1 : 0) | 0, h[4] = h[4] + 3545052371 + (h[3] >>> 0 < c[3] >>> 0 ? 1 : 0) | 0, h[5] = h[5] + 886263092 + (h[4] >>> 0 < c[4] >>> 0 ? 1 : 0) | 0, h[6] = h[6] + 1295307597 + (h[5] >>> 0 < c[5] >>> 0 ? 1 : 0) | 0, h[7] = h[7] + 3545052371 + (h[6] >>> 0 < c[6] >>> 0 ? 1 : 0) | 0, this._b = h[7] >>> 0 < c[7] >>> 0 ? 1 : 0;
          for (var p = 0; p < 8; p++) {
            var v = d[p] + h[p],
              g = v & 65535,
              m = v >>> 16,
              y = ((g * g >>> 17) + g * m >>> 15) + m * m,
              x = ((v & 4294901760) * v | 0) + ((v & 65535) * v | 0);
            l[p] = y ^ x
          }
          d[0] = l[0] + (l[7] << 16 | l[7] >>> 16) + (l[6] << 16 | l[6] >>> 16) | 0, d[1] = l[1] + (l[0] << 8 | l[0] >>> 24) + l[7] | 0, d[2] = l[2] + (l[1] << 16 | l[1] >>> 16) + (l[0] << 16 | l[0] >>> 16) | 0, d[3] = l[3] + (l[2] << 8 | l[2] >>> 24) + l[1] | 0, d[4] = l[4] + (l[3] << 16 | l[3] >>> 16) + (l[2] << 16 | l[2] >>> 16) | 0, d[5] = l[5] + (l[4] << 8 | l[4] >>> 24) + l[3] | 0, d[6] = l[6] + (l[5] << 16 | l[5] >>> 16) + (l[4] << 16 | l[4] >>> 16) | 0, d[7] = l[7] + (l[6] << 8 | l[6] >>> 24) + l[5] | 0
        }
        n.RabbitLegacy = a._createHelper(u)
      }(), r.RabbitLegacy
    })
  }(e0t)), $x
}(function (t, e) {
  (function (r, n, i) {
    t.exports = n(Be(), UE(), tht(), nht(), fs, sht(), yd(), RL(), Eee(), fht(), See(), pht(), mht(), yht(), AL(), Eht(), Ac(), lr(), wht(), Aht(), $ht(), kht(), Lht(), Nht(), Mht(), Bht(), jht(), zht(), Vht(), Kht(), qht(), Qht(), Jht(), t0t())
  })(me, function (r) {
    return r
  })
})(Ydt);
const uu = yp,
  r0t = B6e("0123456789abcdef", 32),
  I9 = {
    "360p": Oe.Q360P,
    "480p": Oe.Q480P,
    "720p": Oe.Q720P,
    "1080p": Oe.Q1080P
  },
  n0t = atob("d0VpcGhUbiE="),
  _ee = atob("MTIzZDZjZWRmNjI2ZHk1NDIzM2FhMXc2"),
  $9 = [atob("aHR0cHM6Ly9zaG93Ym94LnNoZWd1Lm5ldC9hcGkvYXBpX2NsaWVudC9pbmRleC8="), atob("aHR0cHM6Ly9tYnBhcGkuc2hlZ3UubmV0L2FwaS9hcGlfY2xpZW50L2luZGV4Lw==")],
  C9 = atob("bW92aWVib3g="),
  i0t = atob("Y29tLnRkby5zaG93Ym94"),
  k9 = {
    encrypt(t) {
      return uu.TripleDES.encrypt(t, uu.enc.Utf8.parse(_ee), {
        iv: uu.enc.Utf8.parse(n0t)
      }).toString()
    },
    getVerify(t, e, r) {
      return t ? uu.MD5(uu.MD5(e).toString() + r + t).toString() : null
    }
  },
  a0t = () => Math.floor(Date.now() / 1e3 + 60 * 60 * 12),
  hh = (t, e = !1) => {
    const r = {
        childmode: "0",
        app_version: "11.5",
        appid: i0t,
        lang: "en",
        expired_date: `${a0t()}`,
        platform: "android",
        channel: "Website"
      },
      n = k9.encrypt(JSON.stringify({
        ...r,
        ...t
      })),
      i = uu.MD5(C9).toString(),
      a = k9.getVerify(n, C9, _ee),
      s = JSON.stringify({
        app_key: i,
        verify: a,
        encrypt_data: n
      }),
      o = btoa(s),
      c = new URLSearchParams;
    c.append("data", o), c.append("appid", "27"), c.append("platform", "android"), c.append("version", "129"), c.append("medium", "Website");
    const l = e ? $9[1] : $9[0];
    return xe(l, {
      method: "POST",
      parseResponse: JSON.parse,
      headers: {
        Platform: "android",
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: `${c.toString()}&token${r0t()}`
    })
  },
  O9 = t => t.find(e => e.quality === "1080p" && e.path) ? ? t.find(e => e.quality === "720p" && e.path) ? ? t.find(e => e.quality === "480p" && e.path) ? ? t.find(e => e.quality === "360p" && e.path),
  L9 = t => {
    let e = t.subtitles;
    if (e = e.map(n => {
        if (!rO(n.file_path)) return null;
        const a = Cq(n.file_path);
        return {
          ...n,
          type: a
        }
      }).filter(Boolean), e.length === 0) return null;
    const r = e[0];
    return {
      needsProxy: !0,
      langIso: t.language,
      url: r.file_path,
      type: r.type
    }
  };
Fi({
  id: "superstream",
  displayName: "Superstream",
  rank: 200,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var h, p;
    const n = {
        module: "Search3",
        page: "1",
        type: "all",
        keyword: t.meta.title,
        pagelimit: "20"
      },
      i = (await hh(n, !0)).data;
    r(33);
    const a = i.find(v => qk(v.title, t.meta.title) && v.year === Number(t.meta.year));
    if (!a) throw new Error("No entry found on SuperStream");
    const s = a.id;
    if (t.meta.type === ae.MOVIE) {
      const g = (await hh({
        uid: "",
        module: "Movie_downloadurl_v3",
        mid: s,
        oss: "1",
        group: ""
      })).data;
      r(50);
      const m = O9(g.list);
      if (!m) throw new Error("No quality could be found.");
      const y = {
          fid: m.fid,
          uid: "",
          module: "Movie_srt_list_v2",
          mid: s
        },
        b = (await hh(y)).data.list.map(L9).filter(Boolean);
      return {
        embeds: [],
        stream: {
          streamUrl: m.path,
          quality: I9[m.quality],
          type: Ct.MP4,
          captions: b
        }
      }
    }
    if (t.meta.type !== ae.SERIES) throw new Error("Unsupported type");
    const o = {
        uid: "",
        module: "TV_downloadurl_v3",
        tid: s,
        season: t.meta.seasonData.number.toString(),
        episode: (((h = t.meta.seasonData.episodes.find(v => v.id === e)) == null ? void 0 : h.number) ? ? 1).toString(),
        oss: "1",
        group: ""
      },
      c = (await hh(o)).data;
    r(66);
    const l = O9(c.list);
    if (!l) throw new Error("No quality could be found.");
    const u = {
        fid: l.fid,
        uid: "",
        module: "TV_srt_list_v2",
        episode: ((p = t.meta.seasonData.episodes.find(v => v.id === e)) == null ? void 0 : p.number) ? ? 1,
        tid: s,
        season: t.meta.seasonData.number.toString()
      },
      d = (await hh(u)).data.list.map(L9).filter(Boolean);
    return {
      embeds: [],
      stream: {
        quality: I9[l.quality],
        streamUrl: l.path,
        type: Ct.MP4,
        captions: d
      }
    }
  }
});
const xv = "https://net-film.vercel.app",
  P9 = {
    360: Oe.Q360P,
    540: Oe.Q540P,
    480: Oe.Q480P,
    720: Oe.Q720P,
    1080: Oe.Q1080P
  };
Fi({
  id: "netfilm",
  displayName: "NetFilm",
  rank: 15,
  type: [ae.MOVIE, ae.SERIES],
  disabled: !0,
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var v;
    if (!this.type.includes(t.meta.type)) throw new Error("Unsupported type");
    const i = (await xe(`/api/search?keyword=${encodeURIComponent(t.meta.title)}`, {
      baseURL: xv
    })).data.results;
    if (r(25), t.meta.type === ae.MOVIE) {
      const g = i.find(S => S.name === t.meta.title && S.releaseTime === t.meta.year);
      if (!g) throw new Error("No watchable item found");
      const m = g.id;
      r(75);
      const x = (await xe(`/api/episode?id=${m}`, {
          baseURL: xv
        })).data,
        b = x.qualities.reduce((S, T) => T.quality > S.quality ? T : S),
        _ = x.subtitles.map(S => ({
          needsProxy: !1,
          url: S.url.replace("https://convert-srt-to-vtt.vercel.app/?url=", ""),
          type: Li.SRT,
          langIso: S.language
        }));
      return {
        embeds: [],
        stream: {
          streamUrl: b.url.replace("akm-cdn", "aws-cdn").replace("gg-cdn", "aws-cdn"),
          quality: P9[b.quality],
          type: Ct.HLS,
          captions: _
        }
      }
    }
    if (t.meta.type !== ae.SERIES) throw new Error("Unsupported type");
    const a = t.meta.seasonData.number,
      o = i.filter(g => g.name.includes(t.meta.title)).map(g => ({
        ...g,
        season: parseInt(g.name.split(" ").at(-1), 10) || 1
      })).find(g => g.season === a);
    r(50);
    const c = await xe(`/api/detail?id=${o.id}&category=${o.categoryTag[0].id}`, {
        baseURL: xv
      }),
      l = (v = t.meta.seasonData.episodes.find(g => g.id === e)) == null ? void 0 : v.number,
      u = c.data.episodeVo.find(g => g.seriesNo === l);
    r(75);
    const d = (await xe(`/api/episode?id=${o.id}&category=1&episode=${u.id}`, {
        baseURL: xv
      })).data,
      h = d.qualities.reduce((g, m) => m.quality > g.quality ? m : g),
      p = d.subtitles.map(g => ({
        needsProxy: !1,
        url: g.url.replace("https://convert-srt-to-vtt.vercel.app/?url=", ""),
        type: Li.SRT,
        langIso: g.language
      }));
    return {
      embeds: [],
      stream: {
        streamUrl: h.url.replace("akm-cdn", "aws-cdn").replace("gg-cdn", "aws-cdn"),
        quality: P9[h.quality],
        type: Ct.HLS,
        captions: p
      }
    }
  }
});
var sn = (t => (t.M4UFREE = "m4ufree", t.STREAMM4U = "streamm4u", t.PLAYM4U = "playm4u", t.UPCLOUD = "upcloud", t.STREAMSB = "streamsb", t.MP4UPLOAD = "mp4upload", t))(sn || {});
const s0t = "m4ufree.com",
  xp = `https://${s0t}`,
  o0t = `${xp}/search`,
  l0t = `${xp}/ajax`,
  c0t = `${xp}/ajaxtv`,
  u0t = /(.*) \(?(\d*|\d*-|\d*-\d*)\)?$/,
  f0t = /.*-(movie|tvshow)-online-free-m4ufree\.html/,
  d0t = /XSRF-TOKEN=(.*?);.*laravel_session=(.*?);/,
  h0t = /S(\d*)-E(\d*)/;

function bv(t) {
  return new DOMParser().parseFromString(t, "text/html")
}
Fi({
  id: "m4ufree",
  displayName: "m4ufree",
  rank: -1,
  disabled: !0,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    type: e,
    episode: r,
    season: n
  }) {
    var m, y, x, b, _;
    const i = ((y = (m = t.meta.seasons) == null ? void 0 : m.find(S => S.id === n)) == null ? void 0 : y.number) || 1,
      a = t.meta.type === ae.SERIES ? ((x = t.meta.seasonData.episodes.find(S => S.id === r)) == null ? void 0 : x.number) || 1 : void 0,
      s = [],
      o = await xe(`${o0t}/${encodeURIComponent(t.meta.title)}.html`);
    let c = bv(o);
    const u = [...c.querySelectorAll(".item")].map(S => {
      var N;
      const T = (N = S.querySelector(".tiptitle p")) == null ? void 0 : N.innerHTML;
      if (!T) return;
      let R = u0t.exec(T);
      if (!R || !R[1] || !R[2]) return;
      const I = R[1],
        w = Number(R[2].slice(0, 4)),
        C = S.querySelector("a");
      if (!C) return;
      const L = C.href;
      if (R = f0t.exec(L), !R || !R[1]) return;
      let H = R[1];
      return H = H === "tvshow" ? "show" : "movie", {
        type: H,
        title: I,
        year: w,
        href: L
      }
    }).filter(S => S).find(S => S && S.title === t.meta.title && S.year.toString() === t.meta.year);
    if (!u) return {
      embeds: s
    };
    let f = "";
    const d = await xe(u.href, {
      onResponse(S) {
        f = S.response.headers.get("X-Set-Cookie")
      }
    });
    c = bv(d);
    let h = d0t.exec(f);
    if (!h || !h[1] || !h[2]) throw new Error("No regexResults, yikesssssss kinda gross idk");
    const p = `XSRF-TOKEN=${h[1]}; laravel_session=${h[2]}`,
      v = (b = c.querySelector('meta[name="csrf-token"]')) == null ? void 0 : b.getAttribute("content");
    if (!v) return {
      embeds: s
    };
    if (e === ae.SERIES) {
      const T = [...c.querySelectorAll(".episode")].map(w => {
        if (h = h0t.exec(w.innerHTML), !h || !h[1] || !h[2]) return;
        const C = Number(h[1]),
          L = Number(h[2]);
        return {
          id: w.getAttribute("idepisode"),
          episode: C,
          season: L
        }
      }).filter(w => w).find(w => w && w.episode === a && w.season === i);
      if (!T) return {
        embeds: s
      };
      const R = `idepisode=${T.id}&_token=${v}`,
        I = await xe(c0t, {
          method: "POST",
          headers: {
            Accept: "*/*",
            "Accept-Encoding": "gzip, deflate, br",
            "Accept-Language": "en-US,en;q=0.9",
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
            "Sec-CH-UA": '"Not?A_Brand";v="8", "Chromium";v="108", "Microsoft Edge";v="108"',
            "Sec-CH-UA-Mobile": "?0",
            "Sec-CH-UA-Platform": '"Linux"',
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "X-Cookie": p,
            "X-Origin": xp,
            "X-Referer": u.href
          },
          body: R
        });
      c = bv(I)
    }
    const g = [...c.querySelectorAll(".singlemv")].map(S => S.getAttribute("data"));
    for (const S of g) {
      const T = `m4u=${S}&_token=${v}`,
        R = await xe(l0t, {
          method: "POST",
          headers: {
            Accept: "*/*",
            "Accept-Encoding": "gzip, deflate, br",
            "Accept-Language": "en-US,en;q=0.9",
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
            "Sec-CH-UA": '"Not?A_Brand";v="8", "Chromium";v="108", "Microsoft Edge";v="108"',
            "Sec-CH-UA-Mobile": "?0",
            "Sec-CH-UA-Platform": '"Linux"',
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "X-Cookie": p,
            "X-Origin": xp,
            "X-Referer": u.href
          },
          body: T
        }),
        w = (_ = bv(R).querySelector("iframe")) == null ? void 0 : _.src,
        C = H => H.startsWith("https://streamm4u.club") ? sn.STREAMM4U : H.startsWith("https://play.playm4u.xyz") ? sn.PLAYM4U : null;
      if (!w) continue;
      const L = C(w);
      L && s.push({
        url: w,
        type: L
      })
    }
    return console.log(s), {
      embeds: s
    }
  }
});
const Cx = "https://www.hdwatched.xyz",
  p0t = {
    360: Oe.Q360P,
    540: Oe.Q540P,
    480: Oe.Q480P,
    720: Oe.Q720P,
    1080: Oe.Q1080P
  };

function Tee(t) {
  const r = new DOMParser().parseFromString(t, "text/html").querySelector("#vjsplayer > source");
  if (!r) throw new Error("Unable to fetch stream");
  const n = r.getAttribute("src"),
    i = r.getAttribute("res");
  if (!n || !i) throw new Error("Unable to find stream");
  return {
    streamUrl: n,
    quality: i && typeof + i == "number" ? p0t[+i] : Oe.QUNKNOWN
  }
}
async function g0t(t) {
  const e = await xe(`/embed/${t.id}`, {
    baseURL: Cx
  });
  if (!new DOMParser().parseFromString(e, "text/html").querySelector("#vjsplayer > source")) throw new Error("Unable to fetch movie stream");
  return Tee(e)
}
async function m0t(t, {
  media: e,
  episode: r,
  progress: n
}) {
  var p;
  if (e.meta.type !== ae.SERIES) throw new Error("Media type mismatch");
  const i = e.meta.seasonData.number,
    a = (p = e.meta.seasonData.episodes.find(v => v.id === r)) == null ? void 0 : p.number;
  if (!i || !a) throw new Error("Unable to get season or episode number");
  const s = await xe(`${t.href}?season=${e.meta.seasonData.number}`, {
      baseURL: Cx
    }),
    c = new DOMParser().parseFromString(s, "text/html").querySelectorAll("div.i-container"),
    l = [];
  c.forEach(v => {
    var y, x;
    const g = ((y = v.querySelector("a")) == null ? void 0 : y.getAttribute("href")) || "",
      m = ((x = v == null ? void 0 : v.querySelector("span.content-title")) == null ? void 0 : x.textContent) || "";
    l.push({
      title: m,
      href: g,
      id: g.split("/")[2]
    })
  });
  const u = l.find(v => v.title.trim().toLowerCase() === `episode ${a}`);
  if (!u) throw new Error("Unable to find episode");
  n(70);
  const f = await xe(`/embed/${u.id}`, {
    baseURL: Cx
  });
  if (!new DOMParser().parseFromString(f, "text/html").querySelector("#vjsplayer > source")) throw new Error("Unable to fetch movie stream");
  return Tee(f)
}
Fi({
  id: "hdwatched",
  displayName: "HDwatched",
  rank: 150,
  type: [ae.MOVIE, ae.SERIES],
  async scrape(t) {
    const {
      media: e,
      progress: r
    } = t;
    if (!e.imdbId) throw new Error("not enough info");
    if (!this.type.includes(e.meta.type)) throw new Error("Unsupported type");
    const n = await xe(`/search/${e.imdbId}`, {
        baseURL: Cx
      }),
      a = new DOMParser().parseFromString(n, "text/html").querySelectorAll("div.i-container"),
      s = [];
    a.forEach(l => {
      var h, p, v, g, m, y;
      const u = ((h = l.querySelector("a")) == null ? void 0 : h.getAttribute("href")) || "",
        f = ((p = l == null ? void 0 : l.querySelector("span.content-title")) == null ? void 0 : p.textContent) || "",
        d = parseInt(((y = (m = (g = (v = l == null ? void 0 : l.querySelector("div.duration")) == null ? void 0 : v.textContent) == null ? void 0 : g.trim()) == null ? void 0 : m.split(" ")) == null ? void 0 : y.pop()) || "", 10) || 0;
      s.push({
        title: f,
        year: d,
        href: u,
        id: u.split("/")[2]
      })
    }), r(20);
    const o = s.find(l => l.year === (e.meta.year ? +e.meta.year : 0));
    if (!o) throw new Error("Could not find stream");
    if (r(40), e.meta.type === ae.SERIES) {
      const l = await m0t(o, t);
      return {
        embeds: [],
        stream: {
          streamUrl: l.streamUrl,
          quality: l.quality,
          type: Ct.MP4,
          captions: []
        }
      }
    }
    const c = await g0t(o);
    return {
      embeds: [],
      stream: {
        streamUrl: c.streamUrl,
        quality: c.quality,
        type: Ct.MP4,
        captions: []
      }
    }
  }
});
var LI = {},
  v0t = {
    get exports() {
      return LI
    },
    set exports(t) {
      LI = t
    }
  };
(function (t, e) {
  (function (r, n) {
    t.exports = n(Be())
  })(me, function (r) {
    return r.enc.Utf8
  })
})(v0t);
const wee = LI,
  Gl = "https://www.2embed.to";
async function y0t(t) {
  var l;
  const e = bee.stringify(wee.parse(Gl)).replace(/=/g, "."),
    r = await xe(`https://www.google.com/recaptcha/api.js?render=${t}`),
    n = r.substring(r.indexOf("/releases/") + 10, r.indexOf("/recaptcha__en.js")),
    i = await xe(`https://www.google.com/recaptcha/api2/anchor?ar=1&hl=en&size=invisible&cb=flicklax&k=${t}&co=${e}&v=${n}`),
    a = (l = new DOMParser().parseFromString(i, "text/html").getElementById("recaptcha-token")) == null ? void 0 : l.getAttribute("value");
  if (!a) throw new Error("Unable to find cToken");
  const s = {
      v: n,
      reason: "q",
      k: t,
      c: a,
      sa: "",
      co: Gl
    },
    c = (await xe(`https://www.google.com/recaptcha/api2/reload?${new URLSearchParams(s).toString()}`, {
      headers: {
        referer: "https://www.google.com/recaptcha/api2/"
      },
      method: "POST"
    })).match('rresp","(.+?)"');
  return c ? c[1] : null
}
async function x0t(t, e) {
  var b, _, S, T;
  const r = await xe(`${Gl}/ajax/embed/play?id=${t}&_token=${e}`, {
      headers: {
        Referer: Gl
      }
    }),
    n = new URL(r.link),
    i = n.pathname.split("/"),
    a = i[i.length - 1],
    s = await xe(`${n.origin}/embed/m-download/${a}`, {
      headers: {
        referer: Gl
      }
    }),
    o = new DOMParser().parseFromString(s, "text/html"),
    c = Array.from(o.querySelectorAll(".dls-brand")).find(R => {
      var I;
      return ((I = R.textContent) == null ? void 0 : I.trim()) === "Streamlare"
    });
  if (!c) throw new Error("Unable to find streamlare element");
  const l = (_ = (b = c.nextElementSibling) == null ? void 0 : b.querySelector("a")) == null ? void 0 : _.href;
  if (!l) throw new Error("Unable to parse streamlare url");
  const u = [];
  o.querySelectorAll("#user_menu .dropdown-item").forEach(R => {
    var C;
    const I = R.getAttribute("href"),
      w = (C = R.textContent) == null ? void 0 : C.trim().replace("Download", "").trim();
    I && w && u.push({
      url: I,
      lang: w
    })
  });
  const d = await xe(l),
    p = (S = new DOMParser().parseFromString(d, "text/html").querySelector("head > meta:nth-child(3)")) == null ? void 0 : S.getAttribute("content");
  if (!p) throw new Error("Unable to find CSRF token");
  const v = (T = l.match("/[ve]/([^?#&/]+)")) == null ? void 0 : T[1];
  if (!v) throw new Error("Unable to get streamlare video id");
  const g = await xe(`${new URL(l).origin}/api/video/download/get`, {
    method: "POST",
    body: JSON.stringify({
      id: v
    }),
    headers: {
      "X-Requested-With": "XMLHttpRequest",
      "X-CSRF-Token": p
    }
  });
  if (g.message !== "OK") throw new Error("Unable to fetch stream");
  const m = Array.isArray(g.result) ? g.result[0] : g.result.Original;
  if (!m) throw new Error("Unable to get stream data");
  return {
    url: (await PFe(m.url, {
      method: "HEAD",
      referrer: new URL(l).origin
    })).headers.get("X-Final-Destination"),
    subtitles: u
  }
}
Fi({
  id: "2embed",
  displayName: "2Embed",
  rank: 125,
  type: [ae.MOVIE, ae.SERIES],
  disabled: !0,
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var d, h;
    let n = `${Gl}/embed/tmdb/movie?id=${t.tmdbId}`;
    if (t.meta.type === ae.SERIES) {
      const p = t.meta.seasonData.number,
        v = (d = t.meta.seasonData.episodes.find(g => g.id === e)) == null ? void 0 : d.number;
      n = `${Gl}/embed/tmdb/tv?id=${t.tmdbId}&s=${p}&e=${v}`
    }
    const i = await xe(n);
    r(20);
    const a = new DOMParser().parseFromString(i, "text/html"),
      o = Array.from(a.querySelectorAll(".item-server")).find(p => {
        var v;
        return (v = p.textContent) == null ? void 0 : v.includes("Vidcloud")
      }),
      c = o ? o.getAttribute("data-id") : null;
    if (!c) throw new Error("Unable to get source id");
    const l = (h = a.querySelector("body")) == null ? void 0 : h.getAttribute("data-recaptcha-key");
    if (!l) throw new Error("Unable to get site key");
    const u = await y0t(l);
    if (!u) throw new Error("Unable to fetch captcha token");
    r(35);
    const f = await x0t(c, u);
    if (!f.url) throw new Error("Unable to find stream url");
    return {
      embeds: [],
      stream: {
        streamUrl: f.url,
        quality: Oe.QUNKNOWN,
        type: Ct.MP4,
        captions: f.subtitles.map(p => ({
          langIso: p.lang,
          url: `https://cc.2cdns.com${new URL(p.url).pathname}`,
          type: Li.VTT
        }))
      }
    }
  }
});
const b0t = "https://sflix.video";
Fi({
  id: "sflix",
  displayName: "Sflix",
  rank: 50,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var v, g, m, y, x;
    let n = `${t.meta.title} `;
    t.meta.type === ae.MOVIE && (n += t.meta.year ? ? ""), t.meta.type === ae.SERIES && (n += `S${String(t.meta.seasonData.number).padStart(2,"0")}`);
    const i = await xe(`/?s=${encodeURIComponent(n)}`, {
        baseURL: b0t
      }),
      s = (v = new DOMParser().parseFromString(i, "text/html").querySelector(".movies-list .ml-item:first-child a")) == null ? void 0 : v.getAttribute("href");
    if (!s) throw new Error("Movie does not exist");
    r(25);
    const o = await xe(s),
      c = new DOMParser().parseFromString(o, "text/html");
    r(45);
    let l = null;
    if (t.meta.type === ae.MOVIE) l = (g = c.querySelector("iframe")) == null ? void 0 : g.getAttribute("data-lazy-src");
    else if (t.meta.type === ae.SERIES) {
      const b = Array.from(c.querySelectorAll(".desc p a")).map(T => ({
          title: T.getAttribute("title"),
          link: T.getAttribute("href")
        })),
        _ = (m = t.meta.seasonData.episodes.find(T => T.id === e)) == null ? void 0 : m.number,
        S = b.find(T => {
          var R;
          return (R = T.title) == null ? void 0 : R.endsWith(String(_).padStart(2, "0"))
        });
      if (!S) throw new Error("Episode does not exist");
      l = S.link
    }
    if (!l) throw new Error("Outer embed source not found");
    r(65);
    const u = await xe(l),
      d = (y = new DOMParser().parseFromString(u, "text/html").querySelector("iframe")) == null ? void 0 : y.getAttribute("src");
    if (!d) throw new Error("Embed source not found");
    const p = (x = (await xe(d)).match(/file\s*:\s*"([^"]+\.mp4)"/)) == null ? void 0 : x[1];
    if (!p) throw new Error("Unable to get stream");
    return {
      embeds: [],
      stream: {
        streamUrl: p,
        quality: Oe.Q1080P,
        type: Ct.MP4,
        captions: []
      }
    }
  }
});
const eu = "https://gomovies.sx";
Fi({
  id: "gomovies",
  displayName: "GOmovies",
  rank: 300,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e
  }) {
    var d, h;
    const r = await xe("/ajax/search", {
        baseURL: eu,
        method: "POST",
        body: JSON.stringify({
          keyword: t.meta.title
        }),
        headers: {
          "X-Requested-With": "XMLHttpRequest"
        }
      }),
      i = new DOMParser().parseFromString(r, "text/html").querySelectorAll("a.nav-item"),
      s = Array.from(i).map(p => {
        var y, x;
        const v = (y = p == null ? void 0 : p.querySelector("h3.film-name")) == null ? void 0 : y.textContent,
          g = (x = p == null ? void 0 : p.querySelector("div.film-infor span:first-of-type")) == null ? void 0 : x.textContent,
          m = p.getAttribute("href");
        return {
          name: v,
          year: g,
          path: m
        }
      }).find(p => p.name === t.meta.title && (t.meta.type === ae.MOVIE ? p.year === t.meta.year : !0));
    if (!(s != null && s.path)) throw new Error("Media not found");
    let o = (d = s.path.split("-").pop()) == null ? void 0 : d.replace("/", ""),
      c = null;
    if (t.meta.type === ae.SERIES) {
      const p = await xe(`/ajax/v2/tv/seasons/${o}`, {
          baseURL: eu,
          headers: {
            "X-Requested-With": "XMLHttpRequest"
          }
        }),
        g = [...new DOMParser().parseFromString(p, "text/html").querySelectorAll(".ss-item")].map(R => ({
          number: R.innerHTML.replace("Season ", ""),
          dataId: R.getAttribute("data-id")
        })),
        m = t.meta.seasonData.number,
        y = g.find(R => +R.number === m);
      if (!y) throw new Error("Season not found");
      const x = await xe(`/ajax/v2/season/episodes/${y.dataId}`, {
          baseURL: eu,
          headers: {
            "X-Requested-With": "XMLHttpRequest"
          }
        }),
        b = new DOMParser().parseFromString(x, "text/html").querySelectorAll(".eps-item"),
        _ = Array.from(b).map(R => {
          var I, w;
          return {
            dataId: R.getAttribute("data-id"),
            number: (w = (I = R.querySelector("strong")) == null ? void 0 : I.textContent) == null ? void 0 : w.replace("Eps", "").replace(":", "").trim()
          }
        }),
        S = (h = t.meta.seasonData.episodes.find(R => R.id === e)) == null ? void 0 : h.number,
        T = _.find(R => R.number ? +R.number : R.number === S);
      if (!(T != null && T.dataId)) throw new Error("Episode not found");
      o = T.dataId, c = await xe(`/ajax/v2/episode/servers/${o}`, {
        baseURL: eu,
        headers: {
          "X-Requested-With": "XMLHttpRequest"
        }
      })
    } else c = await xe(`/ajax/movie/episodes/${o}`, {
      baseURL: eu,
      headers: {
        "X-Requested-With": "XMLHttpRequest"
      }
    });
    const l = new DOMParser().parseFromString(c, "text/html").querySelector('a[title*="upcloud" i]'),
      u = (l == null ? void 0 : l.getAttribute("data-id")) ? ? (l == null ? void 0 : l.getAttribute("data-linkid"));
    if (!u) throw new Error("Upcloud source not available");
    const f = await xe(`/ajax/sources/${u}`, {
      baseURL: eu,
      headers: {
        "X-Requested-With": "XMLHttpRequest"
      }
    });
    if (!f.link || f.type !== "iframe") throw new Error("No upcloud stream found");
    return {
      embeds: [{
        type: sn.UPCLOUD,
        url: f.link
      }]
    }
  }
});
const N9 = "https://kissasian.li",
  E0t = [{
    type: sn.MP4UPLOAD,
    id: "mp"
  }, {
    type: sn.STREAMSB,
    id: "sb"
  }];
Fi({
  id: "kissasian",
  displayName: "KissAsian",
  rank: 130,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var g;
    let n = "",
      i = "";
    t.meta.type === ae.SERIES && (n = t.meta.seasonData.number === 1 ? "" : `${t.meta.seasonData.number}`, i = `${((g=t.meta.seasonData.episodes.find(m=>m.id===e))==null?void 0:g.number)??""}`);
    const a = new FormData;
    a.append("keyword", `${t.meta.title} ${n}`.trim()), a.append("type", "Drama");
    const s = await xe("/Search/SearchSuggest", {
        baseURL: N9,
        method: "POST",
        body: a
      }),
      o = new DOMParser().parseFromString(s, "text/html"),
      c = Array.from(o.querySelectorAll("a")).map(m => ({
        name: m.textContent,
        url: m.href
      })),
      l = c.find(m => {
        var y;
        return ((y = m.name) == null ? void 0 : y.toLowerCase()) === t.meta.title.toLowerCase()
      }) ? ? c[0];
    if (!l) throw new Error("Drama not found");
    r(30);
    const u = await xe(l.url),
      d = new DOMParser().parseFromString(u, "text/html").querySelectorAll("tbody tr:not(:first-child)"),
      h = Array.from(d).map(m => {
        var b, _, S, T;
        const y = (S = (_ = (b = m == null ? void 0 : m.querySelector("td.episodeSub a")) == null ? void 0 : b.textContent) == null ? void 0 : _.split("Episode")[1]) == null ? void 0 : S.trim(),
          x = (T = m == null ? void 0 : m.querySelector("td.episodeSub a")) == null ? void 0 : T.getAttribute("href");
        return {
          number: y,
          url: x
        }
      }).filter(m => !!m.url),
      p = t.meta.type === ae.MOVIE ? h[0] : h.find(m => m.number === `${i}`);
    if (!(p != null && p.url)) throw new Error("Episode not found");
    r(70);
    let v = await Promise.all(E0t.map(async m => {
      var _;
      const y = await xe(`${p.url}&s=${m.id}`, {
          baseURL: N9
        }),
        b = (_ = new DOMParser().parseFromString(y, "text/html").querySelector("iframe[id=my_video_1]")) == null ? void 0 : _.getAttribute("src");
      return {
        type: m.type,
        url: b ? ? ""
      }
    }));
    return v = v.filter(m => m.url !== ""), {
      embeds: v
    }
  }
});
const S0t = "https://us-west2-compute-proxied.streamflix.one",
  _0t = {
    360: Oe.Q360P,
    540: Oe.Q540P,
    480: Oe.Q480P,
    720: Oe.Q720P,
    1080: Oe.Q1080P
  };
Fi({
  id: "streamflix",
  displayName: "StreamFlix",
  disabled: !1,
  rank: 69,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var o;
    if (!this.type.includes(t.meta.type)) throw new Error("Unsupported type");
    r(30);
    const n = t.meta.type === ae.MOVIE ? "movies" : "tv";
    let i, a;
    t.meta.type === ae.SERIES && (i = t.meta.seasonData.number, a = (o = t.meta.seasonData.episodes.find(c => c.id === e)) == null ? void 0 : o.number);
    const s = await xe(`/api/player/${n}`, {
      baseURL: S0t,
      params: {
        id: t.tmdbId,
        s: i,
        e: a
      }
    });
    if (!s.headers.Referer) throw new Error("No watchable item found");
    return r(90), {
      embeds: [],
      stream: {
        streamUrl: s.sources[0].url,
        quality: _0t[s.sources[0].quality],
        type: Ct.HLS,
        captions: s.subtitles.map(c => ({
          needsProxy: !0,
          url: c.url,
          type: Li.VTT,
          langIso: c.lang
        }))
      }
    }
  }
});
const T0t = "https://fsa.remotestre.am";
Fi({
  id: "remotestream",
  displayName: "Remote Stream",
  disabled: !1,
  rank: 55,
  type: [ae.MOVIE, ae.SERIES],
  async scrape({
    media: t,
    episode: e,
    progress: r
  }) {
    var s;
    if (!this.type.includes(t.meta.type)) throw new Error("Unsupported type");
    r(30);
    const n = t.meta.type === ae.MOVIE ? "Movies" : "Shows";
    let i = `${T0t}/${n}/${t.tmdbId}`;
    if (t.meta.type === ae.SERIES) {
      const o = t.meta.seasonData.number,
        c = (s = t.meta.seasonData.episodes.find(l => l.id === e)) == null ? void 0 : s.number;
      i += `/${o}/${c}/${c}.m3u8`
    } else i += `/${t.tmdbId}.m3u8`;
    if ((await Zh(i)).type !== "application/x-mpegurl") throw new Error("No watchable item found");
    return r(90), {
      embeds: [],
      stream: {
        streamUrl: i,
        quality: Oe.QUNKNOWN,
        type: Ct.HLS,
        captions: []
      }
    }
  }
});
const Ree = "streamm4u.club",
  w0t = `https://${Ree}`,
  R0t = `${w0t}/api`,
  D9 = `${R0t}/source`;
async function A0t(t) {
  const e = [],
    r = t.split("/").pop();
  console.log(`${D9}/${r}`);
  const n = await xe(`${D9}/${r}`, {
    method: "POST",
    body: `r=&d=${Ree}`
  });
  if (n.success) {
    const i = n.data;
    for (const a of i) e.push({
      embedId: "",
      streamUrl: a.file,
      quality: a.label,
      type: a.type,
      captions: []
    })
  }
  return e
}
cg({
  id: "streamm4u",
  displayName: "streamm4u",
  for: sn.STREAMM4U,
  rank: 100,
  async getStream({
    progress: t,
    url: e
  }) {
    const n = (await A0t(e)).sort((i, a) => Number(a.quality.replace("p", "")) - Number(i.quality.replace("p", "")))[0];
    if (!n) throw new Error("No source found");
    return t(100), n
  }
});
cg({
  id: "playm4u",
  displayName: "playm4u",
  for: sn.PLAYM4U,
  rank: 0,
  async getStream() {
    return {
      embedId: "",
      streamUrl: "",
      quality: Oe.Q1080P,
      captions: [],
      type: Ct.MP4
    }
  }
});

function I0t(t) {
  try {
    return JSON.parse(t), !0
  } catch {
    return !1
  }
}
cg({
  id: "upcloud",
  displayName: "UpCloud",
  for: sn.UPCLOUD,
  rank: 200,
  async getStream({
    url: t
  }) {
    const e = new URL(t.replace("embed-5", "embed-4")),
      r = e.pathname.split("/"),
      n = r[r.length - 1],
      i = await xe(`${e.origin}/ajax/embed-4/getSources?id=${n}`, {
        headers: {
          Referer: e.origin,
          "X-Requested-With": "XMLHttpRequest"
        }
      });
    let a = i.sources;
    if (!I0t(a) || typeof a == "string") {
      const s = await xe("https://raw.githubusercontent.com/enimax-anime/key/e4/key.txt"),
        o = yp.AES.decrypt(a, s).toString(yp.enc.Utf8),
        c = JSON.parse(o)[0];
      if (!c) throw new Error("No stream found");
      a = c
    }
    return {
      embedId: sn.UPCLOUD,
      streamUrl: a.file,
      quality: Oe.Q1080P,
      type: Ct.HLS,
      captions: i.tracks.filter(s => s.kind === "captions").map(s => ({
        langIso: s.label,
        url: s.file,
        type: s.file.endsWith("vtt") ? Li.VTT : Li.UNKNOWN
      }))
    }
  }
});
const M9 = [Oe.Q1080P, Oe.Q720P, Oe.Q480P, Oe.Q360P];
async function $0t(t, e) {
  var u;
  const r = bee.stringify(wee.parse(t)).replace(/=/g, "."),
    n = await xe(`https://www.google.com/recaptcha/api.js?render=${e}`),
    i = n.substring(n.indexOf("/releases/") + 10, n.indexOf("/recaptcha__en.js")),
    a = await xe(`https://www.google.com/recaptcha/api2/anchor?ar=1&hl=en&size=invisible&cb=flicklax&k=${e}&co=${r}&v=${i}`),
    s = (u = new DOMParser().parseFromString(a, "text/html").getElementById("recaptcha-token")) == null ? void 0 : u.getAttribute("value");
  if (!s) throw new Error("Unable to find cToken");
  const o = {
      v: i,
      reason: "q",
      k: e,
      c: s,
      sa: "",
      co: t
    },
    l = (await xe(`https://www.google.com/recaptcha/api2/reload?${new URLSearchParams(o).toString()}`, {
      headers: {
        referer: "https://www.google.com/recaptcha/api2/"
      },
      method: "POST"
    })).match('rresp","(.+?)"');
  return l ? l[1] : null
}
cg({
  id: "streamsb",
  displayName: "StreamSB",
  for: sn.STREAMSB,
  rank: 150,
  async getStream({
    url: t,
    progress: e
  }) {
    var d;
    const r = t.replace(".html", "").replace("embed-", "").replace("e/", "").replace("d/", ""),
      n = new URL(r),
      i = await xe(`${n.origin}/d${n.pathname}`);
    e(20);
    const a = n.searchParams.get("caption_1"),
      s = n.searchParams.get("sub_1"),
      c = new DOMParser().parseFromString(i, "text/html").querySelectorAll("[onclick^=download_video]");
    let l = [];
    for (const h of c) {
      const p = h.getAttribute("onclick"),
        g = /download_video\('(.+?)','(.+?)','(.+?)'\)/.exec(p ? ? "");
      if (g !== null) {
        const m = (d = h.querySelector("span")) == null ? void 0 : d.textContent,
          x = /(.+?) \((.+?)\)/.exec(m ? ? "");
        x !== null && l.push({
          parameters: [g[1], g[2], g[3]],
          quality: {
            label: x[1].trim(),
            size: x[2]
          }
        })
      }
    }
    l = l.sort((h, p) => {
      const v = M9.indexOf(h.quality.label),
        g = M9.indexOf(p.quality.label);
      return v - g
    }), e(40);
    let u = await Promise.all(l.map(async h => {
      var _, S;
      const p = await xe(`/dl?op=download_orig&id=${h.parameters[0]}&mode=${h.parameters[1]}&hash=${h.parameters[2]}`, {
          baseURL: n.origin
        }),
        g = (_ = new DOMParser().parseFromString(p, "text/html").querySelector(".g-recaptcha")) == null ? void 0 : _.getAttribute("data-sitekey");
      if (!g) throw new Error("Unable to get captcha key");
      const m = await $0t(n.origin, g);
      if (!m) throw new Error("Unable to get captcha token");
      const y = new FormData;
      y.append("op", "download_orig"), y.append("id", h.parameters[0]), y.append("mode", h.parameters[1]), y.append("hash", h.parameters[2]), y.append("g-recaptcha-response", m);
      const x = await xe(`/dl?op=download_orig&id=${h.parameters[0]}&mode=${h.parameters[1]}&hash=${h.parameters[2]}`, {
          baseURL: n.origin,
          method: "POST",
          body: y
        }),
        b = (S = new DOMParser().parseFromString(x, "text/html").querySelector(".btn.btn-light.btn-lg")) == null ? void 0 : S.getAttribute("href");
      return {
        quality: h.quality.label,
        url: b,
        size: h.quality.size,
        captions: a && s ? [{
          url: a,
          langIso: s,
          type: Li.VTT
        }] : []
      }
    }));
    u = u.filter(h => !!h.url), e(60);
    const f = u[0];
    if (!f.url) throw new Error("No stream url found");
    return {
      embedId: sn.STREAMSB,
      streamUrl: f.url,
      quality: f.quality,
      captions: f.captions,
      type: Ct.MP4
    }
  }
});
cg({
  id: "mp4upload",
  displayName: "mp4upload",
  for: sn.MP4UPLOAD,
  rank: 170,
  async getStream({
    url: t
  }) {
    const e = await xe(t),
      r = new RegExp('(?<=player\\.src\\()\\s*{\\s*type:\\s*"[^"]+",\\s*src:\\s*"([^"]+)"\\s*}\\s*(?=\\);)', "s"),
      i = e.match(r)[1];
    if (!i) throw new Error("Stream url not found");
    return {
      embedId: sn.MP4UPLOAD,
      streamUrl: i,
      quality: Oe.Q1080P,
      captions: [],
      type: Ct.MP4
    }
  }
});
k6e();
var U9;
const F9 = ((U9 = window == null ? void 0 : window.__CONFIG__) == null ? void 0 : U9.VITE_KEY) ? ? {}.VITE_KEY ? ? null;
F9 && window.initMW(kr().PROXY_URLS, F9);
Vje();
G8e({
  immediate: !0
});
const C0t = ce.lazy(async () => (await HMe(), {
  default: lct
}));

function k0t(t) {
  return kr().NORMAL_ROUTER ? E(M8e, {
    children: t.children
  }) : E(F8e, {
    children: t.children
  })
}
D4e.render(E(ce.StrictMode, {
  children: E(IMe, {
    children: E(k0t, {
      children: E(A.Suspense, {
        fallback: "",
        children: E(C0t, {})
      })
    })
  })
}), document.getElementById("root"));
export {
  oZ as A, Xlt as B, TB as D, va as H, Ct as M, sZ as N, OBe as S, wlt as T, OVe as V, E as a, og as b, K6e as c, Oe as d, ae as e, Y as j, A as r
};
